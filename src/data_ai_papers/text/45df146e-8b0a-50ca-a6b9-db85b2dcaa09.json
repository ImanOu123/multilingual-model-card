{"title": "Putting An End to End-to-End: Gradient-Isolated Learning of Representations", "authors": "Sindy L\u00f6we; Peter O'; Connor Bastiaan; S Veeling", "pub_date": "2020-01-27", "abstract": "We propose a novel deep learning method for local self-supervised representation learning that does not require labels nor end-to-end backpropagation but exploits the natural order in data instead. Inspired by the observation that biological neural networks appear to learn without backpropagating a global error signal, we split a deep neural network into a stack of gradient-isolated modules. Each module is trained to maximally preserve the information of its inputs using the InfoNCE bound from Oord et al. [2018]. Despite this greedy training, we demonstrate that each module improves upon the output of its predecessor, and that the representations created by the top module yield highly competitive results on downstream classification tasks in the audio and visual domain. The proposal enables optimizing modules asynchronously, allowing large-scale distributed training of very deep neural networks on unlabelled datasets.", "sections": [{"heading": "Introduction", "text": "Modern deep learning models are typically optimized using end-to-end backpropagation and a global, supervised loss function. Although empirically proven to be highly successful [Krizhevsky et al., 2012, this approach is considered biologically implausible. For one, supervised learning requires large labeled datasets to ensure generalization. In contrast, children can learn to recognize a new category based on a handful of samples. Additionally, despite some evidence for top-down connections in the brain, there does not appear to be a global objective that is optimized by backpropagating error signals [Crick, 1989, Marblestone et al., 2016. Instead, the biological brain is highly modular and learns predominantly based on local information [Caporale and Dan, 2008].\nIn addition to lacking a natural counterpart, the supervised training of neural networks with end-to-end backpropagation suffers from practical disadvantages as well. Supervised learning requires labeled inputs, which are expensive to obtain. As a result, it is not applicable to the majority of available data, and suffers from a higher risk of overfitting, as the number of parameters required for a deep model often exceeds the number of labeled datapoints at hand. At the same time, end-to-end backpropagation creates a substantial memory overhead in a na\u00efve implementation, as the entire computational graph, including all parameters, activations and gradients, needs to fit in a processing unit's working memory. Current approaches to prevent this require either the recomputation of intermediate outputs [Salimans and Bulatov, 2017] or expensive reversible layers [Jacobsen et al., 2018]. This inhibits the application of deep learning models to high-dimensional input data that surpass current memory constraints. This problem is perpetuated as end-to-end training does not allow for an exact way of asynchronously optimizing individual layers [Jaderberg et al., 2017]. In a globally optimized network, every layer needs to wait for its predecessors to provide its inputs, as well as for its successors to provide gradients. )) = z m t , which is used as the input for the following module. The InfoNCE objective is used for its greedy optimization. This loss is calculated by contrasting the predictions of a module for its future representations z m t+k against negative samples z m j , which enforces each module to maximally preserve the information of its inputs. We optionally employ an additional autoregressive module gar, which is not depicted here.\nThis forward and backward locking of the network caused by the backpropagation algorithm impedes the efficiency of hardware accelerator design due to a lack of locality.\nIn this paper, we introduce a novel learning approach, Greedy InfoMax (GIM), that improves upon these problems. Drawing inspiration from biological constraints, we remove end-to-end backpropagation by dividing a deep architecture into gradient-isolated modules that we train using a greedy, self-supervised loss per module. Given unlabeled high-dimensional sequential or spatial data, we encode it iteratively, module by module. By using a loss that enforces the individual modules to maximally preserve the information of their inputs, we enable the stacked model to collectively create compact representations that can be used for downstream tasks. Our contributions are as follows: 1\n\u2022 The proposed Greedy InfoMax algorithm achieves strong performance on audio and image classification tasks despite greedy self-supervised training.\n\u2022 This enables asynchronous, decoupled training of neural networks, allowing for training arbitrarily deep networks on larger-than-memory input data.\n\u2022 We show that mutual information maximization is especially suited for layer-by-layer greedy optimization, and argue that this reduces the problem of vanishing gradients.", "publication_ref": ["b30", "b7", "b35", "b5", "b51", "b24", "b25"], "figure_ref": [], "table_ref": []}, {"heading": "Background", "text": "In order to create compact representations from data that are useful for downstream tasks, we assume that natural data exhibit so-called slow features [Wiskott and Sejnowski, 2002]. It is theorized that such features are highly effective for downstream tasks such as object detection or speech recognition. To illustrate: a patch of a few milliseconds of raw speech utterances shares information with neighboring patches such as the speaker identity, emotion, and phonemes, while it does not necessarily share these with random patches drawn from other utterances. Similarly, a small patch from a natural image shares many aspects with neighboring patches such as the depicted object or lighting conditions.\nRecent work [Hjelm et al., 2019, Oord et al., 2018 has proposed how we can exploit this to learn representations that maximize the mutual information shared among neighbors. In this work, we focus specifically on Contrastive Predictive Coding (CPC) [Oord et al., 2018]. This self-supervised end-to-end learning approach extracts useful representations from sequential inputs by maximizing the mutual information between the extracted representations of temporally nearby patches.\nIn order to achieve this, CPC first processes the sequential input signal x using a deep encoding model g enc (x t ) = z t , and additionally produces a representation c t that aggregates the information of all patches up to time-step t using an autoregressive model g ar (z 0:t ) = c t . Then, the mutual information between the extracted representations z t+k and c t of temporally nearby patches is maximized by employing a specifically designed global probabilistic loss: Following the principles of Noise Contrastive Estimation (NCE) [Gutmann and Hyv\u00e4rinen, 2010], CPC takes a bag X = {z t+k , z j1 , z j2 , ...z j N \u22121 } for each delay k, with one \"positive sample\" z t+k which is the encoding of the input that follows k time-steps after c t , and N \u2212 1 \"negative samples\" z jn which are uniformly drawn from all available encoded input sequences.\nEach pair of encodings (z j , c t ) is scored using a function f (\u2022) to predict how likely it is that the given z j is the positive sample z t+k . In practice, Oord et al. [2018] use a log-bilinear model f k (z j , c t ) = exp z T j W k c t with a unique weight-matrix W k for each k-steps-ahead prediction. The scores from f (\u2022) are used to predict which sample in the bag X is correct, leading to the InfoNCE loss:\nL N = \u2212 k E X log f k (z t+k , c t ) zj \u2208X f k (z j , c t )\n.\n(\n)1\nThis loss is used to optimize both the encoding model g enc and the auto-regressive model g ar to extract the features that are consistent over neighboring patches but which diverge between random pairs of patches. At the same time, the scoring model f k learns to use those features to correctly classify the matching pair. In practice, the loss is trained using stochastic gradient descent with minibatches drawn from a large dataset of sequences, and negative samples drawn uniformly from all sequences in the minibatch. Note, that no min-max issues arise as found in adversarial training.\nAs a result of this configuration, one can derive that the optimal solution for f is proportional to the following density ratio [Oord et al., 2018]:\nf k (z t+k , c t ) \u221d p(z t+k |c t ) p(z t+k ) .(2)\nThis insight allows us to reformulate \u2212L N as a lower bound on the mutual information I(z t+k , c t ), as demonstrated in the appendix of Oord et al. [2018] and proven by Poole et al. [2018]. Minimizing the loss L N thus optimizes the mutual information between consecutive patch representations I(z t+k , c t ), which in itself lower bounds the mutual information I(x t+k , c t ) between the future input x t+k and the current representation c t . Hyvarinen and Morioka [2016] show that a similar patch-contrastive setup leads to the extraction of a set of conditionally-independent components, such as Gabor-like filters found in the early biological vision system.\nLayer-wise Information Preservation in Neuroscience Linsker [1988] developed the InfoMax principle in 1988. It theorizes that the brain learns to process its perceptions by maximally preserving the information of the input activities in each layer. On top of this, neuroscience suggests that the brain predicts its future inputs and learns by minimizing this prediction error [Friston, 2010]. Empirical evidence indicates, for example, that retinal cells carry significant mutual information between the current and the future state of their own activity [Palmer et al., 2015]. Rao and Ballard [1999] indicate that this process may happen at each layer within the brain. Our proposal draws motivation from these theories, resulting in a method that learns to preserve the information between the input and the output of each layer by learning representations that are predictive of future inputs.", "publication_ref": ["b58", "b18", "b41", "b41", "b14", "b41", "b48", "b20", "b11", "b43", "b50"], "figure_ref": [], "table_ref": []}, {"heading": "Greedy InfoMax", "text": "In this paper, we pose the question if we can effectively optimize the mutual information between representations at each layer of a model in isolation, enjoying the many practical benefits that greedy training (decoupled, isolated training of parts of a model) provides. In doing so, we introduce a novel approach for self-supervised representation learning: Greedy InfoMax (GIM). As depicted on the left side of Figure 1, we take a conventional deep learning architecture and divide it by depth into a stack of M modules. This decoupling can happen at the individual layer level or, for example, at the level of blocks found in residual networks [He et al., 2016]. Rather than training this model end-to-end, we prevent gradients from flowing between modules and employ a local self-supervised loss instead, additionally reducing the issue of vanishing gradients.\nAs shown on the right side of Figure 1, each encoding module g m enc within our architecture maps the output from the previous module z m\u22121 t to an encoding z m t = g m enc (GradientBlock(z m\u22121 t\n)). No gradients are flowing between modules, which is enforced using a gradient blocking operator defined as GradientBlock(x) x, \u2207 GradientBlock(x) 0. Oord et al. [2018] propose to use the output of an autoregressive model g ar (z 0:t ) = c t to contrast against future predictions z t+k . However, our preliminary results showed that this did not improve results if applied at every module in the stack and optimizing it requires backpropagation through time, which is considered biologically implausible. Therefore, we train each module g m enc using the following module-local InfoNCE loss:\nf m k (z m t+k , z m t ) = exp z m t+k T W m k z m t (3) L m N = \u2212 k E X log f m k (z m t+k , z m t ) z m j \u2208X f m k (z m j , z m t ) .(4)\nAfter convergence of all modules, the scoring functions f m k (\u2022) can be discarded, leaving a conventional feed-forward neural network architecture that extracts features z M t for downstream tasks:\nz M t = g M enc g M \u22121 enc \u2022 \u2022 \u2022 g 1 enc (x t ) .(5)\nFor certain downstream tasks, a broad context is essential. For example, in speech recognition, the receptive field of z M t might not carry enough information to distinguish phonetic structures. To provide this context, we reintroduce the autoregressive model g ar as an independent module that we optionally append to the stack of encoding modules, resulting in a context-aggregate representation\nc M t = g M ar GradientBlock z M \u22121 0:t .\nIn practice, a GRU or PixelCNN-style model can serve in this role. We train this module independently using the following altered scoring function:\nf M k (z M \u22121 t+k , c M t ) = exp GradientBlock z M \u22121 t+k T W M k c M t .(6)\nIterative Mutual Information Maximization Similarly to the InfoNCE loss in Equation ( 1), our module-local InfoNCE loss in Equation ( 4) maximizes a lower bound on the mutual information I(z m t+k , z m t ) between nearby patch representations, encouraging the extraction of slow features. Most importantly, it follows from Oord et al. [2018], that the module-local InfoNCE loss also maximizes the lower bound of the mutual information I(z m\u22121 t+k , z m t ) between the future input to a module and its current representation. This can be seen as a maximization of the mutual information between the input and the output of a module, subject to the constraint of temporal disparity. Thus, the InfoNCE loss can successfully enforce each module to maximally preserve the information of its inputs, while providing the necessary regularization [Hu et al., 2017, Krause et al., 2010 for circumventing degenerate solutions. These factors contribute to ensuring that the greedily optimized modules provide meaningful inputs to their successors and that the network as a whole provides useful features for downstream tasks without the use of a global error signal.\nPractical Benefits Applying GIM to high-dimensional inputs, we can optimize each module in sequence to decrease the memory costs during training. In the most memory-constrained scenario,  individual modules can be trained, frozen, and their outputs stored as a dataset for the next module, which effectively removes the depth of the network as a factor of the memory complexity.\nAdditionally, GIM allows for training models on larger-than-memory input data with architectures that would otherwise exceed memory limitations. Leveraging the conventional pooling and strided layers found in common network architectures, we can start with small patches of the input, greedily train the first module, extract the now compressed representation spanning larger windows of the input and train the following module using these.\nLast but not least, GIM provides a highly flexible framework for the training of neural networks. It enables the training of individual parts of an architecture at varying update frequencies. When a higher level of abstraction is needed, GIM allows for adding new modules on top at any moment of the optimization process without having to fine-tune previous results.", "publication_ref": ["b15", "b19", "b29"], "figure_ref": ["fig_0", "fig_0"], "table_ref": []}, {"heading": "Experiments", "text": "We test the applicability of the GIM approach to the visual and audio domain. In both settings, a feature-extraction model is divided by depth into modules and trained without labels using GIM.\nThe representations created by the final (frozen) module are then used as the input for a linear classifier, whose accuracy scores provide us with a proxy for the quality and generalizability of the representations created by the self-supervised model.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Vision", "text": "To apply Greedy InfoMax to natural images, we impose a top-down ordering on 2D images. We follow H\u00e9naff et al. [2019], Oord et al. [2018] by extracting a grid of partly-overlapping patches from the image to restrict the receptive fields of the representations. For each patch x i,j in row i and column j of this grid, we predict up to K patches x i+K,j in the rows underneath, skipping the first overlapping patch x i+1,j . Random contrastive samples are drawn with replacement from all samples available inside a batch, using 16 contrastive samples for each evaluation of the loss. No autoregressive module g ar is used for GIM in this regime.", "publication_ref": ["b41"], "figure_ref": [], "table_ref": []}, {"heading": "Experimental Details", "text": "We focus on the STL-10 dataset [Coates et al., 2011] which provides an additional unlabeled training dataset. For data augmentation, we take random 64 \u00d7 64 crops from the 96 \u00d7 96 images, flip horizontally with probability 0.5 and convert to grayscale. We divide each image of 64 \u00d7 64 pixels into a total of 7 \u00d7 7 local patches, each of size 16 \u00d7 16 with 8 pixels overlap. The patches are encoded by a ResNet-50 v2 model [He et al., 2016] without batch normalization [Ioffe and Szegedy, 2015]. We split the model into three gradient-isolated modules that we train in sync and with a constant learning rate. After convergence, a linear classifier is trained -without finetuning the representations -using a conventional softmax activation and cross-entropy loss. This linear classifier accepts the patch representations z M i,j from the final module and first average-pools these, resulting in a single vector representation z M . Remaining implementation details are presented in Appendix A.1. Results As shown in Table 1, Greedy InfoMax (GIM) outperforms its end-to-end trained CPC counterpart, despite its unsupervised features being optimized greedily without any backpropagation between modules. An equivalent randomly initialized feature extraction model exhibits poor performance, showing that GIM extracts useful features. Training the feature extraction model end-to-end and fully supervised performs worse, likely due to the small size of the annotated dataset resulting in overfitting. Although this could potentially be circumvented through regularization techniques [De-Vries and Taylor, 2017], the self-supervised methods do not appear to require regularization as they benefit from the full unlabeled dataset. Using a greedy supervised approach for training the feature model impedes performance, which suggests that mutual information maximization is unique in its direct applicability to greedy optimization.\nIn comparison with the recently proposed Deep InfoMax model from Hjelm et al. [2019] which uses a slightly different end-to-end mutual information maximization approach, AlexNet [Krizhevsky et al., 2012] as their feature-extraction model and an additional hidden layer in the supervised classification model, GIM comes out favorably. Finally, we see that we outperform the state-of-the-art biologically inspired Predsim model from N\u00f8kland and Eidnes [2019], which trains individual layers of a VGG like architecture [Simonyan and Zisserman, 2014] using two supervised loss functions.\nIn Figure 2, we visualize patches that neurons in intermediate modules of the GIM model are sensitive to. This demonstrates that modules later in the model focus on increasingly abstract features. Overall, the results demonstrate that complicated visual tasks can be approached using greedy self-supervised optimization, which can utilize large-scale unlabeled datasets.\nAsynchronous memory usage GIM provides a significant practical advantage arising from the greedy nature of optimization: modules can be trained in isolation given cached outputs from previous modules, effectively removing the depth of the network as a factor of the memory complexity.\nMeasuring the allocated GPU memory of the previously studied models during training (Table 2), indicates that this theoretical benefit holds in practice as well. After splitting the architecture into three separately trainable modules, we can reduce the GPU memory consumption by a factor of 2.8 by training the modules asynchronously (GIM -1st module) compared to training them simultaneously (GIM -all modules).\nWe evaluate whether training modules asynchronously influences the quality of the representations. Focusing on the extreme case, we optimize each module until convergence and fix its parameters, before we train the next module on top of it. This iteratively trained model achieves an accuracy of 79.8% on the image classification downstream task. Thus, the performance declines slightly in comparison to the simultaneously trained model, as previously shown in Table 1 with 81.9% accuracy.\nThe training curves of the two models as shown in Figure 3 provide some insight into this decreased performance. The learning curves of the first module (Figure 3a) reflect that there is no difference in its training in the two models. Modules two and three (Figures 3b and 3c), however, reveal a crucial difference. The iteratively trained modules show a larger divergence between the training and validation loss, indicating stronger overfitting. We tentatively attribute this to the regularizing effect from the initially noisy inputs received by the higher modules when training simultaneously. ", "publication_ref": ["b6", "b15", "b23", "b30", "b40", "b54"], "figure_ref": ["fig_1", "fig_2", "fig_2", "fig_2"], "table_ref": ["tab_0", "tab_1", "tab_0"]}, {"heading": "Audio", "text": "We evaluate GIM in the audio domain on the sequence-global task of speaker classification and the local task of phone classification (distinct phonetic sounds that make up pronunciations of words). These two tasks are interesting for self-supervised representation learning as the former requires representations that discriminate speakers but are invariant to content, while the latter requires the opposite. Strong performance on both tasks thus suggests strong generalization and disentanglement.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Experimental Details", "text": "We follow the setup of Oord et al. [2018] unless specified otherwise and use a 100-hour subset of the publicly available LibriSpeech dataset [Panayotov et al., 2015]. It contains the utterances of 251 different speakers with aligned phone labels divided into 41 classes. These phone labels were provided by Oord et al. [2018] who obtained them by force-aligning phone sequences using the Kaldi toolkit [Povey et al., 2011] and pre-trained models on Librispeech [Panayotov, 2014]. We first train the self-supervised model consisting of five convolutional layers and one autoregressive module, a single-layer gated recurrent unit (GRU). After convergence, a linear multi-class classifier is trained on top of the context-aggregate representation c M without fine-tuning the representations. Remaining implementation details are presented in Appendix A.2.", "publication_ref": ["b45", "b41", "b49", "b44"], "figure_ref": [], "table_ref": []}, {"heading": "Results", "text": "Following Table 3, we analyze the performance of models on phone and speaker classification accuracy. Randomly initialized features perform poorly, demonstrating that both tasks require complex representations. The traditional, hand-engineered MFCC features are commonly used in speech recognition systems [Ganchev et al., 2005], and improve over the random features, but provide limited linear separability on both tasks. On the speaker classification task, CPC and GIM outperform the supervised baselines despite their feature models having been trained without labels, and GIM without end-to-end backpropagation. In this setting, both GIM and Greedy Supervised, where individual layers are trained greedily with a supervised loss function, achieve similar results to their respective end-to-end trained counterparts (CPC and Supervised). When classifying phones, CPC does not reach the supervised performance (64.9% versus 77.7%). GIM achieves 62.5%, while Greedy Supervised accomplishes 73.4%. Thus, in contrast to the vision experiments (Section 4.1), we see similar differences in performance between the greedily trained models (GIM and Greedy Supervised) when compared to their respective end-to-end optimized counterparts (CPC and Supervised).\nOverall, the discrepancy between better-than-supervised performance on the speaker task and lessthan-optimal performance on the phone task suggests that GIM and CPC are biased towards extracting sequence-global features.\nAblation study The local greedy training enabled by GIM provides a step towards biologically plausible optimization and improves memory efficiency. However, the autoregressive module g ar aggregates its inputs over multiple patches and employs Backpropagation Through Time (BPTT), which puts a damper on both benefits. In Table 4, we present results on the performance of ablated models that restrict the flow of gradients through time. Table 4: Ablation studies on the Lib-riSpeech dataset for removing the biologically implausible and memoryheavy backpropagation through time.  3).\nIn order to limit the flow of gradients through time, we modify the autoregressive module. In general, the autoregressive module g ar takes the current input z t , as well as the hidden state of the previous time-step h t\u22121 , in order to produce its output c t , i.e. c t = g ar (z t , h t\u22121 ) (omitting the module-index m here for brevity). In the standard GIM model, we block the flow of gradients to the previous module, such that c t = g ar (GradientBlock(z t ), h t\u22121 ). In the ablation GIM without BPTT, we remove BPTT by blocking the flow of gradients between time-steps, such that c t = g ar (GradientBlock(z t ), GradientBlock(h t\u22121 )). For the ablation GIM without g ar , we remove the autoregressive module entirely. Here, the linear classifier is applied to the representation created by the last encoding module (i.e. z t ).\nIn Table 4, we present the performance of the ablated models. Together, these two ablations indicate a crucial difference between the tested downstream tasks. For the phone classification task, we see a steady decline of the performance when we reduce the modeling of temporal dependencies, indicating their importance for solving this task. When classifying the speaker identity, reducing the modeling of temporal dependencies in the ablated models barely influences their performance.\nTogether with the image classification results from Section 4.1, where no autoregressive module was employed either, this indicates that the GIM approach performs best on downstream tasks where temporal or context dependencies do not need to be modeled by an autoregressive module. In these settings, GIM can outperform the CPC model, which makes use of end-to-end backpropagation, a global objective, and BPTT.\nIntermediate module representations The greedy layer-wise training of GIM allows us to train arbitrarily deep models without ever running into a memory constraint. We investigate how the created representations develop in each individual module by training a linear classifier on top of each module and measuring their performance on the speaker classification task. With results presented in Figure 4, we first observe that each GIM module improves upon the representations of their predecessor. Interestingly, CPC exhibits similar performance in intermediate modules despite these modules relying solely on the error signal from the global loss function on the last module. This is in stark contrast with the supervised end-to-end model, whose intermediate layers lag behind their greedily trained counterparts. This suggests that, in contrast to the supervised loss, the InfoMax principle \"stacks well\", such that the greedy, iterative application of the InfoNCE loss performs similar to its global application.", "publication_ref": ["b12"], "figure_ref": ["fig_4"], "table_ref": ["tab_2", "tab_2"]}, {"heading": "Related Work", "text": "We have studied the effectiveness of the self-supervised CPC approach [H\u00e9naff et al., 2019, Oord et al., 2018 when applied to gradient-isolated modules, freeing the method from end-to-end backpropagation. There are a number of optimization algorithms that eliminate the need for backpropagation altogether [Balduzzi et al., 2015, Kohan et al., 2018, Lillicrap et al., 2016, Ororbia et al., 2018, Scellier and Bengio, 2017, Xiao et al., 2019. In contrast to our method, these methods employ a global supervised loss function and focus on finding more biologically plausible ways to assign credit to neurons.\nA recently published work by N\u00f8kland and Eidnes [2019] likewise demonstrates that backpropagationfree layer-wise training is possible. Their similarity loss might be vaguely interpreted as another way of enforcing clustered representations. However, while our method achieves this entirely in a selfsupervised fashion by clustering temporally or spatially nearby inputs, their similarity loss groups representations based on their class labels. Likewise, Belilovsky et al. [2019] showed that greedy layer-wise training with a supervised loss can scale to ImageNet. In an attempt to validate information bottleneck theory, Elad et al. [2018] develop a supervised, layer-wise training method that maximizes the mutual information between the outputs of a layer and the target whilst minimizing the mutual information between the inputs and outputs. In contrast to our proposal, these methods all rely on labeled data. Jaderberg et al. [2017] develop decoupled neural interfaces, which enjoy the same asynchronous training benefits as Greedy InfoMax (GIM), but achieve this by taking an end-to-end supervised loss and locally predicting its gradients. Bengio et al. [2007], Hinton et al. [2006] focus on deep belief networks and propose a greedy layer-wise unsupervised pretraining method based on Restricted Boltzmann Machine principles, followed by optimizing globally using a supervised loss. Lee et al. [2009] use convolutional deep belief networks for unsupervised pretraining on the TIMIT audio dataset and then evaluate their performance by training supervised classifiers on top. Gao et al. [2018], Ver Steeg and Galstyan [2015] explore total correlation explanation, which is related to mutual information maximization, and show that it can be applied for layer-by-layer training.\nSeveral recent works investigated the utilization of mutual information maximization in a representation learning setting [Belghazi et al., 2018, Hjelm et al., 2019, McAllester, 2018, Oord et al., 2018. Poole et al. [2018] analyse these recent works under a common framework and highlight that InfoNCE exhibits low variance at a cost of high bias and propose new lower bounds that allow for balancing this bias/variance trade-off. However, the analysis of these improved bounds in the context of interpatch mutual information optimization remains in order, and thus we focus on the original CPC In-foNCE loss to bias the learned representations towards slow features [Wiskott and Sejnowski, 2002].\nOutside the information-theoretic framework, context prediction methods have been explored for unsupervised representation learning. A prominent approach in language processing is Word2Vec [Mikolov et al., 2013], in which a word is directly predicted given its context (continuous skip-gram). Likewise, Doersch et al. [2015] study such an approach for the visual domain. Similarly, graph neural networks use contrastive principles to learn unsupervised node embeddings based on their neighbors [Kipf and Welling, 2016, Nickel et al., 2011, Perozzi et al., 2014, Veli\u010dkovi\u0107 et al., 2018. Noise contrastive estimation has also been explored for independent component analysis [Hyvarinen and Morioka, 2016, Hyvarinen et al., 2018. Schmidhuber [1992] proposes a method where individual features are minimized such that they cannot be predicted from other features, forcing them to extract independent factors that carry statistical information, at the risk of neurons latching onto local independent noise sources in the input.", "publication_ref": ["b16", "b41", "b0", "b28", "b33", "b42", "b52", "b59", "b40", "b2", "b10", "b25", "b3", "b17", "b32", "b13", "b1", "b18", "b36", "b41", "b48", "b58", "b37", "b9", "b27", "b38", "b47", "b56", "b20", "b22", "b53"], "figure_ref": [], "table_ref": []}, {"heading": "Conclusion", "text": "We presented Greedy InfoMax, a novel self-supervised greedy learning approach. The relatively strong performance demonstrates that deep neural networks do not necessarily require end-to-end backpropagation of a supervised loss on perceptual tasks. Our proposal enables greedy self-supervised training, which makes the model less vulnerable to overfitting, reduces the vanishing gradient problem and enables memory-efficient asynchronous distributed training. While the biological plausibility of our proposal is limited by the use of negative samples and within-module backpropagation, the results provide evidence that the theorized self-organization in biological perceptual networks is at least feasible and effective in artificial networks, providing food for thought on the credit assignment discussion in perceptual networks , Linsker, 1988.", "publication_ref": ["b34"], "figure_ref": [], "table_ref": []}, {"heading": "A Experimental Setup", "text": "We use PyTorch [Paszke et al., 2017] for all our experiments.", "publication_ref": ["b46"], "figure_ref": [], "table_ref": []}, {"heading": "A.1 Vision Experiments", "text": "In our vision experiments, we employ the ResNet-50 v2 architecture [He et al., 2016], in which we remove the max-pooling layer and adjust the first convolutional layer in such a way that the size of the feature map stays constant. Thus, the first convolutional layer uses a kernel size of 5, a stride of 1 and a padding of 2. Additionally, we do not employ batch normalization [Ioffe and Szegedy, 2015].\nWe train our model on 8 GPUs (GeForce 1080 Ti) each with a minibatch of 16 images. We train it for 300 epochs using Adam [Kingma and Ba, 2014] and a learning rate of 1.5e-4 and use the same random seed in all our experiments.\nFor the self-supervised training using the InfoNCE objective, we need to contrast the predictions of the model for its future representations against negative samples. We draw these samples uniformly at random from across the input batch that is being evaluated. Thus, the negative samples can contain samples from the same image at different patch locations, as well as from different images. We found that including the positive sample (i.e. the future representation that is currently to be predicted) in the negative samples did not have a negative effect on the final performance. For each evaluation of the InfoNCE loss, we use 16 negative samples and predict up to k = 5 rows into the future. For contrasting patches against one another, we spatially mean-pool the representations of each patch.\nBefore applying the linear logistic regression classifier on the output of the third residual block, we spatially mean-pool the created representations of size 7 \u00d7 7 \u00d7 1024 again. Thus, the final representation from which we learn to predict class labels is a 1024-dimensional vector. We use the Adam optimizer for the training of the linear logistic regression classifier and set its learning rate to 1e-3. We optimized this hyperparameter by splitting the labeled training set provided by the STL-10 dataset into a validation set consisting of 20% of the images and a corresponding training set with the remaining images.", "publication_ref": ["b15", "b23", "b26"], "figure_ref": [], "table_ref": []}, {"heading": "A.2 Audio Experiments", "text": "The detailed description of our employed architecture is given in Table 5. We train our model on 4 GPUs (GeForce 1080 Ti) each with a minibatch of 8 examples. Our model is optimized with Adam and a learning rate of 2e-4 for 1000 epochs. We use the same random seed for all our experiments. Overall, our hyperparameters were chosen to be consistent with Oord et al. [2018]. Similarly to the vision experiments, we take the negative samples uniformly at random from across the batch that is currently evaluated. Again, this may include the positive sample. In our audio experiments, we use a total of 10 negative samples and predict up to k = 12 time-steps into the future.\nWe train the linear logistic regression classifier using the representations of the top, autoregressive module without pooling. Again, we employ the Adam optimizer but select different learning rates than before. For this hyperparameter search, we split the training set provided by Oord et al. [2018] into two random subsets using 25% of the samples as a validation set. In the speaker classification experiment, we used a learning rate of 1e-3, while we set it to 1e-4 for the phone classification experiment.", "publication_ref": ["b41"], "figure_ref": [], "table_ref": ["tab_3"]}, {"heading": "Acknowledgments", "text": "We thank Jorn Peters, Marco Federici, Rudy Corona, Pascal Esser, Joop Pascha and the anonymous reviewers for their insightful comments. This research was supported by Philips Research and the NVIDIA GPU Grant.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Kickback cuts backprop's red-tape: biologically plausible credit assignment in neural networks", "journal": "", "year": "2015", "authors": "David Balduzzi; Hastagiri Vanchinathan; Joachim Buhmann"}, {"ref_id": "b1", "title": "Mutual information neural estimation", "journal": "", "year": "2018", "authors": "Mohamed Ishmael Belghazi; Aristide Baratin; Sai Rajeshwar; Sherjil Ozair; Yoshua Bengio; Devon Hjelm; Aaron Courville"}, {"ref_id": "b2", "title": "Greedy layerwise learning can scale to imagenet", "journal": "", "year": "2019", "authors": "Eugene Belilovsky; Michael Eickenberg; Edouard Oyallon"}, {"ref_id": "b3", "title": "Greedy layer-wise training of deep networks", "journal": "", "year": "2007", "authors": "Yoshua Bengio; Pascal Lamblin; Dan Popovici; Hugo Larochelle"}, {"ref_id": "b4", "title": "Towards biologically plausible deep learning", "journal": "", "year": "2015", "authors": "Yoshua Bengio; Dong-Hyun Lee; Jorg Bornschein; Thomas Mesnard; Zhouhan Lin"}, {"ref_id": "b5", "title": "Spike timing-dependent plasticity: a hebbian learning rule", "journal": "Annual Review of Neuroscience", "year": "2008", "authors": "Natalia Caporale; Yang Dan"}, {"ref_id": "b6", "title": "An analysis of single-layer networks in unsupervised feature learning", "journal": "", "year": "2011", "authors": "Adam Coates; Andrew Ng; Honglak Lee"}, {"ref_id": "b7", "title": "The recent excitement about neural networks", "journal": "Nature", "year": "1989", "authors": "Francis Crick"}, {"ref_id": "b8", "title": "Improved regularization of convolutional neural networks with cutout", "journal": "", "year": "2017", "authors": "Terrance Devries; W Graham;  Taylor"}, {"ref_id": "b9", "title": "Unsupervised visual representation learning by context prediction", "journal": "", "year": "2015", "authors": "Carl Doersch; Abhinav Gupta; Alexei A Efros"}, {"ref_id": "b10", "title": "The effectiveness of layer-by-layer training using the information bottleneck principle", "journal": "OpenReview", "year": "2018", "authors": "Adar Elad; Doron Haviv; Yochai Blau; Tomer Michaeli"}, {"ref_id": "b11", "title": "The free-energy principle: a unified brain theory?", "journal": "Nature reviews neuroscience", "year": "2010", "authors": "Karl Friston"}, {"ref_id": "b12", "title": "Comparative evaluation of various mfcc implementations on the speaker verification task", "journal": "", "year": "2005", "authors": "Todor Ganchev; Nikos Fakotakis; George Kokkinakis"}, {"ref_id": "b13", "title": "Rob Brekelmans, Greg Ver Steeg, and Aram Galstyan. Auto-encoding total correlation explanation", "journal": "", "year": "2018", "authors": "Shuyang Gao"}, {"ref_id": "b14", "title": "Noise-contrastive estimation: A new estimation principle for unnormalized statistical models", "journal": "", "year": "2010", "authors": "Michael Gutmann; Aapo Hyv\u00e4rinen"}, {"ref_id": "b15", "title": "Identity mappings in deep residual networks", "journal": "Springer", "year": "2016", "authors": "Kaiming He; Xiangyu Zhang; Shaoqing Ren; Jian Sun"}, {"ref_id": "b16", "title": "Data-efficient image recognition with contrastive predictive coding", "journal": "", "year": "2019", "authors": "J Olivier; Ali H\u00e9naff; Carl Razavi;  Doersch; Aaron Sm Eslami;  Van Den Oord"}, {"ref_id": "b17", "title": "A fast learning algorithm for deep belief nets", "journal": "Neural computation", "year": "2006", "authors": "Geoffrey E Hinton; Simon Osindero; Yee-Whye Teh"}, {"ref_id": "b18", "title": "Learning deep representations by mutual information estimation and maximization", "journal": "", "year": "2019", "authors": "Alex R Devon Hjelm; Samuel Fedorov; Karan Lavoie-Marchildon; Adam Grewal; Yoshua Trischler;  Bengio"}, {"ref_id": "b19", "title": "Learning discrete representations via information maximizing self-augmented training", "journal": "", "year": "2017", "authors": "Weihua Hu; Takeru Miyato; Seiya Tokui; Eiichi Matsumoto; Masashi Sugiyama"}, {"ref_id": "b20", "title": "Unsupervised feature extraction by time-contrastive learning and nonlinear ica", "journal": "", "year": "2016", "authors": "Aapo Hyvarinen; Hiroshi Morioka"}, {"ref_id": "b21", "title": "Nonlinear ICA of Temporally Dependent Stationary Sources", "journal": "PMLR", "year": "2017", "authors": "Aapo Hyvarinen; Hiroshi Morioka"}, {"ref_id": "b22", "title": "Nonlinear ICA using auxiliary variables and generalized contrastive learning", "journal": "", "year": "2018-05", "authors": "Aapo Hyvarinen; Hiroaki Sasaki; Richard E Turner"}, {"ref_id": "b23", "title": "Batch normalization: Accelerating deep network training by reducing internal covariate shift", "journal": "", "year": "2015", "authors": "Sergey Ioffe; Christian Szegedy"}, {"ref_id": "b24", "title": "Deep invertible networks", "journal": "", "year": "2018", "authors": "J\u00f6rn-Henrik Jacobsen; Arnold Smeulders; Edouard Oyallon"}, {"ref_id": "b25", "title": "Decoupled neural interfaces using synthetic gradients", "journal": "", "year": "2017", "authors": "Max Jaderberg; Wojciech Marian Czarnecki; Simon Osindero; Oriol Vinyals; Alex Graves; David Silver; Koray Kavukcuoglu"}, {"ref_id": "b26", "title": "Adam: A method for stochastic optimization", "journal": "", "year": "2014", "authors": "P Diederik; Jimmy Kingma;  Ba"}, {"ref_id": "b27", "title": "Variational graph auto-encoders", "journal": "", "year": "2016", "authors": "N Thomas; Max Kipf;  Welling"}, {"ref_id": "b28", "title": "Error forward-propagation: Reusing feedforward connections to propagate errors in deep learning", "journal": "", "year": "2018", "authors": " Adam A Kohan; Hava T Edward A Rietman;  Siegelmann"}, {"ref_id": "b29", "title": "Discriminative clustering by regularized information maximization", "journal": "", "year": "2010", "authors": "Andreas Krause; Pietro Perona; Ryan G Gomes"}, {"ref_id": "b30", "title": "Imagenet classification with deep convolutional neural networks", "journal": "", "year": "2012", "authors": "Alex Krizhevsky; Ilya Sutskever; Geoffrey E Hinton"}, {"ref_id": "b31", "title": "Difference target propagation", "journal": "Springer", "year": "2015", "authors": "Dong-Hyun Lee; Saizheng Zhang; Asja Fischer; Yoshua Bengio"}, {"ref_id": "b32", "title": "Unsupervised feature learning for audio classification using convolutional deep belief networks", "journal": "", "year": "2009", "authors": "Honglak Lee; Peter Pham; Yan Largman; Andrew Y Ng"}, {"ref_id": "b33", "title": "Random synaptic feedback weights support error backpropagation for deep learning", "journal": "Nature communications", "year": "2016", "authors": "P Timothy; Daniel Lillicrap;  Cownden; B Douglas; Colin J Tweed;  Akerman"}, {"ref_id": "b34", "title": "Self-organization in a perceptual network", "journal": "Computer", "year": "1988", "authors": "Ralph Linsker"}, {"ref_id": "b35", "title": "Toward an integration of deep learning and neuroscience", "journal": "Frontiers in computational neuroscience", "year": "2016", "authors": "Greg Adam H Marblestone; Konrad P Wayne;  Kording"}, {"ref_id": "b36", "title": "Information theoretic co-training", "journal": "", "year": "2018", "authors": "David Mcallester"}, {"ref_id": "b37", "title": "Distributed representations of words and phrases and their compositionality", "journal": "", "year": "2013", "authors": "Tomas Mikolov; Ilya Sutskever; Kai Chen; Greg S Corrado; Jeff Dean"}, {"ref_id": "b38", "title": "A three-way model for collective learning on multi-relational data", "journal": "", "year": "2011", "authors": "Maximilian Nickel; Hans-Peter Volker Tresp;  Kriegel"}, {"ref_id": "b39", "title": "A review of relational machine learning for knowledge graphs", "journal": "Proceedings of the IEEE", "year": "2015", "authors": "Maximilian Nickel; Kevin Murphy; Volker Tresp; Evgeniy Gabrilovich"}, {"ref_id": "b40", "title": "Training neural networks with local error signals", "journal": "", "year": "2019", "authors": "Arild N\u00f8kland; Lars Hiller Eidnes"}, {"ref_id": "b41", "title": "Representation learning with contrastive predictive coding", "journal": "", "year": "2018", "authors": "Aaron Van Den Oord; Yazhe Li; Oriol Vinyals"}, {"ref_id": "b42", "title": "Conducting credit assignment by aligning local representations", "journal": "", "year": "2018", "authors": "Ankur Alexander G Ororbia; Daniel Mali; C Lee Kifer;  Giles"}, {"ref_id": "b43", "title": "Predictive information in a sensory population", "journal": "Proceedings of the National Academy of Sciences", "year": "2015", "authors": "E Stephanie; Olivier Palmer;  Marre; J Michael; William Berry;  Bialek"}, {"ref_id": "b44", "title": "Kaldi pretrained model on LibriSpeech SAT and DNN", "journal": "", "year": "2014-07", "authors": "Vassil Panayotov"}, {"ref_id": "b45", "title": "Librispeech: an asr corpus based on public domain audio books", "journal": "IEEE", "year": "2015", "authors": "Vassil Panayotov; Guoguo Chen; Daniel Povey; Sanjeev Khudanpur"}, {"ref_id": "b46", "title": "Automatic differentiation in pytorch", "journal": "", "year": "2017", "authors": "Adam Paszke; Sam Gross; Soumith Chintala; Gregory Chanan; Edward Yang; Zachary Devito; Zeming Lin; Alban Desmaison; Luca Antiga; Adam Lerer"}, {"ref_id": "b47", "title": "Deepwalk: Online learning of social representations", "journal": "ACM", "year": "2014", "authors": "Bryan Perozzi; Rami Al-Rfou; Steven Skiena"}, {"ref_id": "b48", "title": "On variational lower bounds of mutual information", "journal": "", "year": "2018", "authors": "Ben Poole; Sherjil Ozair ; Alexander A Alemi; George Tucker"}, {"ref_id": "b49", "title": "The kaldi speech recognition toolkit", "journal": "IEEE Signal Processing Society", "year": "2011", "authors": "Daniel Povey; Arnab Ghoshal; Gilles Boulianne; Lukas Burget; Ondrej Glembek; Nagendra Goel; Mirko Hannemann; Petr Motlicek; Yanmin Qian; Petr Schwarz"}, {"ref_id": "b50", "title": "Predictive coding in the visual cortex: a functional interpretation of some extra-classical receptive-field effects", "journal": "Nature neuroscience", "year": "1999", "authors": "P N Rajesh;  Rao; H Dana;  Ballard"}, {"ref_id": "b51", "title": "Gradient checkpointing", "journal": "", "year": "2017", "authors": "Tim Salimans; Yaroslav Bulatov"}, {"ref_id": "b52", "title": "Equilibrium propagation: bridging the gap between energybased models and backpropagation", "journal": "Frontiers in computational neuroscience", "year": "2017", "authors": "Benjamin Scellier; Yoshua Bengio"}, {"ref_id": "b53", "title": "Learning factorial codes by predictability minimization", "journal": "Neural Computation", "year": "1992", "authors": "J\u00fcrgen Schmidhuber"}, {"ref_id": "b54", "title": "Very deep convolutional networks for large-scale image recognition", "journal": "", "year": "2014", "authors": "Karen Simonyan; Andrew Zisserman"}, {"ref_id": "b55", "title": "Going deeper with convolutions", "journal": "", "year": "2015", "authors": "Christian Szegedy; Wei Liu; Yangqing Jia; Pierre Sermanet; Scott Reed; Dragomir Anguelov; Dumitru Erhan; Vincent Vanhoucke; Andrew Rabinovich"}, {"ref_id": "b56", "title": "Deep graph infomax", "journal": "", "year": "2018", "authors": "Petar Veli\u010dkovi\u0107; William Fedus; L William; Pietro Hamilton; Yoshua Li\u00f2; R Devon Bengio;  Hjelm"}, {"ref_id": "b57", "title": "Maximally informative hierarchical representations of High-Dimensional data", "journal": "", "year": "2015-02", "authors": "Greg Ver Steeg; Aram Galstyan"}, {"ref_id": "b58", "title": "Slow feature analysis: unsupervised learning of invariances", "journal": "Neural Comput", "year": "2002-04", "authors": "Laurenz Wiskott; Terrence J Sejnowski"}, {"ref_id": "b59", "title": "Biologically-plausible learning algorithms can scale to large datasets", "journal": "", "year": "2019", "authors": "Will Xiao; Honglin Chen; Qianli Liao; Tomaso Poggio"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 1 :1Figure 1: The Greedy InfoMax Learning Approach. (Left) For the self-supervised learning of representations, we stack a number of modules through which the input is forward-propagated in the usual way, but gradients do not propagate backward. Instead, every module is trained greedily using a local loss. (Right) Every encoding module maps its inputs z m\u22121 t", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 2 :2Figure2: Groups of 4 image patches that excite a specific neuron, at 3 levels in the model (rows). Despite unsupervised greedy training, neurons appear to extract increasingly semantic features. Best viewed on screen.", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Figure 3 :3Figure 3: Training curves for optimizing all modules simultaneously (blue) or iteratively, one at a time (red).While there is no difference in the training methods for the first module (a), later modules (b, c) start out with a lower loss and tend to overfit more when trained iteratively on top of already converged modules.", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "Figure 4 :4Figure4: Speaker Classification error rates on a log scale (lower is better) for intermediate representations (layers 1 to 5), as well as for the final representation created by the autoregressive layer (corresponding to the results in Table3).", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "STL-10 classification results on the test set. The GIM model outperforms the CPC model, despite a lack of end-to-end backpropagation and without the use of a global objective. (\u00b1 standard deviation over 4 training runs.)", "figure_data": "MethodAccuracy (%)Deep InfoMax [Hjelm et al., 2019]78.2Predsim [N\u00f8kland and Eidnes, 2019]80.8Randomly initialized27.0Supervised71.4Greedy Supervised65.2CPC80.5 \u00b1 3.1Greedy InfoMax (GIM)81.9 \u00b1 0.3"}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "GPU memory consumption during training. All models consist of the ResNet-50 architecture and only differ in their training approach. GIM allows efficient greedy training.", "figure_data": "MethodGPU memory (GB)Supervised6.3CPC7.7GIM -all modules7.0GIM -1st module2.5"}, {"figure_label": "3", "figure_type": "table", "figure_id": "tab_2", "figure_caption": "Results for classifying speaker identity and phone labels in the LibriSpeech dataset. All models use the same audio input sizes and the same architecture. Greedy InfoMax creates representations that are useful for audio classification tasks despite its greedy training and lack of a global objective. In the original implementation, Oord et al.[2018]  achieved 64.6% for the phone and 97.4% for the speaker classification task. b Baseline results from Oord et al.[2018].", "figure_data": "PhoneSpeakerMethodClassificationClassificationAccuracy (%)Accuracy (%)Randomly initialized b27.61.9MFCC features b39.717.6Supervised77.798.9Greedy Supervised73.498.7CPC [Oord et al., 2018] a64.999.6Greedy InfoMax (GIM)62.599.4"}, {"figure_label": "5", "figure_type": "table", "figure_id": "tab_3", "figure_caption": "General outline of our architecture for the audio experiments. For applying the InfoNCE objective on these layers, we randomly sample a time-window of size 128 to decrease the dimensionality.", "figure_data": "LayerOutput SizeParameters(Sequence Length \u00d7 Channels)KernelStridePaddingInput20480 \u00d7 1Conv14095 a \u00d7 5121052Conv21023 a \u00d7 512842Conv3512 a \u00d7 512422Conv4257 a \u00d7 512422Conv5128 \u00d7 512121GRU128 \u00d7 256---"}], "formulas": [{"formula_id": "formula_0", "formula_text": "L N = \u2212 k E X log f k (z t+k , c t ) zj \u2208X f k (z j , c t )", "formula_coordinates": [3.0, 222.93, 263.35, 154.7, 26.88]}, {"formula_id": "formula_1", "formula_text": ")1", "formula_coordinates": [3.0, 496.26, 270.41, 7.74, 8.64]}, {"formula_id": "formula_2", "formula_text": "f k (z t+k , c t ) \u221d p(z t+k |c t ) p(z t+k ) .(2)", "formula_coordinates": [3.0, 251.56, 398.1, 252.44, 23.23]}, {"formula_id": "formula_3", "formula_text": "f m k (z m t+k , z m t ) = exp z m t+k T W m k z m t (3) L m N = \u2212 k E X log f m k (z m t+k , z m t ) z m j \u2208X f m k (z m j , z m t ) .(4)", "formula_coordinates": [4.0, 193.88, 339.68, 310.12, 50.65]}, {"formula_id": "formula_4", "formula_text": "z M t = g M enc g M \u22121 enc \u2022 \u2022 \u2022 g 1 enc (x t ) .(5)", "formula_coordinates": [4.0, 233.86, 426.18, 270.14, 12.69]}, {"formula_id": "formula_5", "formula_text": "c M t = g M ar GradientBlock z M \u22121 0:t .", "formula_coordinates": [4.0, 108.0, 493.32, 151.58, 13.03]}, {"formula_id": "formula_6", "formula_text": "f M k (z M \u22121 t+k , c M t ) = exp GradientBlock z M \u22121 t+k T W M k c M t .(6)", "formula_coordinates": [4.0, 181.29, 522.54, 322.71, 15.69]}], "doi": ""}