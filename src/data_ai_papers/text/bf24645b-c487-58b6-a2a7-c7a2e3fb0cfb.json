{"title": "Learning Synchronous Grammars for Semantic Parsing with Lambda Calculus", "authors": "Yuk Wah Wong; Raymond J Mooney", "pub_date": "", "abstract": "This paper presents the first empirical results to our knowledge on learning synchronous grammars that generate logical forms. Using statistical machine translation techniques, a semantic parser based on a synchronous context-free grammar augmented with \u03bboperators is learned given a set of training sentences and their correct logical forms. The resulting parser is shown to be the bestperforming system so far in a database query domain.", "sections": [{"heading": "Introduction", "text": "Originally developed as a theory of compiling programming languages (Aho and Ullman, 1972), synchronous grammars have seen a surge of interest recently in the statistical machine translation (SMT) community as a way of formalizing syntax-based translation models between natural languages (NL). In generating multiple parse trees in a single derivation, synchronous grammars are ideal for modeling syntax-based translation because they describe not only the hierarchical structures of a sentence and its translation, but also the exact correspondence between their sub-parts. Among the grammar formalisms successfully put into use in syntaxbased SMT are synchronous context-free grammars (SCFG) (Wu, 1997) and synchronous treesubstitution grammars (STSG) (Yamada and Knight, 2001). Both formalisms have led to SMT systems whose performance is state-of-the-art (Chiang, 2005;Galley et al., 2006).\nSynchronous grammars have also been used in other NLP tasks, most notably semantic parsing, which is the construction of a complete, formal meaning representation (MR) of an NL sentence. In our previous work (Wong and Mooney, 2006), semantic parsing is cast as a machine translation task, where an SCFG is used to model the translation of an NL into a formal meaning-representation language (MRL). Our algorithm, WASP, uses statistical models developed for syntax-based SMT for lexical learning and parse disambiguation. The result is a robust semantic parser that gives good performance in various domains. More recently, we show that our SCFG-based parser can be inverted to produce a state-of-the-art NL generator, where a formal MRL is translated into an NL (Wong and Mooney, 2007).\nCurrently, the use of learned synchronous grammars in semantic parsing and NL generation is limited to simple MRLs that are free of logical variables. This is because grammar formalisms such as SCFG do not have a principled mechanism for handling logical variables. This is unfortunate because most existing work on computational semantics is based on predicate logic, where logical variables play an important role (Blackburn and Bos, 2005). For some domains, this problem can be avoided by transforming a logical language into a variable-free, functional language (e.g. the GEOQUERY functional query language in Wong and Mooney (2006)). However, development of such a functional language is non-trivial, and as we will see, logical languages can be more appropriate for certain domains.\nOn the other hand, most existing methods for mapping NL sentences to logical forms involve substantial hand-written components that are difficult to maintain (Joshi and Vijay-Shanker, 2001;Bayer et al., 2004;Bos, 2005). Zettlemoyer and Collins (2005) present a statistical method that is consider-ably more robust, but it still relies on hand-written rules for lexical acquisition, which can create a performance bottleneck.\nIn this work, we show that methods developed for SMT can be brought to bear on tasks where logical forms are involved, such as semantic parsing. In particular, we extend the WASP semantic parsing algorithm by adding variable-binding \u03bb-operators to the underlying SCFG. The resulting synchronous grammar generates logical forms using \u03bb-calculus (Montague, 1970). A semantic parser is learned given a set of sentences and their correct logical forms using SMT methods. The new algorithm is called \u03bb-WASP, and is shown to be the best-performing system so far in the GEOQUERY domain.", "publication_ref": ["b0", "b16", "b17", "b4", "b6", "b14", "b15", "b2", "b14", "b9", "b1", "b3", "b19", "b10"], "figure_ref": [], "table_ref": []}, {"heading": "Test Domain", "text": "In this work, we mainly consider the GEOQUERY domain, where a query language based on Prolog is used to query a database on U.S. geography (Zelle and Mooney, 1996). The query language consists of logical forms augmented with meta-predicates for concepts such as smallest and count. Figure 1 shows two sample logical forms and their English glosses. Throughout this paper, we use the notation x 1 , x 2 , . . . for logical variables.\nAlthough Prolog logical forms are the main focus of this paper, our algorithm makes minimal assumptions about the target MRL. The only restriction on the MRL is that it be defined by an unambiguous context-free grammar (CFG) that divides a logical form into subformulas (and terms into subterms). Figure 2(a) shows a sample parse tree of a logical form, where each CFG production corresponds to a subformula.", "publication_ref": ["b18"], "figure_ref": [], "table_ref": []}, {"heading": "The Semantic Parsing Algorithm", "text": "Our work is based on the WASP semantic parsing algorithm (Wong and Mooney, 2006), which translates NL sentences into MRs using an SCFG. In WASP, each SCFG production has the following form:\nA \u2192 \u03b1, \u03b2(1)\nwhere \u03b1 is an NL phrase and \u03b2 is the MR translation of \u03b1. Both \u03b1 and \u03b2 are strings of terminal and nonterminal symbols. Each non-terminal in \u03b1 appears in \u03b2 exactly once. We use indices to show the correspondence between non-terminals in \u03b1 and \u03b2. All derivations start with a pair of co-indexed start symbols, S 1 , S 1 . Each step of a derivation involves the rewriting of a pair of co-indexed non-terminals by the same SCFG production. The yield of a derivation is a pair of terminal strings, e, f , where e is an NL sentence and f is the MR translation of e.\nFor convenience, we call an SCFG production a rule throughout this paper. While WASP works well for target MRLs that are free of logical variables such as CLANG (Wong and Mooney, 2006), it cannot easily handle various kinds of logical forms used in computational semantics, such as predicate logic. The problem is that WASP lacks a principled mechanism for handling logical variables. In this work, we extend the WASP algorithm by adding a variable-binding mechanism based on \u03bb-calculus, which allows for compositional semantics for logical forms.\nThis work is based on an extended version of SCFG, which we call \u03bb-SCFG, where each rule has the following form:\nA \u2192 \u03b1, \u03bbx 1 . . . \u03bbx k .\u03b2 (2)\nwhere \u03b1 is an NL phrase and \u03b2 is the MR translation of \u03b1. Unlike (1), \u03b2 is a string of terminals, non-terminals, and logical variables. The variable-binding operator \u03bb binds occurrences of the logical variables x 1 , . . . , x k in \u03b2, which makes \u03bbx 1 . . . \u03bbx k .\u03b2 a \u03bb-function of arity k. When applied to a list of arguments, (x i 1 , . . . , x i k ), the \u03bbfunction gives \u03b2\u03c3, where \u03c3 is a substitution operator, {x 1 /x i 1 , . . . , x k /x i k }, that replaces all bound occurrences of x j in \u03b2 with x i j . If any of the arguments x i j appear in \u03b2 as a free variable (i.e. not bound by any \u03bb), then those free variables in \u03b2 must be renamed before function application takes place. Each non-terminal A j in \u03b2 is followed by a list of arguments, x j = (x j 1 , . . . , x j k j ). During parsing, A j must be rewritten by a \u03bb-function f j of arity k j . Like SCFG, a derivation starts with a pair of co-indexed start symbols and ends when all nonterminals have been rewritten. To compute the yield of a derivation, each f j is applied to its corresponding arguments x j to obtain an MR string free of \u03bboperators with logical variables properly named.  3. To compute the yield of this MR parse tree, we start from the leaf nodes: apply \u03bbx 1 .state(x 1 ) to the argument (x 1 ), and \u03bbx 1 .\u03bbx 2 .area(x 1 ,x 2 ) to the arguments (x 1 , x 2 ). This results in two MR strings: state(x 1 ) and area(x 1 ,x 2 ). Substituting these MR strings for the FORM nonterminals in the parent node gives the \u03bb-function \u03bbx 1 .smallest(x 2 ,(state(x 1 ),area(x 1 ,x 2 ))). Applying this \u03bb-function to (x 1 ) gives the MR string smallest(x 2 ,(state(x 1 ),area(x 1 ,x 2 ))). Substituting this MR string for the FORM nonterminal in the grandparent node in turn gives the logical form in Figure 1(a). This is the yield of the MR parse tree, since the root node of the parse tree is reached.", "publication_ref": ["b14", "b14"], "figure_ref": [], "table_ref": []}, {"heading": "Lexical Acquisition", "text": "Given a set of training sentences paired with their correct logical forms, { e i , f i }, the main learning task is to find a \u03bb-SCFG, G, that covers the training data. Like most existing work on syntax-based SMT (Chiang, 2005;Galley et al., 2006), we construct G using rules extracted from word alignments. We use the K = 5 most probable word alignments for the training set given by GIZA++ (Och and Ney, 2003), with variable names ignored to reduce sparsity. Rules are then extracted from each word alignment as follows.\nTo ground our discussion, we use the word alignment in Figure 4 as an example. To represent the logical form in Figure 4, we use its linearized parse-a list of MRL productions that generate the logical form, in top-down, left-most order (cf. Figure 2(a)). Since the MRL grammar is unambiguous, every logical form has a unique linearized parse. We assume the alignment to be n-to-1, where each word is linked to at most one MRL production.\nRules are extracted in a bottom-up manner, starting with MRL productions at the leaves of the MR parse tree, e.g. FORM \u2192 state(x 1 ) in Figure 2(a). Given an MRL production, A \u2192 \u03b2, a rule A \u2192 \u03b1, \u03bbx i 1 . . . \u03bbx i k .\u03b2 is extracted such that:\n(1) \u03b1 is the NL phrase linked to the MRL production; (2) x i 1 , . . . , x i k are the logical variables that appear in \u03b2 and outside the current leaf node in the MR parse tree. If x i 1 , . . . , x i k were not bound by \u03bb, they would become free variables in \u03b2, subject to renaming during function application (and therefore, invisible to the rest of the logical form). For example, since x 1 is an argument of the state predicate as well as answer and area, x 1 must be bound (cf. the corresponding tree node in Figure 2(b)). The rule extracted for the state predicate is shown in Figure 3.\nThe case for the internal nodes of the MR parse tree is similar. Given an MRL production, A \u2192 \u03b2, where \u03b2 contains non-terminals A 1 , . . . , A n , a rule A \u2192 \u03b1, \u03bbx i 1 . . . \u03bbx i k .\u03b2 \u2032 is extracted such that: (1) \u03b1 is the NL phrase linked to the MRL production, with non-terminals A 1 , . . . , A n showing the positions of the argument strings; (2) \u03b2 \u2032 is \u03b2 with each non-terminal A j replaced with A j (x j 1 , . . . , x j k j ), where x j 1 , . . . , x j k j are the bound variables in the \u03bb-function used to rewrite A j ; (3) x i 1 , . . . , x i k are the logical variables that appear in \u03b2 \u2032 and outside the current MR sub-parse. For example, see the rule extracted for the smallest predicate in Figure 3, where x 2 is an argument of smallest, but it does not appear outside the formula smallest(...), so x 2 need not be bound by \u03bb. On the other hand, x 1 appears in \u03b2 \u2032 , and it appears outside smallest(...) (as an argument of answer), so x 1 must be bound.\nFORM \u2192 state , \u03bbx1.state(x1) FORM \u2192 by area , \u03bbx1.\u03bbx2.area(x1,x2) FORM \u2192 smallest FORM 1 FORM 2 , \u03bbx1.smallest(x2,(FORM 1 (x1),FORM 2 (x1, x2))) QUERY \u2192 what is (1) FORM 1 , answer(x1,FORM 1 (x1))\nRule extraction continues in this manner until the root of the MR parse tree is reached. Figure 3 shows all the rules extracted from Figure 4. 1", "publication_ref": ["b4", "b6", "b11"], "figure_ref": [], "table_ref": []}, {"heading": "Probabilistic Semantic Parsing Model", "text": "Since the learned \u03bb-SCFG can be ambiguous, a probabilistic model is needed for parse disambiguation. We use the maximum-entropy model proposed in Wong and Mooney (2006), which defines a conditional probability distribution over derivations given an observed NL sentence. The output MR is the yield of the most probable derivation according to this model.\nParameter estimation involves maximizing the conditional log-likelihood of the training set. For each rule, r, there is a feature that returns the number of times r is used in a derivation. More features will be introduced in Section 5.\nTo see why the current lexical acquisition algorithm can be problematic, consider the word alignment in Figure 5 (for the sentence pair in Figure 1(b)). No rules can be extracted for the state predicate, because the shortest NL substring that covers the word states and the argument string Texas, i.e. states bordering Texas, contains the word bordering, which is linked to an MRL production outside the MR sub-parse rooted at state. Rule extraction is forbidden in this case because it would destroy the link between bordering and next to. In other words, the NL and MR parse trees are not isomorphic.\nThis problem can be ameliorated by transforming the logical form of each training sentence so that the NL and MR parse trees are maximally isomorphic. This is possible because some of the operators used in the logical forms, notably the conjunction operator (,), are both associative (a,(b,c) = (a,b),c = a,b,c) and commutative (a,b = b,a). Hence, conjuncts can be reordered and regrouped without changing the meaning of a conjunction. For example, rule extraction would be possible if the positions of the next to and state conjuncts were switched. We present a method for regrouping conjuncts to promote isomorphism between NL and MR parse trees. 2 Given a conjunction, it does the following: (See Figure 6 for the pseudocode, and Figure 5 for an illustration.)\nStep 1. Identify the MRL productions that correspond to the conjuncts and the meta-predicate that takes the conjunction as an argument (count in Figure 5), and figure them as vertices in an undi- Step 5. Find MST\nStep 4. Assign edge weights\nStep 6. Construct MR parse", "publication_ref": ["b14"], "figure_ref": [], "table_ref": []}, {"heading": "Form graph", "text": "Steps 1-3.\nFigure 5: Transforming the logical form in Figure 1(b). The step numbers correspond to those in Figure 6.\nInput: A conjunction, c, of n conjuncts; MRL productions, p1, . . . , pn, that correspond to each conjunct; an MRL production, p0, that corresponds to the meta-predicate taking c as an argument; an NL sentence, e; a word alignment, a.\nLet v(p) be the set of logical variables that appear in p. Create an undirected graph, \u0393, with vertices V = {pi|i = 0, . . . , n}\n1\nand edges E = {(pi, pj)|i < j, v(pi) \u2229 v(pj) = \u2205}. Let e(p) be the set of words in e to which p is linked according to a. Let span(pi, pj) be the shortest substring of e that 2 includes e(pi) \u222a e(pj). Subtract {(pi, pj)|i = 0, span(pi, pj) \u2229 e(p0) = \u2205} from E. Add edges (p0, pi) to E if pi is not already connected to p0.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "3", "text": "For each edge (pi, pj) in E, set edge weight to the minimum word distance between e(pi) and e(pj).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "4", "text": "Find a minimum spanning tree, T , for \u0393 using Kruskal's algorithm.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "5", "text": "Using p0 as the root, construct a conjunction c \u2032 based on T , and then replace c with c \u2032 .", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "6", "text": "Figure 6: Algorithm for regrouping conjuncts to promote isomorphism between NL and MR parse trees.\nrected graph, \u0393. An edge (p i , p j ) is in \u0393 if and only if p i and p j contain occurrences of the same logical variables. Each edge in \u0393 indicates a possible edge in the transformed MR parse tree. Intuitively, two concepts are closely related if they involve the same logical variables, and therefore, should be placed close together in the MR parse tree. By keeping occurrences of a logical variable in close proximity in the MR parse tree, we also avoid unnecessary variable bindings in the extracted rules.\nStep 2. Remove edges from \u0393 whose inclusion in the MR parse tree would prevent the NL and MR parse trees from being isomorphic.\nStep 3. Add edges to \u0393 to make sure that a spanning tree for \u0393 exists.\nSteps 4-6. Assign edge weights based on word dis-tance, find a minimum spanning tree, T , for \u0393, then regroup the conjuncts based on T . The choice of T reflects the intuition that words that occur close together in a sentence tend to be semantically related. This procedure is repeated for all conjunctions that appear in a logical form. Rules are then extracted from the same input alignment used to regroup conjuncts. Of course, the regrouping of conjuncts requires a good alignment to begin with, and that requires a reasonable ordering of conjuncts in the training data, since the alignment model is sensitive to word order. This suggests an iterative algorithm in which a better grouping of conjuncts leads to a better alignment model, which guides further regrouping until convergence. We did not pursue this, as it is not needed in our experiments so far. What is the entity that is a state and also a major river, that traverses something that is the largest?\n(b) answer (x1,smallest(x2,(highest(x1,(point(x1),loc(x1,x3),state(x3))),density(x1,x2)))) Among the highest points of all states, which one has the lowest population density?\n(c) answer(x1,equal(x1,stateid(alaska))) Alaska?\n(d) answer (x1,largest(x2,(largest(x1,(state(x1),next to(x1,x3),state(x3))),population(x1,x2)))) Among the largest state that borders some other state, which is the one with the largest population?\nFigure 7: Typical errors made by the \u03bb-WASP parser, along with their English interpretations, before any language modeling for the target MRL was done.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Modeling the Target MRL", "text": "In this section, we propose two methods for modeling the target MRL. This is motivated by the fact that many of the errors made by the \u03bb-WASP parser can be detected by inspecting the MR translations alone.\nFigure 7 shows some typical errors, which can be classified into two broad categories:\n1. Type mismatch errors. For example, a state cannot possibly be a river (Figure 7(a)). Also it is awkward to talk about the population density of a state's highest point (Figure 7(b)).\n2. Errors that do not involve type mismatch. For example, a query can be overly trivial (Figure 7(c)), or involve aggregate functions on a known singleton (Figure 7(d)).\nThe first type of errors can be fixed by type checking. Each m-place predicate is associated with a list of m-tuples showing all valid combinations of entity types that the m arguments can refer to: These m-tuples of entity types are given as domain knowledge. The parser maintains a set of possible entity types for each logical variable introduced in a partial derivation (except those that are no longer visible). If there is a logical variable that cannot refer to any types of entities (i.e. the set of entity types is empty), then the partial derivation is considered invalid. For example, based on the tuples shown above, point(x 1 ) and density(x 1 , ) cannot be both true, because {POINT} \u2229 {COUNTRY, STATE, CITY} = \u2205. The use of type checking is to exploit the fact that people tend not to ask questions that obviously have no valid answers (Grice, 1975). It is also similar to Schuler's (2003) use of model-theoretic interpretations to guide syntactic parsing.\nErrors that do not involve type mismatch are handled by adding new features to the maximumentropy model (Section 3.2). We only consider features that are based on the MR translations, and therefore, these features can be seen as an implicit language model of the target MRL (Papineni et al., 1997). Of the many features that we have tried, one feature set stands out as being the most effective, the two-level rules in Collins and Koo (2005), which give the number of times a given rule is used to expand a non-terminal in a given parent rule. We use only the MRL part of the rules. For example, a negative weight for the combination of QUERY \u2192 answer(x 1 ,FORM(x 1 )) and FORM \u2192 \u03bbx 1 .equal(x 1 , ) would discourage any parse that yields Figure 7(c). The two-level rules features, along with the features described in Section 3.2, are used in the final version of \u03bb-WASP.", "publication_ref": ["b8", "b13", "b12", "b5"], "figure_ref": [], "table_ref": []}, {"heading": "Experiments", "text": "We evaluated the \u03bb-WASP algorithm in the GEO-QUERY domain. The larger GEOQUERY corpus consists of 880 English questions gathered from various sources (Wong and Mooney, 2006). The questions were manually translated into Prolog logical forms. The average length of a sentence is 7.57 words.\nWe performed a single run of 10-fold cross validation, and measured the performance of the learned parsers using precision (percentage of translations that were correct), recall (percentage of test sentences that were correctly translated), and Fmeasure (harmonic mean of precision and recall). A translation is considered correct if it retrieves the same answer as the correct logical form.\nFigure 8 shows the learning curves for the \u03bb-965  A few observations can be made. First, algorithms that use Prolog logical forms as the target MRL generally show better recall than those using FunQL. In particular, \u03bb-WASP has the best recall by far. One reason is that it allows lexical items to be combined in ways not allowed by FunQL or the hand-written templates in Z&C, e.g. [smallest [state] [by area]] in Figure 3. Second, Z&C has the best precision, although their results are based on 280 test examples only, whereas our results are based on 10-fold cross validation. Third, \u03bb-WASP has the best F-measure.\nTo see the relative importance of each component of the \u03bb-WASP algorithm, we performed two ablation studies. First, we compared the performance of \u03bb-WASP with and without conjunct regrouping (Section 4). Second, we compared the performance of \u03bb-WASP with and without language modeling for the MRL (Section 5). Table 2 shows the results. It is found that conjunct regrouping improves recall (p < 0.01 based on the paired t-test), and the use of two-level rules in the maximum-entropy model improves precision and recall (p < 0.05). Type check-ing also significantly improves precision and recall.\nA major advantage of \u03bb-WASP over SCISSOR and Z&C is that it does not require any prior knowledge of the NL syntax. Figure 9 shows the performance of \u03bb-WASP on the multilingual GEOQUERY data set. The 250-example data set is a subset of the larger GEOQUERY corpus. All English questions in this data set were manually translated into Spanish, Japanese and Turkish, while the corresponding Prolog queries remain unchanged. Figure 9 shows that \u03bb-WASP performed comparably for all NLs. In contrast, SCISSOR cannot be used directly on the non-English data, because syntactic annotations are only available in English. Z&C cannot be used directly either, because it requires NL-specific templates for building CCG grammars.", "publication_ref": ["b14"], "figure_ref": [], "table_ref": []}, {"heading": "Conclusions", "text": "We have presented \u03bb-WASP, a semantic parsing algorithm based on a \u03bb-SCFG that generates logical forms using \u03bb-calculus. A semantic parser is learned given a set of training sentences and their correct logical forms using standard SMT techniques. The result is a robust semantic parser for predicate logic, and it is the best-performing system so far in the GEOQUERY domain.\nThis work shows that it is possible to use standard SMT methods in tasks where logical forms are involved. For example, it should be straightforward to adapt \u03bb-WASP to the NL generation task-all one needs is a decoder that can handle input logical forms. Other tasks that can potentially benefit from 966 ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgments:", "text": "We thank Rohit Kate, Razvan Bunescu and the anonymous reviewers for their valuable comments. This work was supported by a gift from Google Inc.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "", "text": "this include question answering and interlingual MT.\nIn future work, we plan to further generalize the synchronous parsing framework to allow different combinations of grammar formalisms. For example, to handle long-distance dependencies that occur in open-domain text, CCG and TAG would be more appropriate than CFG. Certain applications may require different meaning representations, e.g. frame semantics.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "The Theory of Parsing, Translation, and Compiling", "journal": "Prentice Hall", "year": "1972", "authors": "A V Aho; J D Ullman"}, {"ref_id": "b1", "title": "The MITRE logical form generation system", "journal": "", "year": "2004-07", "authors": "S Bayer; J Burger; W Greiff; B Wellner"}, {"ref_id": "b2", "title": "Representation and Inference for Natural Language: A First Course in Computational Semantics", "journal": "CSLI Publications", "year": "2005", "authors": "P Blackburn; J Bos"}, {"ref_id": "b3", "title": "Towards wide-coverage semantic interpretation", "journal": "", "year": "2005-01", "authors": "J Bos"}, {"ref_id": "b4", "title": "A hierarchical phrase-based model for statistical machine translation", "journal": "", "year": "2005-06", "authors": "D Chiang"}, {"ref_id": "b5", "title": "Discriminative reranking for natural language parsing", "journal": "Computational Linguistics", "year": "2005", "authors": "M Collins; T Koo"}, {"ref_id": "b6", "title": "Scalable inference and training of context-rich syntactic translation models", "journal": "", "year": "2006-07", "authors": "M Galley; J Graehl; K Knight; D Marcu; S Deneefe; W Wang; I Thayer"}, {"ref_id": "b7", "title": "A statistical semantic parser that integrates syntax and semantics", "journal": "", "year": "2005-07", "authors": "R Ge; R J Mooney"}, {"ref_id": "b8", "title": "Logic and conversation", "journal": "Academic Press", "year": "1975", "authors": "H P Grice"}, {"ref_id": "b9", "title": "Compositional semantics with lexicalized tree-adjoining grammar (LTAG): How much underspecification is necessary", "journal": "", "year": "2001", "authors": "A K Joshi; K Vijay-Shanker"}, {"ref_id": "b10", "title": "Universal grammar", "journal": "Theoria", "year": "1970", "authors": "R Montague"}, {"ref_id": "b11", "title": "A systematic comparison of various statistical alignment models", "journal": "Computational Linguistics", "year": "2003", "authors": "F J Och; H Ney"}, {"ref_id": "b12", "title": "Featurebased language understanding", "journal": "", "year": "1997", "authors": "K A Papineni; S Roukos; R T Ward"}, {"ref_id": "b13", "title": "Using model-theoretic semantic interpretation to guide statistical parsing and word recognition in a spoken language interface", "journal": "", "year": "2003", "authors": "W Schuler"}, {"ref_id": "b14", "title": "Learning for semantic parsing with statistical machine translation", "journal": "", "year": "2006", "authors": "Y W Wong; R J Mooney"}, {"ref_id": "b15", "title": "Generation by inverting a semantic parser that uses statistical machine translation", "journal": "", "year": "2007", "authors": "Y W Wong; R J Mooney"}, {"ref_id": "b16", "title": "Stochastic inversion transduction grammars and bilingual parsing of parallel corpora", "journal": "Computational Linguistics", "year": "1997", "authors": "D Wu"}, {"ref_id": "b17", "title": "A syntax-based statistical translation model", "journal": "", "year": "2001", "authors": "K Yamada; K Knight"}, {"ref_id": "b18", "title": "Learning to parse database queries using inductive logic programming", "journal": "", "year": "1996-08", "authors": "J M Zelle; R J Mooney"}, {"ref_id": "b19", "title": "Learning to map sentences to logical form: Structured classification with probabilistic categorial grammars", "journal": "", "year": "2005-07", "authors": "L S Zettlemoyer; M Collins"}], "figures": [{"figure_label": "12", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 1 :Figure 2 :12Figure 1: Sample logical forms in the GEOQUERY domain and their English glosses.", "figure_data": ""}, {"figure_label": "34", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 3 :Figure 4 :34Figure 3: \u03bb-SCFG rules for parsing the English sentence in Figure 1(a).", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "(a) answer(x1,largest(x2,(state(x1),major(x1),river(x1),traverse(x1,x2))))", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "point( ): {(POINT)} density( , ): {(COUNTRY, NUM), (STATE, NUM), (CITY, NUM)}", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "Table 1 summarizes the results at the end of the learning curves (792 training examples for \u03bb-WASP, WASP and SCISSOR, 600 for Z&C).", "figure_data": "Figure 8: Learning curves for various parsing algorithms on the larger GEOQUERY corpus.(%) \u03bb-WASP WASP SCISSOR Z&CPrecision91.9587.1992.0896.25Recall86.5974.7772.2779.29F-measure89.1980.5080.9886.95Table 1: Performance of various parsing algorithms on the larger GEOQUERY corpus.WASP algorithm compared to: (1) the originalWASP algorithm which uses a functional query lan-guage (FunQL); (2) SCISSOR (Ge and Mooney,2005), a fully-supervised, combined syntactic-semantic parsing algorithm which also uses FunQL;and (3) Zettlemoyer and Collins (2005) (Z&C), aCCG-based algorithm which uses Prolog logicalforms."}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_2", "figure_caption": "Performance of \u03bb-WASP with certain components of the algorithm removed.", "figure_data": "(%) Precision Recall(%) Precision Recall\u03bb-WASP91.9586.59\u03bb-WASP91.9586.59w/o conj. regrouping90.7383.07w/o two-level rules88.4684.32and w/o type checking65.4563.18Table 2"}], "formulas": [{"formula_id": "formula_0", "formula_text": "A \u2192 \u03b1, \u03b2(1)", "formula_coordinates": [2.0, 159.27, 658.32, 139.53, 11.15]}, {"formula_id": "formula_1", "formula_text": "A \u2192 \u03b1, \u03bbx 1 . . . \u03bbx k .\u03b2 (2)", "formula_coordinates": [2.0, 373.26, 399.5, 166.75, 12.05]}, {"formula_id": "formula_2", "formula_text": "FORM \u2192 state , \u03bbx1.state(x1) FORM \u2192 by area , \u03bbx1.\u03bbx2.area(x1,x2) FORM \u2192 smallest FORM 1 FORM 2 , \u03bbx1.smallest(x2,(FORM 1 (x1),FORM 2 (x1, x2))) QUERY \u2192 what is (1) FORM 1 , answer(x1,FORM 1 (x1))", "formula_coordinates": [4.0, 126.21, 72.05, 356.23, 40.41]}, {"formula_id": "formula_3", "formula_text": "1", "formula_coordinates": [5.0, 73.97, 388.8, 3.49, 6.26]}], "doi": ""}