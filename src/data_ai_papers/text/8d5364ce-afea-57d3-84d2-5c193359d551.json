{"title": "R-SVM+: Robust Learning with Privileged Information", "authors": "Xue Li; Bo Du; Chang Xu; Yipeng Zhang; Lefei Zhang; Dacheng Tao", "pub_date": "", "abstract": "In practice, the circumstance that training and test data are clean is not always satisfied. The performance of existing methods in the learning using privileged information (LUPI) paradigm may be seriously challenged, due to the lack of clear strategies to address potential noises in the data. This paper proposes a novel Robust SVM+ (R-SVM+) algorithm based on a rigorous theoretical analysis. Under the SVM+ framework in the LUPI paradigm, we study the lower bound of perturbations of both example feature data and privileged feature data, which will mislead the model to make wrong decisions. By maximizing the lower bound, tolerance of the learned model over perturbations will be increased. Accordingly, a novel regularization function is introduced to upgrade a variant form of SVM+. The objective function of R-SVM+ is transformed into a quadratic programming problem, which can be efficiently optimized using off-the-shelf solvers. Experiments on realworld datasets demonstrate the necessity of studying robust SVM+ and the effectiveness of the proposed algorithm.", "sections": [{"heading": "Introduction", "text": "Great advances in machine learning have been inspired by the deeper investigation into the learning process of human beings [Shen et al., 2014;Wang et al., 2018]. Conventional supervised methods utilize the priori knowledge to help us understand the world. Based on a set of examples and their corresponding labels, traditional supervised methods can train a classification model, and then use it to classify unknown test examples. However, in practice, there often exists some auxiliary information associated with an example except for its label. This auxiliary information can be widely found in human teaching and learning process. For example, the teacher plays an important role to provide students with helpful comments, comparisons, and explanations to improve students' performance. Inspired by this fact, Vapnik and Vashist [Vapnik and Vashist, 2009] introduced the paradigm of learning using privileged information (LUPI) that focuses on improving the learning with the auxiliary information which is supplied by a teacher about examples at the training stage. Since this auxiliary information will not be available at the test stage, it is referred to as privileged information.\nAs one of the most popular classifiers, support vector machine (SVM) was first upgraded in the paradigm of learning using privileged information (LUPI) [Vapnik and Vashist, 2009], and the new method is called SVM+. The main idea of SVM+ is to define a linear or nonlinear correcting (slack) function in the privileged feature space to estimate the slack variables in the standard SVM method using privileged information. Recently, an increasing attention has been attracted on the LUPI paradigm [Vapnik and Izmailov, 2015;Motiian et al., 2016;Zhou et al., 2016;Yang et al., 2017], and some SVM+-based algorithms have been proposed and applied for various applications. Beyond L-2 SVM, privileged information is also introduced into an L-1 regularized SVM to reduce time consumption on tuning model parameters [Niu et al., 2012]. Considering privileged label information in the multi-label learning problems, a privileged multi-label learning (PrML) method explores and exploits the connections between different examples' labels and is extended into domain adaptation [You et al., 2017]. Moreover, there are also multi-task multi-class SVM+ [Ji et al., 2012], structural SVM+ [Feyereisl et al., 2014], and the rank transfer method [Sharmanska et al., 2013]. Various optimization techniques to solve SVM+ have been studied recently, such as MAT-SVM+, CVX-SVM+, and L2-loss SVM+ . In , two new algorithms are proposed to efficiently solve linear SVM+ and kernel SVM+ which uses the L2-loss based on the \u03c1-SVM formulation, respectively. These methods have largely advanced the developments on LUPI. However, their successes are usually achieved in the circumstance that training and test data are deemed to be clean and the teacher always makes correct judgement. In practice, we can well design the training set under our demands, but it is difficult and even impossible to tell what test data will be. Existing methods lack clear strategies to address potential noises in the data, and thus their practical performances will be seriously deteriorated. In addition, existing methods in LUPI used to consider that teacher's comments are always accurate. But if there exist noises in the data, teacher may not be guaranteed to make correct judgements any more, which will then influence the student performance as a result.\nIn this paper, we derive a novel Robust SVM+ (R-SVM+) algorithm based on a rigorous theoretical analysis. Considering perturbations over both example feature data and privileged feature data, we study the lower bound of these perturbations that will mislead the model to make wrong judgements. A novel regularization function adapted from this lower bound is introduced to upgrade a variant form of SVM+. In this way, the capability of the learned model to tolerate perturbations over the data will be enhanced -that is to say the robustness of the model will be strengthened. The objective function of R-SVM+ is transformed into a quadratic programming problem, which can be efficiently optimized using off-the-shelf solvers. Experimental results demonstrate the necessity of researching robust SVM+ and the effectiveness of the proposed algorithm.", "publication_ref": ["b1", "b1", "b2", "b0", "b2", "b0", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "Preliminary of LUPI", "text": "The LUPI paradigm considers a set of training examples where privileged information is additionally supplied,\n(x 1 , x * 1 , y 1 ), (x 2 , x * 2 , y 2 ), . . . , (x n , x * n , y n ),\nwhere x i \u2208 R d and x * i \u2208 R d * are the i-th example feature (EF) vector and its corresponding privileged feature (PF) vector, y i \u2208 {+1, \u22121} is the ground-truth label of the i-th training example pair (x i , x * i ), and n is the number of training example pairs.\nThe first approach proposed in the LUPI paradigm is called SVM+ [Vapnik and Vashist, 2009], which tries to measure the misclassification loss of training example with a correcting function learned from privileged information. The objective function of SVM+ can be formulated as follows:\nmin w,w * , b,b * 1 2 ( w, w + \u03c1 w * , w * ) + C n i=1 [ w * , \u03c8(x * i ) + b * ] s.t. y i [ w, \u03c6(x i ) + b] \u2265 1 \u2212 [ w * , \u03c8(x * i ) + b * ], w * , \u03c8(x * i ) + b * \u2265 0, i = 1, . . . , n,(1)\nwhere w and w * are the weight vectors, b and b * are the bias terms, C is the a non-negative parameter which balances the loss term and the regularizer, the term \u03c1 2 w * , w * in Eq. (1) aims to restrict the capacity of the correcting function space, \u03c1 > 0 is the trade-off parameter, the functions \u03c6(\u2022) and \u03c8(\u2022) are two feature mappings induced by the kernels on example features and privileged features, respectively, and a, e denotes the inner product between two vectors a and e.\nBy introducing Lagrange multipliers \u03b1 i \u2265 0 and \u03b2 i \u2265 0, i = 1, . . . , n, we can arrive at the dual form of SVM+,\nmax \u03b1,\u03b2 n i=1 \u03b1 i \u2212 1 2 n i,j=1 \u03b1 i \u03b1 j y i y j k(x i , x j ) \u2212 1 2\u03c1 n i,j=1 (\u03b1 i + \u03b2 i \u2212 C)(\u03b1 j + \u03b2 j \u2212 C)k * (x * i , x * j ),(2)\nsubject to constraints\nn i=1 (\u03b1 i + \u03b2 i \u2212 C) = 0, n i=1 \u03b1 i y i = 0, \u03b1 i \u2265 0, and \u03b2 i \u2265 0, i = 1, .\n. . , n, and where k(x i , x j ) = \u03c6(x i ), \u03c6(x j ) and k * (x * i , x * j ) = \u03c8(x * i ), \u03c8(x * j ) are kernels in example feature and privileged feature spaces, respectively. After solving the dual optimization problem, two weight vectors can be reconstructed as w\n= n i=1 \u03b1 i y i \u03c6(x i ) and w * = 1 \u03c1 n i=1 (\u03b1 i + \u03b2 i \u2212 C)\u03c8(x * i ).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Robust SVM+", "text": "According to the constraint of Eq. (1), we can define two functions f (x) and g(x * ), where f (x) = 1\u2212y[ w, \u03c6(x) +b] denotes a hinge loss of the decision function = w, \u03c6(x) + b on the example (x, y) and g(x * ) = w * , \u03c8(x * ) + b * denotes a loss of the correcting function on the privileged data x * . And f (x) and g(x * ) under the framework of SVM+ are\nf (x) = 1 \u2212 y[ n i=1 \u03b1 i y i k(x i , x) + b], g(x * ) = 1 \u03c1 n i=1 (\u03b1 i + \u03b2 i \u2212 C)k * (x * i , x * ) + b * .(3)\nIn the SVM+ method, the constraint y i [ w, \u03c6(\nx i ) + b] \u2265 1 \u2212 [ w * , \u03c8(x * i ) + b * ] in Eq.\n(1) can be written as Eq. (4). The inequality in Eq. (4) will be satisfied if x and x * are good enough for model training and a small loss f (x) in the decision space can be achieved. It is the basic assumption of LUPI that if a small loss in the correcting space can be obtained, then a small loss in the decision space should also be achieved [Pechyony and Vapnik, 2010],\nf (x) \u2264 g(x * ).(4)\nHowever, in practice there may be some noises over x and x * sometimes. If perturbations caused by noises over examples are large enough, the inequality will not hold, which will then influence the correct decisions of the model on examples. In response to this circumstance, we propose to learn a Robust SVM+ (R-SVM+) algorithm, which has a stronger capability to tolerate perturbations over the data caused by noises. We assume there are some perturbations \u03c4 x \u2208 R d and \u03c4 x * \u2208 R d * over the ideal observations x and x * , respectively, i.e., x + \u03c4 x and x * + \u03c4 x * , which are large enough to make the following inequality satisfied,\nf (x + \u03c4 x ) > g(x * + \u03c4 x * ). (5\n)\nOur purpose is to study what properties \u03c4 x and \u03c4 x * should have if Eq. (5) holds. Therefore, in the following, we proceed to show that these perturbations \u03c4 x and \u03c4 x * actually have the lower bounds based on a rigorous theoretical analysis. According to the theorem of calculus, we have\nf (x + \u03c4 x ) = f (x) + 1 0 \u2207f (x + t\u03c4 x ), \u03c4 x dt, g(x * + \u03c4 x * ) = g(x * ) + 1 0 \u2207g(x * + t\u03c4 x * ), \u03c4 x * dt. (6)\nIf the perturbations are serious enough, according to Eq. (5) and Eq. ( 6), the following inequality is satisfied,\n0 \u2264 g(x * ) \u2212 f (x) < 1 0 \u2207f (x + t\u03c4 x ), \u03c4 x dt \u2212 1 0 \u2207g(x * + t\u03c4 x * ), \u03c4 x * dt = 1 0 [\u2207f (x + t\u03c4 x ); \u2212\u2207g(x * + t\u03c4 x * )] T \u2022 [\u03c4 x ; \u03c4 x * ]dt \u2264 \u03c4 p 1 0 (t, \u03c4 x , \u03c4 x * ) q dt, where \u03c4 = [\u03c4 x ; \u03c4 x * ] \u2208 R d+d * , (t, \u03c4 x , \u03c4 x * ) = [\u2207f (x + t\u03c4 x ); \u2212\u2207g(x * +t\u03c4 x * )] \u2208 R d+d *\nand we have applied H\u00f6lder inequality in the last step that the q-norm is dual to the pnorm, where p and q satisfy 1 p + 1 q = 1. Hence, given g(x * ) \u2265 f (x), we have the minimal perturbations \u03c4 that is required to reverse the decision of the SVM+ classifier,\n\u03c4 p > g(x * ) \u2212 f (x) 1 0 (t, \u03c4 x , \u03c4 x * ) q dt .(7)\nEq. ( 7) indicates the lower bound over the perturbations to bring in the undesirable error in Eq. (5). In order to obtain a more robust classifier, we consider maximizing the lower bound (i.e., the right of Eq. ( 7)). As a result, the new model will have more tolerances over the perturbations, and will thus be more robust. And this is the main idea of our proposed R-SVM+ algorithm. That is to say, we wants 1 0 (t, \u03c4 x , \u03c4 x * ) q dt to be small as well as g(x * ) \u2212 f (x) to be large. Therefore, the new objective function of our proposed R-SVM+ have two components: 1) For f (x) \u2264 g(x * ) + , should be minimized; 2) minimizing the value of function\n\u03a8(t, \u03c4 x , \u03c4 x * ) = 1 0 (t, \u03c4 x , \u03c4 x * ) q dt.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Minimizing", "text": "First, we consider minimizing under the framework of SVM+. We replace the constraints f (\nx i ) \u2264 g(x * i ), i = 1, . . . , n in the original SVM+ objective function with the constraints f (x i ) \u2264 g(x * i ) + i , where i \u2265 0, i = 1, . . . , n.\nThen the optimization problem of this variant form of the SVM+ problem can be transformed into, min\nw,w * ,b,b * , 1 2 ( w, w + \u03c1 w * , w * ) +C n i=1 [ w * , \u03c8(x i * ) + b * ] + \u03c3 n i=1 i s.t. y i [ w,\u03c6(x i ) + b] \u2265 1 \u2212 [ w * , \u03c8(x * i ) + b * ] \u2212 i , w * , \u03c8(x * i ) + b * \u2265 0, i \u2265 0, i = 1, . . . , n,(8)\nwhere \u03c3 > 0 is a tradeoff parameter. Similar variant of Eq. (8) has been discussed in [Vapnik and Vashist, 2009] as well, while in this paper we try to make the value g(x * ) \u2212 f (x) large to enhance the robustness according to Eq. (7). In order to minimize , the value of \u03c3 should be relatively larger compared with C, to reinforce the effect of the smooth function term n i=1 i on the solution. For simplicity, we let \u03c3 = \u03c3 C, where \u03c3 > 1. By introducing Lagrange multipliers \u03b1 i \u2265 0, \u03b2 i \u2265 0 and \u03b7 i \u2265 0, where i = 1, . . . , n, the Lagrangian is constructed as\nL(w, w * , b, b * , , \u03b1, \u03b2, \u03b7) = 1 2 ( w, w + \u03c1 w * , w * ) + n i=1 (\u03c3 C \u2212 \u03b1 i \u2212 \u03b7 i ) i + C n i=1 [ w * , \u03c8(x * i ) + b * ] \u2212 n i=1 \u03b2 i [ w * , \u03c8(x * i ) + b * ] \u2212 n i=1 \u03b1 i y i [ w, \u03c6(x i ) + b] \u2212 1 + [ w * , \u03c8(x * i ) + b * ] .\nWe set the derivatives of the Lagrangian function with respect to w, w * , b, b * , to zeros, and then the Karush-Kuhn-Tucker (KKT) conditions can be obtained. Accordingly, the dual problem of Eq. (8) can be rewritten as,\nmax \u03b1,\u03b2 n i=1 \u03b1 i \u2212 1 2 n i,j=1 \u03b1 i \u03b1 j y i y j k(x i , x j ) \u2212 1 2\u03c1 n i,j=1 (\u03b1 i + \u03b2 i \u2212 C)(\u03b1 j + \u03b2 j \u2212 C)k * (x * i , x * j ), subject to constraints n i=1 (\u03b1 i + \u03b2 i \u2212 C) = 0, n i=1 \u03b1 i y i = 0, 0 \u2264 \u03b1 i \u2264 \u03c3 C\n, and \u03b2 i \u2265 0, where i = 1, . . . , n. We denote \u03b1 \u2022 y as the element-wise product between vectors \u03b1 = [\u03b1 1 , . . . , \u03b1 n ] T \u2208 R n and\ny = [y 1 , . . . , y n ] T \u2208 R n , \u03b2 = [\u03b2 1 , . . . , \u03b2 n ] T \u2208 R n , 1 = [1, . . . , 1] T \u2208 R n , and C = [C, . . . , C] T \u2208 R n . The dual problem can be further reformulated as max \u03b1,\u03b2 1 T \u03b1 \u2212 1 2 (\u03b1 \u2022 y) T K(\u03b1 \u2022 y) \u2212 1 2\u03c1 (\u03b1 + \u03b2 \u2212 C) T K * (\u03b1 + \u03b2 \u2212 C),(9)\nsubject to constraints\n1 T (\u03b1 + \u03b2 \u2212 C) = 0, y T \u03b1 = 0, 0 \u2264 \u03b1 i \u2264 \u03c3 C, and \u03b2 i \u2265 0, i = 1, . . . , n. K \u2208 R n\u00d7n\nis the kernel matrix based on example features whose each element being K ij = k(x i , x j ) and K * is the kernel matrix based on privileged features whose each element being\nK * ij = k * (x * i , x * j ) \u2208 R n\u00d7n .", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Minimizing", "text": "\u03a8(t, \u03c4 x , \u03c4 x * ) To minimize \u03a8(t, \u03c4 x , \u03c4 x * ) = 1 0\n(t, \u03c4 x , \u03c4 x * ) q dt, we can first define the upper bound of perturbations over some fixed range \u2126 p (x, ) = {z \u2208 R d | x \u2212 z p \u2264 }. In this way, we ensure that the upper bound of \u03c4 x and \u03c4 x * is at most by making assertions of perturbations \u03c4 x , \u03c4 x * \u2208 \u2126 p (0, ). We further define z = x + t\u03c4 x and z * = x * + t\u03c4 * , 0 < t \u2264 1. In the following, we discuss the case where p = q = 2 for simplicity, and other cases will be studied in our future work. Then the inequality holds\nsup \u03c4x,\u03c4 x * \u2208\u21262(0, ) 1 0 (t, \u03c4 x , \u03c4 x * ) 2 dt \u2264 max \u03c4x,\u03c4 x * \u2208\u21262(0, ) (t, \u03c4 x , \u03c4 x * ) 2 = max z\u2208\u21262(x, ), z * \u2208\u21262(x * , )\n[\u2207f (z); \u2212\u2207g(z * )] 2 .\n(10) Thus, our problem can be further transformed into minimizing the value of the upper bound, i.e., the right side of Eq. (10). Naturally, we consider using a surrogate \u0398(f, g) of the quantity of right side of Eq. (10) for regularization. According to Eq. (3), we can obtain \u2207f\n(x) = \u2212y n i=1 \u03b1 i y i \u2207 x k(x i , x) and \u2207g(x * ) = 1 \u03c1 n i=1 (\u03b1 i + \u03b2 i \u2212 C)\u2207 x * k(x * i , x * ).\nHere we use the Gaussian kernel k(x i , x j ) = e \u2212\u03b3 xi\u2212xj 2 2 and we set \u03b3 = 1/D in the experiment, where D is the mean of distances among examples in the training set. And a novel regularization function \u0398(f, g) is defined as follows,\n\u0398(f, g) = 1 n n s=1 [\u2207f (x s ); \u2212\u2207g(x * s )] 2 2 = 1 n n s=1 \u2212 y s n i=1 \u03b1 i y i \u2207 xs k(x i , x s ) 2 2 + 1 n n s=1 \u2212 1 \u03c1 n i=1 (\u03b1 i + \u03b2 i \u2212 C)\u2207 x * s k(x * i , x * s ) 2 2 = 1 n n s=1 n i,j=1 \u03b1 i \u03b1 j y i y j h(x i , x j , x s ) + 1 n\u03c1 2 n s=1 n i,j=1 (\u03b1 i + \u03b2 i \u2212 C)(\u03b1 j + \u03b2 j \u2212 C)h * (x * i , x * j , x * s ),(11)\nwhere h(x i , x j , x s ) = \u2207 xs k(x i , x s ), \u2207 xs k(x j , x s ) = 4\u03b3 2 x s \u2212 x i , x s \u2212 x j e \u2212\u03b3 xi\u2212xs 2 2 e \u2212\u03b3 xj \u2212xs 2 2 and h * (x * i , x * j , x * s ) = \u2207 x * s k(x * i , x * s ), \u2207 x * s k(x * j , x * s ) = 4\u03b3 2 x * s \u2212 x * i , x * s \u2212 x * j e \u2212\u03b3 x * i \u2212x * s 2 2 e \u2212\u03b3 x * j \u2212x * s 2 2\n. And we can define a matrix H s with each element being H s,ij = h(x i , x j , x s ) \u2208 R n\u00d7n and a matrix H * s with each element being\nH * s,ij = h * (x * i , x * j , x * s ) \u2208 R n\u00d7n .\nAnd Eq. (11) can be further reformulated as\n\u0398(f, g) = 1 n n s=1 (\u03b1 \u2022 y) T H s (\u03b1 \u2022 y) + 1 n\u03c1 2 n s=1 (\u03b1 + \u03b2 \u2212 C) T H * s (\u03b1 + \u03b2 \u2212 C).(12)", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Objective Function of R-SVM+", "text": "The objective of the proposed R-SVM+ algorithm aims to solve a maximization problem in Eq. ( 9) and a minimization problem in Eq. ( 12) at the same time. Therefore, we arrive at the objective function of R-SVM+ which is a minimization problem,\nmin \u03b1,\u03b2 1 2 (\u03b1 \u2022 y) T K(\u03b1 \u2022 y) \u2212 1 T \u03b1 + 1 2\u03c1 (\u03b1 + \u03b2 \u2212 C) T K * (\u03b1 + \u03b2 \u2212 C) + \u03bb\u0398(f, g),(13)\nsubject to 1 T (\u03b1 + \u03b2 \u2212 C) = 0, y T \u03b1 = 0, 0 \u2264 \u03b1 i \u2264 \u03c3 C, and \u03b2 i \u2265 0, i = 1, . . . , n. And \u03bb is a trade-off parameter to control the effect of the proposed regularization term. Eq. ( 13) can be reformulated with a simple calculation,\nmin \u03b1,\u03b2 1 2 (\u03b1 \u2022 y) T (K + 2\u03bb n n s=1 H s )(\u03b1 \u2022 y) \u2212 1 T \u03b1 + 1 2\u03c1 (\u03b1 + \u03b2 \u2212 C) T (K * + 2\u03bb n\u03c1 n s=1 H * s )(\u03b1 + \u03b2 \u2212 C) s.t. 1 T (\u03b1 + \u03b2 \u2212 C) = 0, y T \u03b1 = 0, 0 \u2264 \u03b1 i \u2264 \u03c3 C, \u03b2 i \u2265 0, i = 1, . . . , n.(14", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": ") We further define two matrices", "text": "A = K + 2\u03bb n n s=1 H s and B = K * + 2\u03bb n\u03c1 n s=1 H * s . And we let \u00b5 = [\u03b1 T , \u03b2 T ] T \u2208 R 2n , v = [(1 + 1 \u03c1 BC) T , ( 1 \u03c1 BC) T ] T \u2208 R 2n , and M = A \u2022 (yy T ) + 1 \u03c1 B 1 \u03c1 B 1 \u03c1 B 1 \u03c1 B \u2208 R 2n\u00d72n .\nFinally, the optimization problem of R-SVM+ can be rewritten as,\nmin \u00b5 1 2 \u00b5 T M \u00b5 \u2212 v T \u00b5 s.t. 1 T (\u03b1 + \u03b2 \u2212 C) = 0, y T \u03b1 = 0, 0 \u2264 \u03b1 i \u2264 \u03c3 C, \u03b2 i \u2265 0, i = 1, . . . , n.(15)\nEq. ( 15) is a typical quadratic programming problem [Gould and Toint, 2004;Coleman and Li, 1996], which can be efficiently solved by off-the-shelf quadratic programming solvers.", "publication_ref": ["b0", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "Experiments", "text": "In order to evaluate the robustness of our proposed R-SVM+ algorithm, we carry out experiments on three real-world datasets for digit classification, face pose classification and human activity recognition tasks, respectively.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Experimental Setting Datasets", "text": "The experiments are executed on three real-world datasets, including the MNIST+ dataset [Vapnik and Vashist, 2009], the RGB-D Face dataset [Hg et al., 2012], and the Human Activity Recognition dataset [Anguita et al., 2013]   dataset is used for the digit classification task that classifies two digits \"5\" and \"8\". It contains 2943 images of \"5\" and 3025 images of \"8\" from the MNIST database [LeCun et al., 1998]. A holistic (poetic) description [Vapnik and Vashist, 2009] for each image is translated into a 21-dimensional feature vector as privileged information. All the images of two digits in the MNIST+ dataset are resized into 10\u00d710 pixels. The 100-dimensional vector of raw pixels is used as the example feature data for each image. The RGB-D Face dataset [Hg et al., 2012] contains color and corresponding depth images of faces of 31 people in different face poses and expressions taken by a Kinect sensor. The depth images are used as privileged information. For each person, the image of each face pose is taken repeatedly for 3 times, which results in 31 \u00d7 3 RGB-depth image pairs for each pose. The face pose recognition task is performed on this dataset. The Human Activity Recognition dataset [Anguita et al., 2013] contains 10299 instances of 30 people performing six activities (i.e., walking, walking upstairs, walking downstairs, sitting, standing, and laying) by wearing a smart phone on the waist. Each example for each activity is described by 561 dimensional features drawn from accelerometer, gyroscope, gravity signals and so on.", "publication_ref": ["b0", "b0", "b0", "b0", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "Implementation Details", "text": "For the MNIST+ dataset, it is randomly split into a training set of 100 images, a test set of 1866 images, and a validation set of 4002 [Vapnik and Vashist, 2009]. In the experiment, we randomly select 80 examples and their corresponding holistic descriptions from the training set as training examples for 10 times and classify the images on the test set.\nFor the RGB-D Face dataset, due to the small number of images per face pose, we merge the poses into four groups: looking up, looking forward, looking down and having facial expressions. Then we train a binary classifier on each pair of groups. We randomly split 40% color and corresponding depth image pairs per class for training, 30% image pairs per class for testing, and the rest 30% for validation for 10 times.\nWe crop each image into the same fixed size of 150 \u00d7 150 and convert each color image into a gray image. Then for each image, it is divided into 100 non-overlapping subregions in 15\u00d715 and for each subregion we extract the LBP feature. By concatenating the LBP features derived from all subregions, PCA is then performed to obtain a 150-dimensional compact representation.\nFor the Human Activity Recognition dataset, we use the first 200-dimensional features which come from the accelerometer and gyroscope 3-axial raw signals and their separation into body and gravity acceleration signals as example features. The remaining 361-dimensional features that come from signals obtained by some post-processing such as a Fast Fourier Transform (FFT) and the magnitude calculated using the Euclidean norm, are used as privileged features. We train one binary classifier on each pair of groups in the experiment. For each dataset, we add white Gaussian noise to examples in the validation set and test set with a specific signal-to-noise ratio (SNR). The classification results in experiments are averaged over 10 independent trials.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Compared Methods", "text": "For all the datasets, we evaluate performances of the proposed R-SVM+ algoirthm compared with the standard support vector machine (SVM), the robust SVM based on the rescaled hinge loss function (RSVM-RHHQ) , SVM+ [Vapnik and Vashist, 2009], and L2-SVM+  methods.\nFor all the methods, the regularization parameter C are selected from 10 {\u22122,1,0,1,2} and the Gaussian kernel is used.   For SVM+, L2-SVM+ and the proposed R-SVM+, we set the parameter of Gaussian kernel \u03b3 = 1 D where D is the mean of distances among examples in the training set according to . While for SVM and RSVM-RHHQ, \u03b3 is selected from 10 {\u22123,\u22122,\u22121,0,1,2,3} , since significantly better performances can be achieved. For RSVM-RHHQ, the scaling constant \u03b7 is varied in range of {0.01, 0.1, 0.5, 1, 2, 3, 10, 100}. For SVM+-based methods, the trade-off parameter \u03c1 is selected from 10 {\u22122,\u22121,0,1,2} . For the proposed R-SVM+, we also vary the parameter \u03c3 in range of {5, 10, 50, 100} and \u03bb in range of 10 {\u22125,\u22124,...,0,1} . The best parameters for all methods are determined with a joint cross validation model selection strategy on the validation set. We also discuss the influences of different components of R-SVM+ on the classification results on the MNIST+ dataset, as an example. Figure 1 (a) shows the performances of R-SVM+ if we separately consider minimizing (referred as R-SVM+ without \u03a8) and minimizing the value of \u03a8(t, \u03c4 x , \u03c4 x * ) (referred as R-SVM+ without ). We can find that in general the introduction of \u03a8(t, \u03c4 x , \u03c4 x * ) obviously plays a more important role on the performance of R-SVM+ when SNR is small. While when SNR is relatively large, the introduction of will boost the accuracy to some extent. And R-SVM+ achieves the best performance by simultaneously considering both components in all cases.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Performance Comparison", "text": "In Table 2 shows the performance of different methods on the RGB-D Face dataset when Gaussian noises with an SNR of 8 are added in the validation and test examples. Generally, we can observe that SVM+ and L2-SVM+ methods are superior to the SVM-based methods in almost all the 6 cases due to the use of depth images as privileged information. In particular, the proposed R-SVM+ algorithm shows its advantage over SVM+ and L2-SVM+ in all the 6 cases, especially in the forth and fifth cases.\nTable 3 reports the classification results of the proposed R-SVM+ algorithm and compared methods on the Human Activity Recognition dataset whose validation and test examples are added with Gaussian noises with an SNR of 4. From the results shown in Table 3, we can see that R-SVM+ outperforms other methods in 5 out of 6 cases. In particular, R-SVM+ obtains obviously better accuracies than SVM, SVM+ and L2-SVM+ in the \"Sitting\" and \"Standing\" cases. This demonstrates the effectiveness and robustness of R-SVM+ against noises. And RSVM-RHHQ also performs obviously better than SVM because of its robust strategy based on SVM. In general, SVM+-based methods get better results than SVM because of the use of privileged information.", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_2", "tab_4", "tab_4"]}, {"heading": "Conclusion", "text": "In this paper, we propose a Robust SVM+ (R-SVM+) algorithm to construct a more robust classifier in the LUPI paradigm for the potential noises in the data. Based on a rigorous theoretical analysis, the lower bound of perturbations of noises that will mislead the model to make incorrect decisions has been evaluated. Accordingly, R-SVM+ can be learned by introducing a novel regularization function into a slack form of SVM+. The effectiveness of the proposed R-SVM+ algorithm and the necessity of studying robust SVM+ methods in the LUPI paradigm are demonstrated by experiments on real-world datasets.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgments", "text": "This work was supported by National Natural Science Foundation of China under grants U1536204, 61471274, and 61711530239, and Australian Research Council Projects: FL-170100117, DE-180101438, DP-180103424, and LP-150100671.   ", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "A reflective newton method for minimizing a quadratic function subject to bounds on some of the variables", "journal": "IEEE", "year": "1996", "authors": "[ References;  Anguita"}, {"ref_id": "b1", "title": "Vladimir Vapnik and Akshay Vashist. A new learning paradigm: Learning using privileged information", "journal": "IEEE Transactions on Image Processing", "year": "2009", "authors": ""}, {"ref_id": "b2", "title": "Person re-identification with metric learning using privileged information", "journal": "", "year": "2016", "authors": ""}], "figures": [{"figure_label": "", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "For training we use 200 examples from the desired class and 200 examples randomly drawn from the rest of examples from the remaining classes. And 600 examples randomly selected from the desired class and the rest of classes respectively are used for testing. The remaining examples from the desired class and the same number of examples from the rest of classes are used as the validation examples.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 1: Discussions of performances of R-SVM+.", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "76\u00b12.71 81.07\u00b12.67 84.42\u00b11.39 6 83.17\u00b11.78 83.37\u00b11.58 82.96\u00b13.26 82.76\u00b11.96 86.08\u00b11.35 8 84.64\u00b11.63 84.59\u00b11.79 84.74\u00b12.78 84.12\u00b11.84 87.39\u00b11.43 10 85.81\u00b11.55 85.86\u00b11.62 86.03\u00b12.80 85.47\u00b11.55 88.45\u00b11.34 15 87.15\u00b11.76 86.10\u00b11.41 88.82\u00b12.06 88.06\u00b11.69 90.04\u00b10.91 No noise 90.97\u00b10.94 87.83\u00b10.84 91.86\u00b10.70 92.12\u00b10.70 92.23\u00b10.55", "figure_data": "SNRSVMRSVM-RHHQSVM+L2-SVM+R-SVM+82.09\u00b11.4980.26\u00b14.0281.. The MNIST+"}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "Classification accuracies (mean \u00b1 standard deviation, %) on the MNIST+ dataset. The best results on each row are in boldface.", "figure_data": "SVMRSVM-RHHQSVM+L2-SVM+R-SVM+Up vs Forward95.07\u00b11.2293.33\u00b11.9595.63\u00b11.69 95.87\u00b11.82 96.59\u00b11.53Up vs Down97.90\u00b10.6697.58\u00b11.3498.08\u00b10.59 98.17\u00b10.68 98.48\u00b10.56Up vs Expression96.38\u00b11.4996.56\u00b11.9496.87\u00b11.68 97.23\u00b11.39 97.72\u00b11.34Forward vs Down88.46\u00b11.2382.73\u00b12.4289.12\u00b12.09 88.96\u00b11.81 91.63\u00b12.01Forward vs Expression 88.73\u00b12.8185.60\u00b12.2688.33\u00b11.80 88.88\u00b11.90 90.16\u00b11.71Down vs Expression89.19\u00b12.4187.72\u00b12.1489.55\u00b12.11 90.04\u00b12.18 90.36\u00b11.43"}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_2", "figure_caption": "Classification accuracies (mean \u00b1 standard deviation, %) on the RGB-D Face dataset when SNR is equal to 8. The best results on each row are highlighted in boldface.", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_3", "figure_caption": "90\u00b11.16 92.21\u00b11.37 93.83\u00b11.44 Walking upstairs 82.38\u00b11.90 91.88\u00b10.98 92.36\u00b10.49 89.98\u00b12.23 93.15\u00b10.76 Walking downstairs 92.04\u00b11.30 93.71\u00b10.68 94.29\u00b10.86 94.37\u00b10.52 94.49\u00b10.71 Sitting 79.84\u00b13.13 87.75\u00b10.87 79.42\u00b15.32 81.29\u00b14.54 87.30\u00b10.71 Standing 81.91\u00b14.13 91.57\u00b10.50 78.97\u00b17.33 78.72\u00b17.29 91.61\u00b11.00 Laying 99.42\u00b10.27 99.55\u00b10.17 99.50\u00b10.21 99.63\u00b10.13 99.65\u00b10.12", "figure_data": "SVMRSVM-RHHQSVM+L2-SVM+R-SVM+Walking89.52\u00b12.1792.07\u00b11.2191."}, {"figure_label": "3", "figure_type": "table", "figure_id": "tab_4", "figure_caption": "Classification accuracies (mean \u00b1 standard deviation, %) on the Human Activity Recognition dataset with an SNR of 4. Best accuracies on each row are highlighted in boldface.", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_5", "figure_caption": "summarizes the classification results of the proposed R-SVM+ algorithm and compared methods, using 80 clean training EF and PF examples, and noisy validation and test examples polluted by Gaussian noises with different SNRs of 4, 6, 8, 10 and 15. And we also report the classification results when validation and test examples are clean. As we can see, the performances of all the methods are significantly affected by varying SNR. Generally, the proposed R-SVM+ algorithm shows bigger superiority than all the compared methods especially when SNR is smaller. Since the distribution of noisy test data could be largely different from that of training data when SNR is small, the advantage of classical SVM+ over SVM is not preserved. When SNR is relatively large (i.e., SNR=15) or examples are clean, SVM+ and L2-SVM+ methods obviously outperform SVM and RSVM-RHHQ. While R-SVM+ achieves obviously better than SVM-based methods in all cases. This demonstrates the proposed R-SVM+ is a robust and effective SVM+-based algorithm against noises.", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_6", "figure_caption": "order to further evaluate the robustness of the proposed R-SVM+ algorithm compared with other SVM+-based methods when PF examples are noisy, we add Gaussian noises to the PF training examples with SNRs of 4, 6, 8, 10, and 15 on the MNIST+ dataset, as an example. As shown in Figure 1 (b), R-SVM+ obviously outperforms SVM+ and L2-SVM+ with varying SNR in general. In detail, R-SVM+ obtains gains in accuracy of +3.1%, +3.9%, +3.6%, +2.6% and +1.2% over SVM+, and gains in accuracy of +4.1%, +4.4%, +3.0%, +3.5% and +2.0% over L2-SVM+ when SNR is equal to 4, 6, 8, 10, and 15, respectively. This is because R-SVM+ also considers maximizing the lower bound of potential perturbations over PF examples and has more tolerances over these noisy examples, thus strengthening the robustness of the R-SVM+ algorithm.", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "(x 1 , x * 1 , y 1 ), (x 2 , x * 2 , y 2 ), . . . , (x n , x * n , y n ),", "formula_coordinates": [2.0, 85.41, 393.15, 180.18, 13.33]}, {"formula_id": "formula_1", "formula_text": "min w,w * , b,b * 1 2 ( w, w + \u03c1 w * , w * ) + C n i=1 [ w * , \u03c8(x * i ) + b * ] s.t. y i [ w, \u03c6(x i ) + b] \u2265 1 \u2212 [ w * , \u03c8(x * i ) + b * ], w * , \u03c8(x * i ) + b * \u2265 0, i = 1, . . . , n,(1)", "formula_coordinates": [2.0, 55.11, 531.67, 241.89, 73.12]}, {"formula_id": "formula_2", "formula_text": "max \u03b1,\u03b2 n i=1 \u03b1 i \u2212 1 2 n i,j=1 \u03b1 i \u03b1 j y i y j k(x i , x j ) \u2212 1 2\u03c1 n i,j=1 (\u03b1 i + \u03b2 i \u2212 C)(\u03b1 j + \u03b2 j \u2212 C)k * (x * i , x * j ),(2)", "formula_coordinates": [2.0, 315.84, 73.17, 242.16, 75.81]}, {"formula_id": "formula_3", "formula_text": "n i=1 (\u03b1 i + \u03b2 i \u2212 C) = 0, n i=1 \u03b1 i y i = 0, \u03b1 i \u2265 0, and \u03b2 i \u2265 0, i = 1, .", "formula_coordinates": [2.0, 315.0, 148.02, 243.0, 34.66]}, {"formula_id": "formula_4", "formula_text": "= n i=1 \u03b1 i y i \u03c6(x i ) and w * = 1 \u03c1 n i=1 (\u03b1 i + \u03b2 i \u2212 C)\u03c8(x * i ).", "formula_coordinates": [2.0, 316.2, 216.08, 241.8, 26.96]}, {"formula_id": "formula_5", "formula_text": "f (x) = 1 \u2212 y[ n i=1 \u03b1 i y i k(x i , x) + b], g(x * ) = 1 \u03c1 n i=1 (\u03b1 i + \u03b2 i \u2212 C)k * (x * i , x * ) + b * .(3)", "formula_coordinates": [2.0, 341.04, 341.89, 216.96, 63.51]}, {"formula_id": "formula_6", "formula_text": "x i ) + b] \u2265 1 \u2212 [ w * , \u03c8(x * i ) + b * ] in Eq.", "formula_coordinates": [2.0, 315.0, 413.78, 242.99, 22.2]}, {"formula_id": "formula_7", "formula_text": "f (x) \u2264 g(x * ).(4)", "formula_coordinates": [2.0, 406.1, 506.1, 151.9, 11.35]}, {"formula_id": "formula_8", "formula_text": "f (x + \u03c4 x ) > g(x * + \u03c4 x * ). (5", "formula_coordinates": [2.0, 380.87, 652.85, 173.26, 11.75]}, {"formula_id": "formula_9", "formula_text": ")", "formula_coordinates": [2.0, 554.13, 655.57, 3.87, 8.64]}, {"formula_id": "formula_10", "formula_text": "f (x + \u03c4 x ) = f (x) + 1 0 \u2207f (x + t\u03c4 x ), \u03c4 x dt, g(x * + \u03c4 x * ) = g(x * ) + 1 0 \u2207g(x * + t\u03c4 x * ), \u03c4 x * dt. (6)", "formula_coordinates": [3.0, 60.36, 79.92, 236.64, 54.94]}, {"formula_id": "formula_11", "formula_text": "0 \u2264 g(x * ) \u2212 f (x) < 1 0 \u2207f (x + t\u03c4 x ), \u03c4 x dt \u2212 1 0 \u2207g(x * + t\u03c4 x * ), \u03c4 x * dt = 1 0 [\u2207f (x + t\u03c4 x ); \u2212\u2207g(x * + t\u03c4 x * )] T \u2022 [\u03c4 x ; \u03c4 x * ]dt \u2264 \u03c4 p 1 0 (t, \u03c4 x , \u03c4 x * ) q dt, where \u03c4 = [\u03c4 x ; \u03c4 x * ] \u2208 R d+d * , (t, \u03c4 x , \u03c4 x * ) = [\u2207f (x + t\u03c4 x ); \u2212\u2207g(x * +t\u03c4 x * )] \u2208 R d+d *", "formula_coordinates": [3.0, 54.0, 158.41, 242.99, 125.47]}, {"formula_id": "formula_12", "formula_text": "\u03c4 p > g(x * ) \u2212 f (x) 1 0 (t, \u03c4 x , \u03c4 x * ) q dt .(7)", "formula_coordinates": [3.0, 115.34, 341.71, 181.66, 29.0]}, {"formula_id": "formula_13", "formula_text": "\u03a8(t, \u03c4 x , \u03c4 x * ) = 1 0 (t, \u03c4 x , \u03c4 x * ) q dt.", "formula_coordinates": [3.0, 89.7, 494.31, 160.57, 15.22]}, {"formula_id": "formula_14", "formula_text": "x i ) \u2264 g(x * i ), i = 1, . . . , n in the original SVM+ objective function with the constraints f (x i ) \u2264 g(x * i ) + i , where i \u2265 0, i = 1, . . . , n.", "formula_coordinates": [3.0, 54.0, 538.15, 243.0, 34.75]}, {"formula_id": "formula_15", "formula_text": "w,w * ,b,b * , 1 2 ( w, w + \u03c1 w * , w * ) +C n i=1 [ w * , \u03c8(x i * ) + b * ] + \u03c3 n i=1 i s.t. y i [ w,\u03c6(x i ) + b] \u2265 1 \u2212 [ w * , \u03c8(x * i ) + b * ] \u2212 i , w * , \u03c8(x * i ) + b * \u2265 0, i \u2265 0, i = 1, . . . , n,(8)", "formula_coordinates": [3.0, 60.32, 595.27, 236.69, 108.89]}, {"formula_id": "formula_16", "formula_text": "L(w, w * , b, b * , , \u03b1, \u03b2, \u03b7) = 1 2 ( w, w + \u03c1 w * , w * ) + n i=1 (\u03c3 C \u2212 \u03b1 i \u2212 \u03b7 i ) i + C n i=1 [ w * , \u03c8(x * i ) + b * ] \u2212 n i=1 \u03b2 i [ w * , \u03c8(x * i ) + b * ] \u2212 n i=1 \u03b1 i y i [ w, \u03c6(x i ) + b] \u2212 1 + [ w * , \u03c8(x * i ) + b * ] .", "formula_coordinates": [3.0, 318.08, 168.4, 236.83, 112.11]}, {"formula_id": "formula_17", "formula_text": "max \u03b1,\u03b2 n i=1 \u03b1 i \u2212 1 2 n i,j=1 \u03b1 i \u03b1 j y i y j k(x i , x j ) \u2212 1 2\u03c1 n i,j=1 (\u03b1 i + \u03b2 i \u2212 C)(\u03b1 j + \u03b2 j \u2212 C)k * (x * i , x * j ), subject to constraints n i=1 (\u03b1 i + \u03b2 i \u2212 C) = 0, n i=1 \u03b1 i y i = 0, 0 \u2264 \u03b1 i \u2264 \u03c3 C", "formula_coordinates": [3.0, 315.0, 345.27, 243.0, 97.14]}, {"formula_id": "formula_18", "formula_text": "y = [y 1 , . . . , y n ] T \u2208 R n , \u03b2 = [\u03b2 1 , . . . , \u03b2 n ] T \u2208 R n , 1 = [1, . . . , 1] T \u2208 R n , and C = [C, . . . , C] T \u2208 R n . The dual problem can be further reformulated as max \u03b1,\u03b2 1 T \u03b1 \u2212 1 2 (\u03b1 \u2022 y) T K(\u03b1 \u2022 y) \u2212 1 2\u03c1 (\u03b1 + \u03b2 \u2212 C) T K * (\u03b1 + \u03b2 \u2212 C),(9)", "formula_coordinates": [3.0, 315.0, 462.57, 243.01, 87.42]}, {"formula_id": "formula_19", "formula_text": "1 T (\u03b1 + \u03b2 \u2212 C) = 0, y T \u03b1 = 0, 0 \u2264 \u03b1 i \u2264 \u03c3 C, and \u03b2 i \u2265 0, i = 1, . . . , n. K \u2208 R n\u00d7n", "formula_coordinates": [3.0, 315.0, 556.92, 243.0, 22.53]}, {"formula_id": "formula_20", "formula_text": "K * ij = k * (x * i , x * j ) \u2208 R n\u00d7n .", "formula_coordinates": [3.0, 315.0, 612.04, 112.72, 12.83]}, {"formula_id": "formula_21", "formula_text": "\u03a8(t, \u03c4 x , \u03c4 x * ) To minimize \u03a8(t, \u03c4 x , \u03c4 x * ) = 1 0", "formula_coordinates": [3.0, 315.0, 634.12, 140.07, 28.94]}, {"formula_id": "formula_22", "formula_text": "sup \u03c4x,\u03c4 x * \u2208\u21262(0, ) 1 0 (t, \u03c4 x , \u03c4 x * ) 2 dt \u2264 max \u03c4x,\u03c4 x * \u2208\u21262(0, ) (t, \u03c4 x , \u03c4 x * ) 2 = max z\u2208\u21262(x, ), z * \u2208\u21262(x * , )", "formula_coordinates": [4.0, 55.77, 106.5, 238.95, 61.25]}, {"formula_id": "formula_23", "formula_text": "(x) = \u2212y n i=1 \u03b1 i y i \u2207 x k(x i , x) and \u2207g(x * ) = 1 \u03c1 n i=1 (\u03b1 i + \u03b2 i \u2212 C)\u2207 x * k(x * i , x * ).", "formula_coordinates": [4.0, 55.2, 232.91, 241.79, 26.96]}, {"formula_id": "formula_24", "formula_text": "\u0398(f, g) = 1 n n s=1 [\u2207f (x s ); \u2212\u2207g(x * s )] 2 2 = 1 n n s=1 \u2212 y s n i=1 \u03b1 i y i \u2207 xs k(x i , x s ) 2 2 + 1 n n s=1 \u2212 1 \u03c1 n i=1 (\u03b1 i + \u03b2 i \u2212 C)\u2207 x * s k(x * i , x * s ) 2 2 = 1 n n s=1 n i,j=1 \u03b1 i \u03b1 j y i y j h(x i , x j , x s ) + 1 n\u03c1 2 n s=1 n i,j=1 (\u03b1 i + \u03b2 i \u2212 C)(\u03b1 j + \u03b2 j \u2212 C)h * (x * i , x * j , x * s ),(11)", "formula_coordinates": [4.0, 54.0, 314.78, 249.31, 175.25]}, {"formula_id": "formula_25", "formula_text": "where h(x i , x j , x s ) = \u2207 xs k(x i , x s ), \u2207 xs k(x j , x s ) = 4\u03b3 2 x s \u2212 x i , x s \u2212 x j e \u2212\u03b3 xi\u2212xs 2 2 e \u2212\u03b3 xj \u2212xs 2 2 and h * (x * i , x * j , x * s ) = \u2207 x * s k(x * i , x * s ), \u2207 x * s k(x * j , x * s ) = 4\u03b3 2 x * s \u2212 x * i , x * s \u2212 x * j e \u2212\u03b3 x * i \u2212x * s 2 2 e \u2212\u03b3 x * j \u2212x * s 2 2", "formula_coordinates": [4.0, 54.0, 492.0, 243.0, 51.59]}, {"formula_id": "formula_26", "formula_text": "H * s,ij = h * (x * i , x * j , x * s ) \u2208 R n\u00d7n .", "formula_coordinates": [4.0, 114.61, 565.99, 142.19, 12.83]}, {"formula_id": "formula_27", "formula_text": "\u0398(f, g) = 1 n n s=1 (\u03b1 \u2022 y) T H s (\u03b1 \u2022 y) + 1 n\u03c1 2 n s=1 (\u03b1 + \u03b2 \u2212 C) T H * s (\u03b1 + \u03b2 \u2212 C).(12)", "formula_coordinates": [4.0, 60.31, 597.81, 236.69, 63.27]}, {"formula_id": "formula_28", "formula_text": "min \u03b1,\u03b2 1 2 (\u03b1 \u2022 y) T K(\u03b1 \u2022 y) \u2212 1 T \u03b1 + 1 2\u03c1 (\u03b1 + \u03b2 \u2212 C) T K * (\u03b1 + \u03b2 \u2212 C) + \u03bb\u0398(f, g),(13)", "formula_coordinates": [4.0, 324.57, 94.62, 233.43, 58.26]}, {"formula_id": "formula_29", "formula_text": "min \u03b1,\u03b2 1 2 (\u03b1 \u2022 y) T (K + 2\u03bb n n s=1 H s )(\u03b1 \u2022 y) \u2212 1 T \u03b1 + 1 2\u03c1 (\u03b1 + \u03b2 \u2212 C) T (K * + 2\u03bb n\u03c1 n s=1 H * s )(\u03b1 + \u03b2 \u2212 C) s.t. 1 T (\u03b1 + \u03b2 \u2212 C) = 0, y T \u03b1 = 0, 0 \u2264 \u03b1 i \u2264 \u03c3 C, \u03b2 i \u2265 0, i = 1, . . . , n.(14", "formula_coordinates": [4.0, 315.0, 202.93, 249.46, 134.37]}, {"formula_id": "formula_30", "formula_text": "A = K + 2\u03bb n n s=1 H s and B = K * + 2\u03bb n\u03c1 n s=1 H * s . And we let \u00b5 = [\u03b1 T , \u03b2 T ] T \u2208 R 2n , v = [(1 + 1 \u03c1 BC) T , ( 1 \u03c1 BC) T ] T \u2208 R 2n , and M = A \u2022 (yy T ) + 1 \u03c1 B 1 \u03c1 B 1 \u03c1 B 1 \u03c1 B \u2208 R 2n\u00d72n .", "formula_coordinates": [4.0, 315.0, 336.33, 242.99, 69.83]}, {"formula_id": "formula_31", "formula_text": "min \u00b5 1 2 \u00b5 T M \u00b5 \u2212 v T \u00b5 s.t. 1 T (\u03b1 + \u03b2 \u2212 C) = 0, y T \u03b1 = 0, 0 \u2264 \u03b1 i \u2264 \u03c3 C, \u03b2 i \u2265 0, i = 1, . . . , n.(15)", "formula_coordinates": [4.0, 376.67, 425.53, 181.33, 82.95]}], "doi": ""}