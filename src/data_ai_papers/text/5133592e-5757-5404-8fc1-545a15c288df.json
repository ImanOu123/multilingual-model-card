{"title": "Learning Dynamic Feature Selection for Fast Sequential Prediction", "authors": "Emma Strubell; Luke Vilnis; Kate Silverstein; Andrew Mccallum", "pub_date": "", "abstract": "We present paired learning and inference algorithms for significantly reducing computation and increasing speed of the vector dot products in the classifiers that are at the heart of many NLP components. This is accomplished by partitioning the features into a sequence of templates which are ordered such that high confidence can often be reached using only a small fraction of all features. Parameter estimation is arranged to maximize accuracy and early confidence in this sequence. Our approach is simpler and better suited to NLP than other related cascade methods. We present experiments in left-to-right part-of-speech tagging, named entity recognition, and transition-based dependency parsing. On the typical benchmarking datasets we can preserve POS tagging accuracy above 97% and parsing LAS above 88.5% both with over a five-fold reduction in run-time, and NER F1 above 88 with more than 2x increase in speed.", "sections": [{"heading": "Introduction", "text": "Many NLP tasks such as part-of-speech tagging, parsing and named entity recognition have become sufficiently accurate that they are no longer solely an object of research, but are also widely deployed in production systems. These systems can be run on billions of documents, making the efficiency of inference a significant concern-impacting not only wall-clock running time but also computer hardware budgets and the carbon footprint of data centers.\nThis paper describes a paired learning and inference approach for significantly reducing computation and increasing speed while preserving accuracy in the linear classifiers typically used in many NLP tasks. The heart of the prediction computation in these models is a dot-product between a dense parameter vector and a sparse feature vector. The bottleneck in these models is then often a combination of feature extraction and numerical operations, each of which scale linearly in the size of the feature vector. Feature extraction can be even more expensive than the dot products, involving, for example, walking sub-graphs, lexicon lookup, string concatenation and string hashing. We note, however, that in many cases not all of these features are necessary for accurate prediction. For example, in part-of-speech tagging if we see the word \"the,\" there is no need to perform a large dot product or many string operations; we can accurately label the word a DETERMINER using the word identity feature alone. In other cases two features are sufficient: when we see the word \"hits\" preceded by a CARDINAL (e.g. \"two hits\") we can be confident that it is a NOUN.\nWe present a simple yet novel approach to improve processing speed by dynamically determining on a per-instance basis how many features are necessary for a high-confidence prediction. Our features are divided into a set of feature templates, such as current-token or previous-tag in the case of POS tagging. At training time, we determine an ordering on the templates such that we can approximate model scores at test time by incrementally calculating the dot product in template ordering. We then use a running confidence estimate for the label prediction to determine how many terms of the sum to compute for a given instance, and predict once confidence reaches a certain threshold.\nIn similar work, cascades of increasingly complex and high-recall models have been used for both structured and unstructured prediction. Viola and Jones (2001) use a cascade of boosted models to perform face detection. Weiss and Taskar (2010) add increasingly higher-order dependencies to a graphical model while filtering the out-put domain to maintain tractable inference. While most traditional cascades pass instances down to layers with increasingly higher recall, we use a single model and accumulate the scores from each additional template until a label is predicted with sufficient confidence, in a stagewise approximation of the full model score. Our technique applies to any linear classifier-based model over feature templates without changing the model structure or decreasing prediction speed.\nMost similarly to our work, Weiss and Taskar (2013) improve performance for several structured vision tasks by dynamically selecting features at runtime. However, they use a reinforcement learning approach whose computational tradeoffs are better suited to vision problems with expensive features. Obtaining a speedup on tasks with comparatively cheap features, such as part-of-speech tagging or transition-based parsing, requires an approach with less overhead. In fact, the most attractive aspect of our approach is that it speeds up methods that are already among the fastest in NLP.\nWe apply our method to left-to-right part-ofspeech tagging in which we achieve accuracy above 97% on the Penn Treebank WSJ corpus while running more than five times faster than our 97.2% baseline. We also achieve a five-fold increase in transition-based dependency parsing on the WSJ corpus while achieving an LAS just 1.5% lower than our 90.3% baseline. Named entity recognition also shows significant speed increases. We further demonstrate that our method can be tuned for 2.5 3.5x multiplicative speedups with nearly no loss in accuracy.", "publication_ref": ["b26", "b27", "b28"], "figure_ref": [], "table_ref": []}, {"heading": "Classification and Structured Prediction", "text": "Our algorithm speeds up prediction for multiclass classification problems where the label set can be tractably enumerated and scored, and the per-class scores of input features decompose as a sum over multiple feature templates. Frequently, classification problems in NLP are solved through the use of linear classifiers, which compute scores for inputlabel pairs using a dot product. These meet our additive scoring criteria, and our acceleration methods are directly applicable. However, in this work we are interested in speeding up structured prediction problems, specifically part-of-speech (POS) tagging and dependency parsing. We apply our classification algorithms to these problems by reducing them to sequential prediction (Daum\u00e9 III et al., 2009). For POS tagging, we describe a sentence's part of speech annotation by the left-to-right sequence of tagging decisions for individual tokens (Gim\u00e9nez and M\u00e0rquez, 2004). Similarly, we implement our parser with a classifier that generates a sequence of shift-reduce parsing transitions (Nivre, 2009). The use of sequential prediction to solve these problems and others has a long history in practice as well as theory. Searn (Daum\u00e9 III et al., 2009) and DAgger (Ross et al., 2011) are two popular principled frameworks for reducing sequential prediction to classification by learning a classifier on additional synthetic training data. However, as we do in our experiments, practitioners often see good results by training on the gold standard labels with an off-the-shelf classification algorithm, as though classifying IID data (Bengtson and Roth, 2008;Choi and Palmer, 2012).\nClassifier-based approaches to structured prediction are faster than dynamic programming since they consider only a subset of candidate output structures in a greedy manner. For example, the Stanford CoreNLP classifier-based partof-speech tagger provides a 6.5x speed advantage over their dynamic programming-based model, with little reduction in accuracy. Because our methods are designed for the greedy sequential prediction regime, we can provide further speed increases to the fastest inference methods in NLP.", "publication_ref": ["b4", "b8", "b18", "b4", "b20", "b0", "b3"], "figure_ref": [], "table_ref": []}, {"heading": "Linear models", "text": "Our base classifier for sequential prediction tasks will be a linear model. Given an input x 2 X , a set of labels Y, a feature map (x, y), and a weight vector w, a linear model predicts the highestscoring label\ny \u21e4 = arg max y2Y w \u2022 (x, y).\n(1)\nThe parameter w is usually learned by minimizing a regularized (R) sum of loss functions (`) over the training examples indexed by i\nw \u21e4 = arg min w X i`( x i , y i , w) + R(w).\nIn this paper, we partition the features into a set of feature templates, so that the weights, feature function, and dot product factor as\nw \u2022 (x, y) = X j w j \u2022 j (x, y)(2)\nfor some set of feature templates { j (x, y)}.\nOur goal is to approximate the dot products in (1) sufficiently for purposes of prediction, while using as few terms of the sum in (2) as possible.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Method", "text": "We accomplish this goal by developing paired learning and inference procedures for featuretemplated classifiers that optimize both accuracy and inference speed, using a process of dynamic feature selection. Since many decisions are easy to make in the presence of strongly predictive features, we would like our model to use fewer templates when it is more confident. For a fixed, learned ordering of feature templates, we build up a vector of class scores incrementally over each prefix of the sequence of templates, which we call the prefix scores. Once we reach a stopping criterion based on class confidence (margin), we stop computing prefix scores, and predict the current highest scoring class. Our aim is to train each prefix to be as good a classifier as possible without the following templates, minimizing the number of templates needed for accurate predictions.\nGiven this method for performing fast inference on an ordered set of feature templates, it remains to choose the ordering. In Section 4.5, we develop several methods for picking template orderings, based on ideas from group sparsity (Yuan and Lin, 2006;Swirszcz et al., 2009), and other techniques for feature subset-selection (Kohavi and John, 1997).", "publication_ref": ["b31", "b22", "b14"], "figure_ref": [], "table_ref": []}, {"heading": "Definitions", "text": "Given a model that computes scores additively over template-specific scoring functions as in (2), parameters w, and an observation x 2 X, we can define the i'th prefix score for label y 2 Y as:\nP i,y (x, w) = i X j=1 w j \u2022 j (x, y),\nor P i,y when the choice of observations and weights is clear from context. Abusing notation we also refer to the vector containing all i'th prefix scores for observation x associated to each label in Y as P i (x, w), or P i when this is unambiguous.\nGiven a parameter m > 0, called the margin, we define a function h on prefix scores:\nh(P i , y) = max{0, max y 0 6 =y P i,y 0 P i,y + m} Algorithm 1 Inference Input: template parameters {w i } k i=1\n, margin m and optional (for train time) true label y\nInitialize: i = 1 while l > 0^i \uf8ff k do l = max y 0 h(P i , y 0 ) (test) or h(P i , y) (train) i i + 1 end while return {P j } i j=1 (train) or max y 0 P i,y 0 (test) Algorithm 2 Parameter Learning Input: examples {(x i , y i )} N i , margin m Initialize: parameters w 0 = 0, i = 1 while i \uf8ff N do prefixes Infer(x i , y i , w i , m) g i ComputeGradient(prefixes) w i+1\nUpdateParameters(w i , g i ) i\ni + 1 end while return w N This is the familiar structured hinge loss function as in structured support vector machines (Tsochantaridis et al., 2004), which has a minimum at 0 if and only if class y is ranked ahead of all other classes by at least m.\nUsing this notation, the condition that some label y be ranked first by a margin can be written as h(P i , y) = 0, and the condition that any class be ranked first by a margin can be written as max y 0 h(P i , y 0 ) = 0.", "publication_ref": ["b25"], "figure_ref": [], "table_ref": []}, {"heading": "Inference", "text": "As described in Algorithm 1, at test time we compute prefixes until some label is ranked ahead of all other labels with a margin m, then predict with that label. At train time, we predict until the correct label is ranked ahead with margin m, and return the whole set of prefixes for use by the learning algorithm. If no prefix scores have a margin, then we predict with the final prefix score involving all the feature templates.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Learning", "text": "We split learning into two subproblems: first, given an ordered sequence of feature templates and our inference procedure, we wish to learn parameters that optimize accuracy while using as few of those templates as possible. Second, given a method for training feature templated classifiers, we want to learn an ordering of templates that optimizes accuracy.\nWe wish to optimize several different objectives during learning: template parameters should have strong predictive power on their own, but also work well when combined with the scores from later templates. Additionally, we want to encourage well-calibrated confidence scores that allow us to stop prediction early without significant reduction in generalization ability.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Learning the parameters", "text": "To learn parameters that encourage the use of few feature templates, we look at the model as outputting not a single prediction but a sequence of prefix predictions {P i }. For each training example, each feature template receives a number of hinge-loss gradients equal to its distance from the index where the margin requirement is finally reached. This is equivalent to treating each prefix as its own model for which we have a hinge loss function, and learning all models simultaneously. Our high-level approach is described in Algorithm 2.\nConcretely, for k feature templates we optimize the following structured max-margin objective (with the dependence of P 's on w written explicitly where helpful):\nw \u21e4 = arg min w X (x,y)`( x, y, w) (x, y, w) = i \u21e4 y X i=1 h(P i (x, w), y) i \u21e4 y = min i2{1..k} i s.t. h(P i , y) = 0\nThe per-example gradient of this objective for weights w j corresponding to feature template j then corresponds to\n@@ w j = i \u21e4 y X i=j j (x, y loss (P i , y)) j (x, y).\nwhere we define y loss (P i , y) = arg max\ny 0 P i,y 0 m \u2022 I(y 0 = y),\nwhere I is an indicator function of the label y, used to define loss-augmented inference.\nWe add an`2 regularization term to the objective, and tune the margin m and the regularization strength to tradeoff between speed and accuracy.\nIn our experiments, we used a development set to choose a regularizer and margin that reduced testtime speed as much as possible without decreasing accuracy. We then varied the margin for that same model at test time to achieve larger speed gains at the cost of accuracy. In all experiments, the margin with which the model was trained corresponds to the largest margin reported, i.e. that with the highest accuracy.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Learning the template ordering", "text": "We examine three approaches to learning the template ordering.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Group Lasso and Group Orthogonal", "text": "Matching Pursuit\nThe Group Lasso regularizer (Yuan and Lin, 2006) penalizes the sum of`2-norms of weights of feature templates (different from what is commonly called \"`2\" regularization, penalizing squared`2 norms),\nP i c i kw i k 2\n, where c i is a weight for each template. This regularizer encourages entire groups of weights to be set to 0, whose templates can then be discarded from the model. By varying the strength of the regularizer, we can learn an ordering of the importance of each template for a given model. The included groups for a given regularization strength are nearly always subsets of one another (technical conditions for this to be true are given in Hastie et al. (2007)). The sequence of solutions for varied regularization strength is called the regularization path, and by slight abuse of terminology we use this to refer to the induced template ordering.\nAn alternative and related approach to learning template orderings is based on the Group Orthogonal Matching Pursuit (GOMP) algorithm for generalized linear models (Swirszcz et al., 2009;Lozano et al., 2011), with a few modifications for the setting of high-dimensional, sparse NLP data (described in Appendix B). Orthogonal matching pursuit algorithms are a set of stagewise feature selection techniques similar to forward stagewise regression (Hastie et al., 2007) and LARS (Efron et al., 2004). At each stage, GOMP effectively uses each feature template to perform a linear regression to fit the gradient of the loss function. This attempts to find the correlation of each feature subset with the residual of the model. It then adds the feature template that best fits this gradient, and retrains the model. The main weakness of this method is that it fits the gradient of the training error which can rapidly overfit for sparse, highdimensional data. Ultimately, we would prefer to use a development set for feature selection.", "publication_ref": ["b31", "b10", "b22", "b15", "b10", "b7"], "figure_ref": [], "table_ref": []}, {"heading": "Wrapper Method", "text": "The wrapper method (Kohavi and John, 1997) is a meta-algorithm for feature selection, usually based on a validation set. We employ it in a stagewise approach to learning a sequence of templates. Given an ordering of the initial sub-sequence and a learning procedure, we add each remaining template to our ordering and estimate parameters, selecting as the next template the one that gives the highest increase in development set performance. We begin the procedure with no templates, and repeat the procedure until we have a total ordering over the set of feature templates. When learning the ordering we use the same hyperparameters as will be used during final training.\nWhile simpler than the Lasso and Matching Pursuit approaches, we empirically found this approach to outperform the others, due to the necessity of using a development set to select features for our high-dimensional application areas.", "publication_ref": ["b14"], "figure_ref": [], "table_ref": []}, {"heading": "Related Work", "text": "Our work is primarily inspired by previous research on cascades of classifiers; however, it differs significantly by approximating the score of a single linear model-scoring as few of its features as possible to obtain sufficient confidence.\nWe pose and address the question of whether a single, interacting set of parameters can be learned such that they efficiently both (1) provide high accuracy and (2) good confidence estimates throughout their use in the lengthening prefixes of the feature template sequence. (These two requirements are both incorporated into our novel parameter estimation algorithm.) In contrast, other work (Weiss and Taskar, 2013;He et al., 2013) learns a separate classifier to determine when to add features. Such heavier-weight approaches are unsuitable for our setting, where the core classifier's features and scoring are already so cheap that adding complex decision-making would cause too much computational overhead.\nOther previous work on cascades uses a series of increasingly complex models, such as the Viola-Jones face detection cascade of classifiers ( 2001), which applies boosted trees trained on subsets of features in increasing order of complexity as needed, aiming to reject many sub-image windows early in processing. We allow scores from each layer to directly affect the final prediction, avoiding duplicate incorporation of evidence.\nOur work is also related to the field of learning and inference under test-time budget constraints (Grubb and Bagnell, 2012;Trapeznikov and Saligrama, 2013). However, common approaches to this problem also employ auxiliary models to rank which feature to add next, and are generally suited for problems where features are expensive to compute (e.g vision) and the extra computation of an auxiliary pruning-decision model is offset by substantial reduction in feature computations (Weiss and Taskar, 2013). Our method uses confidence scores directly from the model, and so requires no additional computation, making it suitable for speeding up classifier-based NLP methods that are already very fast and have relatively cheap features. Some cascaded approaches strive at each stage to prune the number of possible output structures under consideration, whereas in our case we focus on pruning the input features. For example, Xu et al. (2013) learn a tree of classifiers that subdivides the set of classes to minimize average testtime cost. Chen et al. (2012) similarly use a linear cascade instead of a tree. Weiss and Taskar (2010) prune output labels in the context of structured prediction through a cascade of increasingly complex models, and Rush and Petrov (2012) successfully apply these structured prediction cascades to the task of graph-based dependency parsing.\nIn the context of NLP, He et al. (2013) describe a method for dynamic feature template selection at test time in graph-based dependency parsing. Their technique is particular to the parsing taskmaking a binary decision about whether to lock in edges in the dependency graph at each stage, and enforcing parsing-specific, hard-coded constraints on valid subsequent edges. Furthermore, as described above, they employ an auxiliary model to select features. He and Eisner (2012) share our goal to speed test time prediction by dynamically selecting features, but they also learn an additional model on top of a fixed base model, rather than using the training objective of the model itself.\nWhile our comparisons above focus on other methods of dynamic feature selection, there also exists related work in the field of general (static) feature selection. The most relevant results come from the applications of group sparsity, such as the work of Martins et al. (2011) in Group Lasso for NLP problems. The Group Lasso regularizer (Yuan and Lin, 2006) sparsifies groups of feature weights (e.g. feature templates), and has been used to speed up test-time prediction by removing entire templates from the model. The key difference between this work and ours is that we select our templates based on the test-time difficulty of the inference problem, while the Group Lasso must do so at train time. In Appendix A, we compare against Group Lasso and show improvements in accuracy and speed.\nNote that non-grouped approaches to selecting sparse feature subsets, such as boosting and`1 regularization, do not achieve our goal of fast testtime prediction in NLP models, as they would not zero-out entire templates, and still require the computation of a feature for every template for every test instance.", "publication_ref": ["b28", "b12", "b9", "b24", "b28", "b30", "b1", "b27", "b12", "b11", "b17", "b31"], "figure_ref": [], "table_ref": []}, {"heading": "Experimental Results", "text": "We present experiments on three NLP tasks for which greedy sequence labeling has been a successful solution: part-of-speech tagging, transition-based dependency parsing and named entity recognition. In all cases our method achieves multiplicative speedups at test time with little loss in accuracy.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Part-of-speech tagging", "text": "We conduct our experiments on classifier-based greedy part-of-speech tagging. Our baseline tagger uses the same features described in Choi and Palmer (2012). We evaluate our models on the Penn Treebank WSJ corpus (Marcus et al., 1993), employing the typical split of sections used for part-of-speech tagging: 0-18 train, 19-21 development, 22-24 test. The parameters of our models are learned using AdaGrad (Duchi et al., 2011) with`2 regularization via regularized dual averaging (Xiao, 2009), and we used random search on the development set to select hyperparameters.\nThis baseline model (baseline) tags at a rate of approximately 23,000 tokens per second on a 2010 2.1GHz AMD Opteron machine with accuracy comparable to similar taggers (Gim\u00e9nez and M\u00e0rquez, 2004;Choi and Palmer, 2012;Toutanova et al., 2003 Table 1: Comparison of our models using different margins m, with speeds measured relative to the baseline. We train a model as accurate as the baseline while tagging 3.4x tokens/sec, and in another model maintain > 97% accuracy while tagging 5.2x, and > 96% accuracy with a speedup of 10.3x. the greedy Stanford CoreNLP left3words part-ofspeech tagger also tags at approximately 23,000 tokens per second. Significantly higher absolute speeds for all methods can be attained on more modern machines.\nWe include additional baselines that divide the features into templates, but train the templates' parameters more simply than our algorithm. The stagewise baseline learns the model parameters for each of the templates in order, starting with only one template-once each template has been trained for a fixed number of iterations, that template's parameters are fixed and we add the next one. We also create a separately-trained baseline model for each fixed prefix of the feature templates (fixed). This shows that our speedups are not simply due to superfluous features in the later templates.\nOur main results are shown in Table 1. We increase the speed of our baseline POS tagger by a factor of 5.2x without falling below 97% test accuracy. By tuning our training method to more aggressively prune templates, we achieve speedups of over 10x while providing accuracy higher than 96%. It is worth noting that the results for our method (dynamic) are all obtained from a single trained model (with hyperparameters optimized for m = 50, which we observed gave a good speedup with nearly no lossin accuracy on the development set), the only difference being Figure 1: Left-hand plot depicts test accuracy as a function of the average number of templates used to predict. Right-hand plot shows speedup as a function of accuracy. Our model consistently achieves higher accuracy while using fewer templates resulting in the best ratio of speed to accuracy. that we varied the margin at test time. Superior results for m 6 = 50 could likely be obtained by optimizing hyperparameters for the desired margin.\nResults show our method (dynamic) learns to dynamically select the number of templates, often using only a small fraction. The majority of test tokens can be tagged using only the first few templates: just over 40% use one template, and 75% require at most four templates, while maintaining 97.17% accuracy. On average 6.71 out of 46 templates are used, though a small set of complicated instances never surpass the margin and use all 46 templates. The right hand plot of Figure 1 shows speedup vs. accuracy for various settings of the confidence margin m.\nThe left plot in Figure 1 depicts accuracy as a function of the number of templates used at test time. We present results for both varying the number of templates directly (dashed) and margin (solid). The baseline model trained on all templates performs very poorly when using marginbased inference, since its training objective does not learn to predict with only prefixes. When predicting using a fixed subset of templates, we use a different baseline model for each one of the 46 total template prefixes, learned with only those features; we then compare the test accuracy of our dynamic model using template prefix i to the baseline model trained on the fixed prefix i. Our model performs just as well as these separately trained models, demonstrating that our objective learns weights that allow each prefix to act as its own high-quality classifier.", "publication_ref": ["b3", "b16", "b6", "b29", "b8", "b3", "b23"], "figure_ref": [], "table_ref": []}, {"heading": "Learning the template ordering", "text": "As described in Section 4.5, we experimented on part-of-speech tagging with three different algorithms for learning an ordering of feature templates: Group Lasso, Group Orthogonal Matching Pursuit (GOMP), and the wrapper method. For the case of Group Lasso, this corresponds to the experimental setup used when evaluating Group Lasso for NLP in Martins et al. (2011). As detailed in the part-of-speech tagging experiments of Appendix A, we found the wrapper method to work best in our dynamic prediction setting. Therefore, we use it in our remaining experiments in parsing and named entity recognition. Essentially, the Group Lasso picks small templates too early in the ordering by penalizing template norms, and GOMP picks large templates too early by overfitting the train error.", "publication_ref": ["b17"], "figure_ref": [], "table_ref": []}, {"heading": "Transition-based dependency parsing", "text": "We base our parsing experiments on the greedy, non-projective transition-based dependency parser described in Choi and Palmer (2011). Our model uses a total of 60 feature templates based mainly on the word form, POS tag, lemma and assigned head label of current and previous input and stack tokens, and parses about 300 sentences/second on a modest 2.1GHz AMD Opteron machine.\nWe train our parser on the English Penn Tree-Bank, learning the parameters using AdaGrad and the parsing split, training on sections 2-21, testing on section 23 and using section 22 for development and the Stanford dependency framework (de Figure 2: Parsing speedup as a function of accuracy. Our model achieves the highest accuracy while using the fewest feature templates. Marneffe and Manning, 2008). POS tags were automatically generated via 10-way jackknifing using the baseline POS model described in the previous section, trained with AdaGrad using`2 regularization, with parameters tuned on the development set to achieve 97.22 accuracy on WSJ sections 22-24. Lemmas were automatically generated using the ClearNLP morphological analyzer. We measure accuracy using labeled and unlabeled attachment scores excluding punctuation, achieving a labeled score of 90.31 and unlabeled score of 91.83, which are comparable to similar greedy parsers (Choi and Palmer, 2011;Honnibal and Goldberg, 2013).\nOur experimental setup is the same as for partof-speech tagging. We compare our model (dynamic) to both a single baseline model trained on all features, and a set of 60 models each trained on a prefix of feature templates. Our experiments vary the margin used during prediction (solid) as well as the number of templates used (dashed).\nAs in part-of-speech tagging, we observe significant test-time speedups when applying our method of dynamic feature selection to dependency parsing. With a loss of only 0.04 labeled attachment score (LAS), our model produces parses 2.7 times faster than the baseline. As listed in Table 2, with a more aggressive margin our model can parse more than 3 times faster while remaining above 90% LAS, and more than 5 times faster while maintaining accuracy above 88.5%.\nIn Figure 2 we see not only that our dynamic model consistently achieves higher accuracy while Table 2: Comparison of our baseline and templated models using varying margins m and numbers of templates. using fewer templates, but also that our model (dynamic, dashed) performs exactly as well as separate models trained on each prefix of templates (baseline, dashed), demonstrating again that our training objective is successful in learning a single model that can predict as well as possible using any prefix of feature templates while successfully selecting which of these prefixes to use on a perexample basis.", "publication_ref": ["b2", "b5", "b2", "b13"], "figure_ref": [], "table_ref": []}, {"heading": "Named entity recognition", "text": "We implement a greedy left-to-right named entity recognizer based on Ratinov and Roth (2009) using a total of 46 feature templates, including surface features such as lemma and capitalization, gazetteer look-ups, and each token's extended prediction history, as described in (Ratinov and Roth, 2009). Training, tuning, and evaluation are performed on the CoNLL 2003 English data set with the BILOU encoding to denote label spans.\nOur baseline model achieves F1 scores of 88.35 and 93.37 on the test and development sets, respectively, and tags at a rate of approximately 5300 tokens per second on the hardware described in the experiments above. We achieve a 2.3x speedup while maintaining F1 score above 88 on the test set.", "publication_ref": ["b19", "b19"], "figure_ref": [], "table_ref": []}, {"heading": "Conclusions and Future Work", "text": "By learning to dynamically select the most predictive features at test time, our algorithm provides significant speed improvements to classifier-based structured prediction algorithms, which themselves already comprise the fastest methods in NLP. Further, these speed gains come at very lit-  ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgements", "text": "This work was supported in part by the Center for Intelligent Information Retrieval, in part by DARPA under agreement number FA8750-13-2-0020, and in part by NSF grant #CNS-0958392. The U.S. Government is authorized to reproduce and distribute reprint for Governmental purposes notwithstanding any copyright annotation thereon. Any opinions, findings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect those of the sponsor.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Understanding the value of features for coreference resolution", "journal": "", "year": "2008", "authors": "Eric Bengtson; Dan Roth"}, {"ref_id": "b1", "title": "Classifier cascade for minimizing feature evaluation cost", "journal": "", "year": "2012", "authors": "Minmin Chen; \" Zhixiang; \" Eddie;  Xu; Q Kilian; Olivier Weinberger; Dor Chappele;  Kedem"}, {"ref_id": "b2", "title": "Getting the Most out of Transition-based Dependency Parsing. Association for Computational Linguistics", "journal": "", "year": "2011", "authors": "Jinho Choi; Martha Palmer"}, {"ref_id": "b3", "title": "Fast and robust part-of-speech tagging using dynamic model selection", "journal": "", "year": "2012", "authors": "Jinho Choi; Martha Palmer"}, {"ref_id": "b4", "title": "Search-based structured prediction", "journal": "", "year": "2009", "authors": "Hal Daum\u00e9; Iii ; John Langford; Daniel Marcu"}, {"ref_id": "b5", "title": "The stanford typed dependencies representation", "journal": "", "year": "2008", "authors": "Marie-Catherine De Marneffe; Christopher D Manning"}, {"ref_id": "b6", "title": "Adaptive Subgradient Methods for Online Learning and Stochastic Optimization", "journal": "JMLR", "year": "2011", "authors": "John Duchi; Elad Hazan; Yoram Singer"}, {"ref_id": "b7", "title": "Least angle regression", "journal": "The Annals of Statistics", "year": "2004", "authors": "Trevor Bradley Efron; Iain Hastie; Robert Johnstone;  Tibshirani"}, {"ref_id": "b8", "title": "Svmtool: A general pos tagger generator based on support vector machines", "journal": "", "year": "2004", "authors": "Jes\u00fas Gim\u00e9nez; Llu\u00eds M\u00e0rquez"}, {"ref_id": "b9", "title": "SpeedBoost: Anytime Prediction with Uniform Near-Optimality", "journal": "", "year": "2012", "authors": "Alexander Grubb; J Andrew Bagnell"}, {"ref_id": "b10", "title": "Forward stagewise regression and the monotone lasso", "journal": "Electronic Journal of Statistics", "year": "2007", "authors": "Trevor Hastie; Jonathan Taylor; Robert Tibshirani; Guenther Walther"}, {"ref_id": "b11", "title": "Cost-sensitive dynamic feature selection", "journal": "", "year": "2012", "authors": "He He; Jason Eisner"}, {"ref_id": "b12", "title": "Dynamic feature selection for dependency parsing", "journal": "", "year": "2013", "authors": "He He; Hal Daum\u00e9; Iii ; Jason Eisner"}, {"ref_id": "b13", "title": "A Non-Monotonic Arc-Eager Transition System for Dependency Parsing", "journal": "CoNLL", "year": "2013", "authors": "M Honnibal; Y Goldberg"}, {"ref_id": "b14", "title": "Wrappers for feature subset selection", "journal": "Artificial Intelligence", "year": "1997", "authors": "Ron Kohavi; George H John "}, {"ref_id": "b15", "title": "Group orthogonal matching pursuit for logistic regression", "journal": "", "year": "2011", "authors": "C Aur\u00e9lie; Grzegorz Lozano; Naoki Swirszcz;  Abe"}, {"ref_id": "b16", "title": "Building a Large Annotated Corpus of English: The Penn Treebank", "journal": "Computational Linguistics", "year": "1993", "authors": "Mitchell P Marcus; Beatrice Santorini; Mary Ann Marcinkiewicz"}, {"ref_id": "b17", "title": "Structured sparsity in structured prediction", "journal": "", "year": "2011", "authors": "Andr\u00e9 Martins; Noah Smith; Pedro Aguiar; M\u00e1rio Figueiredo"}, {"ref_id": "b18", "title": "Non-projective dependency parsing in expected linear time", "journal": "", "year": "2009", "authors": "Joakim Nivre"}, {"ref_id": "b19", "title": "Design challenges and misconceptions in named entity recognition", "journal": "Association for Computational Linguistics", "year": "2009", "authors": "Lev Ratinov; Dan Roth"}, {"ref_id": "b20", "title": "A reduction of imitation learning and structured prediction to no-regret online learning", "journal": "JMLR Proceedings", "year": "2011", "authors": "St\u00e9phane Ross; Geoffrey J Gordon; Drew Bagnell"}, {"ref_id": "b21", "title": "Vine pruning for efficient multi-pass dependency parsing", "journal": "", "year": "2012", "authors": "M Alexander; Slav Rush;  Petrov"}, {"ref_id": "b22", "title": "Grouped orthogonal matching pursuit for variable selection and prediction", "journal": "", "year": "2009", "authors": "Grzegorz Swirszcz; Naoki Abe; Aurelie C Lozano"}, {"ref_id": "b23", "title": "Feature-rich part-ofspeech tagging with a cyclic dependency network", "journal": "", "year": "2003", "authors": "Kristina Toutanova; Dan Klein; D Christopher; Yoram Manning;  Singer"}, {"ref_id": "b24", "title": "Supervised sequential classification under budget constraints", "journal": "", "year": "2013", "authors": "Kirill Trapeznikov; Venkatesh Saligrama"}, {"ref_id": "b25", "title": "Support vector machine learning for interdependent and structured output spaces", "journal": "", "year": "2004", "authors": "Ioannis Tsochantaridis; Thomas Hofmann; Thorsten Joachims; Yasemin Altun"}, {"ref_id": "b26", "title": "Rapid object detection using a boosted cascade of simple features", "journal": "IEEE", "year": "2001", "authors": "Paul Viola; Michael Jones"}, {"ref_id": "b27", "title": "Structured prediction cascades", "journal": "", "year": "2010", "authors": "David Weiss; Ben Taskar"}, {"ref_id": "b28", "title": "Learning adaptive value of information for structured prediction", "journal": "", "year": "2013", "authors": "David Weiss; Ben Taskar"}, {"ref_id": "b29", "title": "Dual Averaging Method for Regularized Stochastic Learning and Online Optimization", "journal": "", "year": "2009", "authors": "Lin Xiao"}, {"ref_id": "b30", "title": "Cost-sensitive tree of classifiers", "journal": "", "year": "2013", "authors": "\"eddie\" Zhixiang; Matt J Xu;  Kusner; Q Kilian; Minmin Weinberger;  Chen"}, {"ref_id": "b31", "title": "Model selection and estimation in regression with grouped variables", "journal": "Journal of the Royal Statistical Society: Series B (Statistical Methodology)", "year": "2006", "authors": "Ming Yuan; Yi Lin"}], "figures": [{"figure_label": "3", "figure_type": "table", "figure_id": "tab_3", "figure_caption": "Comparison of our baseline and templated NER models using varying margin m and number of templates.tle extra implementation cost and can easily be combined with existing state-of-the-art systems. Future work will remove the fixed ordering for feature templates, and dynamically add additional features based on the current scores of different labels.", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "y \u21e4 = arg max y2Y w \u2022 (x, y).", "formula_coordinates": [2.0, 356.24, 586.38, 120.34, 21.86]}, {"formula_id": "formula_1", "formula_text": "w \u21e4 = arg min w X i`( x i , y i , w) + R(w).", "formula_coordinates": [2.0, 328.41, 652.43, 175.99, 33.63]}, {"formula_id": "formula_2", "formula_text": "w \u2022 (x, y) = X j w j \u2022 j (x, y)(2)", "formula_coordinates": [2.0, 345.76, 728.69, 179.79, 33.63]}, {"formula_id": "formula_3", "formula_text": "P i,y (x, w) = i X j=1 w j \u2022 j (x, y),", "formula_coordinates": [3.0, 111.11, 592.68, 140.04, 34.69]}, {"formula_id": "formula_4", "formula_text": "h(P i , y) = max{0, max y 0 6 =y P i,y 0 P i,y + m} Algorithm 1 Inference Input: template parameters {w i } k i=1", "formula_coordinates": [3.0, 87.5, 64.93, 389.68, 697.38]}, {"formula_id": "formula_5", "formula_text": "Initialize: i = 1 while l > 0^i \uf8ff k do l = max y 0 h(P i , y 0 ) (test) or h(P i , y) (train) i i + 1 end while return {P j } i j=1 (train) or max y 0 P i,y 0 (test) Algorithm 2 Parameter Learning Input: examples {(x i , y i )} N i , margin m Initialize: parameters w 0 = 0, i = 1 while i \uf8ff N do prefixes Infer(x i , y i , w i , m) g i ComputeGradient(prefixes) w i+1", "formula_coordinates": [3.0, 307.28, 110.31, 213.57, 197.53]}, {"formula_id": "formula_6", "formula_text": "w \u21e4 = arg min w X (x,y)`( x, y, w) (x, y, w) = i \u21e4 y X i=1 h(P i (x, w), y) i \u21e4 y = min i2{1..k} i s.t. h(P i , y) = 0", "formula_coordinates": [4.0, 95.7, 446.53, 280.38, 99.35]}, {"formula_id": "formula_7", "formula_text": "@@ w j = i \u21e4 y X i=j j (x, y loss (P i , y)) j (x, y).", "formula_coordinates": [4.0, 92.87, 607.51, 182.17, 38.2]}, {"formula_id": "formula_8", "formula_text": "y 0 P i,y 0 m \u2022 I(y 0 = y),", "formula_coordinates": [4.0, 159.44, 680.06, 120.79, 22.0]}, {"formula_id": "formula_9", "formula_text": "P i c i kw i k 2", "formula_coordinates": [4.0, 347.28, 339.9, 51.15, 21.58]}], "doi": ""}