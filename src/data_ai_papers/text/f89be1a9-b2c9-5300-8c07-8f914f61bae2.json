{"title": "On the Relation Between Approximation Fixpoint Theory and Justification Theory", "authors": "Simon Marynissen; Bart Bogaerts; Marc Denecker; K U Leuven", "pub_date": "", "abstract": "Approximation Fixpoint Theory (AFT) and Justification Theory (JT) are two frameworks to unify logical formalisms. AFT studies semantics in terms of fixpoints of lattice operators, and JT in terms of so-called justifications, which are explanations of why certain facts do or do not hold in a model. While the approaches differ, the frameworks were designed with similar goals in mind, namely to study the different semantics that arise in (mainly) non-monotonic logics. The first contribution of our current paper is to provide a formal link between the two frameworks. To be precise, we show that every justification frame induces an approximator and that this mapping from JT to AFT preserves all major semantics. The second contribution exploits this correspondence to extend JT with a novel class of semantics, namely ultimate semantics: we formally show that ultimate semantics can be obtained in JT by a syntactic transformation on the justification frame, essentially performing some sort of resolution on the rules.", "sections": [{"heading": "Introduction", "text": "In this framework, we are concerned with two theories developed with similar intentions, namely to unify semantics of (mostly non-monotonic) logics, namely Approximation Fixpoint Theory (AFT) and Justification Theory (JT).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Approximation Fixpoint Theory", "text": "In the 1980s and 90s, the area of non-monotonic reasoning (NMR) saw fierce debates about formal semantics. In several subareas, researchers sought to formalise common-sense intuitions about knowledge of introspective agents. In these areas, appeals to similar intuitions were made, resulting in the development of similar mathematical concepts. Despite the obvious similarity, the precise relation between these concepts remained elusive. AFT was founded in the early 2000s by Denecker, Marek and Truszczy\u0144ski [2000] as a way of unifying semantics that emerged in these different subareas. The main contribution of AFT was to demonstrate that, by moving to an algebraic setting, the common principles behind these concepts can be isolated and studied in a general way. This breakthrough allowed results that were achieved in the context of one of these languages to be easily transferred to another. In the early stages, AFT was applied to default logic, auto-epistemic logic, and logic programming [Denecker et al., 2000;Denecker et al., 2003]. In recent years also applications in various other domains have emerged [Strass, 2013;Bi et al., 2014;Charalambidis et al., 2018;Bogaerts and Cruz-Filipe, 2018].\nThe foundations of AFT lie in Tarski's fixpoint theory of monotone operators on a complete lattice [Tarski, 1955]. AFT demonstrates that by moving from the original lattice L to the bilattice L 2 , Tarski's theory can be generalised into a fixpoint theory for arbitrary (i.e., also non-monotone) operators. Crucially, all that is required to apply AFT to a formalism and obtain several semantics is to define an appropriate approximating operator L 2 \u2192 L 2 on the bilattice; the algebraic theory of AFT then takes care of the rest. For instance, to characterise the major logic programming semantics using AFT, it suffices to define Fitting's four-valued immediate consequence operator [Fitting, 2002]. The (partial) stable fixpoints of that operator (as defined by AFT) are exactly the partial stable models of the original program; the wellfounded fixpoint of the operator is the well-founded model of the program, etc.", "publication_ref": ["b0", "b0", "b0", "b0", "b0", "b2"], "figure_ref": [], "table_ref": []}, {"heading": "Justification Theory", "text": "Building on an old semantical framework for (abductive) logic programming [Denecker and De Schreye, 1993], Denecker et al. [2015] defined an abstract theory of justifications suitable for describing the semantics of a range of logics in knowledge representation, computational and mathematical logic, including logic programs, argumentation frameworks and nested least and greatest fixpoint definitions. Justifications provide a refined way of describing the semantics of a logic: they not only define whether an interpretation is a model (under a suitable semantics) of a theory, but also why.\nJustifications -albeit not always in the exact formal form as described by Denecker et al. [2015] -have appeared in different ways in different areas. The stable semantics for logic programs was defined in terms of justifications [Fages, 1990;Schulz and Toni, 2013]. Moreover, an algebra for combining justifications (for logic programs) was defined by Cabalar et al. [2014]; and justifications are underlying provenance systems in databases [Dam\u00e1sio et al., 2013].\nNext to these theoretic benefits, justifications are also used in implementations of answer set solvers (they form the basis of the so-called source-pointer approach in the unfounded set algorithm [Gebser et al., 2009], and turned out to be key in analyzing conflicts in the context of lazy grounding [Bogaerts and Weinzierl, 2018]), as well as to improve parity game solvers [Lapauw et al., 2020].", "publication_ref": ["b0", "b0", "b2", "b0", "b0", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "Correspondence", "text": "The two described frameworks were designed with similar intentions in mind, namely to unify different (mainly nonmonotonic) logics. One major difference between them is that JT is defined logically while AFT is defined purely algebraically. This makes justification frameworks less abstract and easier to grasp, but also in a certain sense less general. On the other hand, Denecker et al. [2015] defined a notion of nesting, which seems promising to integrate the semantics of nested least and nested greatest fixpoint definitions. Despite the differences, certain correspondences between the theories show up: several definitions in justification frameworks seem to have an algebraical counterpart in AFT. This is evident from the fact that many results on justifications are formulated in terms of fixpoints of a so-called derivation operator that happens, for the case of logic programming, to coincide with (Fitting's three-valued version of) the immediate consequence operator for logic programs. Of course, now the question naturally arises whether this correspondence can be made formal, i.e., whether it can formally be shown that semantics induced by JT will always coincide with their equally-named counterpart in AFT. If the answer is positive, this will allow us to translate results between the two theories. Formalising this correspondence is the key contribution of the current paper.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Contributions", "text": "Our contributions can be summarised as follows:\n\u2022 In Section 3, we provide some novel results for JT.\nWhile the main purpose of these results is to support the theorems of Section 4, they also directly advance the state of JT. In this section, we show among others how different semantics induced by JT relate, and we resolve a discrepancy that exists between different definitions of so-called stable and supported branch evaluations in prior work. We formally prove that the different circulating definitions of these branch evaluations indeed induce the same semantics.\n\u2022 In Section 4, we turn our attention to the key contribution of the paper, namely embedding JT in AFT. To do this, we proceed as follows. First, we show that under minor restrictions, each justification frame (intuitively, this is a set of rules that describe when a positive or negative fact is true), can be transformed into an approximator. Next, we show that for each of the most common branch evaluations (these are mathematical structures that are used to associate semantics to a justification frame), the induced semantics by JT is the same as the equally-named semantics on the AFT side. Establishing this result is of particular importance for the future development of JT, since this result immediately makes a large body of theoretical results developed in the context of AFT readily available for JT, as well as all its future application domains, including results on stratification [Vennekens et al., 2006;Bogaerts and Cruz-Filipe, 2021], predicate introduction [Vennekens et al., 2007], and knowledge compilation [Bogaerts and Van den Broeck, 2015]. On the other hand, from the context of AFT, the embedding of JT can serve as inspiration for developing more general algebraic explanation mechanisms.\n\u2022 To illustrate how this connection can be exploited for further exploiting the theory of justifications, we turn our attention to ultimate semantics. In the context of AFT, Denecker and his coauthors have realised that a single operator can have multiple approximators and that the choice of approximator influences the induced semantics. They also showed that -when staying in the realm of consistent AFT -every operator induces a most precise approximator, and called this the ultimate approximator [Denecker et al., 2004]. In Section 5, we transfer this idea to JT. We show there that by means of a simple transformation 1 on the justification frame, we can obtain ultimate semantics. Importantly, since this transformation is defined independent of the branch evaluation at hand, ultimate semantics are not just induced for the semantics that have a counterpart in AFT, but for all conceivable current and future branch evaluations as well.", "publication_ref": ["b2", "b0", "b2", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "Preliminaries: Justification Theory", "text": "In this section, we use the formalisation of JT as done by Marynissen et al. [2020]. Truth values are denoted t (true), f (false) and u (unknown); we write L for {t, f , u}. We make use of two orders on L, the truth order f \u2264 t u \u2264 t t and the precision order u \u2264 p f , t. JT starts with a set F , referred to as a fact space, such that L \u2286 F ; the elements of F are called facts. We assume that F is equipped with an involution \u223c : F \u2192 F (i.e., a bijection that is its own inverse) such that \u223ct = f , \u223cu = u, and \u223cx = x for all x = u. Moreover, we assume that F \\ L is partitioned into two disjoint sets F + and F \u2212 such that x \u2208 F + if and only if \u223cx \u2208 F \u2212 for all x \u2208 F \\ L. Elements of F + are called positive and elements of F \u2212 are called negative facts. An example of a fact space is the set of literals over a propositional vocabulary \u03a3 extended with L where \u223c maps a literal to its negation. For any set A we define \u223cA to be the set of elements of the form \u223ca for a \u2208 A. We distinguish two types of facts: defined and open facts. The former are accompanied by a set of rules that determine their truth value. The truth value of the latter is not governed by the rule system but comes from an external source or is fixed (as is the case for logical facts).\nDefinition 1. A justification frame JF is a tuple F , F d , R such that \u2022 F d is a subset of F closed under \u223c, i.e., \u223cF d = F d ; facts in F d are called defined; \u2022 no logical fact is defined: L \u2229 F d = \u2205; \u2022 R \u2286 F d \u00d7 2 F \\\u2205 ; \u2022 for each x \u2208 F d there is at least one element (x, A) \u2208 R.\nThe set F o of open facts is equal to F \\ F d . An element (x, A) \u2208 R is called a rule with head x and body (or case) A. The set of cases of x in JF is denoted JF (x). Rules (x, A) \u2208 R are denoted as x \u2190 A and if A = {y 1 , . . . , y n }, we often write x \u2190 y 1 , . . . , y n .\nLogic programming rules can easily be transfered to rules in a justification frame. However, in logic programming, only rules for positive facts are given; never for negative facts. Hence, in order to apply JT to logic programming, a mechanism for deriving rules for negative literals is needed. For this, a technique called complementation was invented [Denecker et al., 2015]; it is a generic mechanism that allows turning a set of rules for x into a set of rules for \u223cx. To define complementation, we first define selection functions for x. A selection function for x is a mapping s : JF (x) \u2192 F such that s(A) \u2208 A for all rules of the form x \u2190 A. Intuitively, a selection function chooses an element from the body of each rule of x. For a selection function s, the set {s(A) | A \u2208 JF (x)} is denoted by Im(s).\nDefinition 2. For a set of rules R, we define R * to be the set of rules of the form \u223cx \u2190 \u223cIm(s) for x \u2208 F d that has rules in R and s a selection function for x. The complementation of JF is defined as F ,\nF d , R \u222a R * . A justification frame JF is complementary if it is fixed under complementation, i.e., R \u222a R * = R. Example 1. If R = {x \u2190 a, b; x \u2190 c; }, then R * = {\u223cx \u2190 \u223ca, \u223cc; \u223cx \u2190 \u223cb, \u223cc}. Definition 3. A directed graph is a pair (N, E)\nwhere N is a set of nodes and E \u2286 N \u00d7 N is the set of edges. An internal node is a node with outgoing edges. A leaf is a non-internal node.\nDefinition 4. Let JF = F , F d , R be a justification frame. A justification J in JF is a directed graph (N, E) such that for every internal node n \u2208 N it holds that n \u2190 {m | (n, m) \u2208 E} \u2208 R;\nA justification is locally complete if it has no leaves in F d . We write J(x) to denote the set of locally complete justifications that have an internal node x. Definition 5. Let JF be a justification frame. A JF -branch is either an infinite sequence in F d or a finite non-empty sequence in F d followed by an element in F o . For a justification J in JF , a J-branch starting from x \u2208 F d is a path in J starting from x that is either infinite or ends in a leaf of J. We write B J (x) to denote the set of J-branches starting from x. Not all J-branches are JF -branches since they can end in a defined fact. However, if J is locally complete, any J-branch is also a JF -branch. We denote a branch b as b :\nx 0 \u2192 x 1 \u2192 \u2022 \u2022 \u2022 and define \u223cb as \u223cx 0 \u2192 \u223cx 1 \u2192 \u2022 \u2022 \u2022 . A tail of a branch b is a branch x i \u2192 x i+1 \u2192 \u2022 \u2022 \u2022 for some i \u2265 0.\nDefinition 6. A branch evaluation B is a mapping that maps any JF -branch to an element in F for all justification frames JF . A branch evaluation B is consistent if B(\u223cb) = \u223cB(b) for any branch b. A justification frame JF together with a branch evaluation B form a justification system JS, which is presented as a quadruple F , F d , R, B .\nThe main branch evaluations we are interested in are given below: Definition 7. The supported branch evaluation B sp maps\nx 0 \u2192 x 1 \u2192 \u2022 \u2022 \u2022 to x 1 .\nThe Kripke-Kleene branch evaluation B KK maps finite branches to their last element and infinite branches to u. The well-founded branch evaluation B wf maps finite branches to their last element. It maps infinite branches to t if they have a negative tail, to f if they have a positive tail and to u otherwise. The stable branch evaluation B st maps a branch x 0 \u2192 x 1 \u2192 \u2022 \u2022 \u2022 to the first element that has a different sign than x 0 if it exists; otherwise b is mapped to B wf (b). Definition 8. A (three-valued) interpretation of F is a function I : F \u2192 L such that I(\u223cx) = \u223cI(x) for all x \u2208 F and I( ) = for all \u2208 L. Models under justification semantics are determined by the supported value. Definition 10. Let JF be justification frame and B a branch evaluation. An F -interpretation I is a B-model of JF if for all x \u2208 F , SV B JF (x, I) = I(x), i.e., I is a fixpoint of S B JF . A B sp , B KK , B st , or B wf -model is called a supported, Kripke-Kleene, stable, or well-founded model. Example 3. Let F = {p, \u223cp, q, \u223cq}\u222aL and take R to be the complementation of {p \u2190 p; p \u2190 \u223cq; q \u2190 q}, i.e. adding the rules \u223cp \u2190 \u223cp, q and \u223cq \u2190 \u223cq. There are exactly two locally complete justifications with p as an internal node: p p \u223cq Under B wf , the left justification has a value f for p, while the right justification has a value t for p. Since these justifications are the only locally complete ones containing p as an internal node we have that SV B wf (p, I) = t for all interpretations I of F . This shows us that the unique B wf -model is the interpretation mapping p to t and q to f .", "publication_ref": ["b0"], "figure_ref": [], "table_ref": []}, {"heading": "Tying Up Loose Ends", "text": "In this section, we prove some results about JT that will be needed for developing our theory later on. These results resolve several issues that were left open in prior work, but turn out to be crucial for studying the relationship with AFT.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Pasting Justifications", "text": "Our first result is essentially a pasting result. What it states is that we can, for all branch evaluations of interest to the current paper, build a single justification that explains the value of all facts. In other words, it provides a means of gluing justifications for different facts together. The first theorem has already been proven in a slightly different context by Marynissen et al. [2018].\nTheorem 1. Take B \u2208 {B sp , B KK , B st , B wf }. For every interpretation I, there is a locally complete justification J such that val B (x, J, I) = SV B (x, I) for all x \u2208 F d .\nSimilarly, this holds for B sp and B st , but only for models.\nTheorem 2. Take B \u2208 B sp , B st . For every B-model I, there is a locally complete justification J such that val B (x, J, I) = SV B (x, I) for all x \u2208 F d .", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Equivalence of Branch Evaluations", "text": "Our second result concerns different versions of the stable and supported branch evaluations that circulate in prior work. Marynissen et al. [2018;2020] use the stable and supported branch evaluations as we defined them in Definition 7, while Denecker et al. [2015] use the following alternative.\nDefinition 11. The branch evaluation B sp is equal to B sp on infinite branches and maps finite branches to their last element. The branch evaluation B st is equal to B st except B st maps any finite branch to its last element.\nOf course this begs the question in which sense these branch evaluations are related. What we show next is that for the purpose of defining models, they are interchangeable.\nDefinition 12. Two branch evaluations B 1 and B 2 are equivalent if for all justification frames JF , the B 1 -models and the B 2 -models of JF coincide.\nOur proofs that B sp and B sp , and B st and B st are equivalent, will make use of the following lemma, which intuitively states that to show that an interpretation is a B-model, it suffices to show that the supported value of each fact is at least its value in the interpretation. Lemma 1. Take JS = F , F d , R, B with B consistent. Every interpretation I such that SV JS (x, I) \u2265 t I(x) for all x \u2208 F d , is a B-model of JF . Proposition 1. The two supported branch evaluations B sp and B sp are equivalent. Proposition 2. The two stable branch evaluations B st and B st are equivalent.\nSketch of the proofs of Propositions 1 and 2. The difference between the two branch evaluations at hand is that in the one (B ), finite branches are evaluated with respect to their final element, and the other (B) with respect to some other element y in the branch (second or first sign switch). Take a B-model I and take a justification J as from Theorems 1 or 2. With some care, we can prove that the final element of a J-branch has a larger value than first element in I under \u2264 t . Therefore, I satisfies the conditions of Lemma 1, proving that I is a B -model. The other direction is proven similarly.", "publication_ref": ["b0"], "figure_ref": [], "table_ref": []}, {"heading": "Links between Different Justification Models", "text": "Our third set of results is concerned with the relation between different semantics induced by JT. In the context of logic programming, it is well-known that there is a unique wellfounded model, what the relation between well-founded and stable model is, etcetera. Several such results will follow immediately by establishing the correspondence with AFT, but some of them will be needed in our proof. They are given explicitly, and sometimes in higher generality, in the current section.\nFirst of all, in logic programming, it is well-known that the well-founded and Kripke-Kleene semantics induce a single model. In JT, we find an analogous result for a broad class of branch evaluations. A branch evaluation B is called parametric if B(b) \u2208 F o for all JF -branches and all justification frames JF . Denecker et al. [2015] provided the following result. Proposition 3. If JF is a justification frame and B a parametric branch evaluation, then JF has a single B-model.\nIn this proposition, we of course make use of our earlier assumption that the value of the open facts is fixed. In general, every interpretation of the open facts induces a single model. Corollary 1. Every justification frame has a unique B KKmodel and a unique B wf -model. Proposition 4. The unique B KK -model is a B sp -model. Proposition 5. The well-founded model of JF is a stable model of JF . Proposition 6. Every stable justification model is a supported justification model. Proof sketches of Proposition 4, 5 and 6. The idea of the proof is that the justification according to Theorem 1 also works for the other branch evaluation.\nLemma 2. Let I be a stable justification model. If SV B wf (x, I) = f , then I(x) = f . If SV B wf (x, I) = t, then I(x) = t.\nProof sketch. Take x \u2208 F d with I(x) = f . By using that I is a B st -model, we can prove that every justification J has a branch b \u2208 B J (x) such that I(B wf (b)) \u2264 t u. This concludes that SV B wf (x, I) = t.\nProposition 7. The well-founded model is the \u2264 p -least stable model.\nProof sketch. Lemma 2 implies that the well-founded model is less precise than any stable model. Then Proposition 5 finishes the proof.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Embedding JT in AFT", "text": "We now turn our attention to the main topic of this paper, namely formally prove the correspondence between JT and AFT. We start with a brief recall of the basic definitions that constitute AFT, next show how to obtain an approximator out of a justification frame, and finally prove that indeed, all major semantics are preserved under this correspondence.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Preliminaries: AFT", "text": "Given a complete lattice L, \u2264 , AFT [Denecker et al., 2000] uses the bilattice L 2 = L\u00d7L. We define projection functions as usual: (x, y) 1 = x and (x, y) 2 = y. Pairs (x, y) \u2208 L 2 are used to approximate elements in the interval\n[x, y] = {z | x \u2264 z \u2264 y}. We call (x, y) \u2208 L 2 consistent if x \u2264 y, i.e., if [x, y] is not empty. The set of consistent elements is denoted L c . A pair (x, x) is called exact since it approxi- mates only the element x. The precision order \u2264 p on L 2 is defined as (x, y) \u2264 p (u, v) if x \u2264 u and y \u2265 v. If (u, v) is consistent, this means that [u, v] \u2286 [x, y].\nIf L, \u2264 is a complete lattice, then so is L 2 , \u2264 p . AFT studies fixpoints of operators O : L \u2192 L through operators approximating O. An operator A : L 2 \u2192 L 2 is an approximator of O if it is \u2264 pmonotone and has the property that A(x, x) = (O(x), O(x)) for all x \u2208 L. Approximators are internal in L c (i.e., map L c into L c ). We often restrict our attention to symmetric approximators: approximators A such that, for all x and y, A(x, y) 1 = A(y, x) 2 . Denecker et al. [2004] showed that the consistent fixpoints of interest of a symmetric approximator are uniquely determined by an approximator's restriction to L c and hence, that it usually suffices to define approximators on L c . Such a restriction is called a consistent approximator. As mentioned before, AFT studies fixpoints of O using fixpoints of A. The main type of fixpoints that concern us are given here.\n\u2022 A partial supported fixpoint of A is a fixpoint of A.\n\u2022 The Kripke-Kleene fixpoint of A is the \u2264 p -least fixpoint of A; it approximates all fixpoints of A. \u2022 A partial stable fixpoint of A is a pair (x, y) such that x = lfp(A(\u2022, y) 1 ) and y = lfp(A(x, \u2022) 2 ), where A(\u2022, y) 1 denotes the function L \u2192 L : z \u2192 A(z, y) 1 and analogously A(x, \u2022) 2 stands for L \u2192 L : z \u2192 A(x, z) 2 . \u2022 The well-founded fixpoint of A is the \u2264 p -least partial stable fixpoint of A.", "publication_ref": ["b0"], "figure_ref": [], "table_ref": []}, {"heading": "The Approximator", "text": "Let JF = F , F d , R be a justification frame, fixed throughout this section. Our first goal is to define, from a given justification frame, an approximator on a suitable lattice. Following the correspondence with how this is done in logic programming, we will take as lattice the set of exact interpretations (interpretations that map no facts to u except for u itself). It is easy to see that such interpretations correspond directly to subsets of F + . In other words, we will use the lattice L = 2 F+ , \u2286 . Now, the set L c is isomorphic to the set of three-valued interpretations of F ; under this isomorphism, So far, we are not aware of practical examples with bodies containing u. From now on, we assume that every justification frame does not have u in a rule body. It turns out that in case our justification frame behaves well with respect to negation (if it is complementary), the approximator is the same operator as induced by the branch evaluation B sp . Lemma 3. For a complementary justification frame JF , the function A JF and the support operator S Bsp JF are equal.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Semantic Correspondence", "text": "The central result of this section is the following theorem, which essentially states that for all major semantics, the branch evaluation in JT corresponds to the definitions of AFT. Theorem 3. Take a complementary justification frame JF .\n\u2022 The partial supported fixpoints of A JF are exactly the supported models of JF .\n\u2022 The Kripke-Kleene fixpoint of A JF is the unique Kripke-Kleene model of JF .\n\u2022 The partial stable fixpoints of A JF are exactly the stable models of JF .\n\u2022 The well-founded fixpoint of A JF is the unique wellfounded model of JF . These four points are proven independently; the first follows directly from our observation that A JF and S Bsp JF are in fact the same operator. Proposition 9. The partial supported fixpoints of A JF are exactly the supported models of JF .\nGiven the correspondence between supported semantics, the result for Kripke-Kleene semantics follows quite easily.\nProposition 10. The Kripke-Kleene fixpoint of A JF is equal to the unique B KK -model of JF .\nProof sketch. By combining Propositions 4, and 9, we get that the unique B KK -model (denoted here I BKK ) is a fixpoint of A JF . All that is left to show is that it is the least precise one. Assume towards contradiction that this is not the case, i.e., that there is a fixpoint I of A JF such that I BKK \u2264 p I. From this we can find an x \u2208 F d such that either I BKK (x) = f and I(x) = t, or I BKK (x) = f and I(x) = u. In both cases, we have I BKK (x) = f ; hence every justification J with x as internal node has a finite branch starting with x mapped to an open fact y with I BKK (y) = f . However, since I BKK and I agree on open facts, this also means that SV B sp (x, I) = f , contradicting that I is a B sp -model.\nThe proof of the third point of Theorem 3 is split in two parts, proven separately in the following propositions.\nProposition 11. Each stable model of JF is a partial stable fixpoint of A JF .\nProof sketch. Take a B st -model I = (I 1 , I 2 ) of JF . To show that I is a partial stable fixpoint, we have two lfp equations to prove. We focus on lfp(A JF (\u2022, I 2 ) 1 ) = I 1 . We know from Theorem 1 that a justification J exists that justifies all facts in I 1 . Now, this specific justification induces a dependency order on the facts in I 1 , defined as y J x if y is reachable in J from x through positive facts. Using the definition of stable branch evaluation, we can see that this order is well-founded and subsequenty prove using well-founded induction on this order that all facts in I 1 must be in lfp(A JF (\u2022, I 2 ) 1 ).\nFor the other direction, we first need the following lemma. Proof sketch. Let I = (I 1 , I 2 ) be a partial stable fixpoint of A JF . We prove that SV Bst (x, I) = I(x) for x \u2208 F + . By consistency of S Bst JF [Marynissen et al., 2018], this proves that I is a stable model of JF . The proof consists of three parts.\n1. SV Bst (x, I) = I(x) = t for all x \u2208 I 1 .", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "SV", "text": "Bst (x, I) = I(x) = u for all x \u2208 I 2 \\ I 1 . 3. SV Bst (x, I) = I(x) = f for all x \u2208 F + \\ I 2 .\nThe first part is proven by constructing a possibly non-locally complete justification without infinite branches, every internal node positive, and for every node y we have that I(y) = t. The construction is possible because I 1 is the least fixpoint of A JF (\u2022, I 2 ) 1 . The second part is proven similarly. Last part is a consequence of Lemma 4.\nExample 4. Let F = {x, \u223cx, y, \u223cy, z, \u223cz} \u222a L and let R be the complementation of {x \u2190 y; y \u2190 \u223cz; z \u2190 \u223cx, \u223cy; }, i.e., it adds the rules \u223cx \u2190 \u223cy; \u223cy \u2190 z; \u223cz \u2190 x and \u223cz \u2190 y. The approximator A JF has three partial stable fixpoints: ({x, y} , {x, y}), ({z} , {z}) and (\u2205, {x, y, z}).\nLet us take a look at the fixpoint ({x, y} , {x, y}). Since it is a stable fixpoint, we know that ({x, y} , {x, y}) is a least fixpoint of A JF (\u2022, {x, y}). This operator is monotone with respect to \u2286; hence we can construct the fixpoint by iteratively applying the operator on (\u2205, {x, y}). This produces the following sequence.\n(\u2205, {x, y}) \u2192 ({y} , {x, y}) \u2192 ({x, y} , {x, y})\nThe first step uses the rule y \u2190 \u223cz, while the second step uses the rule x \u2190 y. Combining the two we get the justifiction x \u2192 y \u2192 \u223cz, which has only true nodes in the model ({x, y} , {x, y}), only positive internal nodes and every defined leaf is negative. This illustrates the first step of the proof of Proposition 12. By extending the found justification, we get a locally complete justification with the same value as the supported value.\nThe proof of the fourth point of Theorem 3 follows directly from the third point and Proposition 7.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Ultimate Semantics for Justification Frames", "text": "When applying AFT to new domains, there is not always a clear choice of which approximator to use; the operator on the other hand is often more clear. Denecker et al. [2004] studied the space of approximators and observed that consistent approximators can naturally be ordered according to their precision, where more precise approximator also yield more precise results (e.g., if approximator A is more precise than B, then the A-well-founded fixpoint is guaranteed to be more precise than B's). They also observed that the space of approximators of O has a most precise element, called the ultimate approximator, denoted U(O).\nIn the context of JT, the justification frame uniquely determines the approximator at hand. Still, we show that it is possible to obtain ultimate semantics here as well. To do so, we will develop a method to transform a justification frame JF into its ultimate frame U(JF ). We will then show that the approximator associated to U(JF ) is indeed the ultimate approximator of O JF . The result is a generic mechanism to go from any semantics induced by JT (for arbitrary branch evaluations -not just for those that have an AFT counterpart) to an ultimate variant thereof. Our construction is as follows: Definition 14. Let JF be a complementary justification frame. Let X be the set rules with a positive head. Let X * be the least (w.r.t. \u2286) set containing X that is closed under the addition of rules x \u2190 A if there is a rule x \u2190 B with B \u2286 A, or if there are rules x \u2190 {y} \u222a A, x \u2190 {\u223cy} \u222a A. Let Y be the complementation of X. Then U(JF ) is defined to be the complementary justification frame F , F d , Y . Example 5. Let F d = {x, \u223cx} and F o = {a, \u223ca, b, \u223cb} \u222a F o . Take R to be the complementation of {x \u2190 a, x x \u2190 b, \u223cx}, which adds the following rules \u223cx \u2190 \u223ca, \u223cb \u223cx \u2190 \u223ca, x \u223cx \u2190 b, \u223cx \u223cx \u2190 x, \u223cx A rule x \u2190 A is minimal, if there is no rule x \u2190 B with B \u2282 A. For determining the supported value, you only need to take minimal rules into account. The justification frame U(JF ) has exactly the following minimal rules:\nx \u2190 a, x x \u2190 b, \u223cx x \u2190 a, b \u223cx \u2190 \u223ca, \u223cb \u223cx \u2190 \u223ca, x \u223cx \u2190 \u223cb, \u223cx Of course, it contains many non-minimal rules, for example x \u2190 a, b, x.\nThe justifications in the original system containing x as an internal nodes are exactly the following: Assume from now on we are working under B st . The value of the upper left justification for x is f in every interpretation.\nThe values of the other justifications for x are at most u in B st -models. If it would be t, then the value of these justifications for x is equal to the value of \u223cx, which is f . By taking the ultimate justification frame, the minimal rule x \u2190 a, b is added and the minimal rule \u223cx \u2190 x, \u223cx is removed. This allows for the justification a \u2190 x \u2192 b. If the interpretation of a and b is t, then the value of this justification for x is t. Therefore, ({a, b, x} , {a, b, x}) is an ultimate stable model, while not a stable model. Note that the lower right justification is not a justification in U(JF ). If it would be, then this is a true justification for \u223cx contradicting the consistency.\nIt can be seen that the construction adds rules to JF in two cases. For the first type, if x \u2190 B is a rule in R with B \u2286 A, then if B is sufficient to derive x, clearly so is A. The second type of rule addition essentially performs some sort of case splitting. It states that if a set of facts A can be used with either y or \u223cy to derive x, then the essence for deriving x is the set A itself. In that case, the rule x \u2190 A is added to the ultimate frame. It turns out that this rule of case splitting is indeed sufficient to reconstruct the ultimate semantics in JT. This is formalised in the main theorem of this section: Theorem 4. For any frame JF , A U(JF ) = U(O JF ).\nAn immediate corollary is, for instance that the set of stable models of U(JF ) equals the set of ultimate stable fixpoints of O JF , and similarly for other semantics. Recall that, in the context of lattices with the subset order, which is what we are concerned with here, the ultimate approximator is defined as follows [Denecker et al., 2004]:\nU(O)(I 1 , I 2 ) = \uf8eb \uf8ed I1\u2286K\u2286I2 O(K), I1\u2286K\u2286I2 O(K) \uf8f6 \uf8f8 . (1)\nThe proof of Theorem 4 makes use of the following intermediate results.\nLemma 5. Let I be an interpretation and x \u2208 F d .\nIf O JF (I )(x) = t (respectively f ) for all exact interpretations I with I \u2265 p I, then A U(JF ) (I)(x) = t (resp. f ).\nProof sketch. Take X = {y \u2208 F d | I(x) = u} and let I = (I 1 , I 2 ). We prove for all Y \u2286 X and all complete consistent sets A over X \\ Y that x \u2190 {t} \u222a I 1 \u222a \u223c(F + \\ I 2 ) \u222a A is a rule in U(JF ). If Y = X, then we get that x \u2190 {t} \u222a I 1 \u222a \u223c(F + \\ I 2 ) is a rule in U(JF ) such that its body is true in I, which completes the proof. Our claim is proved by transfinite induction on the size of Y .\nCombining this lemma with Eq. (1) of the ultimate approximator immediately yields that the operator A U(JF ) (I) is as least as precise as the ultimate approximator of O JF . Lemma 6. For all I we have U(O JF )(I) \u2264 p A U(JF ) (I).\nSince the ultimate approximator is the most precise approximator of any given operator, all that is left to prove, to indeed obtain Theorem 4 is that A U(JF ) indeed approximates O JF . That is the content of the last lemma. Lemma 7. A U(JF ) is an approximator of O JF .", "publication_ref": ["b0", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "Conclusion", "text": "In this paper, we presented a general mechanism to translate justification frames into approximating operators and showed that this transformation preserves all semantics the two formalisms have in common. The correspondence we established provides ample opportunity for future work and in fact probably generates more questions than it answers.\nBy embedding JT in AFT, JT gets access to a rich body of theoretical results developed for AFT, but of course said results are only directly applicable to branch evaluations that have a counterpart in AFT. A question that immediately arises is whether results such as stratification results also apply to other branch evaluations, and which assumptions on branch evaluations would be required for that. Another question that pops up on the JT side is whether concepts such as groundedness [Bogaerts et al., 2015] can be transferred.\nOn the AFT side, this embedding calls for a general algebraic study of explanations. Indeed, for certain approximators, namely those that \"come from\" a justification frame, our results give us a method for answering certain why questions in a graph-based manner (with justifications). Lifting this notion of explanation to general approximators would benefit domains of logics that are covered by AFT but not by JT, such as auto-epistemic logic [Moore, 1985] and default logic [Reiter, 1980].\nA last question that emerges naturally is how nesting of justification frames, as defined by Denecker et al. [2015] fits into this story, and whether it can give rise to notions of nested operators on the AFT side.", "publication_ref": ["b0", "b1", "b2"], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgements", "text": "Many thanks to Maurice Bruynooghe for the valuable comments and suggestions on draft versions. This research received partial funding from the FWO Flanders project G0B2221N.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "] Marc Denecker, Victor Marek, and Miros\u0142aw Truszczy\u0144ski. Ultimate approximation and its application in nonmonotonic knowledge representation systems", "journal": "Simon Marynissen", "year": "1990", "authors": "[ References;  Bi"}, {"ref_id": "b1", "title": "Semantical considerations on nonmonotonic logic", "journal": "AIJ", "year": "1985", "authors": "Robert C Moore;  Moore"}, {"ref_id": "b2", "title": "Hannes Strass. Approximating operators and semantics for abstract dialectical frameworks", "journal": "", "year": "1955", "authors": "Raymond Reiter; ; Reiter; Toni ; Schulz; Claudia Schulz; Francesca Toni ; Alfred Tarski; ; Vennekens"}], "figures": [{"figure_label": "2", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Example 2 .2Take F d = {x, \u223cx, y, \u223cy}, F o = {a, \u223ca, b, \u223cb} \u222a L, and R the complementation of {x \u2190 y, a; y \u2190 y, b}, then x a y b is a locally complete justification in F , F d , R because a and b are open facts.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "We will assume that the interpretation of open facts is fixed; hence any two interpretations coincide on open facts. Definition 9. Let JS = F , F d , R, B be a justification system, I an interpretation of F , and J a locally complete justification in JS. Let x \u2208 F d be a node in J. The value of x \u2208 F d by J under I is defined as val B (J, x, I) = min b\u2208B J (x) I(B(b)), where min is with respect to \u2264 t . The supported value of x \u2208 F in JS under I is defined as SV JS (x, I) = max J\u2208J(x) val B (J, x, I) for x \u2208 F d and SV(x, I) = I(x) for x \u2208 F o . For any F -interpretation I, S JS (I) is the mapping F \u2192 L : x \u2192 SV JS (x, I). The function S JS is called the support operator. If JS consists of JF and B, then we write S B JF for S JS . If JF is clear from context, we write SV B for SV JS .", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "a consistent pair (I, J) \u2208 L c corresponds to the three-valued interpretation I such that for positive facts x \u2208 F + , I(x) = t if x \u2208 I, I(x) = f if x \u2208 J, and I(x) = u otherwise. Definition 13. The operator O JF : L \u2192 L of JF maps a subset I of F + to O JF (I) = {x \u2208 F + | \u2203x \u2190 A \u2208 R : \u2200a \u2208 A : (I, I)(a) = t} . The approximator A JF : L c \u2192 L c of JF is defined as follows A JF (I) 1 = {x \u2208 F + | \u2203x \u2190 A \u2208 R : \u2200a \u2208 A : I(a) = t} A JF (I) 2 = {x \u2208 F + | \u2203x \u2190 A \u2208 R : \u2200a \u2208 A : I(a) \u2265 t u} Proposition 8. If no rule body in JF contains u, then A JF is a consistent approximator of O JF .", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Lemma 4 .4Let I be a B sp -model and x \u2208 F + with SV Bsp (x, I) = f . It holds that SV Bst (x, I) = f . Proposition 12. Each partial stable fixpoint of A JF is a stable model of JF .", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "Definition 1. A justification frame JF is a tuple F , F d , R such that \u2022 F d is a subset of F closed under \u223c, i.e., \u223cF d = F d ; facts in F d are called defined; \u2022 no logical fact is defined: L \u2229 F d = \u2205; \u2022 R \u2286 F d \u00d7 2 F \\\u2205 ; \u2022 for each x \u2208 F d there is at least one element (x, A) \u2208 R.", "formula_coordinates": [2.0, 315.0, 652.88, 239.04, 19.99]}, {"formula_id": "formula_1", "formula_text": "F d , R \u222a R * . A justification frame JF is complementary if it is fixed under complementation, i.e., R \u222a R * = R. Example 1. If R = {x \u2190 a, b; x \u2190 c; }, then R * = {\u223cx \u2190 \u223ca, \u223cc; \u223cx \u2190 \u223cb, \u223cc}. Definition 3. A directed graph is a pair (N, E)", "formula_coordinates": [3.0, 54.0, 365.17, 243.01, 74.15]}, {"formula_id": "formula_2", "formula_text": "Definition 4. Let JF = F , F d , R be a justification frame. A justification J in JF is a directed graph (N, E) such that for every internal node n \u2208 N it holds that n \u2190 {m | (n, m) \u2208 E} \u2208 R;", "formula_coordinates": [3.0, 54.0, 478.54, 243.0, 41.68]}, {"formula_id": "formula_3", "formula_text": "x 0 \u2192 x 1 \u2192 \u2022 \u2022 \u2022 and define \u223cb as \u223cx 0 \u2192 \u223cx 1 \u2192 \u2022 \u2022 \u2022 . A tail of a branch b is a branch x i \u2192 x i+1 \u2192 \u2022 \u2022 \u2022 for some i \u2265 0.", "formula_coordinates": [3.0, 315.0, 149.18, 243.01, 31.57]}, {"formula_id": "formula_4", "formula_text": "x 0 \u2192 x 1 \u2192 \u2022 \u2022 \u2022 to x 1 .", "formula_coordinates": [3.0, 315.0, 293.75, 97.94, 9.65]}, {"formula_id": "formula_5", "formula_text": "[x, y] = {z | x \u2264 z \u2264 y}. We call (x, y) \u2208 L 2 consistent if x \u2264 y, i.e., if [x, y] is not empty. The set of consistent elements is denoted L c . A pair (x, x) is called exact since it approxi- mates only the element x. The precision order \u2264 p on L 2 is defined as (x, y) \u2264 p (u, v) if x \u2264 u and y \u2265 v. If (u, v) is consistent, this means that [u, v] \u2286 [x, y].", "formula_coordinates": [5.0, 54.0, 353.31, 243.01, 74.71]}, {"formula_id": "formula_6", "formula_text": "Bst (x, I) = I(x) = u for all x \u2208 I 2 \\ I 1 . 3. SV Bst (x, I) = I(x) = f for all x \u2208 F + \\ I 2 .", "formula_coordinates": [6.0, 61.47, 545.5, 193.51, 25.19]}, {"formula_id": "formula_7", "formula_text": "U(O)(I 1 , I 2 ) = \uf8eb \uf8ed I1\u2286K\u2286I2 O(K), I1\u2286K\u2286I2 O(K) \uf8f6 \uf8f8 . (1)", "formula_coordinates": [7.0, 62.49, 643.82, 234.51, 33.7]}], "doi": ""}