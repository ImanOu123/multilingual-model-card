{"title": "When Attention Meets Fast Recurrence: Training Language Models with Reduced Compute", "authors": "Tao Lei", "pub_date": "", "abstract": "Large language models have become increasingly difficult to train because of the growing computation time and cost. In this work, we present SRU++, a highly-efficient architecture that combines fast recurrence and attention for sequence modeling. SRU++ exhibits strong modeling capacity and training efficiency. On standard language modeling tasks such as ENWIK8, WIKI-103 and BIL-LION WORD datasets, our model obtains better bits-per-character and perplexity while using 3x-10x less training cost compared to topperforming Transformer models. For instance, our model achieves a state-of-the-art result on the ENWIK8 dataset using 1.6 days of training on an 8-GPU machine. We further demonstrate that SRU++ requires minimal attention for near state-of-the-art performance. Our results suggest jointly leveraging fast recurrence with little attention as a promising direction for accelerating model training and inference. 1   ", "sections": [{"heading": "Introduction", "text": "Many recent advances in language modeling have come from leveraging ever larger datasets and model architectures. As a result, the associated computation cost for developing such models have grown enormously, requiring hundreds of GPU hours or days per experiment, and raising concerns about the environmental sustainability of current research (Schwartz et al., 2020). As a consequence, it has become imperative to build computationally efficient models that retain top modeling power while reducing computational costs.\nThe Transformer architecture (Vaswani et al., 2017) was proposed to accelerate model training and has become the predominant architecture in NLP. Specifically, it is built entirely upon selfattention and avoids the use of recurrence to enable strong parallelization. While this change has led to many empirical success and improved computational efficiency, we are interested in revisiting the architectural question: Is attention all we need for modeling?\nThe attention mechanism permits learning dependencies between any parts of the input, making it an extremely powerful neural component in many machine learning applications (Bahdanau et al., 2015;Lin et al., 2017). We hypothesize that this advantage can still be complemented with other computation that is directly designed for sequential modeling. Indeed, several recent works have studied and confirmed the same hypothesis by leveraging recurrence in conjunction with attention. For example, Merity (2019) demonstrates that single-headed attention LSTMs can produce results competitive to Transformer models in language modeling. Other work have incorporated RNNs into Transformer, and obtain better results in machine translation (Lei et al., 2018;Hao et al., 2019) and language understanding benchmarks (Huang et al., 2020). These results highlight one possibility -we could build more efficient models by combining attention and fast recurrent networks Zhang and Sennrich, 2019).\nIn this work, we validate this idea and present a self-attentive recurrent unit that achieves strong computational efficiency. Our work builds upon the SRU (Lei et al., 2018), a highly parallelizable RNN implementation that has been shown effective in language and speech applications (Park et al., 2018;Kim et al., 2019;Hsu et al., 2020;Shangguan et al., 2019). We incorporate attention into the SRU by simply replacing the linear transformation of input with a self-attention component. The proposed architecture, called SRU++, enjoys enhanced modeling capacity and remains equally parallelizable. Figure 1 compares its performance with the Transformer-XL model (Dai et al., 2019) on the ENWIK8 dataset. SRU++ achieves better results while using a fraction of the training resources needed by the baseline.\nWe evaluate SRU++ on standard language modeling benchmarks including the ENWIK8, WIKI-103 and BILLION WORD datasets. SRU++ consistently outperforms various Transformer models on these datasets, delivering better or on par results while using 3x-10x less computation. Our model do not use positional encoding, multi-head attention and other techniques useful to Transformer models. Furthermore, we demonstrate that a couple of attention layers are sufficient for SRU++ to obtain near state-of-the-art performance. These changes not only highlight the effectiveness of recurrence but also enable strong computation reduction in training and inference. Finally, we also showcase the effectiveness of SRU++ on the IWSLT'14 De\u2192En translation task, and open source our implementation in Pytorch to facilitate future research.", "publication_ref": ["b51", "b3", "b32", "b35", "b30", "b17", "b57", "b30", "b37", "b25", "b20", "b43", "b10"], "figure_ref": [], "table_ref": []}, {"heading": "Background: SRU", "text": "We first describe the Simple Recurrent Unit (SRU) in this section. A single layer of SRU involves the following computation:\nf [t] = \u03c3 (Wx[t] + v c[t-1] + b) r[t] = \u03c3 W x[t] + v c[t-1] + b c[t] = f [t] c[t-1] + (1 \u2212 f [t]) (W x[t]) h[t] = r[t] c[t] + (1 \u2212 r[t]) x[t]\nwhere is the element-wise multiplication, W, W and W are parameter matrices and v, v , b and b are parameter vectors to be learnt during training. The SRU architecture consists of a light recurrence component which successively computes the hidden states c[t] by reading the input vector x[t] for each step t. The computation resembles other gated recurrent networks such as LSTM (Hochreiter and Schmidhuber, 1997) and GRU (Cho et al., 2014). Specifically, the state vector c[t] is a weighted average between the previous state c[t-1] and a linear transformation of the input W x[t]. The weighted aggregation is controlled by a forget gate f [t] which is a sigmoid function over the current input and hidden state. Once the internal state c[t] is produced, SRU uses a highway network to introduce a skip connection and compute the final output state h [t]. Similarly, the information flow in the highway network is controlled by a reset gate r [t].\nTwo important code-level optimizations are performed to enhance the parallelism and speed of SRU. First, given the input sequence\nX = {x[1], \u2022 \u2022 \u2022 , x[L]} where each x[t] \u2208 R d is a d- dimensional vector,\nSRU combines the three matrix multiplications across all time steps as a single multiplication. This significantly improves the computation intensity (e.g. GPU utilization). Specifically, the batched multiplication is a linear projection of the input tensor X \u2208 R L\u00d7d :\nU = \uf8eb \uf8ed W W W \uf8f6 \uf8f8 X ,(1)\nwhere U \u2208 R L\u00d73\u00d7d is the output tensor, L is the sequence length and d is the hidden state size.\nThe second optimization performs all elementwise operations in an efficient way. This involves\nf [t] = \u03c3(U[t, 0] + v c[t-1] + b) (2) r[t] = \u03c3(U[t, 1] + v c[t-1] + b ) (3) c[t] = f [t] c[t-1] + (1 \u2212 f [t]) U[t, 2] (4) h[t] = r[t] c[t] + (1 \u2212 r[t]) x[t].\n(5)\nSimilar to other built-in operations such as attention and cuDNN LSTM (Appleyard et al., 2016), SRU implements all these operations as a single CUDA kernel to accelerate computation. Note that each dimension of the hidden vectors is independent once U is computed. The computation can run in parallel across each hidden dimension (and each input sequence given a mini-batch of multiple sequences).", "publication_ref": ["b18", "b9", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "SRU++", "text": "The key modification of SRU++ is to incorporate more expressive non-linear operations into the re- current network. Note that the computation of U (Equation 1) is a linear transformation of the input sequence X. We can replace this linear transformation with self-attention operation to enhance modeling capacity. Specifically, given the input sequence represented as a matrix X \u2208 R L\u00d7d , the attention component computes the query, key and value representations using the following multiplications,\nQ = W q X K = W k Q V = W v Q where W q \u2208 R d \u00d7d , W k , W v \u2208 R d \u00d7d are model parameters. d is\nthe attention dimension that is typically much smaller than d. Note that the keys K and values V are computed using Q instead of X such that the weight matrices W k and W v are significantly smaller. We also tested another variant in which we first project X = WX into the lower dimension d , and then apply three independent d -by-d matrix multiplications over X to obtain the query, key and value representations. This variant achieves similar results.\nNext, we compute a weighted average output A \u2208 R d \u00d7L using the scaled dot-product attention introduced in Vaswani et al. (2017),\nA = softmax Q K \u221a d V .\nThe final output U required by the elementwise recurrence is obtained by another linear projection,\nU = W o (Q + \u03b1 \u2022 A) .\nwhere \u03b1 \u2208 R is a learned scalar and W o \u2208 R 3d\u00d7d is a parameter matrix. Q + \u03b1 \u2022 A is a residual connection which improves gradient propagation and stabilizes training. We initialize \u03b1 to zero and as a result,\nU = W o Q = (W o W q ) X\ninitially falls back to a linear transformation of the input X skipping the attention transformation. Intuitively, skipping attention encourages leveraging recurrence to capture sequential patterns during early stage of training. As |\u03b1| grows, the attention mechanism can learn long-range dependencies for the model. In addition, W o W q can be interpreted as applying a matrix factorization trick with a small inner dimension d < d, reducing the total number of parameters. Figure 2 (a)-(c) compares the differences of SRU, SRU with this factorization trick (but without attention), and SRU++ proposed in this section. The last modification is adding layer normalization (Ba et al., 2016) to each SRU++ layer. In our implementation, we apply normalization after the attention operation and before the matrix multiplication with\nW o , U = W o layernorm(Q + \u03b1 \u2022 A).\nThis implementation is post-layer normalization in which the normalization is added after the residual connection. Alternatively, pre-layer normalization (Xiong et al., 2020) only applies to the nonlinear transformation. While pre-normalization tends to be less sensitive to different learning rates, we use post-normalization for better results following the observations in Liu et al. (2020b). We analyze the effectiveness of layer normalization in Appendix A.2.  ", "publication_ref": ["b51", "b54", "b34"], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "Experimental setup", "text": "Datasets We evaluate our model on four standard NLP benchmarks.\n\u2022 ENWIK8 (Hutter, 2006) is a character-level language modeling dataset consisting of 100M tokens taken from Wikipedia. The vocabulary size of this dataset about 200. We use the standard 90M/5M/5M splits as the training, dev and test sets, and report bits-percharacter (BPC) as the evaluation metric.\n\u2022 WIKI-103  is a wordlevel language modeling dataset. The training data contains 100M tokens extracted from Wikipedia articles. Following prior work, we use a vocabulary of 260K tokens, and adaptive embedding and softmax layers (Grave et al., 2017;Baevski and Auli, 2019).\n\u2022 BILLION WORD (Chelba et al., 2013)   SRU++ and an output linear layer followed by softmax operation. We use single-head attention in each layer and 10 SRU++ layers for all our models. We use the same dropout probability for all layers and tune this value according to the model size and the results on the dev set. By default, we set the hidden dimension d : d = 4 : 1. We report additional analysis and tune this ratio for best results in Section 5 and Appendix A.\nFor simplicity, SRU++ does not use recent techniques that are shown useful to Transformer such as multi-head attention, compressed memory (Rae et al., 2020), relative position (Shaw et al., 2018;Press et al., 2021), nearest-neighbor interpolation (Khandelwal et al., 2020) and attention variants to handle very long context (Sukhbaatar et al., 2019a;.\nWe compare with previous Transformer models that incorporate one or several these techniques. However, we do not compare with results that use additional data or dynamic evaluation (Graves, 2013;Krause et al., 2018), for a fair comparison between all models.\nOptimization We use RAdam (Liu et al., 2020a) with the default \u03b2 values as our optimizer. RAdam is a variant of Adam optimizer (Kingma and Ba, 2014) that is reported less sensitive to the choice of learning rate and warmup steps while achieving similar results at the end. We use a fixed weight decay of 0.1 and an initial learning rate of 0.0003 in our experiments. These values are selected based on ENWIK8 dev set and used for other tasks. See Appendix A.3 for more details. We use a cosine learning rate schedule following Dai et al. (2019). We do not change the initial learning rate unless otherwise specified. See Appendix B for the detailed training configuration of each model. Each training batch contains B sequences (i.e. the batch size) and M consecutive tokens for each sequence (i.e. the unroll size), which gives an effective size of B \u00d7 M tokens per batch. Following standard practice, the previous training batch is provided as additional context for attention, which results in a maximum attention length of 2 \u00d7 M . For ENWIK8 and WIKI-103 datasets, the training data is partitioned into B chunks by concatenating articles and ignoring the boundaries between articles. For BILLION WORD dataset, we follow Dai et al. (2019) and concatenate sentences to create the training batches. Sentences are randomly shuffled and separated by a special token <s> indicating sentence boundaries.", "publication_ref": ["b22", "b14", "b2", "b8", "b40", "b44", "b39", "b24", "b46", "b15", "b28", "b33", "b26", "b10", "b10"], "figure_ref": [], "table_ref": []}, {"heading": "Results", "text": "Does recurrence improve upon attention-only model? We first conduct a comparison with the Transformer-XL model (Dai et al., 2019)  How much attention is needed? Merity (2019) demonstrated that using a single attention layer with LSTM retains most of the modeling capacity compared to using multiple attention layers. We conduct a similar analysis to understand how much attention is needed in SRU++. To do so, we only enable attention every k layers. The layers without attention become the variant with dimension projection illustrated in Figure 2 (b). Note that k = 1 gives the default SRU++ model with attention in every layer, and k = 10 means only the last layer has attention in a 10-layer model. Table 2 presents the results by varying k. Our base model is the same 10-layer SRU++ model in Table 1. We see that using 50% less attention (k = 2) achieves almost no increase in test BPC. Moreover, using only a single attention module (k = 10) leads to a marginal loss of 0.01 BPC but reduces the training time by 40%. Our results still outperform Transformer-XL model and single-headed attention LSTM (Merity, 2019) greatly by 0.03 BPC. Figure 3    Moreover, SRU++ consistently achieves worse results by moving the attention to lower layer closer to the input embedding. We also enable a second attention layer while fixing the first one in the 10th layer. The corresponding results are shown in Figure 4 (bottom). Similarly, SRU++ achieves worse results if the attention is added to one of the lower layers. In contrast, results are comparable once the attention is placed in a highenough layer. These observations suggest that the model should first learn local features before attention plays a most effective role at capturing longrange dependencies. More analyses can be found in Appendix A.\nDoes the ratio d : d matter? Transformer models by default use a FFN dimension that is 4 times larger than the attention dimension (Vaswani et al., 2017). We analyze the ratio of recurrence dimension d to attention dimension d for SRU++. A small value of d can reduce the amount of computation and the number of parameters used in attention layers but may limit the modeling capacity. Table 4 compares the results of using different d : d ratio given a similar amount of model parameters. We fix the model size to around 108M and use 10 SRU++ layers. Changing this ratio from 4 to a higher value gives better result. The best dev result is obtained with a ratio of 8.\nGiven this observation, we report SRU++ result using a default ratio of 4 as well as a ratio of 8 in the subsequent result sections. This ensures we conduct a comparison that uses a setup similarly to the default of Transformer models, but also showcases stronger results SRU++ can achieve.\nENWIK8     Inference speed Table 7 compares the inference speed of SRU++ with other top-performing models on WIKI-103 test set. We use a single V100 GPU for inference. Our large model runs at least 4.5x faster than all baseline models except Shortformer (Press et al., 2021). In addition, our model achieves 0.9-1.1 perplexity lower than Shortformer and runs 50% faster when using 2 attention layers (k = 5).  (Baevski and Auli, 2019) uses 128K tokens and near 1000K steps. The reduced batch size and gradient updates cut down the training cost.\nFinally, model implementation is an important factor for computation saving. Our implementation is highly efficient for two reasons. First, the fast recurrence operation of SRU is a reusable module that is already optimized for speed (Lei et al., 2018). Second, since recurrence encodes positional information, we can use simple singlehead attention and remove positional encoding.\nOn the contrary, advanced attention and positional encoding mechanism can generate nontrivial computation overhead. To see this, we measure the running time of SRU++ and Transformer-XL using Pytorch Profiler. Figure 5 (a) shows the average model forward time of a single batch. SRU++ runs 4-5x times faster compared to the Transformer-XL implementation. Figure 5 (b) breaks down the computation and highlights the most time-consuming operations in both models. The matrix multiplications are one of the most expensive operations for both models. Surprisingly, many operations in the relative attention of Transformer-XL are computationally expensive. For example, the relative attention requires shifting the attention scores and adding up different attention score matrices. Both require a lot of time but they are not needed in non-relative attention. In addition, the last column shows the running time of tensor transpose operators needed by batch matrix-matrix multiplications in attention. Again, the relative attention uses an order of magnitude more time compared to the simple single-head attention used in our model implementation. 4", "publication_ref": ["b10", "b35", "b51", "b39", "b2", "b30"], "figure_ref": ["fig_0", "fig_1", "fig_1"], "table_ref": ["tab_4", "tab_2", "tab_9", "tab_13"]}, {"heading": "Related Work", "text": "Accelerating common architectures for NLP has become an increasingly important research topic recently (Tay et al., 2020;Sun et al., 2020;. Our work is closely related to two lines of research under this topic.   First, previous works have tackled the speed problem of recurrent neural networks (RNNs) and have proposed various fast RNN implementations (Diamos et al., 2016;Campos et al., 2018;Zhang and Sennrich, 2019). Notably, the Quasi-RNN  and SRU (Lei et al., 2018) have invented highly-parallelizable recurrence and combined them with convolutions or highway networks respectively. The resulting architectures achieve equivalent parallelism as convolutional and attention models. This advancement eliminates the need of avoiding recurrence computation to trade model training efficiency, a design choice made by the Transformer architecture. Our model builds on top of SRU.\nSecond, several recent works have argued that using attention alone is not the best architecture in terms of model expressiveness. For example, Dong et al. (2021) demonstrate theoretically and empirically that using pure attention results in performance degeneration. Gulati et al. (2020) have combined convolution and attention and obtained new state-of-the-art results for speech recognition. Moreover, RNNs have been incorporated into Transformer architectures, resulting in improved results in machine translation and language understanding tasks (Lei et al., 2018;Huang et al., 2020). Our work is built upon a similar hypothesis that recurrence and attention are complementary at sequence modeling. We demonstrate that jointly leveraging fast recurrence and attention not only achieves state-of-the-art modeling results but also obtain significant computation reduction.\nBeing orthogonal to our work, many recent works improve the efficiency of Transformer mod-els by accelerating attention computation (Zaheer et al., 2020;Katharopoulos et al., 2020;Vyas et al., 2020;Peng et al., 2021). Examples include Longformer (Beltagy et al., 2020), Reformer (Kitaev et al., 2020, Linformer  and Routing Transformer . In contrast, our work optimizes computational efficiency using recurrence combined with minimal attention and our model can incorporate these attention variants for additional speed improvement.", "publication_ref": ["b49", "b48", "b11", "b7", "b57", "b30", "b12", "b16", "b30", "b56", "b52", "b52", "b38", "b4"], "figure_ref": [], "table_ref": []}, {"heading": "Conclusion", "text": "We present a highly-efficient architecture combining fast recurrence and attention, and evaluate its effectiveness on various language modeling datasets. We demonstrate fast RNNs with little attention not only achieve top results but also reduce training cost significantly. Our work shares a different idea to accelerating attention, therefore providing an orthogonal direction to advancing stateof-the-art model architecture. As future work, we believe the model can be improved using stronger attention or recurrent implementations, better normalization or optimization techniques.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "A Additional results", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "A.1 Detailed analysis of attention", "text": "Table 10 presents a more comprehensive analysis of attention in SRU++ models. First, we change the number of attention layers and their locations in the model. As shown in the top block of Table 10, using attention in 50% of the layers leads to no (or negligible) loss in model performance. This is consistent with the results in Table 2 using a smaller model. Enabling attention in higher layers performs slightly better than evenly distributing attention from the bottom to top layers.\nWe also experiment with using more than one attention head in each of the attention layer, as shown in the middle block of the table. Unlike Transformer models however, we do not observe a significant improvement using multiple heads. We hypothesize that the recurrence states can already carry different features or information that are present in different input positions, making redundant heads unnecessary.\nFinally, changing the ratio d : d from 4 to 8 gives similar improvements regardless of using 2 attention layers or 10 attention layers. This suggests that the amount of attention and the hidden size ratio can be tuned independently for best model performance.", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_2", "tab_4"]}, {"heading": "A.2 The effectiveness of layer normalization", "text": "In our experiments, we have always used layer normalization to stabilize training. However, we also found layer normalization to achieve worse generalization for larger models that are more prone to over-fitting. Figure 6 showcases our empirical observation on the ENWIK8 dataset. Using layer normalization achieves more rapid training progress and lower training loss, but results in higher dev loss in the case of training a 108M model. This generalization gap remains even if we tune the dropout rate carefully. In addition, although using layer normalization in the smaller model with 41M parameters gives slightly better dev results, we still observe a larger generalization gap (indicated by the difference between training loss and dev loss) compared to the run without layer normalization. Similar over-fitting patterns are observed on Wiki-103 dataset, and also in previous work (Xu et al., 2019).\nOn the other hand, turning off layer normalization can achieve better generalization but makes training sensitive to learning rate and parameter initialization. For example, we have to use a smaller learning rate of 0.00025 or lower to avoid sudden gradient explosion during training. These results suggest possible future work by improving the normalization method (Shen et al., 2020;Brock et al., 2021).", "publication_ref": ["b55", "b45", "b6"], "figure_ref": [], "table_ref": []}, {"heading": "A.3 Tuning weight decay and learning rate", "text": "We find that tuning the weight decay and learning rate critical to the success of training SRU++ and achieving best results. Table 9 provides a sensitivity analysis by testing different learning rates and weight decay values. Increasing the weight decay consistently gives better results for all learning rates tested. Tuning the learning rate is also needed to reach the best result. The non-trivial effect of weight decay seems to be unique for SRU++.\nOn the other hand, the performance of SRU++ remains robust once the appropriate weight decay and learning rate are set. As shown in previous results and analyses, SRU++ achieves strong and relatively stable results to various hidden sizes, number of attention layers and datasets. In particular, using the same weight decay value generalize well for all datasets (including language modeling and translation tasks) and model configurations tested.  Table 11 shows the detailed training configuration of SRU++ models on ENWIK8 dataset. Most training options are kept the same for all models. We tune the dropout probability more carefully as we found training is more prone to over-fitting and under-fitting for this dataset. The large model is trained with 2x batch size. As a result, we increase the learning rate proportionally by a factor of \u221a 2 (Hoffer et al., 2017), which results in a rounded learning rate of 0.0004.\nTable 12 presents the detailed training configuration on WIKI-103 dataset. Similarly we use d = 3072 and d = 4096 for the base and large model respectively for a hidden size ratio d : d = 4 : 1. Following (Baevski and Auli, 2019), we use an adaptive word embedding layer and an adaptive softmax layer for our models, and we tie the weight matrices of the two layers. We keep the total number of parameters comparable when we use a different hidden size ratio d : d = 8 : 1.", "publication_ref": ["b19"], "figure_ref": [], "table_ref": ["tab_19", "tab_2", "tab_2"]}, {"heading": "Machine translation", "text": "We use the open-sourced code from Lin et al. (2020) for the IWSLT'14 De\u2192En translation task. The Transformer model tuned by the original work uses 8 layers for both the encoder and decoder and a total of 20M parameters. Most of the training configuration remains the same as the original work 6 , except for a couple of changes. First, we use RAdam optimizer and the same \u03b2 values for consistency with the language model task. We use the same weight decay value of 0.1 for SRU++. The Transformer model uses a weight decay of 0 that is tuned based on dev set performance. Second, we increase the number of training epochs to 50 (or equivalently 64K training steps) since all models achieve better BLEU scores by training longer. This ensures we compare models when they reach the maximum performance.\nOur SRU++ model uses a hidden size d = 1024, an attention size d = 256 and 6 layers for the encoder and decoder, resulting in a similar number of parameters as the Transformer model in comparison. Let X src be the output representation of the SRU++ encoder. Each SRU++ decoder layer make uses of X src by simplying treating it as extra attention context. That is, the query, key and value 6 https://github.com/asappresearch/ imitkd/blob/master/configs/iwslt/ teacher.yaml representations are computed by concatenating the input of the current layer X tgt with X src ,\nQ = [Q src , Q tgt ] = W q [X src , X tgt ] K = W k Q V = W v Q\nThe resulting representations Q tgt , K and V are used for the rest of the attention computation. The attention mask is set such that each target token can only attend to all source tokens and preceding target tokens.   ", "publication_ref": ["b31"], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgement", "text": "We would like to thank ASAPP Inc. for making this work possible. We thank Hugh Perkins, Joshua Shapiro, Sam Bowman, Danqi Chen and Yu Zhang for providing invaluable feedback for this work. Finally, we thank Jeremy Wohlwend, Jing Pan, Prashant Sridhar and Kyu Han for helpful discussions, and ASAPP Language Technology and Infra teams for the compute cluster setup for our research experiments.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Optimizing performance of recurrent neural networks on gpus", "journal": "", "year": "2016", "authors": "Jeremy Appleyard; Tomas Kocisky; Phil Blunsom"}, {"ref_id": "b1", "title": "", "journal": "", "year": "", "authors": "Jimmy Lei Ba; Jamie Ryan Kiros; Geoffrey E Hin"}, {"ref_id": "b2", "title": "Adaptive input representations for neural language modeling", "journal": "", "year": "2019", "authors": "Alexei Baevski; Michael Auli"}, {"ref_id": "b3", "title": "Neural machine translation by jointly learning to align and translate", "journal": "", "year": "2015", "authors": "Dzmitry Bahdanau; Kyunghyun Cho; Yoshua Bengio"}, {"ref_id": "b4", "title": "Longformer: The long-document transformer", "journal": "", "year": "2020", "authors": "Iz Beltagy; Matthew E Peters; Arman Cohan"}, {"ref_id": "b5", "title": "Quasi-Recurrent Neural Networks", "journal": "", "year": "2017", "authors": "James Bradbury; Stephen Merity; Caiming Xiong; Richard Socher"}, {"ref_id": "b6", "title": "Characterizing signal propagation to close the performance gap in unnormalized resnets", "journal": "", "year": "2021", "authors": "Andrew Brock; Soham De; Samuel L Smith"}, {"ref_id": "b7", "title": "Skip rnn: Learning to skip state updates in recurrent neural networks. In International Conference on Learning Representations", "journal": "", "year": "2018", "authors": "V\u00edctor Campos; Brendan Jou; Xavier Gir\u00f3 I Nieto; Jordi Torres; Shih-Fu Chang"}, {"ref_id": "b8", "title": "One billion word benchmark for measuring progress in statistical language modeling", "journal": "", "year": "2013", "authors": "Ciprian Chelba; Tomas Mikolov; Mike Schuster; Qi Ge"}, {"ref_id": "b9", "title": "Learning phrase representations using RNN encoder-decoder for statistical machine translation", "journal": "EMNLP", "year": "2014", "authors": "Kyunghyun Cho; Bart Van Merri\u00ebnboer; Caglar Gulcehre; Dzmitry Bahdanau; Fethi Bougares; Holger Schwenk; Yoshua Bengio"}, {"ref_id": "b10", "title": "Transformer-XL: Attentive language models beyond a fixed-length context", "journal": "", "year": "2019", "authors": "Zihang Dai; Zhilin Yang; Yiming Yang; Jaime Carbonell; Quoc Le; Ruslan Salakhutdinov"}, {"ref_id": "b11", "title": "Persistent rnns: Stashing recurrent weights on-chip", "journal": "", "year": "2016", "authors": "Greg Diamos; Shubho Sengupta; Bryan Catanzaro; Mike Chrzanowski; Adam Coates; Erich Elsen; Jesse Engel; Awni Hannun; Sanjeev Satheesh"}, {"ref_id": "b12", "title": "Attention is not all you need: pure attention loses rank doubly exponentially with depth", "journal": "", "year": "2021", "authors": "Yihe Dong; Jean-Baptiste Cordonnier; Andreas Loukas"}, {"ref_id": "b13", "title": "Accessing higher-level representations in sequential transformers with feedback memory", "journal": "", "year": "2020", "authors": "Angela Fan; Thibaut Lavril; Edouard Grave; Armand Joulin; Sainbayar Sukhbaatar"}, {"ref_id": "b14", "title": "Efficient softmax approximation for gpus", "journal": "", "year": "2017", "authors": "Edouard Grave; Armand Joulin; Moustapha Ciss\u00e9; Herv\u00e9 J\u00e9gou"}, {"ref_id": "b15", "title": "Generating sequences with recurrent neural networks", "journal": "", "year": "2013", "authors": "Alex Graves"}, {"ref_id": "b16", "title": "Conformer: Convolution-augmented transformer for speech recognition", "journal": "", "year": "2020", "authors": "Anmol Gulati; James Qin; Chung-Cheng Chiu; Niki Parmar; Yu Zhang; Jiahui Yu; Wei Han; Shibo Wang; Zhengdong Zhang; Yonghui Wu; Ruoming Pang"}, {"ref_id": "b17", "title": "Modeling recurrence for transformer", "journal": "", "year": "2019", "authors": "Jie Hao; Xing Wang; Baosong Yang; Longyue Wang; Jinfeng Zhang; Zhaopeng Tu"}, {"ref_id": "b18", "title": "Long short-term memory", "journal": "Neural Computation", "year": "1997", "authors": "Sepp Hochreiter; J\u00fcrgen Schmidhuber"}, {"ref_id": "b19", "title": "Train longer, generalize better: closing the generalization gap in large batch training of neural networks", "journal": "", "year": "2017", "authors": "Elad Hoffer; Itay Hubara; Daniel Soudry"}, {"ref_id": "b20", "title": "Efficient inference for neural machine translation", "journal": "", "year": "2020", "authors": "Yi-Te Hsu; Sarthak Garg; Yi-Hsiu Liao; Ilya Chatsviorkin"}, {"ref_id": "b21", "title": "Ajay Mishra, and Bing Xiang. 2020. Trans-blstm: Transformer with bidirectional lstm for language understanding", "journal": "", "year": "", "authors": "Zhiheng Huang; Peng Xu; Davis Liang"}, {"ref_id": "b22", "title": "The human knowledge compression contest", "journal": "", "year": "2006", "authors": "Marcus Hutter"}, {"ref_id": "b23", "title": "Nikolaos Pappas, and Fran\u00e7ois Fleuret. 2020. Transformers are RNNs: Fast autoregressive transformers with linear attention", "journal": "", "year": "", "authors": "Angelos Katharopoulos; Apoorv Vyas"}, {"ref_id": "b24", "title": "Generalization through memorization: Nearest neighbor language models", "journal": "", "year": "2020", "authors": "Urvashi Khandelwal; Omer Levy; Dan Jurafsky; Luke Zettlemoyer; Mike Lewis"}, {"ref_id": "b25", "title": "From research to production and back: Ludicrously fast neural machine translation", "journal": "", "year": "2019", "authors": "Young Jin Kim; Marcin Junczys-Dowmunt; Hany Hassan; Alham Fikri Aji; Kenneth Heafield; Roman Grundkiewicz; Nikolay Bogoychev"}, {"ref_id": "b26", "title": "Adam: A method for stochastic optimization", "journal": "", "year": "2014", "authors": "Diederik Kingma; Jimmy Ba"}, {"ref_id": "b27", "title": "Reformer: The efficient transformer", "journal": "", "year": "2020", "authors": "Nikita Kitaev; Lukasz Kaiser; Anselm Levskaya"}, {"ref_id": "b28", "title": "Dynamic evaluation of neural sequence models", "journal": "", "year": "2018", "authors": "Ben Krause; Emmanuel Kahembwe; Iain Murray; Steve Renals"}, {"ref_id": "b29", "title": "Albert: A lite bert for self-supervised learning of language representations", "journal": "", "year": "2020", "authors": "Zhenzhong Lan; Mingda Chen; Sebastian Goodman; Kevin Gimpel; Piyush Sharma; Radu Soricut"}, {"ref_id": "b30", "title": "Simple recurrent units for highly parallelizable recurrence", "journal": "EMNLP", "year": "2018", "authors": "Tao Lei; Yu Zhang; Sida I Wang; Hui Dai; Yoav Artzi"}, {"ref_id": "b31", "title": "Autoregressive knowledge distillation through imitation learning", "journal": "EMNLP", "year": "2020", "authors": "Alexander Lin; Jeremy Wohlwend; Howard Chen; Tao Lei"}, {"ref_id": "b32", "title": "A structured self-attentive sentence embedding", "journal": "", "year": "2017", "authors": "Zhouhan Lin; Minwei Feng; C\u00edcero Nogueira; Mo Santos; Bing Yu; Bowen Xiang; Yoshua Zhou;  Bengio"}, {"ref_id": "b33", "title": "On the variance of the adaptive learning rate and beyond", "journal": "", "year": "2020", "authors": "Liyuan Liu; Haoming Jiang; Pengcheng He; Weizhu Chen; Xiaodong Liu; Jianfeng Gao; Jiawei Han"}, {"ref_id": "b34", "title": "Understanding the difficulty of training transformers", "journal": "EMNLP", "year": "2020", "authors": "Liyuan Liu; Xiaodong Liu; Jianfeng Gao; Weizhu Chen; Jiawei Han"}, {"ref_id": "b35", "title": "Single headed attention rnn", "journal": "", "year": "2019", "authors": "Stephen Merity"}, {"ref_id": "b36", "title": "Pointer sentinel mixture models", "journal": "", "year": "2017", "authors": "Stephen Merity; Caiming Xiong; James Bradbury; Richard Socher"}, {"ref_id": "b37", "title": "Fully neural network based speech recognition on mobile and embedded devices", "journal": "", "year": "2018", "authors": "Jinhwan Park; Yoonho Boo; Iksoo Choi; Sungho Shin; Wonyong Sung"}, {"ref_id": "b38", "title": "Random feature attention", "journal": "", "year": "2021", "authors": "Hao Peng; Nikolaos Pappas; Dani Yogatama; Roy Schwartz; Noah Smith; Lingpeng Kong"}, {"ref_id": "b39", "title": "Shortformer: Better language modeling using shorter inputs", "journal": "", "year": "2021", "authors": "Ofir Press; Noah A Smith; Mike Lewis"}, {"ref_id": "b40", "title": "Compressive transformers for long-range sequence modelling", "journal": "", "year": "2020", "authors": "Jack W Rae; Anna Potapenko; M Siddhant; Chloe Jayakumar; Timothy P Hillier;  Lillicrap"}, {"ref_id": "b41", "title": "Efficient content-based sparse attention with routing transformers", "journal": "", "year": "2021", "authors": "Aurko Roy; Mohammad Saffar; Ashish Vaswani; David Grangier"}, {"ref_id": "b42", "title": "", "journal": "2020. Green AI. Communications of the ACM", "year": "", "authors": "Roy Schwartz; Jesse Dodge; A Noah; Oren Smith;  Etzioni"}, {"ref_id": "b43", "title": "Optimizing speech recognition for the edge", "journal": "", "year": "2019", "authors": "Yuan Shangguan; Jian Li; Qiao Liang; Raziel Alvarez; Ian Mcgraw"}, {"ref_id": "b44", "title": "Self-attention with relative position representations", "journal": "", "year": "2018", "authors": "Peter Shaw; Jakob Uszkoreit; Ashish Vaswani"}, {"ref_id": "b45", "title": "PowerNorm: Rethinking batch normalization in transformers", "journal": "", "year": "2020", "authors": "Sheng Shen; Zhewei Yao; Amir Gholami; Michael Mahoney; Kurt Keutzer"}, {"ref_id": "b46", "title": "Adaptive attention span in transformers", "journal": "", "year": "2019", "authors": "Sainbayar Sukhbaatar; Edouard Grave; Piotr Bojanowski; Armand Joulin"}, {"ref_id": "b47", "title": "Augmenting self-attention with persistent memory", "journal": "", "year": "2019", "authors": "Sainbayar Sukhbaatar; Edouard Grave; Guillaume Lample; Herve Jegou; Armand Joulin"}, {"ref_id": "b48", "title": "Mobile-BERT: a compact task-agnostic BERT for resourcelimited devices", "journal": "", "year": "2020", "authors": "Zhiqing Sun; Hongkun Yu; Xiaodan Song; Renjie Liu; Yiming Yang; Denny Zhou"}, {"ref_id": "b49", "title": "Efficient transformers: A survey", "journal": "", "year": "2020", "authors": "Yi Tay; Mostafa Dehghani; Dara Bahri; Donald Metzler"}, {"ref_id": "b50", "title": "Shatter: An efficient transformer encoder with single-headed self-attention and relative sequence partitioning", "journal": "", "year": "2021", "authors": "Ran Tian; Joshua Maynez; Ankur P Parikh"}, {"ref_id": "b51", "title": "Attention is all you need", "journal": "", "year": "2017", "authors": "Ashish Vaswani; Noam Shazeer; Niki Parmar; Jakob Uszkoreit; Llion Jones; Aidan N Gomez; Illia Kaiser;  Polosukhin"}, {"ref_id": "b52", "title": "Fast transformers with clustered attention", "journal": "", "year": "2020", "authors": "Apoorv Vyas; Angelos Katharopoulos; Fran\u00e7ois Fleuret"}, {"ref_id": "b53", "title": "Linformer: Selfattention with linear complexity", "journal": "", "year": "2020", "authors": "Sinong Wang; Z Belinda; Madian Li; Han Khabsa; Hao Fang;  Ma"}, {"ref_id": "b54", "title": "On layer normalization in the transformer architecture", "journal": "", "year": "2020", "authors": "Ruibin Xiong; Yunchang Yang; Di He; Kai Zheng; Shuxin Zheng; Chen Xing; Huishuai Zhang; Yanyan Lan; Liwei Wang; Tieyan Liu"}, {"ref_id": "b55", "title": "Understanding and improving layer normalization", "journal": "", "year": "2019", "authors": "Jingjing Xu; Xu Sun; Zhiyuan Zhang; Guangxiang Zhao; Junyang Lin"}, {"ref_id": "b56", "title": "Big bird: Transformers for longer sequences", "journal": "", "year": "2020", "authors": "Manzil Zaheer; Guru Guruganesh; Joshua Kumar Avinava Dubey; Chris Ainslie; Santiago Alberti; Philip Ontanon; Anirudh Pham; Qifan Ravula; Li Wang;  Yang"}, {"ref_id": "b57", "title": "A lightweight recurrent network for sequence modeling", "journal": "", "year": "2019", "authors": "Biao Zhang; Rico Sennrich"}], "figures": [{"figure_label": "2", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 2 :2Figure 2: An illustration of SRU and SRU++ networks: (a) the original SRU, (b) the SRU variant with projection to reduce the number of parameters, experimented in Lei et al. (2018) and (c) SRU++ proposed in this work. Numbers indicate the dimension of intermediate inputs/outputs given hidden size d = 2048 and attention size d = 512.", "figure_data": ""}, {"figure_label": "5", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 5 :5Figure 5: Profiling of SRU++ and Transformer-XL: (a) forward time (in milliseconds) of small and large models and (b) forward time used in various types of time-consuming operations. We use a single GPU for profiling to avoid extra overhead such as data synchronization between GPUs. We use an unroll size / context length M = 512 and 1024 respectively for small and large models. All models use a batch size B = 16 for profiling.", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "Figure1: Bits-per-character on ENWIK8 dev set vs. GPU hours used for training. SRU++ obtains better BPC by using 1/8 of the resources. We compare with Transformer-XL as it is one of the strongest models on the datasets tested. Models are trained with single precision and comparable training settings.", "figure_data": "1.5Transformer-XL1.3SRU++ SRU++ (single attention)1.2090180270360Effective training hours1.50Bits Per Character (BPC)1.17 1.335.1x efficiencyTransformer-XL SRU++ (single attention)8.7x efficiency1.00090180270360Effective training hours1.50Bits Per Character (BPC)1.17 1.335.1x efficiencyTransformer-XL SRU++ (single attention) 8.7x efficiency1.09 1.171.00090180270360Effective training hours1"}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_2", "figure_caption": "", "figure_data": ": Test BPC of SRU++ and Transformer-XL onENWIK8 dataset. We train SRU++ using the samesetting as Transformer-XL base model. Numbers aresmaller the better. B is the number of sequence. M isthe unroll size (and additional context size)."}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_4", "figure_caption": "Results of SRU++ on ENWIK8 by enabling attention every k layers. We adjust the hidden size so the number of parameters are comparable. \u2020 indicates mixed precision training.", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_5", "figure_caption": "Dev BPC vs. total GPU hours used on EN-WIK8 for each model. Using automatic mixed precision (amp) and only one attention sub-layer achieves 16x reduction. To compute the dev BPC, the maximum attention length is the same as the unroll size M during training.", "figure_data": "1.5Bits Per Character (BPC)1.2 1.3Transformer-XL SRU++ SRU++ (k=10, mixed precision)1.0090180270360Figure 3:Effective training hours"}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_6", "figure_caption": "on EN-WIK8 dataset 2 . Their base model consists of 41M parameters and 12 Transformer layers. Following the official instructions, we reproduced the reported test BPC of 1.06 by training with 4 Nvidia 2080 Ti GPUs. The training took about 4 days or a total of 360 GPU hours equivalently.We train a 10-layer SRU++ model with 42M parameters. For a fair comparison, we use the same hyperparameter setting including the effective batch size, attention context length, learning rate and the number of training iterations as the Transformer-XL base model. Notably, our base model can be trained using 2 GPUs due to less GPU memory usage. After training, we set the at-the SRU++ model. For the latter, we always apply attention in the last layer and move the location of the other. X-axis is the layer index. The layer closest to the input embedding layer has index 1.tention context length to 2048 for testing, similarly to the Transformer-XL baseline. Table1presents the results. Our model achieves a test BPC of 1.03, outperforming the baseline by a large margin. This result suggests that combining recurrence and attention can greatly outperform an attention-only model. We obtain a BPC of 1.02 by extending the attention context length from 512 to 768, while keeping the number of tokens per batch the same.", "figure_data": "42M modelDev BPCTest BPC1.173Dev BPC10dev_bpc=1.072 test_bpc=1.053dev_bpc=1.053 test_bpc=1.0321.0531.032dev_bpc=1.074 test_bpc=1.055dev_bpc=1.056 test_bpc=1.0341.0561.034dev_bpc=1.073 test_bpc=1.053dev_bpc=1.056 test_bpc=1.0331.0561.0331.074 1.067 1.064 1.061 1.058 1.057 1.056 1.056 1.053dev_bpc=1.074 test_bpc=1.054dev_bpc=1.057 test_bpc=1.0351.0571.035dev_bpc=1.074 test_bpc=1.055dev_bpc=1.058 test_bpc=1.0361.0581.036dev_bpc=1.077 test_bpc=1.057dev_bpc=1.061 test_bpc=1.0401.0611.040dev_bpc=1.079 test_bpc=1.059dev_bpc=1.064 test_bpc=1.0431.0641.04312345678910dev_bpc=1.081 test_bpc=1.062dev_bpc=1.067 test_bpc=1.0481.0671.048dev_bpc=1.085 test_bpc=1.068dev_bpc=1.074 test_bpc=1.0561.0741.056dev_bpc=1.174 test_bpc=1.177dev_bpc=1.173 test_bpc=1.1761.1731.176dev_bpc=1.176 test_bpc=1.184dev_bpc=1.176 test_bpc=1.1841.0561.0541.0541.0531.0501.0491.0501.050dev_bpc=1.069 test_bpc=1.048dev_bpc=1.050 test_bpc=1.0261.050dev_bpc=1.070 test_bpc=1.048dev_bpc=1.050 test_bpc=1.0251.050dev_bpc=1.069 test_bpc=1.048dev_bpc=1.049 test_bpc=1.0261.04923456789dev_bpc=1.070 test_bpc=1.049 dev_bpc=1.073 test_bpc=1.053dev_bpc=1.050 test_bpc=1.026 dev_bpc=1.053 test_bpc=1.0321.050 1.053Location of the attentiondev_bpc=1.073 test_bpc=1.053dev_bpc=1.054 test_bpc=1.0321.054dev_bpc=1.073 test_bpc=1.054dev_bpc=1.054 test_bpc=1.0331.054Figure 4: Analyzing where to apply attention. We en-dev_bpc=1.075 test_bpc=1.055dev_bpc=1.056 test_bpc=1.0351.056able only one attention layer (top figure) or two (bottomfigure) inWhich layer to put the 1 attention1.21.16Dev BPC Test BPC1.121.081.0411234566789102 https://github.com/kimiyoung/transformer-xl/tree/master/pytorch"}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_7", "figure_caption": "showcases the training efficiency of our model. SRU++ isModelParameters \u2193 Test BPC \u2193 GPU days \u2193 Longformer 30L(Beltagy et al.", "figure_data": ", 2020)102M0.99104  \u2020All-attention network 36L (Sukhbaatar et al., 2019b)114M0.9864Transformer-XL 24L (Dai et al., 2019)277M0.99-\u2022 Compressive memory (Rae et al., 2020)-0.97-Feedback Transformer (Fan et al., 2020)77M0.96-SRU++ Base108M0.976  \u2020\u2022 only 2 attention layers (k = 5)98M0.984  \u2020SRU++ Large191M0.9612  \u2020\u2022 d = 8 d195M0.9513  \u2020"}, {"figure_label": "3", "figure_type": "table", "figure_id": "tab_8", "figure_caption": "Comparison with top-performing models on ENWIK8 dataset. We include the training cost (measured by the number of GPUs used \u00d7 the number of days) if it is reported in the previous work. Our results are obtained using an AWS p3dn instance with 8 V100 GPUs. The reported training time of all-attention network is based on V100 GPUs while the training time of Longformer is based on RTX8000 GPUs (which is about 90% speed of V100). \u2020 indicates mixed precision training.", "figure_data": "Ratio Dimensions d, dDev BPC \u2193430727680.997638406400.992844805600.9911050405040.992"}, {"figure_label": "4", "figure_type": "table", "figure_id": "tab_9", "figure_caption": "Applying attention in the first bottom layer achieves significantly worse result. We believe this is due to the lack of positional information for attention, since SRU++ does not use positional encoding. Enabling attention in subsequent layers gives much better and comparable results because recurrence can encode positional information.", "figure_data": ""}, {"figure_label": "3", "figure_type": "table", "figure_id": "tab_10", "figure_caption": "", "figure_data": "compares our model with othertop-performing models on the ENWIK8 dataset.We train a base model with d = 3072 and a largemodel with d = 4096 using 400K training steps.The unroll size and attention context length are setto 1024 during training and 3072 during evalua-"}, {"figure_label": "5", "figure_type": "table", "figure_id": "tab_11", "figure_caption": "Comparison with top-performing models on WIKI-103 dataset. We include the training cost (measured by the number of GPUs used \u00d7 the number of days) if it is reported in the previous work. The reported training costs are based on V100 GPUs. Our results are similarly obtained using an AWS p3dn instance with 8 V100 GPUs. \u2020 indicates mixed precision training.", "figure_data": "ModelParamPPL \u2193 Days \u2193Transformer331M25.6 25.257  \u2020 147  \u2020465M23.9192  \u2020SRU++328M25.136  \u2020SRU++ (k = 5)465M23.563  \u2020"}, {"figure_label": "6", "figure_type": "table", "figure_id": "tab_12", "figure_caption": "Test perplexity and effective GPU days for training of SRU++ models and the Transformer models of Baevski and Auli (2019) on BILLION WORD dataset.", "figure_data": "ModelSpeed\u2191 PPL\u2193kNNLM (Khandelwal et al.)14515.8Trans (Baevski and Auli)2.5k18.7Trans-XL (Dai et al.)3.2k18.3Shortformer (Press et al.)15k18.2SRU++ Large15k17.1SRU++ Large (k = 5)22k17.3tion. To compare the computation efficiency wereport the effective GPU days -the number ofGPUs multiplied by the number of days neededto finish training. Our base model achieves bet-ter BPC and uses a fraction of the training costreported in previous work. Furthermore, our largemodels achieve a new state-of-the-art result on thisdataset, reaching a test BPC of 0.96 when d = 4 dand 0.95 when d = 8 d .WIKI-103 Table 5 presents the result of SRU++models and other top results on the WIKI-103dataset. We train one base model with 148M pa-rameters and a few large models which containabout 230M parameters. As shown in the table,our base model obtains a test perplexity of 18.3using 8 GPU days of training, about 3x reductioncompared to the Transformer model in Baevskiand Auli (2019) and over 10x reduction com-pared to Feedback Transformer (Fan et al., 2020).Again, changing the hidden size ratio to d = 8 dimproves the modeling capacity. Our big model"}, {"figure_label": "7", "figure_type": "table", "figure_id": "tab_13", "figure_caption": "", "figure_data": ": Inference speed (tokens/second) on WIKI-103test set. Results of baselines are taken from Press et al.(2021). We use a single V100 GPU, a batch size of 1and maximum attention length 2560 for consistency.achieves a test perplexity of 17.1. The requiredtraining cost remains significantly lower.BILLION WORD We double our training itera-tions to 800K and use a learning rate of 0.0002 forthe BILLION WORD dataset. We train a base modelusing d = 4096, d = 1024 and an effective batchsize of 65K tokens per gradient update. We alsotrain a large model by increasing the hidden sized to 7616 and the batch size to 98K. In addition,we use only 2 attention layers (k = 5) for the largemodel. Table 6 reports the test perplexity and asso-ciated training cost. Our base and large model ob-tain a test perplexity of 25.1 and 23.5 respectively,outperforming the Transformer model of Baevskiand Auli (2019) given similar model size. More-over, SRU++ achieves 3-4x training cost reductionand is trained using 8 GPUs. In comparison, theTransformer model uses 32 or 64 V100 GPUs."}, {"figure_label": "8", "figure_type": "table", "figure_id": "tab_14", "figure_caption": "Results on IWSLT'14 De\u2192En test set. We use a beam size of 5. BLEU scores and training time are averaged over 4 independent runs.", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_15", "figure_caption": "For example, SRU++ uses a maximum effective batch size of 98K tokens and 800K training steps on the BILLION WORD dataset, while the Transformer model in comparison", "figure_data": "IWSLT Does SRU++ work well for othertasks? We study this question by evaluatingSRU++ on the IWSLT'14 De\u2192En translationtask. We use the open-sourced training and eval-uation code of Lin et al. (2020). The base modelis an 8-layer Transformer model containing 20Mparameters. We train SRU++ models using 6 lay-ers and d = 1024, resulting in similar numberof parameters. We use the original settings suchas learning rate and batch size, except that weuse RAdam optimizer for consistency and increasethe number of training epochs to 50. Both archi-tectures achieve much higher BLEU scores givenmore training epochs. 3 Table 8 presents the test re-sults. Without additional hyperparameter tuning,SRU++ achieves 0.4 BLEU score higher and lesstraining time compared to the Transformer modeltuned in Lin et al. (2020).Why does SRU++ reduce training cost in ourexperiments? Several factors contribute to thecomputation reduction observed in our experi-ments. First, combining attention and recurrencegives stronger modeling capacity. As shown inour experiments, SRU++ often achieves compara-ble results using fewer layers and/or fewer param-eters. The required computation are much lowerfor shallower and smaller models.We also observe higher training efficiency, re-quiring fewer training steps and smaller trainingbatch compared to several Transformer models."}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_16", "figure_caption": "", "figure_data": "42M parameters139M parametersSRU++69.8223.3Transformer-XL284.61175.61,2001175.6900SRU++ Transformer-XL600284.6223.369.8041M parameters139M parameters"}, {"figure_label": "3", "figure_type": "table", "figure_id": "tab_17", "figure_caption": "", "figure_data": "MatMulMem concatLayernormRecurrenceRel. position:Rel. position:Transposescore shiftscore additionSRU++130.715.93.323.29.3Transformer-XL160.451564.6269.1255.3"}, {"figure_label": "9", "figure_type": "table", "figure_id": "tab_19", "figure_caption": "Dev BPC of SRU++ given a learning rate \u2208 {1.5, 2, 3} \u00d7 10 \u22124 and a weight decay \u2208 {0.1, 0.01, 0}. '-' means the training run diverged or got gradient explosion.", "figure_data": "B Training detailsLanguage modeling We use the RAdam opti-mizer 5 with the default hyperparameters \u03b2 1 = 0.9and \u03b2 2 = 0.999 for all our experiments. We use acosine learning rate schedule with only 1 cycle forsimplicity. For faster training, we also leverage thenative automatic mixed precision (AMP) trainingand distributed data parallel (DDP) of Pytorch inall experiments, except those in Table 1 and Fig-"}, {"figure_label": "10", "figure_type": "table", "figure_id": "tab_21", "figure_caption": "Results of 10-layer SRU++ models by varying the attention setting. We report the dev BPC on the EN-WIK8 dataset. The first column indicates layers where the attention are located. Smaller index numbers represent layers that are closer to the input of the model.", "figure_data": "w/o layernorm (train)w/o layernorm (dev)w/ layernorm (train)w/ layernorm (dev)Wall timeStepValueWall timeStepValueWall timeStepValueWall timeStepValue1611337071.5371500 1000 2.6572740077972401611338188.95985008000 1.06636869907379001611336585.1795100 1000 2.1199855804443401611337751.47629008000 1.02143514156342001611337101.2236000 1200 2.5296814441680901611339461.661960 16000 0.96417135000228901611336616.170890 1200 2.0141015052795401611339081.8197300 16000 0.9392434954643251611337219.7553800 2000 2.1696639060974101611340734.3594600 24000 0.93300139904022201611336740.0102600 2000 1.76426994800568001611340408.721070 24000 0.90976583957672101611337249.5076100 2200 2.1076946258544901611342004.957120 32000 0.91142374277114901611336771.302070 2200 1.72581005096436001611341738.663950 32000 0.88737612962722801611337308.776290 2600 2.0045335292816201611343273.7114700 40000 0.89655661582946801611336833.7248400 2600 1.66235792636871001611343067.5646800 40000 0.87473732233047501611337338.5322400 2800 1.96348631381989001611344546.9411700 48000 0.88563859462738001611336864.8088900 2800 1.63814222812653001611344401.873110 48000 0.86276417970657401611337368.2808800 3000 1.92501080036163001611345817.9004100 56000 0.87569892406463601611336895.9084900 3000 1.61475372314453001611345732.8109500 56000 0.85363227128982501611337427.8713000 3400 1.8575707674026501611347089.4916100 64000 0.87206929922103901611336958.114630 3400 1.57317698001862001611347048.0255700 64000 0.84860163927078301611337457.7218200 3600 1.82873272895813001611348360.7054900 72000 0.86862176656723001611336989.4217000 3600 1.55559539794922001611348367.725490 72000 0.84279555082321201611337487.7397000 3800 1.80094218254089001611349630.3297000 80000 0.85823237895965601611337020.5708900 3800 1.53790950775146001611349690.5925300 80000 0.8373959660530091611337517.8699700 4000 1.77797591686249001611350901.0565900 88000 0.85467469692230201611337051.9692100 4000 1.52420306205750001611351013.3003600 88000 0.8325747251510621611337636.9908000 4800 1.69345617294312001611352174.063930 96000 0.85203737020492601611337177.0957400 4800 1.4708098173141501611352332.728960 96000 0.82893961668014501611337906.0310200 6600 1.55198490619659001611353446.0834700 104000 0.84361302852630601611337456.8190400 6600 1.37704896926880001611353660.6106600 104000 0.8239091634750370"}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_22", "figure_caption": "Understanding the empirical effect of layer normalization. We show the training and dev loss of SRU++ models using 41M parameters and 108M parameters on ENWIK8 dataset. The model with layer normalization fits the training data better, but achieves worse generalization.", "figure_data": "Stepw/o layernormw/o layernorm(train)1000 2.6572740077972401200 2.5296814441680902000 2.1696639060974102200 2.1076946258544902600 2.0045335292816202800 1.96348631381989003000 1.92501080036163003400 1.8575707674026503600 1.82873272895813003800 1.80094218254089004000 1.77797591686249004800 1.6934561729431200"}], "formulas": [{"formula_id": "formula_0", "formula_text": "f [t] = \u03c3 (Wx[t] + v c[t-1] + b) r[t] = \u03c3 W x[t] + v c[t-1] + b c[t] = f [t] c[t-1] + (1 \u2212 f [t]) (W x[t]) h[t] = r[t] c[t] + (1 \u2212 r[t]) x[t]", "formula_coordinates": [2.0, 78.85, 634.31, 202.29, 59.21]}, {"formula_id": "formula_1", "formula_text": "X = {x[1], \u2022 \u2022 \u2022 , x[L]} where each x[t] \u2208 R d is a d- dimensional vector,", "formula_coordinates": [2.0, 306.14, 304.68, 218.27, 36.94]}, {"formula_id": "formula_2", "formula_text": "U = \uf8eb \uf8ed W W W \uf8f6 \uf8f8 X ,(1)", "formula_coordinates": [2.0, 359.52, 417.78, 164.89, 38.01]}, {"formula_id": "formula_3", "formula_text": "f [t] = \u03c3(U[t, 0] + v c[t-1] + b) (2) r[t] = \u03c3(U[t, 1] + v c[t-1] + b ) (3) c[t] = f [t] c[t-1] + (1 \u2212 f [t]) U[t, 2] (4) h[t] = r[t] c[t] + (1 \u2212 r[t]) x[t].", "formula_coordinates": [2.0, 317.19, 528.41, 207.22, 59.21]}, {"formula_id": "formula_4", "formula_text": "Q = W q X K = W k Q V = W v Q where W q \u2208 R d \u00d7d , W k , W v \u2208 R d \u00d7d are model parameters. d is", "formula_coordinates": [3.0, 70.87, 399.56, 218.27, 83.86]}, {"formula_id": "formula_5", "formula_text": "A = softmax Q K \u221a d V .", "formula_coordinates": [3.0, 112.77, 656.84, 134.47, 25.95]}, {"formula_id": "formula_6", "formula_text": "U = W o (Q + \u03b1 \u2022 A) .", "formula_coordinates": [3.0, 124.35, 724.15, 111.31, 12.07]}, {"formula_id": "formula_7", "formula_text": "U = W o Q = (W o W q ) X", "formula_coordinates": [3.0, 345.81, 324.29, 131.85, 12.06]}, {"formula_id": "formula_8", "formula_text": "W o , U = W o layernorm(Q + \u03b1 \u2022 A).", "formula_coordinates": [3.0, 337.2, 584.07, 156.14, 39.56]}, {"formula_id": "formula_9", "formula_text": "Q = [Q src , Q tgt ] = W q [X src , X tgt ] K = W k Q V = W v Q", "formula_coordinates": [14.0, 362.85, 112.4, 97.76, 62.32]}], "doi": "10.21437/Interspeech.2020-3015"}