{"title": "Online Elicitation of Necessarily Optimal Matchings", "authors": "Jannik Peters", "pub_date": "", "abstract": "In this paper, we study the problem of eliciting preferences of agents in the house allocation model. For this we build on a recent model of Hosseini et al. (2021) [AAAI'21]  and focus on the task of eliciting preferences to find matchings which are necessarily optimal, i.e., optimal under all possible completions of the elicited preferences. In particular, we follow the approach of Hosseini et al. ( 2021) and investigate the elicitation of necessarily Pareto optimal (NPO) and necessarily rank-maximal (NRM) matchings. Most importantly, we answer their open question and give an online algorithm for eliciting an NRM matching in the next-best query model which is 3 2 -competitive, i.e., it takes at most 3 2 as many queries as an optimal algorithm. Besides this, we extend this field of research by introducing two new natural models of elicitation and by studying both the complexity of determining whether a necessarily optimal matching exists in them, and by giving online algorithms for these models.", "sections": [{"heading": "Introduction", "text": "One of the key settings in the area of matching under preferences is the so-called house allocation or assignment problem. In this problem we are given two sets, a set of agents A and a set of houses H with agents having preferences over houses. This simple setting has found multiple real life applications, for instance in the allocation of people to jobs (Hylland and Zeckhauser 1979), papers to reviewers (Garg et al. 2010), or students to student dorms (Chen and S\u00f6nmez 2002). Over the years, various solution concepts have been designed for the house allocation problem, for instance Pareto optimality (Abdulkadiroglu and S\u00f6nmez 1998) (Abraham et al. 2004), popularity (Abraham et al. 2007) or rank-maximality (Irving et al. 2006).\nHowever, most of the work on house allocation problems assumes the preferences of the agents to be given in their entirety, while in many real-world applications only partial preferences might be known and eliciting complete rankings from agents might be costly.\nAs an expository (non-serious) example (based on a real life story), imagine a group of AI researchers meeting in their office kitchen to celebrate the acceptance of multiple papers. For this occasion, the researchers decide to eat some ice pops. However, after opening the freezer, they notice that only one ice pop of each kind is left, causing discussion on how to fairly divide the ice. Quickly, the group agrees that a rank-maximal allocation would be the fairest they could currently think of. Now there is just one problem left, due to time constraints and hunger, the researchers do not want to all give their whole ranking to each other. Instead, they agree that they should start off with naming the ice pop they like the most. But how should they continue after this, and who should be asked for their second favorite ice?\nTo deal with this problem Hosseini, Menon, Shah, and Sikdar (2021) initiated the study of finding matchings that are necessarily optimal by eliciting partial preferences from the agents. In their model Hosseini et al. (2021) use so-called top-k preferences in which each agent has only elicited a prefix of their true preferences. To obtain these preferences, they introduce the next-best query model, in which agents can be asked to reveal the top house they have not revealed yet. The goal in this setting is to ask as few queries as possible in order to find a matching that is necessarily optimal, i.e., optimal under every possible linear extension of the top-k preferences. The performance of such an elicitation algorithm is then measured in terms of the so-called competitive ratio, i.e., the ratio between the number of queries of the algorithm and the number of queries of an optimal algorithm with knowledge of the complete preferences. As their main results, Hosseini et al. (2021) gave an O( \u221a n)competitive elicitation algorithm for finding a necessarily Pareto optimal matching, showed that no elicitation algorithm for finding a necessarily Pareto optimal matching can be o( \u221a n)-competitive, and proved that no elicitation algorithm for finding a necessarily rank-maximal matching can be 4 3 \u2212\u03b5-competitive for any \u03b5 > 0. Further, they conjectured that an online algorithm with a constant competitive ratio for eliciting necessarily rank-maximal matchings is possible, and left this as their most important open question.", "publication_ref": ["b20", "b15", "b12", "b1", "b2", "b22", "b18", "b18", "b18"], "figure_ref": [], "table_ref": []}, {"heading": "Our results", "text": "We contribute to this line of research in the following way. First, we confirm the conjecture of Hosseini et al. (2021) and show that an online algorithm with a 3 2 -competitive ratio for eliciting a necessarily rank-maximal matching does exist in the next-best query model. Further, we show that this algorithm is optimal and no online-algorithm can have a competitive ratio better than 3 2 . Besides this, our many focus lies on the hybrid-query model in which agents can be arXiv:2112.04227v1 [cs.GT] \n\u221a n) \u2020 O( \u221a n) \u2020 1 1 \u2126(n 1 3 ) O(n 1 3 +\u03b5 ) Rank-maximal 3 2 3 2 3 2 O(n) 3 2 6\nTable 1: Overview over the lower (LB) and upper bounds (UB) on the possible competitiveness of online algorithms derived for eliciting Pareto optimal and rank-maximal matchings in the different query models. Results marked with \u2020 were shown by Hosseini et al. (2021).\nasked to either elicit a house of a given rank or to return the rank of a given house. In this model, we give an online algorithm with a constant competitive ratio for eliciting a necessarily rank-maximal matching, as well as, for any \u03b5 > 0, an O(n 1 3 +\u03b5 )-competitive algorithm for eliciting a necessarily Pareto optimal matching which almost meets the lower bound of \u2126(n 13 ). To add on to this, we also give a polynomial time algorithm for determining whether an NRM matching exists and show that the same problem becomes NP-complete for Pareto optimal matchings.\nFinally, we also introduce the set-compare model in which agents can be asked to give their top-choice element out of a set. Here, we show that this model is already powerful enough to obtain a 1-competitive elicitation algorithm for Pareto optimal matchings. We show that determining whether an NPO matching under this preference model exists, is NP-complete as well, and that the 3 2 lower bound obtained for the next-best model is also valid for the setcompare model. For a brief overview over the competitiveness bounds derived in this paper, we refer the reader to Table 1.", "publication_ref": ["b18", "b18"], "figure_ref": [], "table_ref": []}, {"heading": "Related Work", "text": "The house allocation or assignment problem is one of the key matching settings in both computer science and economics. Besides the aforementioned classical works of for instance (Bogomolnaia and Moulin 2001;Hylland and Zeckhauser 1979;Shapley and Scarf 1974) recent papers on house allocation include work on envy-free house allocation (Gan, Suksompong, and Voudouris 2019;Beynier et al. 2019) on diversity constrains (Benabbou et al. 2018), incorporating cardinal queries in ordinal preferences (Ma, Menon, and Larson 2021) or closely related to us on Pareto optimal house allocation under probabilistic uncertainty (Aziz, Bir\u00f3, de Haan, and Rastegari 2019).\nRank-maximal matchings were first introduced by Irving (2003) and were subsequently studied and characterized by Irving et al. (2006). Following these two initial papers, several works studied algorithmic aspects of various variants of the problem (Kavitha and Shah 2006;Michail 2007;Paluch 2013;Ghosal, Nasre, and Nimbhorkar 2019;Nasre, Nimbhorkar, and Pulath 2019). Besides this Belahc\u00e8ne, Mousseau, and Wilczynski (2021) studied rankmaximality (and popularity) in a variant of the house allocation problem, where not only the allocation of the houses, but also the selection of the allocated houses, i.e., which houses are matched and which are unmatched, matter. Very recently Aziz and Sun (2021) used rank-maximality and algorithmic techniques of Irving et al. (2006) for the school choice problem with diversity constraints.\nBesides the aforementioned works by Hosseini et al. (2021); Aziz et al. (2019) uncertainty in matching markets has been incorporated in several papers in the literature on two-sided matchings for instance by Rastegari et al. (2013); Liu et al. (2014). Besides this, Drummond and Boutilier (2014) studied preference elicitation for the stable matching problem or (Genc et al. 2017;Mai and Vazirani 2018;Chen, Skowron, and Sorge 2019) who studied stable matchings under various aspects of robustness, e.g., stable under probabilistic perturbations or after a certain number of swaps in the input rankings. Finally, very closely related to our work is also the study of possible and necessary winners in computational social choice, where given partial preferences of voters, a candidate winning every election or some election is required. See (Lang 2020) for a recent survey on this topic.", "publication_ref": ["b9", "b20", "b36", "b14", "b8", "b6", "b27", "b3", "b22", "b23", "b30", "b17", "b31", "b4", "b22", "b18", "b3", "b32", "b26", "b13", "b16", "b28", "b10", "b25"], "figure_ref": [], "table_ref": []}, {"heading": "Preliminaries", "text": "For a, b \u2208 N let [a, b] = {a, a + 1, . . . , b} and [a] = [1, a].\nThroughout the paper, we let A = {a 1 , . . . , a n } denote our set of agents and H = {h 1 , . . . , h n } our set of houses. A matching in our setting is simply a subset M \u2286 A \u00d7 H such that no agent and no house appear in more than one pair. If (a i , h j ) \u2208 M for some agent a i \u2208 A and house h j \u2208 H we say that a i is matched to h j .\nFurther, we assume that each agent a i \u2208 A has a strict preference list i over all houses in H. If h j i h k for two houses h j and h k we say that a i prefers h j to h k . When h j appears in the kth place in the preference list of a i we say that the rank of h j in the preference list of a i is k and write rank(a i , h j ) = k. For a given subset H \u2286 H and agent a i , we call max i (H ) the maximum element of H with regard to i , i.e., the house in H which a i likes the most. We refer to the collection of preference lists as a preference profile .\nWe are now ready to define the two problems we investigate in our paper.\nPareto optimality. We begin with the classical notion of Pareto optimal matchings (Abdulkadiroglu and S\u00f6nmez 1998). Given a matching M , we say that another matching\nM dominates M if \u2022 for every agent a i \u2208 A it holds that M (a i ) i M (a i ) or M (a i ) = M (a i ) ; \u2022 for at least one agent a i \u2208 A it holds that M (a i ) i M (a i ). Now, a matching M is Pareto optimal if there is no matching M which dominates M .\nRank-maximality. As our second optimality concept we consider rank-maximality. For a given matching M let r\nM l := |{a i \u2208 A | rank(a i , M (a i )) = l}| for any l \u2208 [n]\n. Now a matching is rank-maximal if and only if there is no other matching M and l \u2208\n[n] such that r M k = r M k for all k \u2208 [l \u2212 1] and r M l < r M\nl , i.e., the vector (r M 1 , . . . , r M n ) is lexicographically maximal among all matchings. If such a matching M were to exist, we also say that M rankdominates M . Thus, a matching M is rank-maximal if it first maximizes the number of agents matched to their first choice, subject to that maximizes the number of agents matched to their second choice and so on. Elicitation Protocols. Now, we turn to the three different elicitation protocols we study in our work. For the definition of the models, we assume that we are given a fixed instance of the house allocation problem with preference profile .\n\u2022 First, we investigate the next-best query model as defined by Hosseini et al. (2021). In this model, we are only allowed to ask one type of query. Namely, we can query a single agent, who will return the house they rank the highest, which has not been revealed yet, i.e., if this is the kth query asked to the agent, the query returns the house ranked kth by the agent in . For any agent a \u2208 A we denote such a query as Q(a) and we refer to the set of agents revealed to by A as rev(a). \u2022 Next we study the hybrid-query model. Here we can ask two types of queries. Firstly, a rank query Q(a i , k) for an agent a i \u2208 A and k \u2264 n returns the house h j \u2208 H with rank(a i , h j ) = k and secondly a house query Q(a i , h j ) for an a i \u2208 A and a house h j \u2208 H returns rank(a i , h j ).\nSimilarly to the next-best query model, for any a \u2208 A we refer to rev(a) as the set of houses h \u2208 H for which we know rank(a, h). \u2022 As our third model, we study a less restricted version of the next-best query model, which we call the set-compare query model. Here a query Q(a i , H ) consists of an agent a i \u2208 A and a subset of houses H \u2286 H and returns max i (H ), i.e., the house a i likes best in H . This model is inspired by recent works of learning rankings in the area of machine learning (Chen, Li, and Mao 2018;Ren, Liu, and Shroff 2019;Gopalan 2019, 2020). For any of the three aforementioned query models, let Q 1 , . . . , Q k be a sequence of queries with answers \u03b1 1 , . . . , \u03b1 k (we also refer to this as partial preferences throughout the paper). We call a preference profile consistent with these queries if the output of these queries on would be \u03b1 1 , . . . , \u03b1 k as well. A matching M is now necessarily Pareto optimal(NPO) (necessarily rankmaximal(NRM)) for a given sequence of queries if M is Pareto optimal (rank-maximal) for all preference profiles consistent with these queries. The goal is now to design an online-algorithm which can ask queries according to one of the three aforementioned models and outputs a matching that is either necessarily Pareto optimal or necessarily rank-maximal according to the queries the algorithm asked. We assume that the online-algorithm only has access to the agents, houses and the answers to the queries, but not to the underlying preferences themselves.\nIn order to compare the performance of these algorithms, we measure their competitive ratio in comparison to an optimal algorithm which also knows the underlying preference profile. For any instance, such an optimal algorithm asks the minimum number of queries, after which a necessarily optimal matching with regard to these queries, asked by the optimal algorithm, can be given. We call an online algorithm \u03b1-competitive if for any preference profile the online algorithm asks at most \u03b1 \u2022 OPT queries, where OPT is the number of queries of the optimal algorithm on this instance.\nFinally, we note that partial preferences in the next-best query model can be equivalently expressed by an incomplete preference profile (with induced rank function rank ), in the hybrid-query model, by an incomplete rank function rank (with induced partial preference profile ) in which each agent only lists ranks for a subset of houses, and in the set-compare model, by having a partial order i for each agent a i .", "publication_ref": ["b0", "b18", "b11", "b33"], "figure_ref": [], "table_ref": []}, {"heading": "Pareto-optimal Matchings", "text": "We start off with Pareto-optimal matchings. Here, Hosseini et al. ( 2021) managed to give an asymptotically tight O( \u221a n)-competitive elicitation algorithm for the next-best query model. As our main results, we first give a 1competitive algorithm for eliciting NPO matchings in the set-compare model, followed by a classification of NPO matchings in the hybrid-query model together with an O(n 1 3 +\u03b5 )-competitive elicitation algorithm for any \u03b5 > 0. Before we turn to our elicitation algorithms, we quickly recap the famous serial dictatorship mechanism (Abdulkadiroglu and S\u00f6nmez 1998) and its relation to Pareto optimal matchings. Definition 1 (Serial Dictatorship Mechanism). The serial dictatorship mechanism takes as input a permutation \u03c3 of the agents together with a preference profile and returns a matching SD (\u03c3) which iteratively matches agent \u03c3(i) to their most preferred house in not matched to by an agent in \u03c3(1), . . . , \u03c3(i \u2212 1).\nAs shown by Abdulkadiroglu and S\u00f6nmez (1998) the serial dictatorship mechanism is already enough to classify all Pareto optimal matchings. Theorem 1 (Abdulkadiroglu and S\u00f6nmez (1998)). Given a preference profile a matching M is Pareto optimal if and only if there is a permutation of the agents \u03c3 such that M = SD (\u03c3).\nThis immediately brings us to the set-compare query model where we can show that this model is already sufficient to simulate the serial dictatorship mechanism, which allows us to construct a 1-competitive algorithm.\nTheorem 2. There exists a 1-competitive algorithm in the set-compare model for computing a necessarily Paretooptimal matching. Proof. Our algorithm is a simple adaption of the serial dictatorship mechanism to the set-compare model. It works iteratively by constructing a matching M . In iteration i let H i be the set of houses already matched by M in previous iterations. Then in iteration i we query h := Q(a i , H \\ H i ) and add (a i , h) to M . Note that we do not need to query in iteration n since only one agent/house pair is left. It is easy to see that for all possible preference extensions, in iteration i agent a i is matched to the currently unmatched house they prefer the most. Therefore, this algorithm simulates the serial dictatorship mechanism and thus produces a (necessarily) Pareto optimal matching. Furthermore, the algorithm only uses n \u2212 1 queries and is therefore 1-competitive, since at most 1 agent can be left unqueried by the optimal algorithm.\nWe further note that this proof can also be generalized to the setting where the set H in each query can contain at most k houses, e.g., if k = 2 this would mean that only pair-wise comparisons could be asked to the agents. For a proof sketch, we refer to the full version. For the hybridquery model, we start off with the complexity of determining whether an NPO matching exists. While it is still polynomial time checkable if a given matching is NPO, we also show that it is NP-complete to determine the existence of an NPO matching.\nTheorem 3. Given a matching M and partial preferences rank in the hybrid-query model, it can be determined in polynomial time whether M is necessarily Pareto optimal.\nProof. This follows fairly simply by adapting the algorithm of Hosseini et al. (2021) for determining whether a matching M is NPO in the next-best model. We create an auxiliary directed graph G = (A, E) in which we add an arc from agent a i to agent a j if it is possible for a i to prefer M (a j ) to M (a i ). Then a cycle in G implies that a matching dominating M exists in a preference extension of rank . To be more precise, we add an edge from a i to\na j if M (a i ), M (a j ) \u2208 rev(i) and rank (a i , M (a j )) < rank (a i , M (a i )); or if M (a i ) \u2208 rev(i), M (a j ) /\n\u2208 rev(i) and there is a rank k < rank(a i , M (a i )) with no revealed house for a i ; or if M (a i ) / \u2208 rev(i), M (a j ) \u2208 rev(i) and there is a rank k > rank(a i , M (a j )) with no revealed house for a i ; or if M (a i ), M (a j ) / \u2208 rev(i). It is easy to see that there is a preference profile consistent with the partial preferences in which a i prefers M (a j ) to M (a i ) if and only if there is an edge from a i to a j . Thus, a cycle in G would indeed imply that we could extend the preferences in such a way, that we could construct a matching M dominating M , by swapping the houses along the cycle. On the other hand, if a matching M dominates M in some preference extension, there has to be a cycle of agents a 1 , . . . , a k , a k+1 = a 1 with agent a i preferring M (a i+1 ) to M (a i ) for this preference extension and thus also forming a cycle in G.\nThis algorithm also translates into an algorithm for determining whether a matching M is necessarily Pareto optimal in the set-compare model, again by adding edges from one agent to another, if there is any extension where one agent could prefer the house of the other agent.\nCorollary 1. Given a matching M and partial preferences in the set-compare model it can be determined in polynomial time whether M is necessarily Pareto optimal.\nUsing the simple algorithm in Theorem 3 we can also give a succinct classification of necessarily Pareto optimal matchings in the hybrid-query model using the Serial Dictatorship mechanism.\nLemma 1. Given partial preferences rank in the hybridquery model a matching M is necessarily Pareto optimal if and only if there is a permutation \u03c3 of A such that for all possible preference extensions of rank it holds that M = SD (\u03c3) .\nProof. Let M be an NPO matching and G the graph constructed in Theorem 3 for M . Since M is NPO the graph G is acyclic. Therefore, there exists a topological ordering of G. Let \u03c3 be a reversed topological ordering of G. Then for every i \u2208 [n] and every possible preference extension (and thus also in ), the agent \u03c3(i) could only possibly prefer the houses already matched to the agents \u03c3(1), . . . , \u03c3(i \u2212 1) if they were assigned their partner in M . Therefore, SD (\u03c3) would set SD (\u03c3)(\u03c3(i)) = M (\u03c3(i)). Thus, by induction, we get that SD (\u03c3) = M . This however does not translate to an algorithm for finding an NPO matching or determining that one exists. To show the NP-completeness of this problem we reduce from the NP-complete (2,2)-E3-SAT problem, (Berman, Karpinski, and Scott 2004). In an instance of the (2,2)-E3-SAT problem we are given a set of variables X and a set of clauses C over X with each clause in C having length exactly 3 such that each variable in X appears exactly twice in negated form and twice in positive form in C. Theorem 4. Given partial preferences rank in the hybridquery model it is NP-complete to determine whether an NPO matching exists.\nThe proof of this theorem and all further missing proofs are in the appendix. Using this result, we can also show that the same problem is NP-complete in the set-compare model. For this we simply show how to, given an instance in the hybrid-query model, construct an instance in the setcompare model, such that a matching is NPO in the former model if and only if is also NPO in the latter. Theorem 5. Given partial preferences in the setcompare model, it is NP-complete to determine whether a necessarily Pareto-optimal matching exists.\nEven though it is inherently hard to find an NPO matching given partial preferences in the hybrid query model, we can still give an elicitation algorithm improving upon the competitive ratio for the next-best query model. Before proving this, we give a useful lower bound on the number of queries asked to an agent by using the serial dictatorship characterization of NPO matchings. Lemma 2. Let rank be partial preferences and M be an NPO matching in the hybrid-query model. Then there exists a permutation of agents \u03c3 such that for all i \u2208\n[n] agent \u03c3(i) has revealed at least min(rank (\u03c3(i), M (\u03c3(i))), n \u2212 i) of their preference list if M (\u03c3(i)) \u2208 rev(\u03c3(i)). If M (\u03c3(i)) / \u2208 rev(\u03c3(i)) the agent must have revealed at least n\u2212i houses.\nProof. By Lemma 1 we know that there has to be a permutation of agents \u03c3 such that M = SD (\u03c3) for all possible preference extensions of rank . Then since for every preference extension SD (\u03c3) matched \u03c3(i) to M (\u03c3(i)) we Algorithm 1: Elicitation algorithm for Pareto optimal matchings in the hybrid query model Input: Set of agents A, set of houses H, parameter c 0 > 1 3 . Output: A necessarily Pareto optimal matching.\n1: set E \u2190 \u2205, M \u2190 \u2205, j \u2190 0 2: for i = 1, . . . , n do 3:\nfor all a \u2208 A do 4:\nE \u2190 E \u222a {{a, Q(a, i)}}\n5:\nend for 6:\nM \u2190 maximum size Pareto-optimal matching in (A \u222a H, E)\n7: if i = n cj then 8: if |M | \u2265 n \u2212 n (cj +1)/2 then 9:\nbreak for loop 10:\nelse 11:\nj \u2190 j + 1, c j \u2190 (3c j\u22121 + 1)/2 + c 0 \u2212 1 12: end if 13: end if 14: end for 15: H \u2286 H \u2190 subset matched by M 16: A \u2286 A \u2190 subset matched by M 17: for all a \u2208 A \\ A do 18: h \u2190 arg min h\u2208H\\H Q(a, h) 19: M \u2190 M \u222a {{a, h}} 20: H \u2190 H \u222a {h} 21: end for\nknow that all houses matched to \u03c3(i + 1), . . . , \u03c3(n) must be ranked lower than M (\u03c3(i)) in all preference extensions. Thus, we either know the preferences of all houses matched to \u03c3(i + 1), . . . , \u03c3(n) and have thus revealed at least n \u2212 i of the preference list of \u03c3(i) or there is at least one house matched to \u03c3(i + 1), . . . , \u03c3(n) we do not know the preference of. Then we must have queried the preferences of all houses ranked at least as high as M (\u03c3(i)) thus requiring us to reveal at least rank (\u03c3(i), M (\u03c3(i))) houses in the preference list of \u03c3(i).\nThe crucial idea behind our Algorithm 1 for eliciting an NPO matching is now as follows. Assume that we want to construct an algorithm with competitive ratio n c for some constant c > 0 and that we know that at least k agents must be matched to a house of at least rank r with k \u2265 r, for instance by knowing that the maximum matching in the topr preferences has size n\u2212k. Then by Lemma 2 we know that at least k 2 agents must be asked at least min(r, k 2 ) queries, since at least k 2 of the agents matched to a house with a rank of at least r must be listed between r and n \u2212 k 2 by \u03c3. Thus, we know that any optimal algorithm must ask at least \u2126(kr) queries which allows our online algorithm to ask O(n c kr) queries. The trick behind Algorithm 1 is now to choose these values of c, k, and r appropriately. To give some further idea behind the value of 1 3 we show that c 0 > 1 3 implies that the (c j ) series in Algorithm 1 is increasing.\nLemma 3. The series (c j ) j\u2208N with c j+1 = (3c j + 1)/2 + c 0 \u2212 1 is increasing if c 0 > 1 3 . Using this Lemma, we can now turn to the correctness of Algorithm 1. Theorem 6. For any c > 1 3 Algorithm 1 is an O(n c0 )competitive algorithm for eliciting a necessarily Pareto optimal matching in the hybrid-query model.\nAs an easy corollary, this implies that for any \u03b5 > 0, we can reach a competitive ratio of O(n 1 3 +\u03b5 ). Further, we can also show that this competitive ratio is almost asymptotically optimal by showing that no online algorithm can be o(n 1   3 )competitive. Theorem 7. There is no online algorithm in the hybridquery model for computing a necessarily Pareto optimal matching with a competitive ratio of o(n 1   3 ). This of course still leaves the possibility of an online algorithm with a competitive ratio of \u0398(n 1   3 ).", "publication_ref": ["b0", "b0", "b18", "b7"], "figure_ref": [], "table_ref": []}, {"heading": "Rank-Maximal Matchings", "text": "In this section, we turn to the problem of eliciting rankmaximal matchings. In their paper, Hosseini et al. (2021) showed that no online algorithm for the rank-maximal matching problem in the next-best query setting can be better than 4 3 competitive. Here, we give an algorithm that is 3 2competitive and improve the lower bound of Hosseini et al. (2021) to 3 2 as well, thus showing that the competitive ratio of our algorithm is tight. However, before defining this algorithm, we first need to recap some results from the classical work of Irving et al. (2006). First, we recall the definition of the so-called Dulmage-Mendelsohn decomposition. Theorem 8 (Irving et al. (2006), Manlove (2013)). Given a bipartite graph G = (V, E) there exists a partition of V into three sets O, E, U such that Further, it is shown by Irving et al. (2006) that E is the set of vertices which can reach an unmatched vertex in any maximum matching with an alternating path of even length, vertices in O can reach an unmatched vertex with an alternating path of odd length, and vertices in U cannot reach any unmatched vertex using an alternating path. Using the Dulmage-Mendelsohn decomposition Irving et al. (2006) defined the following iterative algorithm for finding a rankmaximal matching. In each iteration i the algorithm maintains a graph G i = (A \u222a H, E i ) and a matching M i in G.", "publication_ref": ["b18", "b18", "b22", "b22", "b29", "b22", "b22"], "figure_ref": [], "table_ref": []}, {"heading": "It is initialized with", "text": "E 0 = \u2205, M 0 = \u2205, O 0 = \u2205 = U 0 and E 0 = A \u222a H. For each i = 1, . . . , n the algorithm\n\u2022 adds all edges of rank i or less that have not been deleted yet to E i and computes a maximum matching\nM i in G i = (A \u222a H, E i ) by augmenting M i\u22121 ;\nAlgorithm 2: Elicitation algorithm for rank-maximal matchings in the next-best model Input: Set of agents A, set of houses H. Output: A necessarily rank-maximal matching \n1: U \u2190 A {set of unfinished agents} 2: V \u2190 H {set of available houses} 3: E \u2190 \u2205, M \u2190 \u2205, F \u2190 \u2205 4: if |A| = 2 then 5: let h 1 = Q(a 1 ), return {{a 1 , h 1 }, {a 2 , h 2 }} 6: end if 7: for i in 1, . . . n \u2212 1 do 8: for all a \u2208 U do 9: h \u2190 Q(a) 10: if h \u2208 V\nU i , E i , O i for G i\n\u2022 deletes all edges incident to a node in U i and O i with a rank greater or equal to i, as well as all edges connecting either two nodes in O i or a node in O i with a node in U i ;\nThe key observations of Irving et al. (2006) are now that Lemma 4. \u2022 Every rank-maximal matching in the instance restricted to top-k preferences is a maximum matching in G k . \u2022 Every M k is a rank-maximal matching in the instance restricted to top-k preferences.\nUsing these observations, we can now simulate the algorithm of Irving et al. (2006) by tracking the set of forbidden edges F , i.e., the set of edges deleted in the third step of (Irving et al. 2006) in each iteration, and by not asking any queries to an agent who has been in U i or O i for any i \u2208 [n]. Please refer to Figure 1 for an example of Algorithm 2 being executed. To get a good bound on the competitive ratio of Algorithm 2 we observe a simple lemma based on the Dulmage-Mendelsohn decomposition and its relation to preferences of agents in a necessarily rank-maximal matching. For a given house allocation instance and agent a \u2208 A let r a := min i\u2208[n] a / \u2208 E i . It is easy to see that for any instance, our algorithm asks exactly r a queries to a. We can now show that the optimal algorithm must ask at least r a \u2212 1 queries to agent a if this agent is matched to a preference the agent has revealed. Lemma 5. Given a house allocation instance (A, H, ) partial preferences in the next-best query model and necessarily rank-maximal matching M for it has to hold that |rev(a)| \u2265 r a \u2212 1 for all agents matched to a revealed preference by M .\na 1 : h 1 , h 4 , h 2 , h 3 , h 5 a 2 : h 1 , h 2 , h 3 , h 4 , h 5 a 3 : h 4 , h 1 , h 3 , h 2 , h 5 a 4 : h 4 , h 5 , h 3 , h 2 , h 1 a 4 : h 4 , h 5 , h 2 , h 3 , h 5 Preferences a 1 a 2 a 3 a 4 a 5 h 1 h 2 h 3 h 4 h 5 Iteration 1 a 1 a 2 a 3 a 4 a 5 h 1 h 2 h 3 h 4 h 5 Iteration 2 a 1 a 2 a 3 a 4 a 5 h 1 h 2 h 3 h 4 h 5 Iteration 3\nProof. Towards a contradiction, we assume that there is some agent a \u2208 A with M (a) \u2208 rev(a) and |rev(a)| < r a \u2212 1. Then since M is rank-maximal in all completions of and thus also in we know that a \u2208 E ra\u22121 . Hence, there has to be an alternating path of even length \u03c1 :\n= a = a 1 , M (a 1 ), a 2 , . . . , M (a k\u22121 ), a k in G ra\u22121 from a to an un- matched agent a k . Since a k is unmatched in G ra\u22121 by M we know that rank(a k , M (a k )) > r a \u2212 1 in .\nFurther, assume that there is some a i with i > 1 such that rank(a i , M (a i\u22121 )) > rank(a i\u22121 , M (a i\u22121 )). Then, since a i\u22121 must be in E j for all j \u2208 [r a \u2212 1] due to \u03c1 , we know that M (a i\u22121 ) must be in O rank(ai\u22121,M (ai\u22121)) which in turn implies that {a i , M (a i\u22121 )} is not an edge in G ra\u22121 . Thus, rank(a i , M (a i\u22121 )) \u2264 rank(a i\u22121 , M (a i\u22121 )) has to hold in . Further, we can extend in such a way that rank(a 1 , M (a k )) \u2264 r a \u2212 1, while keeping all other preferences according to . For these preferences, we can augment M with the path\na 1 , M (a k ), a k , M (a k\u22121 ), a k\u22121 , . . . a 2 , M (a 1 )\nand get a matching that rank-dominates M since rank(a i , M\n(a i\u22121 )) \u2264 rank(a i\u22121 , M (a i\u22121 )), as well as rank(a 1 , M (a k )) \u2264 r a \u2212 1, while previously rank(a k , M (a k )) > r a \u2212 1.\nTherefore, no agent a \u2208 A matched to a revealed preference can have less than r a \u2212 1 of their preference revealed. This simple lemma is in fact already sufficient to get a constant upper bound of at most 3 on the competitive ratio of Algorithm 2. To see this, consider the following. We know from Lemma 5 and the fact that at most one agent can be matched to an unrevealed preference and that all but one agent are asked at least min(r a \u2212 1, 1) queries by the optimal algorithm and exactly r a queries by our algorithm. Further, the agent matched to the unrevealed preference is asked at most n \u2212 1 queries by our algorithm. Let A be the set of agents matched to revealed preferences. Then, we can bound the competitive ratio by\na\u2208A (r a ) + n \u2212 1 a\u2208A (min(r a \u2212 1, 1)) \u2264 a\u2208A (r a + 1) a\u2208A (min(r a \u2212 1, 1)) .\nSince for any a \u2208 A the term ra+1 min(ra\u22121,1) is at most 3, this implies the upper bound of 3 on the competitive ratio. However, we can improve upon this and can even show that the algorithm is 3 2 -competitive. Theorem 9. Algorithm 2 is a 3 2 -competitive algorithm for eliciting a rank-maximal matching in the next-best query model.\nFurther, we can show that this bound is tight (up to subconstant factors) by showing that for any \u03b5 > 0, no online algorithm can have a competitive ratio better than 3 2 \u2212 \u03b5. Theorem 10. No online algorithm in the next-best query model can achieve a competitive ratio better than 3 2 \u2212 \u03b5 for any \u03b5 > 0.\nProof. Let k \u2265 2 be an integer and consider the following instance with n = 2k + 1. We start off with the basic preferences of the agents. Here for any i \u2208 [k] (with the assumption that 1 \u2212 1 = k), we assume that the basic preference\nof agent a 2i\u22121 is h 2i\u22121 h 2(i\u22121) \u2022 \u2022 \u2022 h 2k+1 and the basic preference of agent a 2i is h 2i\u22121 h 2i \u2022 \u2022 \u2022 h 2k+1\nwith the preferences between the second and the last house being arbitrary. Further, the basic preference of agent a 2k+1 is h 2k\u22121 h 2k \u2022 \u2022 \u2022 h 2k+1 (just like for agent a 2k ). For our adversarial instance, we assume that all but one agent have their basic preference, with the one special agent instead listing h 2k+1 as their third preference. It is easy to see that in such an instance, a rank-maximal matching must match k agents to their first choice, k agents to their second choice and the special agent to h 2k+1 , since the special agent is the only one not listing h 2k+1 last. The existence of such a matching easily follows by matching the special agent a i to h 2k+1 , any agent a j with j < i to h j and any agent a j with j > i to h j\u22121 . This is a valid matching and matches exactly k agents to their first choice, namely all agents with an odd index that is smaller than i and all agents with an even index that is larger than i, k to their second choice and a i to their third choice, thus being rank-maximal. For an example of this construction, we refer to Figure 2.\nHence, the optimal algorithm can ask 2 queries to each non-special agent and 3 queries to the special agent and can thus elicit an NRM matching. An adversary on the other hand can simply reveal other houses than h 2k+1 when asked for the third house of any agent until the last agent is asked. Thus, any online algorithm needs to ask every agent at least 3 queries.\nTherefore, the competitive ratio of any online algorithm has to be at least 3(2k+1) 2(2k+1)+1 = 3 2 \u2212 3 8k+6 and thus we get that no online algorithm can be 3 2 \u2212 \u03b5-competitive for any \u03b5 > 0.\nWith some slight adjustments to the adversary, the same construction also works for the hybrid-query and setcompare model, thus also implying a lower bound of 3 2 in both models. Corollary 2. In both the set-compare and hybrid query models, there is no online algorithm with a competitive ratio of 3 2 \u2212 \u03b5 for any \u03b5 > 0.\nWe also construct an algorithm, which decides in polynomial time whether a necessarily rank-maximal matching exists, thus standing in contrast to the NP-hardness of the same decision problem for Pareto optimal matchings. Theorem 11. Given partial preferences rank in the hybridquery model, it can be decided in polynomial time whether a necessarily rank-maximal matching exists and whether a given matching M is necessarily rank-maximal.\nFinally, we modify Algorithm 2 to get an algorithm with a constant competitive ratio in the hybrid-query model. Theorem 12. There exists a 6-competitive algorithm for eliciting a rank-maximal matching in the hybrid query model. However, we were not able to find an online algorithm for the set-compare setting achieving a sublinear competitive ratio for eliciting a rank-maximal matching.", "publication_ref": ["b22", "b22", "b22"], "figure_ref": ["fig_0", "fig_1"], "table_ref": []}, {"heading": "Discussion", "text": "There are multiple open questions and possible future research directions which can be derived from this work.\nFirstly, there are still gaps left between the upper bounds and lower bounds we showed in this paper. Most importantly, it would be very interesting to find out whether there is an algorithm with a constant (or even sublinear) competitive ratio for eliciting an NRM matching in the set-compare model. Besides this, the complexity of determining whether a matching is NRM is also open in the set-compare model.\nSecondly, there are several other notions of optimality left to explore, for instance (Huang et al. 2016) fair matchings or the general class of profile-based matchings (Kwanashie et al. 2014) encompassing both fair and rankmaximal matchings. Of course, it might also be interesting to study further querying models or models of partial preferences.", "publication_ref": ["b19", "b24"], "figure_ref": [], "table_ref": []}, {"heading": "A Missing proofs", "text": "Before giving the missing proofs of the theorems from the main body of work, we give a proof sketch that serial dictatorship mechanism can be efficiently simulated in the setcompare model, even if the size of the sets one can query is upper bounded. We define the set-compare-k query model, as the set-compare query model with the additional requirement that for any query Q(a, H ) it has to hold that |H | \u2264 k.\nProposition 1. For any k > 2 there is a 1-competitive algorithm in the set-compare-k query model for eliciting an NPO matching.\nProof Sketch. We again iteratively simulate the serial dictatorship mechanism. We start off by setting M = \u2205. Then in iteration i, we can find the unmatched house agent a i ranks the highest using n\u2212i k\u22121 -queries, by at first choosing an arbitrary subset of size k, asking a i for their top-choice in this subset, then taking k \u2212 1 other unmatched houses, together with the previous top-choice and so on. The final output of this is guaranteed to be the highest ranked, unmatched house of a i . We can thus add this house and a i to M in accordance with the serial dictatorship mechanism. Further, we note that we can also generalize Lemma 1 to the set-compare setting. Thus, for the optimal algorithm there also has to be a permutation of the agents \u03c3 such that the resulting matching of the optimal algorithm M is the result of the serial dictatorship mechanism on any preference extension and \u03c3. Thus, agent \u03c3(1) must rank M (\u03c3(1)) better than all other houses, \u03c3(2) must rank M (\u03c3(2)) better than all other houses except for M (\u03c3(1)) and so on. It is therefore easy to see that agent \u03c3(i) must have been asked at least n\u2212i k\u22121 queries, hence showing that our algorithm is 1-competitive.\nWe note that this is only a proof sketch, with the result not being part of the main work. We defer a proper study of this setting, also with regard to rank-maximality, to future work.\nFollowing this, we give the proofs of the remaining missing theorems from the main body of the paper.\nTheorem 4. Given partial preferences rank in the hybridquery model it is NP-complete to determine whether an NPO matching exists.\nProof. To show membership in NP we observe that the problem of checking whether a matching is NPO is solvable in polynomial time, as shown in Theorem 3. Thus any NPO matching M is enough as a polynomial size witness and thus the problem is in NP. For our reduction, we reduce from (2,2)-E3-SAT. Let X = {x 1 , . . . , x n } be the set of variables and C = {C 1 , . . . , C m } be the set of clauses in our (2,2)-E3-SAT instance. Each variable x i \u2208 X appears in exactly two clauses in negative form and two clauses in positive form. We assume that we have some ordering over these clauses such that we can identify one of the clauses as being the first clause x i (or x i respectively) and the other one as the second one x i appears in.\nIn our reduction, we create the following houses:\n\u2022 for each variable x i \u2208 X we create two selection houses s 1 i and s 2 i . Further, we create two positive variable houses h 1 i and h 2 i and two negative variable houses h 1 i and h 2 i . If C is the clause x i appears in the first time, we say that h 1 i belongs to C and similarly h 2 i belongs to C if C is the second clause x i appears in. The equivalent notation is also used for x i with the negative variable houses.\n\u2022 for each clause C \u2208 C we add a clause house h C ; \u2022 we add 2 3 n + 2 dummy houses d 1 , . . . , d 2 3 n , d, and d .\nNote that due to the nature of our problem 3m = 4n holds and therefore the total number of houses is 6n + m + 2 3 n + 2 = 6n + 4 3 n + 2 3 n + 2 = 8n + 2. Next we come to the agents and their revealed preferences.\n\u2022 For each variable x i \u2208 X we add four agents, two positive agents x 1 i and x 2 i and two negative agents x 1\ni and x 2 i . The positive agent x 1 i has revealed that rank (x 1 i , s\n1 i ) = 1, rank (x 1 i , s 2 i ) = 2, rank (x 1 i , h 1 i ) = 4, rank (x 1 i , h 2 i ) = 5.\nFurther, for each other house except for h 1 i and h 2 i the agent has a revealed rank between 6 and 8n + 1, with variable houses being ranked before dummy houses and dummy houses before clause houses. The internal ranking in these house classes is arbitrary, except that we require every house from d 1 , . . . , d 2 3 n to be before d and d . Therefore, the only unrevealed ranks are 3 and 8n + 2 and the only unrevealed houses are h 1 i and h 2 i . The revealed preferences for the second positive agent x 2 i are the same. For x 1 i and x 2 i we have the same preferences, except that they have h 1 i and h 2 i unrevealed and h 1 i and h 2 i revealed.\n\u2022 Next, for each clause C \u2208 C we add three agents C 1 , C 2 , and C 3 . Let h 1 , h 2 , and h 3 be the three variables houses belonging to C. Then we assume that the three agents have revealed their top 2 3 n + 4 ranks such that that they induce the preferences\nC 1 : h 1 h 2 h 3 h C d 1 \u2022 \u2022 \u2022 d 2 3 n C 2 : h 2 h 3 h 1 h C d 1 \u2022 \u2022 \u2022 d 2 3 n C 3 : h 3 h 1 h 2 h C d 1 \u2022 \u2022 \u2022 d 2 3 n\nwith the preferences over all other houses being unrevealed. \u2022 Finally, we add two dummy agents a 1 d , a 2 d who have revealed rank such that the preference list from position m\nto 8n + 1 is d d h 1 1 h 1 1 s 1 1 \u2022 \u2022 \u2022 h 2 n s 1 n s 2 n d 1 \u2022 \u2022 \u2022 d 2 3 n .\nThus, the only unrevealed houses of a 1 d and a 2 d are the clause houses, one of which is listed last while the other m \u2212 1 clause houses are a prefix of the preference list.\nNote, that there are 4n + 3m + 2 = 8n + 2 agents, thus fulfilling the condition that the number of agents and houses is the same.\n\u21d2 First, we assume that our (2,2)-E3-SAT instance is satisfiable and that \u03a6 is a satisfying assignment. We now show how to construct an ordering of the agents, such that the serial dictatorship method with regard to that ordering is consistent with any possible preference completion. First, for any variable x i if x i appears in \u03a6, our serial dictatorship mechanism asks x 1 i and then x 2 i (who get matched to s 1 i and s 2 i ), followed by the clause agents who rank h 1 i and h 2 i first. Afterwards, we ask x 1 i and x 2 i to pick their top choice, which is h 1 i and h 2 i regardless of the preference completion. Now, since \u03a6 is a satisfying assignment, for any clause C there has to be at least one agent C j who is currently unmatched. This is due to the fact that the only clause houses matched, are matched to variable houses, belonging to variables not in \u03a6. For these clause houses, the top-choice which is not matched yet is guaranteed to be h C , since all the variable houses are matched. We can therefore ask a clause agent to be matched to their corresponding clause house. Finally, we can match the remaining clause agents to dummy agents and the dummy agents to d and d , since all clause houses are matched. Since this is a serial dictatorship order that works for any completion of the preferences, the matching is guaranteed to be NPO.\n\u21d0 Let M be an NPO matching. First, assume that M (a 1 d ) = d and M (a 1 d ) = d .\nWe will distinguish two cases based on the houses a d could be matched to.\n\u2022 If a 1 d is matched to a clause house h C , there is a completion such that h C is ranked last by a 1 d and first by a 2 d , thus implying that they form a cycle.\n\u2022 If a 1 d is matched to either a selection, dummy, or variable house, then every preference list except for a d 2 can be completed in such a way that the house matched to a 1 d is in front of d and d in each preference list. Therefore, there needs to be a cycle containing a 1 d and another agent with both preferring the partner house of the other.\nDue to a 2 d having the same revealed preferences as a 1 d this also implies that a 2 d is matched to either d or d . Next, we assume that there is any variable agent matched to a clause house. However, then this variable agent would prefer d and d to their current house, while the preferences of a 1 d could be completed to prefer the clause house to d and d thus inducing a cycle. Thus, we know that every clause house must be matched to a clause agent. Let C, C \u2208 C be two distinct clauses and assume that C j for some j \u2208 [3] is matched to h C . Since h C as well as d and d are unrevealed by C j and since the dummy agent a 1 d could prefer h C to d and d we know that C j cannot be matched to h C in any NPO matching. Therefore, for any clause C \u2208 C there needs to be one agent C j with M (C j ) = h Cj . This however implies that at least one variable agent corresponding to a variable from C j must be matched to their corresponding variable houses. Since the negative houses could be ranked last by any positive agent and vice versa, this implies that this agent matched to a variable house must be positive if the variable house is positive and negative if the variable house is negative.\nLet \u03a6 be the assignment setting all variables to true for which a positive agent is matched to a variable house and all variables to false for which a negative agent is matched to a variable house. To show that this is a valid definition, assume that there is some variable x i for which both a negative and a positive agent are matched to a variable house. Then it is easy to see that the preferences of both agents could be completed in such a way that both agents prefer each other's house to their own. Thus, \u03a6 is a valid assignment. Moreover, we know that for each clause, there is at least one agent, who is also positive if and only if the house is positive, matched to this variable house. Thus, each clause is fulfilled by at least one variable from \u03a6 and the (2,2)-E3-SAT instance is satisfiable.\nTheorem 5. Given partial preferences in the setcompare model, it is NP-complete to determine whether a necessarily Pareto-optimal matching exists.\nProof. For this, we give a simple reduction from the problem of determining whether an NPO matching exists in the hybrid-query setting. Assume that we are given partial preferences rank in the hybrid-query model. For a given agent a \u2208 A we call a revealed house h \u2208 H a prefix house of a, if all ranks from 1 to rank(a, h) are revealed. It is easy to see that no unrevealed house can be ranked better than a prefix house, while all unranked houses could be ranked better than a non-prefix house.\nFor our reduction, we now create partial preferences in the set-compare model, by taking the partial order for each agent which ranks \u2022 every prefix house better than every unrevealed house and every house with a worse rank; \u2022 every revealed non prefix house better than every revealed house with a worse rank. Now assume we are given a matching M . We show that M is NPO in the hybrid-query preferences if and only if M is NPO in the constructed set-compare preferences.\nFirst, assume that M is not necessarily Pareto optimal in the hybrid-query preferences. Then there is a cycle a 1 , . . . , a k = a 1 with agent a i preferring M (a i+1 ) to M (a i ) in some preference extension of rank . Therefore, we know that M (a i ) i M (a i+1 ) does not hold in . Since i is a partial order, we can extend i to i in such a way that M (a i+1 ) i M (a i ). By doing this for all agents, we see that M is also not necessarily Pareto optimal in . Similarly, if M is not NPO in there is some cycle a 1 , . . . , a k = a 1 with agent a i preferring M (a i+1 ) to M (a i ) in some preference extension of . Thus, for each agent a i on the cycle there is some extension of rank with rank (a i , M (a i )) \u2265 rank (a i , M (a i+1 )) which in turn shows that M is also not NPO for rank .\nThus, we can reduce to the problem of determining whether a matching is NPO in the set-compare model and hence this problem is NP-complete as well.\nLemma 3. The series (c j ) j\u2208N with c j+1 = (\n3c j + 1)/2 + c 0 \u2212 1 is increasing if c 0 > 1 3 .\nProof. We show this by induction. Let j > 0 be given and assume that c j > 1 3 . Further, let \u03b5 = 1 3 \u2212 c 0 . Then,\nc j+1 = 3c j + 1 2 + c 0 \u2212 1 = c j + c j + 1 2 + 1 3 + \u03b5 \u2212 1 \u2265 c j + 2 3 + 1 3 + \u03b5 \u2212 1 = c j + \u03b5.\nThus, it holds that c j+1 \u2265 c j + \u03b5 and the sequence is monotonically increasing.\nTheorem 6. For any c > 1 3 Algorithm 1 is an O(n c0 )competitive algorithm for eliciting a necessarily Pareto optimal matching in the hybrid-query model. Proof. To show this bound, let (A, H, ) be a given house allocation instance.\nFirst, we observe that the matching M is indeed Pareto optimal. For this, let A be the set of agents matched in the first 'for loop'. Since M is Pareto optimal when restricted to A , there is some permutation \u03c3 of A such that SD (\u03c3 ) = M when restricted to A . We now create a permutation \u03c3 of A by first copying \u03c3 and for any j \u2208 [|A |, n] setting \u03c3(j) to be the agent matched the jth time by our algorithm. Now, running the serial dictatorship mechanism on \u03c3 results in any agent in A being matched to their respective partner in M , due to \u03c3 consisting of \u03c3 . Further, Algorithm 1 matches any agent in the second for loop to the unmatched house they prefer the most, thus resulting in SD (\u03c3) = M .\nWe show that Algorithm 1 is O(n c0 )-competitive by considering the maximum value of j.\n\u2022 As our base case, if the maximum value of j is 0, we get that for i = n c0 we have that |M | \u2265 n \u2212 n (cj +1)/2 , and our algorithm at most takes n n c0 + n (c0+1)/2 n (c0+1)/2 \u2208 O(n 1+c0 ) queries. Since the optimal algorithm uses at least n \u2212 1 queries, the competitive ratio in this case is in O(n c0 ).\n\u2022 Now assume that the maximum value j takes is at least 1 (and let j be this maximum value) and that the for loop breaks. Then for i = n cj\u22121 we know that M < n \u2212 n (cj\u22121+1)/2 . Thus, at least n (cj\u22121+1)/2 agents are matched to a house with a rank worse than n cj\u22121 for any NPO matching. Let M be the NPO matching produced by the optimal algorithm with partial preferences rank and \u03c3 the corresponding permutation of A such that SD (\u03c3) = M for all extensions of rank . By definition of the serial dictatorship mechanism it is easy to see that for any i \u2208 [n] and a \u2208 A we have that \u03c3(i) = a implies rank(a, M (a)) \u2264 i. Therefore, and by the fact that n (cj\u22121+1)/2 \u2265 n cj\u22121 , we get that\nmin(rank(a, M (a)), n \u2212 \u03c3 \u22121 (a)) \u2265 1 2 n cj\u22121\nfor at least 1 2 n (cj\u22121+1)/2 many agents, since \u03c3 \u22121 (a) \u2264 n \u2212 1 2 n (cj\u22121+1)/2 for at least 1 2 n (cj\u22121+1)/2 many a \u2208 A with rank(a, M (a)) \u2265 n cj\u22121 . Thus, by Lemma 2 the optimal algorithm needs at least\n\u2126 n (cj\u22121+1)/2 n cj\u22121 \u2208 \u2126 n (3cj\u22121+1)/2 queries. Since our algorithm uses O(nn cj + n (cj +1)/2 n (cj +1)/2 ) = O(n cj +1 ) = O(n 1+(3cj\u22121+1)/2+c0\u22121 ) = O(n (3cj\u22121+1)/2 n c0 )\nqueries, we get a competitive ratio of O(n c0 ) in this case.\n\u2022 Finally, if the for loop never breaks, we know that our algorithm uses O(n 2 ) many queries. Further, we can assume that n co\u2212 1 3 \u2265 2 and n c0 \u2265 1 since we are only dealing with asymptotics. Then following the calculations of Lemma 3 we get that\nn cj+1 \u2265 n cj +c0\u2212 1 3 \u2265 2n cj > n cj + 1.\nTherefore, the sequence ( n cj ) j\u2208N is monotonically increasing as well. Further, we know that for the maximum j it has to hold that (3c j\u22121 + 1)/2 + c 0 \u2212 1 > 1 since the sequence is monotonically increasing by Lemma 3 and otherwise the algorithm would enter the case for i = n 1 . This implies that c 0 > 2 \u2212 (3c j\u22121 + 1)/2. By the same argument as in the last case, we can lower bound the number of queries asked by the optimal algorithm by \u2126 n (3cj\u22121+1)/2 and thus get a competitive ratio of O(n 2\u2212(3cj\u22121+1)/2 ) \u2208 O(n c0 ).\nTheorem 7. There is no online algorithm in the hybridquery model for computing a necessarily Pareto optimal matching with a competitive ratio of o(n\n1 3 ).\nProof. For this, we construct a family of instances such that any correct online algorithm must ask at least \u2126(nn 1 3 ) queries, while an optimal offline algorithm can do it using O(n) queries. For simplicity, we assume that n 1 3 is an integer. We divide the set of agents into three sets \u2022 a set of first-choice agents A 1 , consisting of n \u2212 2n Similarly, we also divide our set of houses into a set of firstchoice houses H 1 of size n \u2212 n 2 3 and a set of special houses H 2 of size n 2 3 . The preferences of the first-choice agents are such that each first-choice agent has a unique first-choice house as their first-choice and lists all special houses at the end of their preference list with the rest of their preference list being completed arbitrarily. Every special agent also has a unique first-choice house as their first choice and lists a special house somewhere in their first n 1 3 preferences. All other special houses are listed in last n 2 3 as well. Finally, all second-choice agents, share their first-house with some other agent and list the first choice of a unique special agent somewhere in their first n 1 3 preferences. Our family of instances now consist of all preferences inducing such profiles. Our adversary now works as follows:\n\u2022 For any agent asked to reveal their first-choice house, we just reveal consistently any 'first-choice' house that has not been revealed twice yet. \u2022 For any agent asked to reveal a house in their first n 1 3 preferences, we always reveal a first-choice house while still possible.\n\u2022 For any agent asked to reveal the rank of a special house, we always return the lowest consistent rank in the last n\n2 3\nranks, while this is still possible. \u2022 The rest of the preferences are revealed consistently.\nWe claim that any online algorithm working against this adversary must ask at least \u2126(nn 1 3 ) queries. Let A be the set of agents matched to special houses. For any a \u2208 A there are now two possibilities. If a \u2208 A 2 , so a 2 is a special agent, and a is matched to one of their first n 1 3 choices, then we know that these preferences could not be completed consistently by placing the agent in the last n 2 3 houses of a . Thus, this agent could not have been a first-choice agent. This, however, easily implies that each first choice agent must have been asked at least n 1 3 queries, since otherwise the preferences could be consistently completed with that agent being a special agent. Hence, this would already imply that our online algorithm asked \u2126(n 4 3 ) queries. Therefore, the only choice remaining is all special houses being matched to agents who list them in their last n 2 3 preferences. Thus, using Lemma 2 we can deduce that any online algorithm must have asked at least 1 2 n 2 3 queries to at least 1 2 n 2 3 of them, therefore also implying that any online algorithm must ask at least \u2126(n 1+ 1 3 ) queries in this case. An algorithm having access to all preferences on the other hand can ask any top-choice agent for their top-choice, any special agent until it reaches the special house of this agent and any second-choice agent until it reaches the unique top-choice house of a special agent in ranks in the top n 1 3 houses. After this the preferences are top-k preferences and a matching of size n is possible. By Hosseini et al. (2021) this implies that an NPO matching exists. Since it can be found using\nO(n + n 1 3 n 2 3 ) = O(n) queries, this shows that no algorithm can be o(n 1 3 )-competitive.\nTheorem 9. Algorithm 2 is a 3 2 -competitive algorithm for eliciting a rank-maximal matching in the next-best query model.\nProof. To see that the matching M computed by Algorithm 2 is indeed rank-maximal, we observe that the graph (A \u222a H, E) after finishing the elicitation step in iteration i is equivalent to the graph G i . Every agent only elicits preferences until they are in either U or O which is equivalent to the deletion of all preferences of a higher rank. Further, by deleting all edges between O, O and O, U and by adding them to F we ensure that these edges cannot be used or added to the graph. Finally, removing houses from V once they are in U or O is again equivalent to the deletion step in the original algorithm. Thus, by Lemma 4 the matching M is rank-maximal. To show that the algorithm is also 2 -competitive, we show that almost all agents need to be queried until they would be a part of either U or O in the decomposition. In Lemma 5 we have already shown that no agent a \u2208 A matched to a revealed preference can have less than r a \u2212 1 of their preference revealed. Now we turn to agents matched to an agent they have not revealed yet 1 . Let M be any NRM matching with corresponding partial preferences and a \u2208 A an agent matched to a house they have not revealed yet. Now, if either M (a) / \u2208 rev(a ) or rank(a , M (a)) = n for any a \u2208 A, we can get a matching that dominates M in an extension of the preferences by matching a to M (a ) and a to M (a). Thus, rank(a , M (a)) = n has to hold for any a \u2208 A \\ {a}. Thus, any optimal algorithm leaving matching an agent to a preference this agent has not revealed yet has to ask (n \u2212 1) 2 queries. On the other hand, we know that our algorithm asks at most n(n \u2212 1) queries. Thus, in this special case, we get an upper bound on the competitive ratio of n(n\u22121)\n(n\u22121) 2 = n n\u22121 . Since our algorithm is 1-competitive for n \u2264 2 this implies a competitiveness of n n\u22121 \u2264 3 2 if the optimal algorithm matches an agent to an unqueried house.\nTherefore, we can now assume that |rev(a)| \u2265 max(r a \u2212 1, 1) for all a \u2208 A. Finally, for h \u2208 H let A h := {a \u2208 A | rank(a, h) = 1}. It is easy to see that for n > 2, there need to be at least 2|A h | \u2212 1 queries to agents in A h , since otherwise there would be two agents with only their first agent revealed, which would be a contradiction to every agent only being matched to a revealed preference. Of course, this also holds for any non-empty subset of A h . Now let OPT(A ) be the number of queries asked to agents in the set A \u2286 A. We thus get that for any h \u2208 H and A \u2286 A h it has to hold that OPT(A ) \u2265 max( on the competitive ratio. For any h \u2208 H we can now distin-guish two cases. If a\u2208A h r a \u2265 3|A h | we get\na\u2208A h r a OPT(A h ) \u2264 a\u2208A h r a max( a\u2208A h (max(r a \u2212 1, 1)), 2|A h | \u2212 1) \u2264 a\u2208A h r a a\u2208A h (max(r a \u2212 1, 1)) \u2264 a\u2208A h r a a\u2208A h r a \u2212 |A h | \u2264 a\u2208A h r a a\u2208A h r a \u2212 1 3 a\u2208A h r a = a\u2208A h r a 2 3 a\u2208A h r a = 3 2 .\nIf a\u2208A h r a < 3|A h | there must be at least one a \u2208 A h with r a = 2. Let A 2 h be this subset. If |A 2 h | \u2265 2 we can see that\na\u2208A h r a OPT(A h ) = a\u2208A h \\A 2 h r a + 2|A 2 h | OPT(A h \\ A 2 h ) + OPT(A 2 h ) \u2264 max( a\u2208A h \\A 2 h r a a\u2208A h \\A 2 h r a \u2212 |A h \\ A 2 h | , 2|A 2 h | 2|A 2 h | \u2212 1 ) \u2264 3 2 since we know that a\u2208A h \\A 2 h r a \u2265 3|A h \\A 2 h |. If, however |A 2 h | = 1\n, then there must be exactly one a \u2208 A h with r a = 2. This implies that either a \u2208 O 2 or a \u2208 U 2 . Since all other agents in A h are in E 2 this shows that h / \u2208 E 2 . Therefore, G n contains no edge between a and h and any rank-maximal matching matches a to their second ranked house. However, then the optimal algorithm must have asked two queries to agent a and therefore we get an upper bound on the competitive ratio of\na\u2208A h r a max( a\u2208A h (max(r a \u2212 1, 1)), 2|A h | \u2212 1) \u2264 3|A h | \u2212 1 2|A h | \u2264 3 2 .\nThus our algorithm correctly elicits a necessarily rankmaximal matching with a competitive ratio of 3 2 . Corollary 2. In both the set-compare and hybrid query models, there is no online algorithm with a competitive ratio of 3 2 \u2212 \u03b5 for any \u03b5 > 0. Proof.\nHybrid-query model. We begin with the hybrid query model and take the same preference structure as in the proof of Theorem 10, i.e., at the family of preferences isomorphic to the preference structure in the proof. However, in this case, we need to change the elicitation of the preferences by our adversary slightly. When asked for a first-choice house, we still reveal the preferences according to the basic preferences and when asked for the third preference or the rank of the special house we can either return any first-choice house or the last rank for this special house until the last agent queried.\nFor the second-choice houses, however, we need to adjust the adversary. For i \u2208 [k\u22121] we call the agents a 2i\u22121 and a 2i the block A i and similarly the agents a 2k\u22121 , a 2k , and a 2k+1 form the block A k . Based on the total preferences, we see that the agents in block A i share their second choice agents with blocks A i\u22121 and A i+1 with indices taken modulo k.\nWhile eliciting preferences, we call two blocks A i and A j neighboring if they share a second-choice house. It is easy to see that any way of answering the queries for second-choice houses such that the blocks form a cycle of length n based on the neighborhood relation leads to a preference profile isomorphic to the one specified in Theorem 10. In order to use this, until the final preference of the agents is revealed, if any agent is queried for their second choice agent, the adversary first checks if there is any second-choice house revealed by an agent in a block not reachable by the neighborhood relation. If this is the case, we can safely return this agent as the second-choice. If none such agent exists, we return any second-choice agent, not queried before. For the final agent revealing their second-choice agent, there is only one choice left, which we reveal.\nThis model of eliciting preferences leads to a cycle of blocks as described above, and thus to preferences isomorphic to the ones described in Theorem 10. Further, every second-choice agent needs to appear at least once as a second-choice agent for any matching to be NRM. Now assume that the blocks do not form a path according to the neighbor relation. Then either one second-choice houses is still unrevealed or the last query to an agent would be able to reveal a second-choice house in a different connected component according to the neighbor relation, since these two blocks cannot reach each other. Thus, since the blocks need to form a path, we need to reveal two secondchoice houses for at least k \u2212 2 blocks. Thus, we need to ask at least 2k \u2212 4 second-choice queries. Since we also need to query every first and every third choice, this leads to a competitive ratio of at least 2k\u22124+2(2k+1) 2(2k+1)+1 = 3 2 \u2212 13 8k+6 . Thus, also no algorithm can be 3 2 \u2212 \u03b5-competitive for the hybridquery model.\nSet-compare model. The same construction also works in the set-compare model. If an agent a i is asked for their bestchoice of a set containing all houses (or their top-choice house), we simply return their top-choice house. If asked for their best-choice out of a set only not containing their top-choice house i.e., their second choice house, we reveal the preferences according to the construction in the hybridquery model. Finally, if asked to reveal their best-choice out of a smaller set not containing their first or second choice we simply reveal any house that is not the special house until all agents have been queried for the special house at least once.\nSince we need to know the top-choice of every agent we need to ask every agent for their best-choice. Further, since we need to reveal every second-choice agent at least once as the best-choice out of a set, we need to ask at least 2k \u2212 4 queries as previously shown. Finally, we need to ask every agent at least one query containing neither their first and second choice, but the special house. Thus, the competitive ratio is also lower bounded by 3 2 \u2212 13 8k+6 in this case.\nTheorem 11. Given partial preferences rank in the hybridquery model, it can be decided in polynomial time whether  Proof. In order to show this, we provide a short necessary condition of necessarily rank-maximal matchings, provided that one exists. Given partial preferences in the hybrid query model, for an agent a \u2208 A let a be the last rank with no revealed house and k a be the first rank with no revealed house. Then we define max rank(a, h) to be rank(a, h) if h \u2208 rev(a) and max rank(a, h) = a otherwise, i.e., max rank(a, h) is the worst possible rank of h for a in any possible completion. We now show that if an NRM matching M exists it is rank-maximal in the instance (A, H, max rank).\nlet h 1 = Q(a 1 , 1), return {{a 1 , h 1 }, {a 2 , h 2 }} 6: end if 7: for i in 1, . . . n \u2212 1 do 8: for all a \u2208 U do 9: h \u2190 Q(a, i) 10: if h \u2208 V\nAssume that M is indeed NRM and that there is a matching M rank-dominating M in (A, H, max rank). Then we extend the preferences, by setting rank(a, M (a)) = a for all a \u2208 A and by extending all other preferences in any consistent manner. The signature of M under rank and max rank is the same, while the signature of M under rank is guaranteed to be at least as large as under max rank. Thus, M also rank-dominates M under rank and M is not NRM.\nFor our next step let (E 1 , O 1 , U 1 ), . . . , (E n , O n , U n ) be the Dulmange-Mendelsohn decompositions of (A, H, max rank). Let a \u2208 A be an agent and h / \u2208 rev(a). If either a / \u2208 E a \u22121 or h / \u2208 E a \u22121 then we know that no rank-maximal matching in (A, H, max rank) and thus also no NRM matching can match a and h. On the other hand, assume that a \u2208 E a\u22121 and h \u2208 E a \u22121 . Then we can extend the preferences in such a way that rank(a, h) = k a and for all other a \u2208 A with h / \u2208 rev(a) it holds that rank(a , h) = a . Under these preferences a \u2208 E ka\u22121 and h \u2208 E ka\u22121 still hold. Further, if there was another a \u2208 E ka\u22121 with rank(a , h) = k a this would have implied that h / \u2208 E a\u22121 , since we only decreased the ranks of the other agents and since \u2212 1 \u2265 k a . Hence, a, h \u2208 U ka has to hold and they have to be matched. Therefore, an agent a is matched to an unrevealed agent h in an NRM matching if and only if a \u2208 E a \u22121 and h \u2208 E a\u22121 . Thus, it is sufficient to calculate the Dulmange-Mendelsohn decompositions of (A, H, max rank), match all agents a \u2208 A to unrevealed houses h \u2208 H if a \u2208 E a\u22121 and h \u2208 E a \u22121 and then calculate a rank-maximal matching in the instance without the already matched agents and houses. Afterwards, we check if this matching is indeed NRM and return it if it is, otherwise we return that no NRM matching exists.\nIf there is no NRM matching this is indeed correct. Otherwise, assume that an NRM matching M exists and let M be the matching returned by our algorithm. By our previous proof, we know that the agents matched to unrevealed preferences by M and M are the same. Further, for any other preference extension, the signature over the agents matched to revealed preferences is obviously the same, since M is rank-maximal on these agents. Thus M and M have the same signature for all possible preference extensions and therefore M is NRM.\nBefore turning to the correctness proof of Algorithm 3 we show a few auxiliary lemmas for the hybrid query model. For a given preference profile and an NRM matching M with partial preferences rank of , we call an agent a \u2208 A a prefix agent, if the ranks 1 to r a \u22121 are all revealed for rank. Similarly, we call all other agents non-prefix agents. We can show that all houses not ranked by a non-prefix agent a can be guaranteed to be matched to an agent that rank them at most at rank k a , i.e., the first rank for which agent a has not revealed a house yet. Lemma 6. Let a \u2208 A be a non prefix agent. Then for any house h / \u2208 rev(a) with h = M (a) there exists a k \u2264 k a with h / \u2208 E k .\nProof. Assume that there is a h / \u2208 rev(a) with h \u2208 E k for every k \u2264 k a and assume that the preferences are completed such that rank(a, h) = k a , i.e., the smallest unrevealed rank, with all other preferences consistent with .\nSince a, h \u2208 E i for any i < k a there must exist an edge between a and h in G ka . However, since h \u2208 E ka , when only looking at , when h is not matched to a, there is an alternating path from h to an unmatched house h not containing a. Hence, we could augment this matching along this path and by matching a to h. Thus, a had to be matched to h in the first place.\nSimilarly, we can show that a non-prefix agent must reveal a house for each rank matched by a rank-maximum matching which is better than his own rank. Lemma 7. Let a \u2208 A be a non-prefix agent. Then for all a \u2208 A with rank(a , M (a )) < r a it has to either hold that M (a ) \u2208 rev(a) or for all r < rank(a , M (a )) there has to be a h \u2208 H with h \u2208 rev(a) and rank(a, h ) = r .\nProof. Assume that rank(a , M (a )) < r a and M (a ) / \u2208 |rev(a)|. Since M matches a to M (a ) we know that M (a ) \u2208 E r for all r < rank(a , M (a )). However, since also a \u2208 E r there cannot be an edge between a and M (a ) in G r in any preference completion and thus a must elicit a preference with rank r . Otherwise, a could elicit M (a ) with rank r .\nTheorem 12. There exists a 6-competitive algorithm for eliciting a rank-maximal matching in the hybrid query model.\nProof. It is easy to see that the matching computed by Algorithm 3 is indeed necessarily rank-maximal, since any agent a / \u2208 U in line 26 will be in either U or O and will thus be matched to a house they have already revealed. Further, the only houses unrevealed by an agent a \u2208 U in line 26 are houses which are in U or O and can thus not be matched to a in any rank-maximal matching by Lemma 4. Thus, the preferences elicited in algorithm 3 are a superset of the edges of G n which by Lemma 4 implies that we correctly find a necessarily rank-maximal matching.\nLet OPT be the optimal algorithm and OPT P be the set of prefix agents after the partial preferences were revealed by OPT and OPT N P the non-prefix agents of OPT. Similarly, let ALG P and ALG N P be the prefix and non-prefix agents of our algorithm. For simplicity, we also let i and c be the respective values of the variables at the end of our algorithm. For any agent a \u2208 A let OPT a be the number of queries asked to a by an optimal algorithm and ALG a the number of queries asked by our algorithm. Our goal is now to bound ALGa OPTa \u2264 6 for any agent, thus showing that the competitive ratio is at most 6. Before doing this, we must however discuss the case, where rev(a) = \u2205 for some agent a \u2208 A. Firstly, assume that there is some a \u2208 A with rank(a , M (a ) > 1. Then we can extend the preferences in such a way that rank(a, M (a ) = 1 and the matching is not NRM. Thus, it needs to hold that all agents except for a are matched to their first choice. Further, similar to the proof in Theorem 9 we must know that rank(a , M (a)) = n for all agents. Thus, any optimal algorithm must ask at least 2(n \u2212 1) queries. Further, our algorithm asks every agent one question and then queries a and the agent sharing the first choice agent with a both exactly two queries. Since we can assume that n \u2265 3 we get an upper bound on the competitive ratio of n+4 2(n\u22121) \u2264 7 4 \u2264 2. Now we can assume that rev(a) = \u2205 and distinguish four cases:\n\u2022 For any a \u2208 A with a \u2208 OPT P and a \u2208 ALG P we know that our algorithm asks at most r a queries to a while the optimal algorithm asks at least r a \u2212 1. Thus, the quotient for a is upper bounded by\nALG a OPT a \u2264 r a r a \u2212 1 \u2264 2 1 = 2.\n\u2022 If a \u2208 OPT P and a \u2208 ALG N P we know that r a > i and thus r a \u2212 1 \u2265 i \u2265 c \u2265 |V |. Thus, the quotient for a in this case is upper bounded by\nALG a OPT a \u2264 i + |V | i \u2264 1 + |V | |V | = 2.\n\u2022 Next, assume that a \u2208 OPT N P and a \u2208 ALG P . Then we know that in iteration i = r a it has to hold that c \u2264 |V |. By Lemma 6 we know that all but one house not in U ra and O ra , i.e., in V , need to be queried by a in the optimal algorithm. Similarly, by Lemma 7 we know that at most c+1 ranks before r a can be unqueried, namely all ranks r without any agent a such that rank(a , M (a )) as well as the largest r such that such an a exists. Since no house with a rank smaller than r a can belong to E ra we get OPT a \u2265 r a \u2212 c + |V | \u2212 2 \u2265 r a \u2212 2 + c \u2212 c. Thus, we get an upper bound on the quotient of ALG a OPT a \u2264 r a r a \u2212 2 \u2264 3 since we know that at least one query is asked to a. \u2022 Finally, the case of a \u2208 OPT N P and a \u2208 ALG N P remains. Let p a be the length of the prefix of the preferences queried by the optimal algorithm. If p a > i, we get that a gets asked at least i \u2265 |V | queries by the optimal algorithm. Since our algorithm asks at most i + |V | queries, this implies a quotient of 2.\nIf p a \u2264 i, then we know by Lemma 6 that the optimal algorithm must ask at least |V | + p a \u2212 1 queries to a. If p a = i, this implies a quotient of\nALG a OPT a \u2264 i + |V | |V | + p a \u2212 1 = i + |V | i + |V | \u2212 1 \u2264 2.\nIf p a < i, we know that every but one house in V must be queried by the optimal algorithm and at most c i\u22121 + 1 \u2264 |V | + 1 ranks can be left unqueried by the optimal algorithm, thus leading to a quotient of at most\nALG a OPT a \u2264 i + |V | (|V | \u2212 1) + (i \u2212 |V | \u2212 1) = i + |V | i \u2212 2 \u2264 6\ndue to |V | \u2264 c \u2264 i and since we can assume that at least one query has been asked to a.\nThus, the competitive ratio is at most 6.", "publication_ref": ["b18"], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgments", "text": "This work was supported by the Deutsche Forschungsgemeinschaft under grant BR 4744/2-1 and Graduiertenkolleg \"Facets of Complexity\" (GRK 2434). Further, I want to thank the reviewers of AAAI, Markus Brill, Felix Brandt, Jonas Israel, and Ulrike Schmidt-Kraepelin for their helpful comments and suggestions.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Random Serial Dictatorship and the Core from Random Endowments in House Allocation Problems", "journal": "Econometrica", "year": "1998", "authors": "A Abdulkadiroglu; T S\u00f6nmez"}, {"ref_id": "b1", "title": "Pareto Optimality in House Allocation Problems", "journal": "", "year": "2004", "authors": "D J Abraham; K Cechl\u00e1rov\u00e1; D F Manlove; K Mehlhorn"}, {"ref_id": "b2", "title": "", "journal": "Popular Matchings. SIAM Journal on Computing", "year": "2007", "authors": "D J Abraham; R W Irving; T Kavitha; K Mehlhorn"}, {"ref_id": "b3", "title": "Pareto Optimal Allocation under Uncertain Preferences: Uncertainty Models, Algorithms, and Complexity", "journal": "Artif. Intell", "year": "2019", "authors": "H Aziz; P Bir\u00f3; R De Haan; B Rastegari"}, {"ref_id": "b4", "title": "Multi-Rank Smart Reserves", "journal": "", "year": "2021", "authors": "H Aziz; Z Sun"}, {"ref_id": "b5", "title": "Combining Fairness and Optimality when Selecting and Allocating Projects", "journal": "", "year": "2021", "authors": "K Belahc\u00e8ne; V Mousseau; A Wilczynski"}, {"ref_id": "b6", "title": "Diversity Constraints in Public Housing Allocation", "journal": "ACM", "year": "2018", "authors": "N Benabbou; M Chakraborty; X.-V Ho; J Sliwinski; Y Zick"}, {"ref_id": "b7", "title": "Approximation Hardness of Short Symmetric Instances of MAX-3SAT", "journal": "", "year": "2004", "authors": "P Berman; M Karpinski; A Scott"}, {"ref_id": "b8", "title": "Local Envyfreeness in House Allocation Problems", "journal": "Autonomous Agents and Multi-Agent Systems", "year": "2019", "authors": "A Beynier; Y Chevaleyre; L Gourv\u00e8s; A Harutyunyan; J Lesca; N Maudet; A Wilczynski"}, {"ref_id": "b9", "title": "A New Solution to the Random Assignment Problem", "journal": "Journal of Economic Theory", "year": "2001", "authors": "A Bogomolnaia; H Moulin"}, {"ref_id": "b10", "title": "Matchings under Preferences: Strength of Stability and Trade-offs", "journal": "", "year": "2019", "authors": "J Chen; P Skowron; M Sorge"}, {"ref_id": "b11", "title": "A Nearly Instance Optimal Algorithm for Top-k Ranking Under the Multinomial Logit Model", "journal": "SIAM", "year": "2018", "authors": "X Chen; Y Li; J Mao"}, {"ref_id": "b12", "title": "Improving Efficiency Of On-campus Housing: An Experimental Study", "journal": "American economic review", "year": "2002", "authors": "Y Chen; T S\u00f6nmez"}, {"ref_id": "b13", "title": "Preference Elicitation and Interview Minimization in Stable Matchings", "journal": "", "year": "2014", "authors": "J Drummond; C Boutilier"}, {"ref_id": "b14", "title": "Envyfreeness in House Allocation Problems", "journal": "Mathematical Social Sciences", "year": "2019", "authors": "J Gan; W Suksompong; A A Voudouris"}, {"ref_id": "b15", "title": "Assigning Papers to Referees", "journal": "Algorithmica", "year": "2010", "authors": "N Garg; T Kavitha; A Kumar; K Mehlhorn; J Mestre"}, {"ref_id": "b16", "title": "Robust Stable Marriage", "journal": "", "year": "2017", "authors": "B Genc; M Siala; B O'sullivan; G Simonin"}, {"ref_id": "b17", "title": "Rank-Maximal Matchings-Structure and Algorithms", "journal": "Theoretical Computer Science", "year": "2019", "authors": "P Ghosal; M Nasre; P Nimbhorkar"}, {"ref_id": "b18", "title": "Necessarily Optimal One-Sided Matchings", "journal": "", "year": "2021", "authors": "H Hosseini; V Menon; N Shah; S Sikdar"}, {"ref_id": "b19", "title": "Fair Matchings and Related Problems", "journal": "Algorithmica", "year": "2016", "authors": "C.-C Huang; T Kavitha; K Mehlhorn; D Michail"}, {"ref_id": "b20", "title": "The Efficient Allocation of Individuals to Positions", "journal": "Journal of Political economy", "year": "1979", "authors": "A Hylland; R Zeckhauser"}, {"ref_id": "b21", "title": "Greedy Matchings", "journal": "", "year": "2003", "authors": "R W Irving"}, {"ref_id": "b22", "title": "Rank-Maximal Matchings", "journal": "ACM Transactions on Algorithms (TALG)", "year": "2006", "authors": "R W Irving; T Kavitha; K Mehlhorn; D Michail; K E Paluch"}, {"ref_id": "b23", "title": "Efficient Algorithms for Weighted Rank-Maximal Matchings and Related Problems", "journal": "Springer", "year": "2006", "authors": "T Kavitha; C D Shah"}, {"ref_id": "b24", "title": "Profile-based Optimal Matchings in the Student/Project Allocation Problem", "journal": "Springer", "year": "2014", "authors": "A Kwanashie; R W Irving; D F Manlove; C T Sng"}, {"ref_id": "b25", "title": "Collective Decision Making under Incomplete Knowledge: Possible and Necessary Solutions", "journal": "", "year": "2020", "authors": "J Lang"}, {"ref_id": "b26", "title": "Stable Matching with Incomplete Information", "journal": "Econometrica", "year": "2014", "authors": "Q Liu; G J Mailath; A Postlewaite; L Samuelson"}, {"ref_id": "b27", "title": "Improving Welfare in One-sided Matching using Simple Threshold Queries", "journal": "", "year": "2021", "authors": "T Ma; V Menon; K Larson"}, {"ref_id": "b28", "title": "Finding Stable Matchings That Are Robust to Errors in the Input", "journal": "", "year": "2018", "authors": "T Mai; V V Vazirani"}, {"ref_id": "b29", "title": "Algorithmics of Matching Under Preferences", "journal": "World Scientific Publishing Company", "year": "2013", "authors": "D F Manlove"}, {"ref_id": "b30", "title": "Reducing Rank-Maximal to Maximum Weight Matching", "journal": "Theoretical Computer Science", "year": "2007", "authors": "D Michail"}, {"ref_id": "b31", "title": "Classified Rank-Maximal Matchings and Popular Matchings-Algorithms and Hardness", "journal": "Springer", "year": "2013", "authors": "M Nasre; P Nimbhorkar; N Pulath"}, {"ref_id": "b32", "title": "Two-sided Matching with Partial Information", "journal": "", "year": "2013", "authors": "B Rastegari; A Condon; N Immorlica; K Leyton-Brown"}, {"ref_id": "b33", "title": "On Sample Complexity Upper and Lower Bounds for Exact Ranking from Noisy Comparisons", "journal": "", "year": "2019", "authors": "W Ren; J K Liu; N Shroff"}, {"ref_id": "b34", "title": "Combinatorial Bandits with Relative Feedback", "journal": "", "year": "2019", "authors": "A Saha; A Gopalan"}, {"ref_id": "b35", "title": "From PAC to Instance-Optimal Sample Complexity in the Plackett-Luce Model", "journal": "PMLR", "year": "2020", "authors": "A Saha; A Gopalan"}, {"ref_id": "b36", "title": "On Cores and Indivisibility", "journal": "Journal of Mathematical Economics", "year": "1974", "authors": "L S Shapley; H Scarf"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 1 :1Figure 1: Exemplary run of Algorithm 2. The edges displayed are the edges in E at the end of each iteration. Vertices in black are in E, vertices in green are in O and vertices in red are in U. Edges in red are the edges added in each iteration and dashed edges are matched by M in each iteration(Of course other matchings would also be valid).", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 2 :2Figure2: Construction of Theorem 10 for k = 3 and special agent a 4 . The basic preferences for ranks 1 and 2 are shown on the left, with rank 1 edges in black and rank 2 edges in red and the edge of the special agent in blue. The matching on the right, is the rank-maximal matching.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "of second-choice agents A 2 consisting of n 2 3 agents, \u2022 and a set of special agents A of size n 2 3 .", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "a\u2208A (max(r a \u2212 1, 1)), 2|A | \u2212 1) Since our algorithm asks a\u2208A r a = h\u2208H a\u2208A h r a queries we get that the competitive ratio is at most h\u2208H a\u2208A h r a h\u2208H OPT(A h ) . By using the fact that for all a, b, c, d \u2208 R >0 it holds that", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "Any maximum matching only contains edges between U and U as well as between E and O. \u2022 Any maximum matching matches every vertex in U and in O. \u2022 The cardinality of a maximum matching is |O| + 1 2 |U|. \u2022 There is no edge between E and E as well as between E and U.", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_3", "figure_caption": "Algorithm 3: Elicitation algorithm for rank-maximal matchings in the hybrid-query model Input: Set of agents A, set of houses H. Output: A necessarily rank-maximal matching 1: U \u2190 A {set of unfinished agents} 2: V \u2190 H {set of available houses} 3: E \u2190 \u2205, M \u2190 \u2205, F \u2190 \u2205 4: if |A| = 2 then", "figure_data": "5:"}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_4", "figure_caption": "If an agenta \u2208 A is in U or O remove a from U \u2208 H is in U or O remove h from V", "figure_data": "and {a, h} / \u2208 F then11:E \u2190 E \u222a {{a, h}}12:end if13:end for14:augment M to be a maximum matching in (A\u222aH, E)15:if M matches no house of rank i then16:c \u2190 c + 117:end if18:if c \u2265 |V | then19:break for-loop20:end if21:compute Dulmage-Mendelsohn decompositionU, E, O for M22:23: If a house h 24: Add any edges between O, O and O, U to F and re-move them from E25: end for26: if U = \u2205 then27:for all h \u2208 V, a \u2208 U do28:query Q(a, h)29:end for30:compute rank-maximal matching M with completedpreferences31: end if32: return Ma necessarily rank-maximal matching exists and whether agiven matching M is necessarily rank-maximal."}], "formulas": [{"formula_id": "formula_0", "formula_text": "\u221a n) \u2020 O( \u221a n) \u2020 1 1 \u2126(n 1 3 ) O(n 1 3 +\u03b5 ) Rank-maximal 3 2 3 2 3 2 O(n) 3 2 6", "formula_coordinates": [2.0, 60.36, 68.39, 225.79, 31.11]}, {"formula_id": "formula_1", "formula_text": "For a, b \u2208 N let [a, b] = {a, a + 1, . . . , b} and [a] = [1, a].", "formula_coordinates": [2.0, 319.5, 292.93, 231.9, 9.3]}, {"formula_id": "formula_2", "formula_text": "M dominates M if \u2022 for every agent a i \u2208 A it holds that M (a i ) i M (a i ) or M (a i ) = M (a i ) ; \u2022 for at least one agent a i \u2208 A it holds that M (a i ) i M (a i ). Now, a matching M is Pareto optimal if there is no matching M which dominates M .", "formula_coordinates": [2.0, 319.5, 530.41, 238.5, 86.54]}, {"formula_id": "formula_3", "formula_text": "M l := |{a i \u2208 A | rank(a i , M (a i )) = l}| for any l \u2208 [n]", "formula_coordinates": [2.0, 324.0, 645.95, 230.5, 12.55]}, {"formula_id": "formula_4", "formula_text": "[n] such that r M k = r M k for all k \u2208 [l \u2212 1] and r M l < r M", "formula_coordinates": [2.0, 319.5, 669.45, 238.5, 25.76]}, {"formula_id": "formula_5", "formula_text": "a j if M (a i ), M (a j ) \u2208 rev(i) and rank (a i , M (a j )) < rank (a i , M (a i )); or if M (a i ) \u2208 rev(i), M (a j ) /", "formula_coordinates": [4.0, 54.0, 374.13, 238.5, 21.83]}, {"formula_id": "formula_6", "formula_text": "[n] agent \u03c3(i) has revealed at least min(rank (\u03c3(i), M (\u03c3(i))), n \u2212 i) of their preference list if M (\u03c3(i)) \u2208 rev(\u03c3(i)). If M (\u03c3(i)) / \u2208 rev(\u03c3(i)) the agent must have revealed at least n\u2212i houses.", "formula_coordinates": [4.0, 319.5, 599.22, 238.5, 41.61]}, {"formula_id": "formula_7", "formula_text": "7: if i = n cj then 8: if |M | \u2265 n \u2212 n (cj +1)/2 then 9:", "formula_coordinates": [5.0, 58.98, 192.7, 157.03, 33.61]}, {"formula_id": "formula_8", "formula_text": "j \u2190 j + 1, c j \u2190 (3c j\u22121 + 1)/2 + c 0 \u2212 1 12: end if 13: end if 14: end for 15: H \u2286 H \u2190 subset matched by M 16: A \u2286 A \u2190 subset matched by M 17: for all a \u2208 A \\ A do 18: h \u2190 arg min h\u2208H\\H Q(a, h) 19: M \u2190 M \u222a {{a, h}} 20: H \u2190 H \u222a {h} 21: end for", "formula_coordinates": [5.0, 54.5, 239.49, 213.44, 120.16]}, {"formula_id": "formula_9", "formula_text": "E 0 = \u2205, M 0 = \u2205, O 0 = \u2205 = U 0 and E 0 = A \u222a H. For each i = 1, . . . , n the algorithm", "formula_coordinates": [5.0, 319.5, 647.05, 238.5, 20.61]}, {"formula_id": "formula_10", "formula_text": "M i in G i = (A \u222a H, E i ) by augmenting M i\u22121 ;", "formula_coordinates": [5.0, 332.45, 684.24, 225.55, 20.61]}, {"formula_id": "formula_11", "formula_text": "1: U \u2190 A {set of unfinished agents} 2: V \u2190 H {set of available houses} 3: E \u2190 \u2205, M \u2190 \u2205, F \u2190 \u2205 4: if |A| = 2 then 5: let h 1 = Q(a 1 ), return {{a 1 , h 1 }, {a 2 , h 2 }} 6: end if 7: for i in 1, . . . n \u2212 1 do 8: for all a \u2208 U do 9: h \u2190 Q(a) 10: if h \u2208 V", "formula_coordinates": [6.0, 54.5, 105.0, 202.29, 107.52]}, {"formula_id": "formula_12", "formula_text": "U i , E i , O i for G i", "formula_coordinates": [6.0, 66.95, 392.79, 65.48, 9.65]}, {"formula_id": "formula_13", "formula_text": "a 1 : h 1 , h 4 , h 2 , h 3 , h 5 a 2 : h 1 , h 2 , h 3 , h 4 , h 5 a 3 : h 4 , h 1 , h 3 , h 2 , h 5 a 4 : h 4 , h 5 , h 3 , h 2 , h 1 a 4 : h 4 , h 5 , h 2 , h 3 , h 5 Preferences a 1 a 2 a 3 a 4 a 5 h 1 h 2 h 3 h 4 h 5 Iteration 1 a 1 a 2 a 3 a 4 a 5 h 1 h 2 h 3 h 4 h 5 Iteration 2 a 1 a 2 a 3 a 4 a 5 h 1 h 2 h 3 h 4 h 5 Iteration 3", "formula_coordinates": [6.0, 320.34, 60.56, 234.17, 907889.44]}, {"formula_id": "formula_14", "formula_text": "= a = a 1 , M (a 1 ), a 2 , . . . , M (a k\u22121 ), a k in G ra\u22121 from a to an un- matched agent a k . Since a k is unmatched in G ra\u22121 by M we know that rank(a k , M (a k )) > r a \u2212 1 in .", "formula_coordinates": [6.0, 319.5, 365.24, 238.5, 42.87]}, {"formula_id": "formula_15", "formula_text": "a 1 , M (a k ), a k , M (a k\u22121 ), a k\u22121 , . . . a 2 , M (a 1 )", "formula_coordinates": [6.0, 345.94, 527.29, 185.62, 9.65]}, {"formula_id": "formula_16", "formula_text": "(a i\u22121 )) \u2264 rank(a i\u22121 , M (a i\u22121 )), as well as rank(a 1 , M (a k )) \u2264 r a \u2212 1, while previously rank(a k , M (a k )) > r a \u2212 1.", "formula_coordinates": [6.0, 319.5, 556.29, 238.5, 31.57]}, {"formula_id": "formula_17", "formula_text": "a\u2208A (r a ) + n \u2212 1 a\u2208A (min(r a \u2212 1, 1)) \u2264 a\u2208A (r a + 1) a\u2208A (min(r a \u2212 1, 1)) .", "formula_coordinates": [7.0, 77.17, 295.17, 203.87, 25.38]}, {"formula_id": "formula_18", "formula_text": "of agent a 2i\u22121 is h 2i\u22121 h 2(i\u22121) \u2022 \u2022 \u2022 h 2k+1 and the basic preference of agent a 2i is h 2i\u22121 h 2i \u2022 \u2022 \u2022 h 2k+1", "formula_coordinates": [7.0, 54.0, 541.77, 238.5, 20.61]}, {"formula_id": "formula_19", "formula_text": "1 i ) = 1, rank (x 1 i , s 2 i ) = 2, rank (x 1 i , h 1 i ) = 4, rank (x 1 i , h 2 i ) = 5.", "formula_coordinates": [10.0, 66.95, 267.37, 225.55, 23.28]}, {"formula_id": "formula_20", "formula_text": "C 1 : h 1 h 2 h 3 h C d 1 \u2022 \u2022 \u2022 d 2 3 n C 2 : h 2 h 3 h 1 h C d 1 \u2022 \u2022 \u2022 d 2 3 n C 3 : h 3 h 1 h 2 h C d 1 \u2022 \u2022 \u2022 d 2 3 n", "formula_coordinates": [10.0, 81.9, 485.25, 178.72, 37.68]}, {"formula_id": "formula_21", "formula_text": "to 8n + 1 is d d h 1 1 h 1 1 s 1 1 \u2022 \u2022 \u2022 h 2 n s 1 n s 2 n d 1 \u2022 \u2022 \u2022 d 2 3 n .", "formula_coordinates": [10.0, 66.95, 568.6, 214.01, 27.99]}, {"formula_id": "formula_22", "formula_text": "\u21d0 Let M be an NPO matching. First, assume that M (a 1 d ) = d and M (a 1 d ) = d .", "formula_coordinates": [10.0, 319.5, 296.98, 238.49, 21.94]}, {"formula_id": "formula_23", "formula_text": "3c j + 1)/2 + c 0 \u2212 1 is increasing if c 0 > 1 3 .", "formula_coordinates": [11.0, 54.0, 682.93, 238.5, 23.86]}, {"formula_id": "formula_24", "formula_text": "c j+1 = 3c j + 1 2 + c 0 \u2212 1 = c j + c j + 1 2 + 1 3 + \u03b5 \u2212 1 \u2265 c j + 2 3 + 1 3 + \u03b5 \u2212 1 = c j + \u03b5.", "formula_coordinates": [11.0, 329.46, 82.75, 218.59, 46.29]}, {"formula_id": "formula_25", "formula_text": "min(rank(a, M (a)), n \u2212 \u03c3 \u22121 (a)) \u2265 1 2 n cj\u22121", "formula_coordinates": [11.0, 349.01, 611.86, 187.01, 22.31]}, {"formula_id": "formula_26", "formula_text": "\u2126 n (cj\u22121+1)/2 n cj\u22121 \u2208 \u2126 n (3cj\u22121+1)/2 queries. Since our algorithm uses O(nn cj + n (cj +1)/2 n (cj +1)/2 ) = O(n cj +1 ) = O(n 1+(3cj\u22121+1)/2+c0\u22121 ) = O(n (3cj\u22121+1)/2 n c0 )", "formula_coordinates": [11.0, 347.69, 691.63, 188.62, 10.81]}, {"formula_id": "formula_27", "formula_text": "n cj+1 \u2265 n cj +c0\u2212 1 3 \u2265 2n cj > n cj + 1.", "formula_coordinates": [12.0, 132.76, 187.48, 93.94, 26.06]}, {"formula_id": "formula_28", "formula_text": "1 3 ).", "formula_coordinates": [12.0, 216.81, 384.87, 11.45, 11.61]}, {"formula_id": "formula_29", "formula_text": "2 3", "formula_coordinates": [12.0, 552.92, 136.6, 3.39, 9.43]}, {"formula_id": "formula_30", "formula_text": "O(n + n 1 3 n 2 3 ) = O(n) queries, this shows that no algorithm can be o(n 1 3 )-competitive.", "formula_coordinates": [12.0, 319.5, 496.12, 238.5, 24.82]}, {"formula_id": "formula_31", "formula_text": "a\u2208A h r a OPT(A h ) \u2264 a\u2208A h r a max( a\u2208A h (max(r a \u2212 1, 1)), 2|A h | \u2212 1) \u2264 a\u2208A h r a a\u2208A h (max(r a \u2212 1, 1)) \u2264 a\u2208A h r a a\u2208A h r a \u2212 |A h | \u2264 a\u2208A h r a a\u2208A h r a \u2212 1 3 a\u2208A h r a = a\u2208A h r a 2 3 a\u2208A h r a = 3 2 .", "formula_coordinates": [13.0, 323.73, 77.0, 231.33, 87.61]}, {"formula_id": "formula_32", "formula_text": "a\u2208A h r a OPT(A h ) = a\u2208A h \\A 2 h r a + 2|A 2 h | OPT(A h \\ A 2 h ) + OPT(A 2 h ) \u2264 max( a\u2208A h \\A 2 h r a a\u2208A h \\A 2 h r a \u2212 |A h \\ A 2 h | , 2|A 2 h | 2|A 2 h | \u2212 1 ) \u2264 3 2 since we know that a\u2208A h \\A 2 h r a \u2265 3|A h \\A 2 h |. If, however |A 2 h | = 1", "formula_coordinates": [13.0, 319.5, 211.88, 238.5, 95.59]}, {"formula_id": "formula_33", "formula_text": "a\u2208A h r a max( a\u2208A h (max(r a \u2212 1, 1)), 2|A h | \u2212 1) \u2264 3|A h | \u2212 1 2|A h | \u2264 3 2 .", "formula_coordinates": [13.0, 352.62, 391.15, 173.46, 53.49]}, {"formula_id": "formula_34", "formula_text": "let h 1 = Q(a 1 , 1), return {{a 1 , h 1 }, {a 2 , h 2 }} 6: end if 7: for i in 1, . . . n \u2212 1 do 8: for all a \u2208 U do 9: h \u2190 Q(a, i) 10: if h \u2208 V", "formula_coordinates": [14.0, 320.0, 148.83, 211.7, 63.68]}, {"formula_id": "formula_35", "formula_text": "ALG a OPT a \u2264 r a r a \u2212 1 \u2264 2 1 = 2.", "formula_coordinates": [16.0, 124.54, 159.47, 111.57, 23.23]}, {"formula_id": "formula_36", "formula_text": "ALG a OPT a \u2264 i + |V | i \u2264 1 + |V | |V | = 2.", "formula_coordinates": [16.0, 110.32, 228.82, 140.01, 23.23]}, {"formula_id": "formula_37", "formula_text": "ALG a OPT a \u2264 i + |V | |V | + p a \u2212 1 = i + |V | i + |V | \u2212 1 \u2264 2.", "formula_coordinates": [16.0, 90.74, 543.71, 179.17, 23.22]}, {"formula_id": "formula_38", "formula_text": "ALG a OPT a \u2264 i + |V | (|V | \u2212 1) + (i \u2212 |V | \u2212 1) = i + |V | i \u2212 2 \u2264 6", "formula_coordinates": [16.0, 74.7, 625.02, 211.24, 23.23]}], "doi": ""}