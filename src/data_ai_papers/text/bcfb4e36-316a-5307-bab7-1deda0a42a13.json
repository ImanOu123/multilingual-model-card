{"title": "SPLATNet: Sparse Lattice Networks for Point Cloud Processing", "authors": "Hang Su; Subhransu Maji; Evangelos Kalogerakis; Ming-Hsuan Yang; Jan Kautz", "pub_date": "2018-05-09", "abstract": "We present a network architecture for processing point clouds that directly operates on a collection of points represented as a sparse set of samples in a high-dimensional lattice. Na\u00efvely applying convolutions on this lattice scales poorly, both in terms of memory and computational cost, as the size of the lattice increases. Instead, our network uses sparse bilateral convolutional layers as building blocks. These layers maintain efficiency by using indexing structures to apply convolutions only on occupied parts of the lattice, and allow flexible specifications of the lattice structure enabling hierarchical and spatially-aware feature learning, as well as joint 2D-3D reasoning. Both point-based and image-based representations can be easily incorporated in a network with such layers and the resulting model can be trained in an end-to-end manner. We present results on 3D segmentation tasks where our approach outperforms existing state-of-the-art techniques.", "sections": [{"heading": "Introduction", "text": "Data obtained with modern 3D sensors such as laser scanners is predominantly in the irregular format of point clouds or meshes. Analysis of point clouds has several useful applications such as robot manipulation and autonomous driving. In this work, we aim to develop a new neural network architecture for point cloud processing.\nA point cloud consists of a sparse and unordered set of 3D points. These properties of point clouds make it difficult to use traditional convolutional neural network (CNN) architectures for point cloud processing. As a result, existing approaches that directly operate on point clouds are dominated by hand-crafted features. One way to use CNNs for point clouds is by first pre-processing a given point cloud in a form that is amenable to standard spatial convolutions. Following this route, most deep architectures for 3D point cloud analysis require pre-processing of irregular point clouds into either voxel representations (e.g., [45,37,44]) or 2D images by view projection (e.g., [41,34,24,9]).", "publication_ref": ["b44", "b36", "b43", "b40", "b33", "b23", "b8"], "figure_ref": [], "table_ref": []}, {"heading": "SPLATNet 3D", "text": "SPLATNet 2D-3D ...  SPLATNet 3D directly takes point cloud as input and predicts labels for each point. SPLATNet 2D-3D , on the other hand, jointly processes both point cloud and the corresponding multi-view images for better 2D and 3D predictions. This is due to the ease of implementing convolution operations on regular 2D or 3D grids. However, transforming point cloud representation to either 2D images or 3D voxels would often result in artifacts and more importantly, a loss in some natural invariances present in point clouds.\nRecently, a few network architectures [33,35,48] have been developed to directly work on point clouds. One of the main drawbacks of these architectures is that they do not allow a flexible specification of the extent of spatial connectivity across points (filter neighborhood). Both [33] and [35] use max-pooling to aggregate information across points either globally [33] or in a hierarchical manner [35]. This pooling aggregation may lose surface information because the spatial layouts of points are not explicitly considered. It is desirable to capture spatial relationships in point clouds through more general convolution operations while being able to specify filter extents in a flexible manner.\nIn this work, we propose a generic and flexible neural network architecture for processing point clouds that alleviates some of the aforementioned issues with existing deep architectures. Our key observation is that the bilateral convolution layers (BCLs) proposed in [22,25] have several favorable properties for point cloud processing. BCL provides a systematic way of filtering unordered points while enabling flexible specifications of the underlying lattice structure on which the convolution operates. BCL smoothly maps input points onto a sparse lattice, performs convolutions on the sparse lattice and then smoothly interpolates the filtered signal back onto the original input points. With BCLs as building blocks, we propose a new neural network architecture, which we refer to as SPLATNet (SParse LATtice Networks), that does hierarchical and spatially-aware feature learning for unordered points. SPLATNet has several advantages for point cloud processing:\n\u2022 SPLATNet takes the point cloud as input and does not require any pre-processing to voxels or images.\n\u2022 SPLATNet allows an easy specification of filter neighborhood as in standard CNN architectures.\n\u2022 With the use of hash table, our network can efficiently deal with sparsity in the input point cloud by convolving only at locations where data is present.\n\u2022 SPLATNet computes hierarchical and spatially-aware features of an input point cloud with sparse and efficient lattice filters.\n\u2022 In addition, our network architecture allows an easy mapping of 2D points into 3D space and vice-versa.\nFollowing this, we propose a joint 2D-3D deep architecture that processes both the multi-view 2D images and the corresponding 3D point cloud in a single forward pass while being end-to-end learnable.\nThe inputs and outputs of two versions of the proposed network, SPLATNet 3D and SPLATNet 2D-3D , are depicted in Figure 1. We demonstrate the above advantages with experiments on point cloud segmentation. Experiments on both RueMonge2014 facade segmentation [38] and ShapeNet part segmentation [46] demonstrate the superior performance of our technique compared to state-of-the-art techniques, while being computationally efficient.", "publication_ref": ["b32", "b34", "b47", "b32", "b34", "b32", "b34", "b21", "b24", "b37", "b45"], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "Related Work", "text": "Below we briefly review existing deep learning approaches for 3D shape processing and explain differences with our work.\nMulti-view and voxel networks. Multi-view networks pre-process shapes into a set of 2D rendered images encoding surface depth and normals under various 2D projections [41,34,3,24,9,20]. These networks take advantage of high resolution in the input rendered images and transfer learning through fine-tuning of 2D pre-trained image-based architectures. On the other hand, 2D projections can cause surface information loss due to self-occlusions, while viewpoint selection is often performed through heuristics that are not necessarily optimal for a given task.\nVoxel-based methods convert the input 3D shape representation into a 3D volumetric grid. Early voxel-based architectures executed convolution in regular, fixed voxel grids, and were limited to low shape resolutions due to high memory and computation costs [45,30,34,6,15,39]. Instead of using fixed grids, more recent approaches preprocess the input shapes into adaptively subdivided, hierarchical grids with denser cells placed near the surface [37,36,27,44,42]. As a result, they have much lower computational and memory overhead. On the other hand, convolutions are often still executed away from the surface, where most of the shape information resides. An alternative approach is to constrain the execution of volumetric convolutions only along the input sparse set of active voxels of the grid [16]. Our approach generalizes this idea to highdimensional permutohedral lattice convolutions. In contrast to previous work, we do not require pre-processing points into voxels that may cause discretization artifacts and surface information loss. We smoothly map the input surface signal to our sparse lattice, perform convolutions over this lattice, and smoothly interpolate the filter responses back to the input surface. In addition, our architecture can easily incorporate feature representations originating from both 3D point clouds and rendered images within the same lattice, getting the best of both worlds.\nPoint cloud networks. Qi et al. [33] pioneered another type of deep networks having the advantage of directly operating on point clouds. The networks learn spatial feature representations for each input point, then the point features are aggregated across the whole point set [33], or hierarchical surface regions [35] through max-pooling. This aggregation may lose surface information since the spatial layout of points is not explicitly considered. In our case, the input points are mapped to a sparse lattice where convolution can be efficiently formulated and spatial relationships in the input data can be effectively captured through flexible filters.\nNon-Euclidean networks. An alternative approach is to represent the input surface as a graph (e.g., a polygon mesh or point-based connectivity graph), convert the graph into its spectral representation, then perform convolution in the spectral domain [8,19,11,4]. However, structurally different shapes tend to have largely different spectral bases, and thus lead to poor generalization. Yi et al. [47] proposed aligning shape basis functions through a spectral transformer, which, however, requires a robust initialization scheme. Another class of methods embeds the input shapes into 2D parametric domains and then execute convolutions within these domains [40,28,13]. However, these embeddings can suffer from spatial distortions or require topologically consistent input shapes. Other methods parameterize the surface into local patches and execute surface-based convolution within these patches [29,5,31]. Such non-Euclidean networks have the advantage of being invariant to surface deformations, yet this invariance might not al- ways be desirable in man-made object segmentation and classification tasks where large deformations may change the underlying shape or part functionalities and semantics. We refer to Bronstein et al. [7] for an excellent review of spectral, patch-and graph-based methods.\nJoint 2D-3D networks. FusionNet [18] combines shape classification scores from a volumetric and a multi-view network, yet this fusion happens at a late stage, after the final fully connected layer of these networks, and does not jointly consider their intermediate local and global feature representations. In our case, the 2D and 3D feature representations are mapped onto the same lattice, enabling endto-end learning from both types of input representations.", "publication_ref": ["b40", "b33", "b2", "b23", "b8", "b19", "b44", "b29", "b33", "b5", "b14", "b38", "b36", "b35", "b26", "b43", "b41", "b15", "b32", "b32", "b34", "b7", "b18", "b10", "b3", "b46", "b39", "b27", "b12", "b28", "b4", "b30", "b6", "b17"], "figure_ref": [], "table_ref": []}, {"heading": "Bilateral Convolution Layer", "text": "In this section, we briefly review the Bilateral Convolution Layer (BCL) that forms the basic building block of our SPLATNet architecture for point clouds. BCL provides a way to incorporate sparse high-dimensional filtering inside neural networks. In [22,25], BCL was proposed as a learnable generalization of bilateral filtering [43,2], hence the name 'Bilateral Convolution Layer'. Bilateral filtering involves a projection of a given 2D image into a higher-dimensional space (e.g., space defined by position and color) and is traditionally limited to hand-designed filter kernels. BCL provides a way to learn filter kernels in high-dimensional spaces for bilateral filtering. BCL is also shown to be useful for information propagation across video frames [21]. We observe that BCL has several favorable properties to filter data that is inherently sparse and highdimensional, like point clouds. Here, we briefly describe how a BCL works and then discuss its properties.", "publication_ref": ["b21", "b24", "b42", "b1", "b20"], "figure_ref": [], "table_ref": []}, {"heading": "Inputs to BCL", "text": "Let F \u2208 R n\u00d7d f be the given input features to a BCL, where n denotes the number of input points and d f denotes the dimensionality of input features at each point. For 3D point clouds, input features can be low-level features such as color, position, etc., and can also be high-level features such as features generated by a neural network.\nOne of the interesting characteristics of BCL is that it allows a flexible specification of the lattice space in which the convolution operates. This is specified as lattice features at each input point. Let L \u2208 R n\u00d7d l denote lattice features at input points with d l denoting the dimensionality of the feature space in which convolution operates. For instance, the lattice features can be point position and color (XY ZRGB) that define a 6-dimensional filtering space for BCL. For standard 3D spatial filtering of point clouds, L is given as the position (XY Z) of each point. Thus BCL takes input features F and lattice features L of input points and performs d l -dimensional filtering of the points.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Processing steps in BCL", "text": "As illustrated in Figure 2, BCL has three processing steps, splat, convolve and slice, that work as follows.\nSplat. BCL first projects the input features F onto the d ldimensional lattice defined by the lattice features L, via barycentric interpolation. Following [1], BCL uses a permutohedral lattice instead of a standard Euclidean grid for efficiency purposes. The size of lattice simplices or space between the grid points is controlled by scaling the lattice features \u039bL, where \u039b is a diagonal d l \u00d7 d l scaling matrix.\nConvolve. Once the input points are projected onto the d ldimensional lattice, BCL performs d l -dimensional convolution on the splatted signal with learnable filter kernels. Just like in standard spatial CNNs, BCL allows an easy specification of filter neighborhood in the d l -dimensional space.\nSlice. The filtered signal is then mapped back to the input points via barycentric interpolation. The resulting signal can be passed on to other BCLs for further processing. This step is called 'slicing'. BCL allows slicing the filtered signal onto a different set of points other than the input points. This is achieved by specifying a different set of lattice features L out \u2208 R m\u00d7d l at m output points of interest.\nAll the above three processing steps in BCL can be written as matrix multiplications:\nF c = S slice B conv S splat F c ,(1)\nwhere F c denotes the c th column/channel of the input feature F andF c denotes the corresponding filtered signal.", "publication_ref": ["b0"], "figure_ref": ["fig_2"], "table_ref": []}, {"heading": "Properties of BCL", "text": "There are several properties of BCL that makes it particularly convenient for point cloud processing. Here, we mention some of those properties:\n\u2022 The input points to BCL need not be ordered or lie on a grid as they are projected onto a d l -dimensional grid defined by lattice features L in .\n... \u2022 The input and output points can be different for BCL with the specification of different input and output lattice features L in and L out .\n+ SPLATNet 3D CNN 1 + BCL L 3D | \u039b 0 /2 T-1 BCL L 3D | \u039b 0 /2 BCL L 3D | \u039b 0 1\u2a091 CONV 1\u2a091 CONV 1\u2a091 CONV CNN 2 SPLATNet 2D-3D ... ... 1\u2a091 CONV Input point cloud Input images 3D predictions (SPLATNet 3D ) 3D predictions (SPLATNet 2D-3D ) 2D predictions (SPLATNet 2D-3D ) BCL ss L 2D , L 3D | \u039b a 2D\u279d3D 2D-3D Fusion + BCL ss L 3D , L 2D | \u039b b 3D\u279d2D 1\u2a091 CONV\n\u2022 Since BCL allows separate specifications of input and lattice features, input signals can be projected into a different dimensional space for filtering. For instance, a 2D image can be projected into 3D space for filtering.\n\u2022 Just like in standard spatial convolutions, BCL allows an easy specification of filter neighborhood.\n\u2022 Since a signal is usually sparse in high-dimension, BCL uses hash tables to index the populated vertices and does convolutions only at those locations. This helps in efficient processing of sparse inputs.\nRefer to [1] for more information about sparse highdimensional Gaussian filtering on a permutohedral lattice and refer to [22] for more details on BCL.", "publication_ref": ["b0", "b21"], "figure_ref": [], "table_ref": []}, {"heading": "SPLATNet 3D for Point Cloud Processing", "text": "We first introduce SPLATNet 3D , an instantiation of our proposed network architecture which operates directly on 3D point clouds and is readily applicable to many important 3D tasks. The input to SPLATNet 3D is a 3D point cloud P \u2208 R n\u00d7d , where n denotes the number of points and d \u2265 3 denotes the number of feature dimensions including point locations XY Z. Additional features are often available either directly from 3D sensors or through preprocessing. These can be RGB color, surface normal, curvature, etc. at the input points. Note that input features F of the first BCL and lattice features L in the network each comprises a subset of the d feature dimensions:\nd f \u2264 d, d l \u2264 d.\nAs output, SPLATNet 3D produces per-point predictions. Tasks like 3D semantic segmentation and 3D object part labeling fit naturally under this framework. With simple techniques such as global pooling [33], SPLATNet 3D can be modified to produce a single output vector and thus can be extended to other tasks such as classification.\nNetwork architecture. The architecture of SPLATNet 3D is depicted in Figure 3. The network starts with a single 1 \u00d7 1 CONV layer followed by a series of BCLs. The 1 \u00d7 1 CONV layer processes each input point separately without any data aggregation. The functionality of BCLs is already explained in Section 3. For SPLATNet 3D , we use T BCLs each operating on a 3D lattice (d l = 3) constructed using 3D point locations XY Z as lattice features, L in = L out \u2208 R n\u00d73 . We note that different BCLs can use different lattice scales \u039b. Recall from Section 3 that \u039b is a diagonal matrix that controls the spacing between the grid points in the lattice. For BCLs in SPLATNet 3D , we use the same lattice scales along each of the X, Y and Z directions, i.e., \u039b = \u03bbI 3 , where \u03bb is a scalar and I 3 denotes a 3 \u00d7 3 identity matrix. We start with an initial lattice scale \u03bb 0 for the first BCL and subsequently divide the lattice scale by a factor of 2 (\u03bb t = \u03bb t\u22121 /2) for the next T \u2212 1 BCLs. In other words, SPLATNet 3D with T BCLs use the following lattice scales: (\u039b 0 , \u039b 0 /2, . . . , \u039b 0 /2 T \u22121 ). Lower lattice scales imply coarser lattices and larger receptive fields for the filters. Thus, in SPLATNet 3D , deeper BCLs have longerrange connectivity between input points compared to earlier layers. We will discuss more about the effects of different lattice spaces and their scales later. Like in standard CNNs, SPLATNet allows an easy specification of filter neighborhoods. For all the BCLs, we use filters operating on onering neighborhoods and refer to the supp. material for details on the number of filters per layer.\nThe responses of the T BCLs are concatenated and then passed through two additional 1 \u00d7 1 CONV layers. Finally, a softmax layer produces point-wise class label probabilities. The concatenation operation aggregates information from BCLs operating at different lattice scales. Similar techniques of concatenating outputs from network layers at different depths have been useful in 2D CNNs [17]. All parameterized layers, except for the last CONV layer, are followed by ReLU and BatchNorm. More details about the network architecture are given in the supp. material.\nLattice spaces and their scales. The use of BCLs in SPLATNet allows easy specifications of lattice spaces via lattice features and also lattice scales via a scaling matrix.\nChanging the lattice scales \u039b directly affects the resolution of the signal on which the convolution operates. This gives us direct control over the receptive fields of network layers. Figure 4 shows lattice cell visualizations for different lattice spaces and scales. Using coarser lattice can increase the effective receptive field of a filter. Another way to increase the receptive field of a filter is by increasing its neighborhood size. But, in high-dimensions, this will significantly increase the number of filter parameters. For instance, 3D filters of size 3, 5, 7 on a regular Euclidean grid have 3 3 = 27, 5 3 = 125, 7 3 = 343 parameters respectively. On the other hand, making the lattice coarser would not increase the number of filter parameters leading to more computationally efficient network architectures.\nWe observe that it is beneficial to use finer lattices (larger lattice scales) earlier in the network, and then coarser lattices (smaller lattice scales) going deeper. This is consistent with the common knowledge in 2D CNNs: increasing receptive field gradually through the network can help build hierarchical representations with varying spatial extents and abstraction levels.\nAlthough we mainly experiment with XY Z lattices in this work, BCL allows for other lattice spaces such as position and color space (XY ZRGB) or normal space. Using different lattice spaces enforces different connectivity across input points that may be beneficial to the task. In one of the experiments, we experimented with a variant of SPLATNet 3D , where we add an extra BCL with position and normal lattice features (XY Zn x n y n z ) and observed minor performance improvements.  ", "publication_ref": ["b32", "b16"], "figure_ref": ["fig_3", "fig_5"], "table_ref": []}, {"heading": "Joint 2D-3D Processing with SPLATNet 2D-3D", "text": "Oftentimes, 3D point clouds are accompanied by 2D images of the same target. For instance, many modern 3D sensors capture RGBD streams and perform 3D reconstruction to obtain 3D point clouds, resulting in both 2D images and point clouds of a scene together with point correspondences between 2D and 3D. One could also easily sample point clouds along with 2D renderings from a given 3D mesh. When such aligned 2D-3D data is present, SPLATNet provides an extremely flexible framework for joint processing. We propose SPLATNet 2D-3D , another SPLATNet instantiation designed for such joint processing.\nThe network architecture of the SPLATNet 2D-3D is depicted in the green box of Figure 3. SPLATNet 2D-3D encompasses SPLATNet 3D as one of its components and adds extra computational modules for joint 2D-3D processing. Next, we explain each of these extra components of SPLATNet 2D-3D , in the order of their computations. CNN 1 . First, we process the given multi-view 2D images using a 2D segmentation CNN, which we refer to as CNN 1 .\nIn our experiments, we use the DeepLab [10] architecture for CNN 1 and initialize the network weights with those pretrained on PASCAL VOC segmentation [12]. BCL 2D\u21923D . CNN 1 outputs features of the image pixels, whose 3D locations often do not exactly correspond to points in the 3D point cloud. We project information from the pixels onto the point cloud using a BCL with only splat and slice operations. As mentioned in Section 3, one of the interesting properties of BCL is that it allows for different input and output points by separate specifications of input and output lattice features, L in and L out . Using this property, we use BCL to splat 2D features onto the 3D lattice space and then slice the 3D splatted signal on the point cloud. We refer to this BCL, without a convolution operation, as BCL 2D\u21923D as illustrated in Figure 5. Specifically, we use 3D locations of the image pixels as input lattice features, L in = L 2D \u2208 R m\u00d73 , where m denotes the number of input image pixels. In addition, we use 3D locations of points in the point cloud as output lattice features, L out = L 3D \u2208 R n\u00d73 , which are the same lattice features used in SPLATNet 3D . The lattice scale, \u039b a , controls the smoothness of the projection and can be adjusted according to the sparsity of the point cloud.\n2D-3D Fusion. At this point, we have the result of CNN 1 projected onto 3D points and also the intermediate features from SPLATNet 3D that exclusively operates on the input point cloud. Since both of these signals are embedded in the same 3D space, we concatenate these two signals and then use a series of 1 \u00d7 1 CONV layers for further processing. The output of the '2D-3D Fusion' module is passed on to a softmax layer to compute class probabilities at each input point of the point cloud. Given input features of 2D images, pixels are projected onto a 3D permutohedral lattice defined by 3D positional lattice features. The splatted signal is then sliced onto the points of interest in a 3D point cloud.\nBCL 3D\u21922D . Sometimes, we are also interested in segmenting 2D images and want to leverage relevant 3D information for better 2D segmentation. For this purpose, we back-project the 3D features computed by the '2D-3D Fusion' module onto the 2D images by a BCL 2D\u21923D module. This is the reverse operation of BCL 2D\u21923D , where the input and output lattice features are swapped. Similarly, a hyperparameter \u039b b controls the smoothness of the projection.\nCNN 2 .\nWe then concatenate the output from CNN 1 , input images and the output of BCL 3D\u21922D , and pass them through another 2D CNN, CNN 2 , to obtain refined 2D semantic predictions. In our experiments, we find that a simple 2-layered network is good enough for this purpose. All components in this 2D-3D joint processing framework are differentiable, and can be trained end-to-end. Depending on the availability of 2D or 3D ground-truth labels, loss functions can be defined on either one of the two domains, or on both domains in a multi-task learning setting. More details of the network architecture are provided in the supp. material. We believe that this joint processing capability offered by SPLATNet 2D-3D can result in better predictions for both 2D images and 3D point clouds. For 2D images, leveraging 3D features helps in view-consistent predictions across multiple viewpoints. For point clouds, incorporating 2D CNNs help leverage powerful 2D deep CNN features computed on high-resolution images.", "publication_ref": ["b9", "b11"], "figure_ref": ["fig_3", "fig_6"], "table_ref": []}, {"heading": "Experiments", "text": "We evaluate SPLATNet on tasks on two different benchmark datasets of RueMonge2014 [38] and ShapeNet [46]. On RueMonge2014, we conducted experiments on the tasks of 3D point cloud labeling and multi-view image labeling. On ShapeNet, we evaluated SPLATNet on 3D part segmentation. We use Caffe [23] neural network framework for all the experiments. Full code and trained models are publicly available on our project website 1 . ", "publication_ref": ["b37", "b45", "b22"], "figure_ref": [], "table_ref": []}, {"heading": "RueMonge2014 facade segmentation", "text": "Here, the task is to assign semantic label to every point in a point cloud and/or corresponding multi-view 2D images.\nDataset. RueMonge2014 [38] provides a standard benchmark for 2D and 3D facade segmentation and also inverse procedural modeling. The dataset consists of 428 highresolution and multi-view images obtained from a street in Paris. A point cloud with approximately 1M points is reconstructed using the multi-view images. A ground-truth labeling with seven semantic classes of door, shop, balcony, window, wall, sky and roof are provided for both 2D images and the point cloud. Sample point cloud sections and 2D images with their corresponding ground truths are shown in Figure 6 and 7 respectively. For evaluation, Intersection over Union (IoU) score is computed for each of the seven classes and then averaged to get a single overall IoU.\nPoint cloud labeling. We use our SPLATNet 3D architecture for the task of point cloud labeling on this dataset. We use 5 BCLs followed by a couple of 1 \u00d7 1 CONV layers. Input features to the network comprise of a 7-dimensional vector at each point representing RGB color, normal and height above the ground. For all the BCLs, we use XY Z lattice space (L 3D ) with \u039b 0 = 64I 3 . Experimental results with average IoU and runtime are shown in Table 1a. Results show that, with only 3D data, our method achieves an IoU of 65.4 which is a considerable improvement (6.2 IoU \u2191) over the state-of-the-art deep network, OctNet [37].\nSince this dataset comes with multi-view 2D images, one could leverage the information present in 2D data for better point cloud labeling. We use SPLATNet 2D-3D to leverage 2D information and obtain better 3D segmentations. Table 1a shows the experimental results when using both the 2D and 3D data as input. SPLATNet 2D-3D obtains an average IoU of 69.8 outperforming the previous state-of-the-art by a large margin (6.9 IoU \u2191), thereby setting up a new stateof-the-art on this dataset. This is also a significant improvement from the IoU obtained with SPLATNet 3D demonstrating the benefit of leveraging 2D and 3D information in a joint framework. Runtimes in Table 1a also indicate that our SPLATNet approach is much faster compared to traditional Autocontext techniques. Sample visual results for 3D facade labeling are shown in Figure 6.\nMulti-view image labeling. As illustrated in Section 5, we extend 2D CNNs with SPLATNet 2D-3D to obtain better multi-view image segmentation. Table 1b shows the results of multi-view image labeling on this dataset using different techniques. Using DeepLab (CNN 1 ) already outperforms existing state-of-the-art by a large margin. Leveraging 3D information via SPLATNet 2D-3D boosts the performance to 70. 6 IoU. An increase of 1.3 IoU from only using CNN 1 demonstrates the potential of our joint 2D-3D framework in leveraging 3D information for better 2D segmentation.", "publication_ref": ["b37", "b36", "b5"], "figure_ref": ["fig_7", "fig_7"], "table_ref": ["tab_0", "tab_0", "tab_0", "tab_0"]}, {"heading": "ShapeNet part segmentation", "text": "The task of part segmentation is to assign a part category label to each point in a point cloud representing a 3D object.\nDataset. The ShapeNet Part dataset [46] is a subset of ShapeNet, which contains 16681 objects from 16 categories, each with 2-6 part labels. The objects are consistently aligned and scaled to fit into a unit cube, and the ground-truth annotations are provided on sampled points on the shape surfaces. It is common to assume that the category of the input 3D object is known, narrowing the possible part labels to the ones specific to the given object category. We report standard IoU scores for evaluation of part segmentation. An IoU score is computed for each object and then averaged within the objects in a category to compute mean", "publication_ref": ["b45"], "figure_ref": [], "table_ref": []}, {"heading": "Input", "text": "Ground truth SPLATNet2D-3D IoU (mIoU) for each object category. In addition to reporting mIoU score for each object category, we also report 'class average mIoU' which is the average mIoU across all object categories, and also 'instance average mIoU', which is the average mIoU across all objects.\n3D part segmentation. We evaluate both SPLATNet 3D and SPLATNet 2D-3D for this task. First, we discuss the architecture and results with SPLATNet 3D that uses only 3D point clouds as input. Since the category of the input object is assumed to be known, we train separate networks for each object category. SPLATNet 3D network architecture for this taks is also composed of 5 BCLs. Point locations XY Z are used as input features as well as lattice features L for all the BCLs and the lattice scale for the first BCL layer is \u039b 0 = 64I 3 . Experimental results are shown in Table 2. SPLATNet 3D obtains a class average mIoU of 82.0 and an instance average mIoU of 84.6, which is on-par with the best networks that only take point clouds as input (Point-  Net++ [35] uses surface normals as additional inputs). We also adopt our SPLATNet 2D-3D network, which operates on both 2D and 3D data, for this task. For the joint framework to work, we need rendered 2D views and corresponding 3D locations for each pixel in the renderings. We first render 3-channel images: Phong shading [32], depth, and height from ground. Cameras are placed on the 20 vertices of a dodecahedron from a fixed distance, pointing towards the object's center. The 2D-3D correspondences can be generated by carrying the XY Z coordinates of 3D points into the rendering rasterization pipeline so that each pixel also acquires coordinate values from the surface point projected onto it. Results in Table 2 show that incorporating 2D information allows SPLATNet 2D-3D to improve noticeably from SPLATNet 3D with 1.7 and 0.8 increase in class and instance average mIoU respectively. SPLATNet 2D-3D obtains a class average IoU of 83.7 and an instance average IoU of 85.4, outperforming existing state-of-the-art approaches.\nOn one Nvidia GeForce GTX 1080 Ti, SPLATNet 3D runs at 9.4 shapes/sec, while SPLATNet 2D-3D is slower at 0.4 shapes/sec due to a relatively large 2D network operat-ing on 20 high-resolution (512 \u00d7 512) views, which takes up more than 95% of the computation time. In comparison, PointNet++ runs at 2.7 shapes/sec on the same hardware 2 .\nSix-dimensional filtering. We experiment with a variant of SPLATNet 3D where an additional BCL with 6-dimensional position and normal lattice features (XY Zn x n y n z ) is added between the last two 1 \u00d7 1 CONV layers. This modification gave only a marginal improvement of 0.2 IoU over standard SPLATNet 3D in terms of both class and instance average mIoU scores.", "publication_ref": ["b34", "b31"], "figure_ref": [], "table_ref": ["tab_1", "tab_1"]}, {"heading": "Conclusion", "text": "In this work, we propose the SPLATNet architecture for point cloud processing. SPLATNet directly takes point clouds as input and computes hierarchical and spatiallyaware features with sparse and efficient lattice filters. In addition, SPLATNet allows an easy mapping of 2D information into 3D and vice-versa, resulting in a novel network architecture for joint processing of point clouds and multi-view images. Experiments on two different benchmark datasets show that the proposed networks compare favorably against state-of-the-art approaches for segmentation tasks. In the future, we would like to explore the use of additional input features (e.g., texture) and also the use of other high-dimensional lattice spaces in our networks.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "", "text": "Acknowledgements Maji acknowledges support from NSF (Grant No. 1617917). Kalogerakis acknowledges support from NSF (Grant No. 1422441 and 1617333). Yang acknowledges support from NSF (Grant No. 1149783). We acknowledge the MassTech Collaborative grant for funding the UMass GPU cluster.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Supplementary", "text": "In this supplementary material, we provide additional details and explanations to help readers gain a better understanding of our technique.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "A. Point Cloud Density Normalization", "text": "BCL has a normalization scheme to deal with uneven point density, or more specifically, the fact that some lattice vertices are supported by more data points than others. Input signals are filtered directly with the learnable filter kernels, and are also filtered in a separate second round with their values replaced by 1s with a Gaussian kernel. The filter responses in the second round are then used for normalizing responses from the first round. This is similar to using homogeneous coordinates, which are widely adopted in bilateral filtering implementations such as [1].", "publication_ref": ["b0"], "figure_ref": [], "table_ref": []}, {"heading": "B. RueMonge2014 Facade Segmentation", "text": "Network architecture of SPLATNet 3D . We use 5 BCLs (T = 5) followed by 2 1 \u00d7 1 CONV layers in SPLATNet 3D for the facade segmentation task. We omit the initial 1 \u00d7 1 CONV layer since we find it has no effect on the overall performance. The number of output channels in each layer are: B64-B128-B128-B128-B64-C64-C7. Note that although written as a linear structure, the network has skip connections from all BCLs (layers start with 'B') to the penultimate 1 \u00d7 1 CONV layer. We use an initial scale \u039b 0 = 32I 3 for scaling lattice features XY Z, and divide the scale in half after each BCL:\nThe unit of raw input features XY Z is meter, with Y (aligned with gravity axis) having a range of 7.1 meters. For all the BCLs, we use filters operating on one-ring neighborhoods on the lattice.\nNetwork architecture of SPLATNet 2D-3D . We use SPLATNet 3D as described above as the 3D component of our 2D-3D joint model. The '2D-3D Fusion' component has 2 1\u00d71 CONV layers: C64-C7. DeepLab [10] segmentation architecture is used as CNN 1 . CNN 2 is a small network with 2 CONV layers: C32-C7, where the first layer has 3 \u00d7 3 filters and 32 output channels, and the second one has 1 \u00d7 1 filters and 7 output channels. We use \u039b a = 64 and \u039b b = 1000 for 2D\u21943D projections with BCLs. Note that the dataset provides one-to-many mappings from 3D points to pixels. By using a very large scale (i.e., \u039b b = 1000), 3D unaries are directly mapped to the corresponding 2D pixel locations without any interpolation.\nTraining. We randomly sample facade segments of 60k points and use a batch size of 4 when training SPLATNet 3D . CNN 1 is initialized with Pascal VOC [12] pre-trained weights and fine-tuned for 2D facade segmentation. Adam optimizer [26] with an initial learning rate of 0.0001 is used for training both SPLATNet 3D and SPLATNet 2D-3D . Since the training data is small, we augment point cloud training data with random rotations, translations, and small color perturbations. We also augment 2D image data with small color perturbations during training.", "publication_ref": ["b9", "b11", "b25"], "figure_ref": [], "table_ref": []}, {"heading": "C. ShapeNet Part Segmentation", "text": "Network architecture of SPLATNet 3D . We use a 1 \u00d7 1 CONV layer in the beginning, followed by 5 BCLs (T = 5), and then 2 1 \u00d7 1 CONV layers in SPLATNet 3D for the ShapeNet part segmentation task. The number of output channels in each layer are: C32-B64-B128-B256-B256-B256-C128-Cx. 'x' in the last CONV layer denotes the number of part categories, and ranges from 2-6 for different object categories. We use an initial scale \u039b 0 = 64I 3 for scaling lattice features XY Z, and divide the scale in half after each BCL:\nNetwork architecture of SPLATNet 2D-3D . We use SPLATNet 3D as described above as the 3D component of the joint model. The '2D-3D Fusion' component has 2 1\u00d71 CONV layers: C128-Cx. The same DeepLab architecture is used for CNN 1 . We use \u039b a = 32 in BCL 2D\u21923D . Since 2D prediction is not needed, CNN 2 and BCL 3D\u21922D are omitted.\nTraining. We train separate models for each object category. CNN 1 is initialized the same way as in the facade experiment. Adam optimizer with an initial learning rate of 0.0001 is used. We augment point cloud data with random rotations, translations, and scalings during training.\nWe train our networks until validation loss plateaus. Training SPLATNet 3D and SPLATNet 2D-3D take about 2.5 and 3 days respectively. With default settings, training PointNet++ takes 3.5 days on the same hardware. Dataset labeling issues. We observed a few types of labeling issues in the ShapeNet Part dataset:\n\u2022 Some object part categories are frequently labeled incorrectly. E.g., skateboard axles are often mistakenly labeled as 'deck' or 'wheel' (Figure 9a).\n\u2022 Some object parts, e.g. 'fin' of some rockets, have incomplete range or coverage (Figure 9b).\n\u2022 Some object part categories are labeled inconsistently between shapes. E.g., airplane landing gears are seen labeled as 'body', 'engine', or 'wings' (Figure 9c).\n\u2022 Some categories have parts that are labeled as 'other', which can be confusing for the classifier as these parts do not have clear semantic meanings or structures. E.g., in the case of earphones, anything that is not 'headband' or 'earphone' are given the same label ('other') (Figure 9d). Our predictions appear to be more accurate than the ground truth in some cases (see the skateboard axles in 9a and the rocket fins in 9b).\nThe first two issues make evaluations and comparisons on the benchmark less reliable, while the other two make learning ill-posed or unnecessarily hard for the networks.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Fast high-dimensional filtering using the permutohedral lattice", "journal": "Computer Graphics Forum", "year": "2004", "authors": "A Adams; J Baek; M A Davis"}, {"ref_id": "b1", "title": "Non-linear Gaussian filters performing edge preserving diffusion", "journal": "Springer", "year": "1995", "authors": "V Aurich; J Weule"}, {"ref_id": "b2", "title": "GIFT: a real-time and scalable 3D shape search engine", "journal": "", "year": "2016", "authors": "S Bai; X Bai; Z Zhou; Z Zhang; L J Latecki"}, {"ref_id": "b3", "title": "Learning class-specific descriptors for deformable shapes using localized spectral convolutional networks", "journal": "", "year": "2015", "authors": "D Boscaini; J Masci; S Melzi; M M Bronstein; U Castellani; P Vandergheynst"}, {"ref_id": "b4", "title": "Learning shape correspondence with anisotropic convolutional neural networks", "journal": "", "year": "2016", "authors": "D Boscaini; J Masci; E Rodol\u00e0; M M Bronstein"}, {"ref_id": "b5", "title": "Generative and discriminative voxel modeling with convolutional neural networks", "journal": "", "year": "2016", "authors": "A Brock; T Lim; J M Ritchie; N Weston"}, {"ref_id": "b6", "title": "Geometric deep learning: Going beyond euclidean data", "journal": "IEEE Signal Processing Magazine", "year": "2017", "authors": "M M Bronstein; J Bruna; Y Lecun; A Szlam; P Vandergheynst"}, {"ref_id": "b7", "title": "Spectral networks and locally connected networks on graphs", "journal": "", "year": "2014", "authors": "J Bruna; W Zaremba; A Szlam; Y Lecun"}, {"ref_id": "b8", "title": "3D object classification via spherical projections", "journal": "", "year": "2017", "authors": "Z Cao; Q Huang; K Ramani"}, {"ref_id": "b9", "title": "Semantic image segmentation with deep convolutional nets and fully connected CRFs", "journal": "", "year": "2015", "authors": "L.-C Chen; G Papandreou; I Kokkinos; K Murphy; A L Yuille"}, {"ref_id": "b10", "title": "Convolutional neural networks on graphs with fast localized spectral filtering", "journal": "", "year": "2016", "authors": "M Defferrard; X Bresson; P Vandergheynst"}, {"ref_id": "b11", "title": "The Pascal Visual Object Classes Challenge: A retrospective", "journal": "IJCV", "year": "2015-01", "authors": "M Everingham; S M A Eslami; L Van Gool; C K I Williams; J Winn; A Zisserman"}, {"ref_id": "b12", "title": "GWCNN: A metric alignment layer for deep shape analysis", "journal": "Computer Graphics Forum", "year": "2017", "authors": "D Ezuz; J Solomon; V G Kim; M Ben-Chen"}, {"ref_id": "b13", "title": "Efficient 2D and 3D facade segmentation using auto-context. PAMI", "journal": "", "year": "2017", "authors": "R Gadde; V Jampani; R Marlet; P Gehler"}, {"ref_id": "b14", "title": "PointNet: A 3D convolutional neural network for real-time object class recognition", "journal": "", "year": "2016", "authors": "A Garcia-Garcia; F Gomez-Donoso; J G Rodr\u00edguez; S Orts; M Cazorla; J A L\u00f3pez"}, {"ref_id": "b15", "title": "Submanifold sparse convolutional networks", "journal": "", "year": "2017", "authors": "B Graham; L Van Der Maaten"}, {"ref_id": "b16", "title": "Hypercolumns for object segmentation and fine-grained localization", "journal": "", "year": "2015", "authors": "B Hariharan; P Arbel\u00e1ez; R Girshick; J Malik"}, {"ref_id": "b17", "title": "FusionNet: 3D object classification using multiple data representations", "journal": "", "year": "2016", "authors": "V Hegde; R Zadeh"}, {"ref_id": "b18", "title": "Deep convolutional networks on graph-structured data", "journal": "", "year": "2015", "authors": "M Henaff; J Bruna; Y Lecun"}, {"ref_id": "b19", "title": "Learning local shape descriptors with viewbased convolutional neural networks", "journal": "ACM Trans. Graph", "year": "2018", "authors": "H Huang; E Kalegorakis; S Chaudhuri; D Ceylan; V Kim; E Yumer"}, {"ref_id": "b20", "title": "Video propagation networks", "journal": "", "year": "2017", "authors": "V Jampani; R Gadde; P V Gehler"}, {"ref_id": "b21", "title": "Learning sparse high dimensional filters: Image filtering, dense CRFs and bilateral neural networks", "journal": "", "year": "2004", "authors": "V Jampani; M Kiefel; P V Gehler"}, {"ref_id": "b22", "title": "Caffe: Convolutional architecture for fast feature embedding", "journal": "", "year": "2014", "authors": "Y Jia; E Shelhamer; J Donahue; S Karayev; J Long; R Girshick; S Guadarrama; T Darrell"}, {"ref_id": "b23", "title": "3D shape segmentation with projective convolutional networks", "journal": "", "year": "2017", "authors": "E Kalogerakis; M Averkiou; S Maji; S Chaudhuri"}, {"ref_id": "b24", "title": "Permutohedral lattice CNNs", "journal": "", "year": "2015-05", "authors": "M Kiefel; V Jampani; P V Gehler"}, {"ref_id": "b25", "title": "Adam: A method for stochastic optimization", "journal": "", "year": "2014", "authors": "D Kingma; J Ba"}, {"ref_id": "b26", "title": "Escape from cells: Deep Kd-Networks for the recognition of 3D point cloud models", "journal": "", "year": "2008", "authors": "R Klokov; V Lempitsky"}, {"ref_id": "b27", "title": "Convolutional neural networks on surfaces via seamless toric covers", "journal": "ACM Trans. Graph", "year": "2017", "authors": "H Maron; M Galun; N Aigerman; M Trope; N Dym; E Yumer; V G Kim; Y Lipman"}, {"ref_id": "b28", "title": "Geodesic convolutional neural networks on Riemannian manifolds", "journal": "", "year": "2015", "authors": "J Masci; D Boscaini; M Bronstein; P Vandergheynst"}, {"ref_id": "b29", "title": "3D convolutional neural networks for landing zone detection from LiDAR", "journal": "", "year": "2015", "authors": "D Maturana; S Scherer"}, {"ref_id": "b30", "title": "Geometric deep learning on graphs and manifolds using mixture model CNNs", "journal": "", "year": "2017", "authors": "F Monti; D Boscaini; J Masci; E Rodola; J Svoboda; M M Bronstein"}, {"ref_id": "b31", "title": "Illumination for computer generated pictures", "journal": "Commun. ACM", "year": "", "authors": "B T Phong"}, {"ref_id": "b32", "title": "PointNet: Deep learning on point sets for 3D classification and segmentation", "journal": "", "year": "2008", "authors": "C R Qi; H Su; K Mo; L J Guibas"}, {"ref_id": "b33", "title": "Volumetric and multi-view CNNs for object classification on 3D data", "journal": "", "year": "2016", "authors": "C R Qi; H Su; M Niener; A Dai; M Yan; L J Guibas"}, {"ref_id": "b34", "title": "PointNet++: Deep hierarchical feature learning on point sets in a metric space", "journal": "", "year": "2008", "authors": "C R Qi; L Yi; H Su; L Guibas"}, {"ref_id": "b35", "title": "Oct-NetFusion: Learning depth fusion from data", "journal": "", "year": "2017", "authors": "G Riegler; A O Ulusoy; H Bischof; A Geiger"}, {"ref_id": "b36", "title": "Octnet: Learning deep 3D representations at high resolutions", "journal": "", "year": "2006", "authors": "G Riegler; A O Ulusoys; A Geiger"}, {"ref_id": "b37", "title": "Learning where to classify in multi-view semantic segmentation", "journal": "", "year": "2014", "authors": "H Riemenschneider; A B\u00f3dis-Szomor\u00fa; J Weissenberg; L Van Gool"}, {"ref_id": "b38", "title": "Orientation-boosted voxel nets for 3D object recognition", "journal": "", "year": "2017", "authors": "N Sedaghat; M Zolfaghari; E Amiri; T Brox"}, {"ref_id": "b39", "title": "Deep learning 3D shape surfaces using geometry images", "journal": "", "year": "2016", "authors": "A Sinha; J Bai; K Ramani"}, {"ref_id": "b40", "title": "Learned-Miller. Multi-view convolutional neural networks for 3D shape recognition", "journal": "", "year": "2015", "authors": "H Su; S Maji; E Kalogerakis; E "}, {"ref_id": "b41", "title": "Octree generating networks: Efficient convolutional architectures for high-resolution 3D outputs", "journal": "", "year": "2017", "authors": "M Tatarchenko; A Dosovitskiy; T Brox"}, {"ref_id": "b42", "title": "Bilateral filtering for gray and color images", "journal": "", "year": "1998", "authors": "C Tomasi; R Manduchi"}, {"ref_id": "b43", "title": "O-CNN: Octree-based convolutional neural networks for 3D shape analysis", "journal": "ACM Trans. Graph", "year": "2002", "authors": "P.-S Wang; Y Liu; Y.-X Guo; C.-Y. Sun; X Tong"}, {"ref_id": "b44", "title": "3D shapenets: A deep representation for volumetric shapes", "journal": "", "year": "2015", "authors": "Z Wu; S Song; A Khosla; F Yu; L Zhang; X Tang; J Xiao"}, {"ref_id": "b45", "title": "A scalable active framework for region annotation in 3D shape collections", "journal": "ACM Trans. Graph", "year": "2008", "authors": "L Yi; V G Kim; D Ceylan; I Shen; M Yan; H Su; A Lu; Q Huang; A Sheffer; L Guibas"}, {"ref_id": "b46", "title": "SyncSpecCNN: Synchronized spectral CNN for 3D shape segmentation", "journal": "", "year": "2008", "authors": "L Yi; H Su; X Guo; L Guibas"}, {"ref_id": "b47", "title": "Deep sets", "journal": "", "year": "2017", "authors": "M Zaheer; S Kottur; S Ravanbakhsh; B Poczos; R R Salakhutdinov; A J Smola"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 1 :1Figure1: From point clouds and images to semantics. SPLATNet 3D directly takes point cloud as input and predicts labels for each point. SPLATNet 2D-3D , on the other hand, jointly processes both point cloud and the corresponding multi-view images for better 2D and 3D predictions.", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Figure 2 :2Figure 2: Bilateral Convolution Layer. Splat: BCL first interpolates input features F onto a d l -dimensional permutohedral lattice defined by the lattice features L at input points. Convolve: BCL then does d l -dimensional convolution over this sparsely populated lattice. Slice: The filtered signal is then interpolated back onto the input signal. For illustration, input and output are shown as point cloud and the corresponding segmentation labels.", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Figure 3 :3Figure 3: SPLATNet. Illustration of inputs, outputs and network architectures for SPLATNet 3D and SPLATNet 2D-3D .", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "(x, y, z), I3(x, y, z), 8I3 (nx, ny, nz), I3", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_5", "figure_caption": "Figure 4 :4Figure 4: Effect of different lattice spaces and scales. Visualizations for different lattice feature spaces L = (x, y, z), (x, y, z), (n x , n y , n z ) along with lattice scales \u039b = I 3 , 8I 3 , I 3 . (n x , n y , n z ) refers to point normals. All points falling in the same lattice cell are colored the same.", "figure_data": ""}, {"figure_label": "5", "figure_type": "figure", "figure_id": "fig_6", "figure_caption": "Figure 5 :5Figure 5: 2D to 3D projection. Illustration of 2D to 3D projection using splat and sliceusingsplatandsliceoperations.Given input features of 2D images, pixels are projected onto a 3D permutohedral lattice defined by 3D positional lattice features. The splatted signal is then sliced onto the points of interest in a 3D point cloud.", "figure_data": ""}, {"figure_label": "6", "figure_type": "figure", "figure_id": "fig_7", "figure_caption": "Figure 6 :6Figure 6: Facade point cloud labeling. Sample visual results of SPLATNet 3D and SPLATNet 2D-3D .", "figure_data": ""}, {"figure_label": "7", "figure_type": "figure", "figure_id": "fig_8", "figure_caption": "Figure 7 :7Figure 7: 2D facade segmentation. Sample visual results of SPLATNet 2D-3D .", "figure_data": ""}, {"figure_label": "8", "figure_type": "figure", "figure_id": "fig_9", "figure_caption": "Figure 8 :8Figure 8: ShapeNet part segmentation. Sample visual results of SPLATNet 3D and SPLATNet 2D-3D .", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "Results on facade segmentation. Average IoU scores and approximate runtimes for point cloud labeling and 2D image labeling using different techniques. Runtimes indicate the time taken to segment the entire test data (202 images sequentially for 2D and a point cloud for 3D).", "figure_data": "MethodAverage IoURuntime (min)With only 3D dataOctNet [37]59.2-Autocontext3D [14]54.416SPLATNet3D (Ours)65.40.06With both 2D and 3D dataAutocontext2D-3D [14]62.987SPLATNet2D-3D (Ours)69.81.20(a) Point cloud labelingMethodAverage IoURuntime (min)Autocontext2D [14]60.5117Autocontext2D-3D [14]62.7146DeepLab2D [10]69.30.84SPLATNet2D-3D (Ours)70.64.34(b) Multi-view image labeling"}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "Results on ShapeNet part segmentation. Class average mIoU, instance average mIoU and mIoU scores for all the categories on the task of point cloud labeling using different techniques.-bag cap car chair ear-guitar knife lamp laptop motor-mug pistol rocket skate-table avg. avg. plane 90.8 71.8 91.0 85.9 83.7 95.3 71.6 94.1 81.3 58.7 76.4 82.6 SyncSpecCNN [47] 82.0 84.7 81.6 81.7 81.9 75.2 90.2 74.9 93.0 86.1 84.7 95.6 66.7 92.7 81.6 60.6 82.9 82.1 SPLATNet3D 82.0 84.6 81.9 83.9 88.6 79.5 90.1 73.5 91.3 84.7 84.5 96.3 69.7 95.0 81.7 59.2 70.4 81.3 SPLATNet2D-3D 83.7 85.4 83.2 84.3 89.1 80.3 90.7 75.5 92.1 87.1 83.9 96.3 75.6 95.8 83.8 64.0 75.5 81.8", "figure_data": "#instances2690 76 55 898 3758 69787 392 1547 451202 184 28366152 5271class instance airphonebikeboardYi et al. [46]79.0 81.4 81.0 78.4 77.7 75.7 87.6 61.9 92.0 85.4 82.5 95.7 70.6 91.9 85.9 53.1 69.8 75.33DCNN [33]74.9 79.4 75.1 72.8 73.3 70.0 87.2 63.5 88.4 79.6 74.4 93.9 58.7 91.8 76.4 51.2 65.3 77.1Kd-network [27]77.4 82.3 80.1 74.6 74.3 70.3 88.6 73.5 90.2 87.2 81.0 94.9 57.4 86.7 78.1 51.8 69.9 80.3PointNet [33]80.4 83.7 83.4 78.7 82.5 74.9 89.6 73.0 91.5 85.9 80.8 95.3 65.2 93.0 81.2 57.9 72.8 80.6PointNet++ [35]81.9 85.1 82.4 79.0 87.7 77.3"}], "formulas": [{"formula_id": "formula_0", "formula_text": "F c = S slice B conv S splat F c ,(1)", "formula_coordinates": [3.0, 372.42, 579.78, 172.7, 9.65]}, {"formula_id": "formula_1", "formula_text": "+ SPLATNet 3D CNN 1 + BCL L 3D | \u039b 0 /2 T-1 BCL L 3D | \u039b 0 /2 BCL L 3D | \u039b 0 1\u2a091 CONV 1\u2a091 CONV 1\u2a091 CONV CNN 2 SPLATNet 2D-3D ... ... 1\u2a091 CONV Input point cloud Input images 3D predictions (SPLATNet 3D ) 3D predictions (SPLATNet 2D-3D ) 2D predictions (SPLATNet 2D-3D ) BCL ss L 2D , L 3D | \u039b a 2D\u279d3D 2D-3D Fusion + BCL ss L 3D , L 2D | \u039b b 3D\u279d2D 1\u2a091 CONV", "formula_coordinates": [4.0, 89.83, 81.72, 417.27, 163.72]}, {"formula_id": "formula_2", "formula_text": "d f \u2264 d, d l \u2264 d.", "formula_coordinates": [4.0, 223.91, 656.06, 62.45, 9.65]}, {"formula_id": "formula_3", "formula_text": "CNN 2 .", "formula_coordinates": [6.0, 50.11, 351.71, 28.54, 9.72]}], "doi": ""}