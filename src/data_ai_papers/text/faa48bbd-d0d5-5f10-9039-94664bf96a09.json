{"title": "Vocabulary Learning via Optimal Transport for Neural Machine Translation", "authors": "Jingjing Xu; Hao Zhou; Chun Gan; Zaixiang Zheng; Lei Li; Bytedance Ai Lab; - Madison", "pub_date": "", "abstract": "The choice of token vocabulary affects the performance of machine translation. This paper aims to figure out what is a good vocabulary and whether one can find the optimal vocabulary without trial training. To answer these questions, we first provide an alternative understanding of the role of vocabulary from the perspective of information theory. Motivated by this, we formulate the quest of vocabularization -finding the best token dictionary with a proper size -as an optimal transport (OT) problem. We propose VOLT, a simple and efficient solution without trial training. Empirical results show that VOLT outperforms widely-used vocabularies in diverse scenarios, including WMT-14 English-German and TED's 52 translation directions. For example, VOLT achieves 70% vocabulary size reduction and 0.5 BLEU gain on English-German translation. Also, compared to BPE-search, VOLT reduces the search time from 384 GPU hours to 30 GPU hours on English-German translation. Codes are available at https: //github.com/Jingjing-NLP/VOLT.", "sections": [{"heading": "Introduction", "text": "Due to the discreteness of text, vocabulary construction ( vocabularization for short) is a prerequisite for neural machine translation (NMT) and many other natural language processing (NLP) tasks using neural networks (Mikolov et al., 2013;Vaswani et al., 2017;Gehrmann et al., 2018;Zhang et al., 2018;Devlin et al., 2019). Currently, sub-word approaches like Byte-Pair Encoding (BPE) are widely used in the community (Ott et al., 2018;Ding et al., 2019;Liu et al., 2020), and achieve quite promising results in practice (Sennrich et al., 2016;Costa-juss\u00e0 and Fonollosa, 2016;Lee et al., 2017;Kudo and Richardson, 2018;Al-Rfou et al., 2019;Wang et al., 2020).\nThe key idea of these approaches is selecting the most frequent sub-words (or word pieces with higher probabilities) as the vocabulary tokens. In information theory, these frequency-based approaches are simple forms of data compression to reduce entropy (Gage, 1994), which makes the resulting corpus easy to learn and predict (Martin and England, 2011;Bentz and Alikaniotis, 2016).\nHowever, the effects of vocabulary size are not sufficiently taken into account since current approaches only consider frequency (or entropy) as the main criteria. Many previous studies (Sennrich and Zhang, 2019;Ding et al., 2019;Provilkov et al., 2020;Salesky et al., 2020) show that vocabulary size also affects downstream performances, especially on low-resource tasks. Due to the lack of appropriate inductive bias about size, trial training (namely traversing all possible sizes) is usually required to search for the optimal size, which takes high computation costs. For convenience, most existing studies only adopt the widely-used settings in implementation. For example, 30K-40K is the most popular size setting in all 42 papers of Conference of Machine Translation (WMT) through 2017 and 2018 (Ding et al., 2019).\nIn this paper, we propose to explore automatic vocabularization by simultaneously considering entropy and vocabulary size without expensive trial training. Designing such a vocabularization approach is non-trivial for two main reasons. First, it is challenging to find an appropriate objective function to optimize them at the same time. Roughly speaking, the corpus entropy decreases with the increase of vocabulary size, which benefits model learning (Martin and England, 2011). On the other side, too many tokens cause token sparsity, which hurts model learning (Allison et al., 2006). Second, supposing that an appropriate measurement is given, it is still challenging to We sample BPE-generated vocabularies with different sizes from Eo-En translation and draw their entropy (See Eq.2) and BLEU lines. \"Star\" represents the vocabulary with the maximum marginal utility. Marginal utility (See Eq.1) evaluates the increase of benefit (entropy decrease) from an increase of cost (size).\nsolve such a discrete optimization problem due to the exponential search space. To address the above problems, we propose a VOcabulary Learning approach via optimal Transport, VOLT for short. It can give an appropriate vocabulary in polynomial time by considering corpus entropy and vocabulary size. Specifically, given the above insight of contradiction between entropy and size, we first borrow the concept of Marginal Utility in economics (Samuelson, 1937) and propose to use Marginal Utility of Vocabularization (MUV) as the measurement. The insight is quite simple: in economics, marginal utility is used to balance the benefit and the cost and we use MUV to balance the entropy (benefit) and vocabulary size (cost). Higher MUV is expected for Pareto optimality. Formally, MUV is defined as the negative derivative of entropy to vocabulary size. Figure 1 gives an example about marginal utility. Preliminary results verify that MUV correlates with the downstream performances on two-thirds of tasks (See Figure 2).\nThen our goal turns to maximize MUV in tractable time complexity. We reformulate our discrete optimization objective into an optimal transport problem (Cuturi, 2013) that can be solved in polynomial time by linear programming. Intuitively, the vocabularization process can be regarded as finding the optimal transport matrix from the character distribution to the vocabulary token distribution. Finally, our proposed VOLT will yield a vocabulary from the optimal transport matrix.\nWe evaluate our approach on multiple machine translation tasks, including WMT-14 English-German translation, TED bilingual translation, and TED multilingual translation. Empirical results show that VOLT beats widely-used vocabularies in diverse scenarios. Furthermore, VOLT is a lightweight solution and does not require expensive computation resources. On English-German translation, VOLT only takes 30 GPU hours to find vocabularies, while the traditional BPE-Search solution takes 384 GPU hours.", "publication_ref": ["b18", "b29", "b11", "b31", "b8", "b19", "b9", "b16", "b25", "b6", "b15", "b14", "b0", "b30", "b10", "b17", "b2", "b26", "b9", "b21", "b23", "b9", "b17", "b1", "b24", "b7"], "figure_ref": ["fig_0", "fig_1"], "table_ref": []}, {"heading": "Related Work", "text": "Initially, most neural models were built upon word-level vocabularies (Costa-juss\u00e0 and Fonollosa, 2016;Vaswani et al., 2017;Zhao et al., 2019). While achieving promising results, it is a common constraint that word-level vocabularies fail on handling rare words under limited vocabulary sizes.\nResearchers recently have proposed several advanced vocabularization approaches, like bytelevel approaches (Wang et al., 2020), characterlevel approaches (Costa-juss\u00e0 and Fonollosa, 2016;Lee et al., 2017;Al-Rfou et al., 2019), and sub-word approaches (Sennrich et al., 2016;Kudo and Richardson, 2018). Byte-Pair Encoding (BPE) (Sennrich et al., 2016) is proposed to get subword-level vocabularies. The general idea is to merge pairs of frequent character sequences to create sub-word units. Sub-word vocabularies can be regarded as a trade-off between character-level vocabularies and word-level vocabularies. Compared to word-level vocabularies, it can decrease the sparsity of tokens and increase the shared features between similar words, which probably have similar semantic meanings, like \"happy\" and \"happier\". Compared to character-level vocabularies, it has shorter sentence lengths without rare words. Following BPE, some variants recently have been proposed, like BPE-dropout (Provilkov et al., 2020), SentencePiece (Kudo and Richardson, 2018), and so on.\nDespite promising results, most existing subword approaches only consider frequency while the effects of vocabulary size is neglected. Thus, trial training is required to find the optimal size, which brings high computation costs. More recently, some studies notice this problem and propose some practical solutions (Kreutzer and Sokolov, 2018;Cherry et al., 2018;Salesky et al., 2020). ", "publication_ref": ["b6", "b29", "b32", "b30", "b6", "b15", "b0", "b25", "b14", "b25", "b21", "b14", "b13", "b4", "b23"], "figure_ref": [], "table_ref": []}, {"heading": "Marginal Utility of Vocabularization", "text": "In this section, we propose to find a good vocabulary measurement by considering entropy and size.\nAs introduced in Section 1, it is non-trivial to find an appropriate objective function to optimize them simultaneously. On one side, with the increase of vocabulary size, the corpus entropy is decreased, which benefits model learning (Bentz and Alikaniotis, 2016). On the other side, a large vocabulary causes parameter explosion and token sparsity problems, which hurts model learning (Allison et al., 2006).\nTo address this problem, we borrow the concept of Marginal Utility in economics (Samuelson, 1937) and propose to use Marginal Utility of Vocabularization (MUV) as the optimization objective. MUV evaluates the benefits (entropy) a corpus can get from an increase of cost (size). Higher MUV is expected for higher benefit-cost ratio. Preliminary results verify that MUV correlates with downstream performances on two-thirds of translation tasks (See Figure 2). According to this feature, our goal turns to maximize MUV in tractable time complexity.\nDefinition of MUV Formally, MUV represents the negative derivation of entropy to size. For simplification, we leverage a smaller vocabulary to estimate MUV in implementation. Specially, MUV is calculated as:\nM v(k+m) = \u2212(H v(k+m) \u2212 H v(k) ) m ,(1)\nwhere v(k), v(k + m) are two vocabularies with k and k + m tokens, respectively. H v represents the corpus entropy with the vocabulary v, which is defined by the sum of token entropy. To avoid the effects of token length, here we normalize entropy with the average length of tokens and the final entropy is defined as:\nHv = \u2212 1 lv i\u2208v P (i) log P (i),(2)\nwhere P (i) is the relative frequency of token i from the training corpus and l v is the average length of tokens in vocabulary v.", "publication_ref": ["b2", "b1", "b24"], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "Preliminary Results", "text": "To verify the effectiveness of MUV as the vocabulary measurement, we conduct experiments on 45 language pairs from TED and calculate the Spearman correlation score * between MUV and BLEU scores. We adopt the same and widely-used settings to avoid the effects of other attributes on BLEU scores, such as model hyper-parameters and training hyper-parameters.\nWe generate a sequence of vocabularies with incremental sizes via BPE. All experiments use the same hyper-parameters. Two-thirds of pairs show positive correlations as shown in Figure 2. The middle Spearman score is 0.4. We believe that it is a good signal to show MUV matters. Please refer to Section 5 for more dataset details and Appendix A for more implementation details.\nGiven MUV, we have two natural choices to get the final vocabulary: search and learning. In the search-based direction, we can combine MUV with widely-used vocabularization solutions. For example, the optimal vocabularies can be obtained by enumerating all candidate vocabularies generated by BPE. While being simple and effective, it is not a self-sufficient approach. Furthermore, it still requires a lot of time to generate vocabularies and calculate MUV. To address these problems, we further explore a learning-based solution VOLT for more vocabulary possibilities. We empirically compare MUV-Search and VOLT in Section 5.", "publication_ref": [], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "Maximizing MUV via Optimal Transport", "text": "This section describes the details of the proposed approach. We first show the general idea of VOLT in Section 4.1, then describe the optimal transport solution in Section 4.2, followed by the implementation details in Section 4.3.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Overview", "text": "We formulate vocabulary construction as a discrete optimization problem whose target is to find the vocabulary with the highest MUV according to Eq. 1. However, the vocabulary is discrete and such discrete search space is too large to traverse, which makes the discrete optimization intractable.\nIn this paper, we simplify the original discrete optimization problem by searching for the optimal vocabulary from vocabularies with fixed sizes. Intuitively, MUV is the first derivative of entropy according to the vocabulary size (Eq. 1), and we introduce an auxiliary variable S (S is an incremental integer sequence) to approximate the computation by only computing MUV between vocabulary sizes as adjacent integers in S.\nFormally\n, S = {i, 2 \u2022 i, ..., (t \u2212 1) \u2022 i, \u2022 \u2022 \u2022 }\nwhere each timestep t represents a set of vocabularies with the number up to S[t]. For any vocabulary, its MUV score can be calculated based on a vocabulary from its previous timestep. With sequence S, the target to find the optimal vocabulary v(t) with the highest MUV can be formulated as: \narg max v(t\u22121) \u2208 V S[t\u22121] ,v(t)\u2208V S[t] M v(t) = arg max v(t\u22121)\u2208V S[t\u22121] ,v(t)\u2208V S[t] \u2212 1 i H v(t) \u2212 H v(t\u2212\narg max t 1 i max v(t)\u2208V S[t] H v(t) \u2212 max v(t\u22121)\u2208V S[t\u22121] H v(t\u22121) .(3)\nwhere i means the size difference between t \u2212 1 vocabulary and t vocabulary. MUV requires the size difference as a denominator. Based on this equation, the whole solution is split into two steps: 1) searching for the optimal vocabulary with the highest entropy at each timestep t; 2) enumerating all timesteps and outputing the vocabulary corresponding to the time step satisfying Eq. 3. The first step of our approach is to search for the vocabulary with the highest entropy from\nV S[t] .\nFormally, the goal is to find a vocabulary v(t) such that entropy is maximized, where l v is the average length for tokens in v(t), P (i) is the probability of token i. However, notice that this problem is in general intractable due to the extensive vocabulary size. Therefore, we instead propose a relaxation in the formulation of discrete optimal transport, which can then be solved efficiently via the Sinkhorn algorithm (Cuturi, 2013).\narg max v(t)\u2208V S[t] \u2212 1 l v(t) i\u2208v(t) P (i) log P (i),(4)\nIntuitively, we can imagine vocabulary construction as a transport process that transports chars into token candidates with the number up to S[t]. As shown in Figure 3, the number of chars is fixed, and not all token candidates can get enough chars. Each transport matrix can build a vocabulary by collecting tokens with chars. Different transport matrices bring different transport costs. The target of optimal transport is to find a transport matrix to minimize the transfer cost, i.e., negative entropy in our setting.", "publication_ref": ["b7"], "figure_ref": ["fig_2"], "table_ref": []}, {"heading": "Vocabularization via Optimal Transport", "text": "Given a set of vocabularies V S[t] , we want to find the vocabulary with the highest entropy. Consequently, the objective function in Eq. 4 becomes\nmin v\u2208V S[t] 1 lv i\u2208v P (i) log P (i), s.t. P (i) = Token(i) i\u2208v Token(i) , lv = i\u2208v len(i) |v| .\nToken(i) is the frequency of token i in the vocabulary v. len(i) represents the length of token i. Notice that both the distribution P (i) and the average length l v depend on the choice of v.\nObjective Approximation To obtain a tractable lower bound of entropy, it suffices to give a tractable upper bound of the above objective function. We adopt the merging rules to segment raw text similar with BPE where two consecutive tokens will be merged into one if the merged one is in the vocabulary. To this end, let T \u2208 V S[t] be the vocabulary containing top S[t] most frequent tokens, C be the set of chars and |T|, |C| be their sizes respectively. Since T is an element of V S[t] , clearly, we have\nmin v\u2208V S[t] 1 lv i\u2208v P (i) log P (i) \u2264 1 l T i\u2208T P (i) log P (i). (5\n)\nHere we start from the upper bound of the above objective function, that is 1 l T i\u2208T P (i) log P (i) and then search for a refined token set from T. In this way, we reduce the search space into the subsets of T. Let P (i, j) be the joint probability distribution of the tokens and chars that we want to learn. Then we have\ni\u2208T P (i) log P (i) = i\u2208T j\u2208C P (i, j) log P (i) = i\u2208T j\u2208C P (i, j) log P (i, j) L 1 + i\u2208T j\u2208C P (i, j)(\u2212 log P (j|i)) L 2 . (6)\nThe details of proof can be found at Appendix C. Since L 1 is nothing but the negative entropy of the joint probability distribution P (i, j), we shall denote it as \u2212H(P ).\nLet D be the |C| \u00d7 |T| matrix whose (i, j)-th entry is given by \u2212 log P (j|i), and let P be the joint probability matrix, then we can write\nL2 = P , D = i j P (i, j)D(i, j).(7)\nIn this way, Eq. 6 can be reformulated as the following objective function which has the same form as the objective function in optimal transport:\nmin P \u2208R m\u00d7n P , D \u2212 \u03b3H(P ).(8)\nSetup of OT From the perspective of optimal transport, P can be regarded as the transport matrix, and D can be regarded as the distance matrix. Intuitively, optimal transport is about finding the best transporting mass from the char distribution to the target token distribution with the minimum work defined by P , D .\nTo verify the validness of transport solutions, we add the following constraints. First, to avoid invalid transport between char j and token i, we set the distance to +\u221e if the target token i does not contain the char j. Otherwise, we use 1 len(i) to estimate P (j|i) where len(i) is the length of token i. Formally, the distance matrix is defined as\nD(i, j) = \u2212 log P (j|i) = +\u221e, if j / \u2208 i \u2212 log P (j|i) = \u2212 log 1 len(i) , otherwise\nFurthermore, the number of chars is fixed and we set the sum of each row in the transport matrix to the probability of char j. The upper bound of the char requirements for each token is fixed and we set the sum of each column in the transport matrix to the probablity of token j. Formally, the constraints are defined as:\n| j P (i, j) \u2212 P (i)| \u2264 ,(9)\nand i P (i, j) = P (j).\nGiven transport matrix P and distance matrix D, the final objective can be formulated as:\narg min P \u2208R |C|\u00d7|T| \u2212H(P ) + P , D , s.t. i P (i, j) = P (j), | j P (i, j) \u2212 P (i)| \u2264 ,\nwith small > 0. Figure 4 shows the details of optimal transport solution. Strictly speaking, this is an unbalanced entropy regularized optimal transport problem. Nonetheless, we can still use the generalized Sinkhorn algorithm to efficiently find the target vocabulary as detailed in Section 4.6 of Peyr\u00e9 and Cuturi (2019). The algorithm details are shown in Algorithm 1. At each timestep t, we can generate a new vocabulary associated with entropy scores based on the transport matrix P . Finally, we collect these vocabularies associated with entropy scores, and output the vocabulary satisfying Eq. 3.", "publication_ref": ["b20"], "figure_ref": [], "table_ref": []}, {"heading": "Implementation", "text": "Algorithm 1 lists the process of VOLT. First, we rank all token candidates according to their frequencies. For simplification, we adopt BPEgenerated tokens (e.g. BPE-100K) as the token candidates. It is important to note that any segmentation algorithms can be used to initialize token candidates. Experiments show that different initialization approaches result in similar results. We simply adopt BPE-100K for bilingual translation and BPE-300K for multilingual translation in this work. All token candidates with their probabilities are then used to initialize L in Algorithm 1.\nFigure 4: The details of optimal transport. The objective function is the sum of negative entropy and transport cost. Each element D(i, j) in the distance matrix is the negative log of 1/n where n is the length of token i. It defines the distance between char j and token i. To avoid invalid transport between char j and token i, we set the distance to infinite if the target token i does not contain the char j.\nThe size of the incremental integer sequence S is a hyper-parameter and set to (1K, ..., 10K) for bilingual translation, (40K, ..., 160K) for multilingual settings. At each timestep, we can get the vocabulary with the maximum entropy based on the transport matrix. It is inevitable to handle illegal transport case due to relaxed constraints. We remove tokens with distributed chars less than 0.001 token frequencies. Finally, we enumerate all timesteps and select the vocabulary satisfying Eq. 3 as the final vocabulary.\nAfter generating the vocabulary, VOLT uses a greedy strategy to encode text similar to BPE. To encode text, it first splits sentences into characterlevel tokens. Then, we merge two consecutive tokens into one token if the merged one is in the vocabulary. This process keeps running until no tokens can be merged. Out-of-vocabulary tokens will be split into smaller tokens.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Experiments", "text": "To evaluate the performance of VOLT, we conduct experiments on three datasets, including WMT-14 English-German translation, TED bilingual translation, and TED multilingual translation.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Settings", "text": "We run experiments on the following machine translation datasets. See Appendix B for more model and training details. v.reshape(1, -1) // End of Sinkhorn algorithm entropy, vocab = get vocab(optimal matrix) vocabularies.append(entropy,vocab) Output v * from vocabularies satisfying Eq. 3 dataset is processed following Ott et al. (2018). We choose newstest14 as the test set.\n2. TED bilingual dataset: We include two settings: X-to-English translation and Englishto-X translation. We choose 12 languagepairs with the most training data. We use the language code according to ISO-639-1 standard \u2020 . TED data is provided by Qi et al. (2018).\n3. TED multilingual dataset: We conduct experiments with 52 language pairs on a many-to-English setting. The network is trained on all language pairs. We adopt the same preprocessing pipeline in the WMT-14 En-De dataset.", "publication_ref": ["b19", "b22"], "figure_ref": [], "table_ref": []}, {"heading": "Main Results", "text": "Vocabularies Searched by VOLT are Better than Widely-used Vocabularies on Bilingual MT Settings. Ding et al. (2019) gather 42 papers that have been accepted by the research track of Conference of Machine Translation (WMT) through 2017 and 2018. Among these papers, the authors find that 30K-40K is the most popular range for the number of BPE merge actions. Following this work, we first compare our methods with dominant BPE-30K. The results are listed in Table 1. As we can see, the vocabularies searched by VOLT achieve higher BLEU scores with large   2019) study how the size of BPE affects the model performance in low-resource settings. They conduct experiments on four language pairs and find that smaller vocabularies are more suitable for lowresource datasets. For Transformer architectures, the optimal vocabulary size is less than 4K, around up to 2K merge actions. We compare VOLT and BPE-1K on an X-to-English bilingual setting. The results are shown in Table 2. We can see that VOLT can find a good vocabulary on par with heuristically searched vocabularies in terms of BLEU scores. Note that BPE-1K is selected based on plenty of experiments. In contrast, VOLT only requires one trials for evaluation and only takes 0.5 CPU hours plus 30 GPU hours to find the optimal vocabulary.\nVOLT Works Well on Multilingual MT Settings. We conduct a multilingual experiment. These languages come from multiple language families and have diverse characters. We compare VOLT with BPE-60K, the most popular setting in multilingual translation tasks. Table 3 lists the full results. The size of the searched vocabulary is around 110K. As we can see, VOLT achieves better BLEU scores on most pairs.", "publication_ref": ["b9"], "figure_ref": [], "table_ref": ["tab_1", "tab_2"]}, {"heading": "VOLT is a Green Vocabularization Solution.", "text": "One advantage of VOLT lies in its low resource consumption. We compare VOLT with BPE-Search, a method to select the best one from a BPE-generated vocabulary set based on their BLEU scores. The results are shown in Table 4. In BPE-Search, we first define a vocabulary set including BPE-1K, BPE-2K, BPE-3K, BPE-4K, BPE-5K, BPE-6K, BPE-7K, BPE-8K, BPE-9K, BPE-10K, BPE-20K, BPE-30K. Then, we run full experiments to select the best vocabulary. Table 4 demonstrates that VOLT is a lightweight solution that can find a competitive vocabulary within 0.5 hours on a single CPU, compared to BPE-Search that takes hundreds of GPU hours. The cost of BPE-Search is the sum of the training time on all vocabularies. Furthermore, we also compare VOLT with MUV-Search as introduced in Section 3. MUV-Search is a method that combines MUV and popular approaches by selecting the vocabulary with the highest MUV as the final vocabulary. ", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_3", "tab_3"]}, {"heading": "Discussion", "text": "We conduct more experiments to answer the following questions: 1) can a baseline beat strong approaches with a better vocabulary; 2) can VOLT beat recent vocabulary solutions, like Sentence-Piece; 3) can VOLT work on diverse architectures?\nA Simple Baseline with a VOLT-generated Vocabulary Reaches SOTA Results. We compare VOLT and several strong approaches on the En-De  dataset. Table 5 shows surprisingly good results. Compared to the approaches in the top block, VOLT achieves almost the best performance with a much smaller vocabulary. These results demonstrate that a simple baseline can achieve good results with a well-defined vocabulary.\nVOLT Beats SentencePiece and WordPiece.\nSentencePiece and WordPiece are two variants of sub-word vocabularies. We also compare our approach with them on WMT-14 En-De translation to evaluate the effectiveness of VOLT. The middle block of Table 5 lists the results of Senten-Piece and WordPiece. We implement these two approaches with the default settings. We can observe that VOLT outperforms SentencePiece and WordPiece by a large margin, with over 1 BLEU improvements.\nVOLT Works on Various Architectures. This work mainly uses Transformer-big in experiments.\nWe are curious about whether VOLT works on other architectures. We take WMT-14 En-De translation as an example and implement a Convolutional Seq2Seq model. The network uses the default settings from Fairseq \u2021 . We set the maximum epochs to 100 and average the last five models as the final network for evaluation. All experiments run on the same environment (2 Tesla-V100-GPUs + 1 Gold-6130-CPU), with the same beam size for decoding. The speedup mainly comes from larger batch size with reduced embedding parameters. We also find that although VOLT reduces the Softmax computations, it does not significantly boost the Softmax running time due to optimized parallel computation in GPUs.\nVOLT Vocabularies and BPE Vocabularies are Highly Overlapped. For simplification, VOLT starts from BPE-segmented tokens. We take WMT En-De as an example to see the difference between VOLT vocabulary and BPE vocabulary. The size of VOLT vocabulary is around 9K and we adopt BPE-9K vocabulary for comparison. We find that these two vocabularies are highly overlapped, especially for those high-frequency words.\nThey also have similar downstream performance. Therefore, from an empirical perspective, BPE with VOLT size is also a good choice.", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_4", "tab_4"]}, {"heading": "Conclusion", "text": "In this work, we propose a new vocabulary search approach without trail training. The whole framework starts from an informtaion-therotic understanding. According to this understanding, we formulate vocabularization as a two-step discrete optimization objective and propose a principled optimal transport solution VOLT. Experiments show that VOLT can effectively find a well-performing vocabulary in diverse settings.\nAppendix C: Proofs for Eq. 6\ni\u2208T P (i) log P (i) =\ni\u2208T j\u2208C P (i, j) log P (i) = i\u2208T j\u2208C P (i, j) log P (i, j) \u2022 P (i) P (i, j)\n=\ni\u2208T j\u2208C P (i, j) log P (i, j) + i\u2208T j\u2208C P (i, j) log P (i) P (i, j)\n=\ni\u2208T j\u2208C P (i, j) log P (i, j)\nL 1 +\ni\u2208T j\u2208C P (i, j)(\u2212 log P (j|i))\nL 2 .", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgments", "text": "We thank the anonymous reviewers, Demi Guo, for their helpful feedback. Lei Li and Hao Zhou are corresponding authors.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Appendix A: MUV", "text": "To evaluate the relationship between MUV and BLEU scores, we conduct experiments on 45 language pairs (X-En) with most resources (including ar-en, eg-en, cs-en, da-en, de-en, el-en, es-en, eten, fa-en, fi-en, fr-ca-en, fr-en, gl-en, he-en, hi-en, hr-en, hu-en, hy-en, id-en, it-en, ja-en, ka-en, koen, ku-en, lt-en, mk-en, my-en, nb-en, nl-en, pl-en, pt-br-en, pt-en, ro-en, ru-en, sk-en, sl-en, sq-en, sren, sv-en, th-en, tr-en, uk-en, vi-en, zh-cn-en, zhtw- ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Appendix B: Experiments", "text": "Models. We use Fairseq to train a Transformerbig model with the same setting in the original paper (Ott et al., 2018). The input embedding and output embeddings are shared. We use the Adam optimizer (Kingma and Ba, 2015) with a learning rate 5e-4 and an inverse sqrt decay schedule. The warm-up step is 4, 000, the dropout rate is 0.3, the update frequency is 4, the number of tokens is 9, 600, or 4, 800 in a single batch.\nTraining and Evaluation. We run WMT-14 En-De experiments with 8 GPUs, TED bilingual translation with 4 GPUs, TED multilingual translation with 16 GPUs. We set a beamwidth to 4 for En-De and 5 for the other. For bilingual translation, we run approaches 40 epochs, average the last five models on all datasets, and use the averaged model to generate translation results.\nFor multilingual translation, all approaches run 10 epochs and we adopt the last model for evaluation. We calculate case-sensitive tokenized BLEU for evaluation.", "publication_ref": ["b19", "b12"], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Character-level language modeling with deeper self-attention", "journal": "AAAI Press", "year": "2019-01-27", "authors": "Rami Al-Rfou; Dokook Choe; Noah Constant; Mandy Guo; Llion Jones"}, {"ref_id": "b1", "title": "Another look at the data sparsity problem", "journal": "Springer", "year": "2006-09-11", "authors": "Ben Allison; David Guthrie; Louise Guthrie"}, {"ref_id": "b2", "title": "The word entropy of natural languages", "journal": "", "year": "2016", "authors": "Christian Bentz; Dimitrios Alikaniotis"}, {"ref_id": "b3", "title": "How large a vocabulary does text classification need? A variational approach to vocabulary selection", "journal": "Association for Computational Linguistics", "year": "2019-06-02", "authors": "Wenhu Chen; Yu Su; Yilin Shen; Zhiyu Chen; Xifeng Yan; William Yang Wang"}, {"ref_id": "b4", "title": "Revisiting character-based neural machine translation with capacity and compression", "journal": "", "year": "2018", "authors": "Colin Cherry; George F Foster; Ankur Bapna; Orhan Firat; Wolfgang Macherey"}, {"ref_id": "b5", "title": "Conference on Empirical Methods in Natural Language Processing", "journal": "Association for Computational Linguistics", "year": "2018-11-04", "authors": ""}, {"ref_id": "b6", "title": "Character-based neural machine translation", "journal": "", "year": "2016-08-07", "authors": "Marta R Costa-Juss\u00e0; A R Jos\u00e9;  Fonollosa"}, {"ref_id": "b7", "title": "Sinkhorn distances: Lightspeed computation of optimal transport", "journal": "", "year": "2013-12-05", "authors": "Marco Cuturi"}, {"ref_id": "b8", "title": "BERT: pre-training of deep bidirectional transformers for language understanding", "journal": "", "year": "2019-06-02", "authors": "Jacob Devlin; Ming-Wei Chang; Kenton Lee; Kristina Toutanova"}, {"ref_id": "b9", "title": "A call for prudent choice of subword merge operations in neural machine translation", "journal": "European Association for Machine Translation", "year": "2019-08-19", "authors": "Shuoyang Ding; Adithya Renduchintala; Kevin Duh"}, {"ref_id": "b10", "title": "A new algorithm for data compression", "journal": "C Users Journal", "year": "1994", "authors": "Philip Gage"}, {"ref_id": "b11", "title": "Bottom-up abstractive summarization", "journal": "", "year": "2018-10-31", "authors": "Sebastian Gehrmann; Yuntian Deng; Alexander M Rush"}, {"ref_id": "b12", "title": "Adam: A method for stochastic optimization", "journal": "", "year": "2015-05-07", "authors": "P Diederik; Jimmy Kingma;  Ba"}, {"ref_id": "b13", "title": "Learning to segment inputs for NMT favors character-level processing", "journal": "CoRR", "year": "2018", "authors": "Julia Kreutzer; Artem Sokolov"}, {"ref_id": "b14", "title": "Sentencepiece: A simple and language independent subword tokenizer and detokenizer for neural text processing", "journal": "", "year": "2018-10-31", "authors": "Taku Kudo; John Richardson"}, {"ref_id": "b15", "title": "Fully character-level neural machine translation without explicit segmentation", "journal": "Transactions of the Association for Computational Linguistics", "year": "2017", "authors": "Jason Lee; Kyunghyun Cho; Thomas Hofmann"}, {"ref_id": "b16", "title": "Very deep transformers for neural machine translation. CoRR, abs", "journal": "", "year": "2008", "authors": "Xiaodong Liu; Kevin Duh; Liyuan Liu; Jianfeng Gao"}, {"ref_id": "b17", "title": "Mathematical theory of entropy. 12. Cambridge university press", "journal": "", "year": "2011", "authors": "F G Nathaniel; James W Martin;  England"}, {"ref_id": "b18", "title": "Distributed representations of words and phrases and their compositionality", "journal": "", "year": "2013-12-05", "authors": "Tomas Mikolov; Ilya Sutskever; Kai Chen; Gregory S Corrado; Jeffrey Dean"}, {"ref_id": "b19", "title": "Scaling neural machine translation", "journal": "", "year": "2018-10-31", "authors": "Myle Ott; Sergey Edunov; David Grangier; Michael Auli"}, {"ref_id": "b20", "title": "", "journal": "Computational optimal transport. Found. Trends Mach. Learn", "year": "2019", "authors": "Gabriel Peyr\u00e9; Marco Cuturi"}, {"ref_id": "b21", "title": "Bpe-dropout: Simple and effective subword regularization", "journal": "", "year": "2020-07-05", "authors": "Ivan Provilkov; Dmitrii Emelianenko; Elena Voita"}, {"ref_id": "b22", "title": "When and why are pre-trained word embeddings useful for neural machine translation?", "journal": "", "year": "2018-06-01", "authors": "Ye Qi; Devendra Singh Sachan; Matthieu Felix; Sarguna Padmanabhan; Graham Neubig"}, {"ref_id": "b23", "title": "Optimizing segmentation granularity for neural machine translation", "journal": "", "year": "2020-01", "authors": "Elizabeth Salesky; Andrew Runge; Alex Coda"}, {"ref_id": "b24", "title": "A note on measurement of utility. The review of economic studies", "journal": "", "year": "1937", "authors": "A Paul;  Samuelson"}, {"ref_id": "b25", "title": "Neural machine translation of rare words with subword units", "journal": "", "year": "2016-08-07", "authors": "Rico Sennrich; Barry Haddow; Alexandra Birch"}, {"ref_id": "b26", "title": "Revisiting lowresource neural machine translation: A case study", "journal": "Long Papers", "year": "2019-07-28", "authors": "Rico Sennrich; Biao Zhang"}, {"ref_id": "b27", "title": "Self-attention with relative position representations", "journal": "", "year": "2018-06-01", "authors": "Peter Shaw; Jakob Uszkoreit; Ashish Vaswani"}, {"ref_id": "b28", "title": "The evolved transformer", "journal": "PMLR", "year": "2019-06", "authors": "David R So; V Quoc; Chen Le;  Liang"}, {"ref_id": "b29", "title": "Attention is all you need", "journal": "", "year": "2017-12-09", "authors": "Ashish Vaswani; Noam Shazeer; Niki Parmar; Jakob Uszkoreit; Llion Jones; Aidan N Gomez; Lukasz Kaiser; Illia Polosukhin"}, {"ref_id": "b30", "title": "Neural machine translation with byte-level subwords", "journal": "AAAI Press", "year": "2020-02-07", "authors": "Changhan Wang; Kyunghyun Cho; Jiatao Gu"}, {"ref_id": "b31", "title": "Deep learning for sentiment analysis: A survey", "journal": "Wiley Interdisciplinary Reviews: Data Mining and Knowledge Discovery", "year": "2018", "authors": "Lei Zhang; Shuai Wang; Bing Liu"}, {"ref_id": "b32", "title": "Recurrent neural network for text classification with hierarchical multiscale dense connections", "journal": "", "year": "2019-08-10", "authors": "Yi Zhao; Yanyan Shen; Junjie Yao"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 1 :1Figure1: An illustration of marginal utility. We sample BPE-generated vocabularies with different sizes from Eo-En translation and draw their entropy (See Eq.2) and BLEU lines. \"Star\" represents the vocabulary with the maximum marginal utility. Marginal utility (See Eq.1) evaluates the increase of benefit (entropy decrease) from an increase of cost (size).", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 2 :2Figure 2: MUV and downstream performance are positively correlated on two-thirds of tasks. X-axis classifies Spearman scores into different groups. Y-axis shows the number of tasks in each group. The middle Spearman score is 0.4.", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Figure 3 :3Figure 3: An illustration of vocabulary construction from a transport view. Each transport matrix represents a vocabulary. The transport matrix decides how many chars are transported to token candidates. The tokens with zero chars will not be added into the vocabulary.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "1. dataset: This dataset has 4.5M sentence pairs. The Algorithm 1: VOLT Input: A sequence of token candidates L ranked by frequencies, an incremental integer sequence S where the last item of S is less than |L|, a character sequence C, a training corpus Dc Parameters: u \u2208 R |C| + , v \u2208 R |T| + vocabularies = [] for item in S do // Begin of Sinkhorn algorithm Initialize u = ones() and v = ones() T = L[: item] Calculate token frequencies P (T) based on Dc Calculate char frequencies P (C) based on Dc Calculate D while not converge do u = P (T)/Dv v = P (C)/D T u optimal matrix = u.reshape(-1, 1) * D *", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "Comparison between vocabularies search by VOLT and widely-used BPE vocabularies. VOLT achieves higher BLEU scores with large size reduction. Here the vocabulary size is adopted from the X-En setting.39.57 39.95 40.11 19.79 26.52 16.27 34.61 32.48 27.65 15.15 29.37 28.20 VOLT 29.80 39.97 40.47 40.42 20.36 27.98 16.96 34.64 32.59 28.08 16.17 29.98 28.52 42.59 45.12 40.72 24.95 37.49 31.45 38.79 37.01 35.60 25.70 36.36 27.48 VOLT 32.30 42.34 45.93 40.72 25.33 38.70 32.97 39.09 37.31 36.53 26.75 36.68 27.39", "figure_data": "BilingualWMT-14TEDEn-XDeEs PTbrFrRuHeArItNlRoTrDeViBPE-30K 29.31 X-En DeEs PTbrFrRuHeArItNlRoTrDeViBPE-30K 32.60 Vocab Size (K) DeEs PTbrFrRuHeArItNlRoTrDeViBPE-30K33.629.9 29.8 29.8 30.1 30.0 30.3 33.5 29.8 29.8 29.9 30.0 29.9VOLT11.65.35.29.23.37.39.43.22.43.27.28.28.4"}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_2", "figure_caption": "Comparison between vocabularies search by VOLT and BPE-1K, recommended by Ding et al. (2019) for low-resource datasets. Here we take TED X-En bilingual translation as an example. This table demonstrates that vocabularies searched by VOLT are on par with heuristically-searched vocabularies in terms of BLEU scores. 45.58 40.90 24.94 38.62 32.23 38.75 37.44 35.74 25.94 37.00 27.28 35.65 VOLT 42.34 45.93 40.72 25.33 38.70 32.97 39.09 37.31 36.53 26.75 36.68 27.39 35.81", "figure_data": "X-EnEs PTbrFrRuHeArItNlRoTrDeViAvgBPE-1K 42.36 Vocab Size (K) Es PTbrFrRuHeArKoItNlRoTrDeAvgBPE-1K1.41.31.31.41.31.54.71.21.21.21.21.21.6VOLT5.35.29.23.37.39.43.22.43.27.28.28.46.0size reduction. The promising results demonstratethat VOLT is a practical approach that can finda well-performing vocabulary with higher BLEUand smaller size.Vocabularies Searched by VOLT are on Parwith Heuristically-searched Vocabularies onLow-resource Datasets.Ding et al. ("}, {"figure_label": "4", "figure_type": "table", "figure_id": "tab_3", "figure_caption": "", "figure_data": ": Results of VOLT, MUV-Search and BPE-Search. MUV-Search does not require full training andsaves a lot of costs. Among them, VOLT is the mostefficient solution. MUV-Search and VOLT require ad-ditional costs for downstream evaluation, which takesaround 32 GPU hours. \"GH\" and \"CH\" represent GPUhours and CPU hours, respectively.En-DeBLEUSizeCostBPE-Search29.912.6K384 GHMUV-Search29.79.70K 5.4 CH + 30 GHVOLT29.811.6K 0.5 CH + 30 GHWe generate a sequence of BPE vocabularies withincremental size 1K, 2K, 3K, 4K, 5K, 6K, 7K, 8K,9K, 10K, 20K. For t-th vocabulary v(t), its MUVscore is calculated according to v(t) and v(t \u2212 1).We enumerate all vocabularies and select the vo-cabulary with the highest MUV as the final vocab-ulary. The comparison between VOLT and MUV-Search is shown in Table 4. Although MUV-Search does not require downstream full-training,it still takes a lot of time to generate vocabular-ies and calculate MUV. Among them, VOLT is themost efficient approach."}, {"figure_label": "5", "figure_type": "table", "figure_id": "tab_4", "figure_caption": "Comparison between VOLT and strong baselines. VOLT achieves almost the best performance with a much smaller vocabulary.", "figure_data": "En-DeBLEU Parameters(Vaswani et al., 2017)28.4210M(Shaw et al., 2018)29.2213M(Ott et al., 2018)29.3210M(So et al., 2019)29.8218M(Liu et al., 2020)30.1256MSentencePiece28.7210MWordPiece29.0210MVOLT29.8188M"}, {"figure_label": "6", "figure_type": "table", "figure_id": "tab_5", "figure_caption": "", "figure_data": ": Vocabularies searched by VOLT are bet-ter than widely-used vocabularies on various archi-tectures. Here \"better\" means competitive results butmuch smaller sizes.En-DeApproach BLEUSizeTransformer-bigBPE-30K VOLT29.3 29.833.6K 11.6KConvolutional Seq2SeqBPE-30K VOLT26.4 26.333.6K 11.6K"}, {"figure_label": "6", "figure_type": "table", "figure_id": "tab_6", "figure_caption": "demonstrates that vocabularies searched by VOLT also works on Convolutional Seq2Seq with competitive BLEU but much smaller size. In this work, we verify the effectiveness of VOLT on architectures with standard sizes. Since model capacity is also an important factor on BLEU scores, we recommend larger vocabularies associated with more embedding parameters for small architectures.VOLT can Bring Slight Speedup During Training. We evaluate the running time for VOLT vocabulary and BPE-30K on WMT En-De translation. The model with VOLT-searched vocabulary (11.6k tokens) can process 133 sentences per second, while the model with BPE-30K (33.6k tokens) only executes 101 sentences per second.", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "M v(k+m) = \u2212(H v(k+m) \u2212 H v(k) ) m ,(1)", "formula_coordinates": [3.0, 112.85, 697.23, 177.42, 20.4]}, {"formula_id": "formula_1", "formula_text": "Hv = \u2212 1 lv i\u2208v P (i) log P (i),(2)", "formula_coordinates": [3.0, 361.31, 130.02, 164.23, 23.47]}, {"formula_id": "formula_2", "formula_text": ", S = {i, 2 \u2022 i, ..., (t \u2212 1) \u2022 i, \u2022 \u2022 \u2022 }", "formula_coordinates": [4.0, 120.12, 290.95, 141.06, 9.84]}, {"formula_id": "formula_3", "formula_text": "arg max v(t\u22121) \u2208 V S[t\u22121] ,v(t)\u2208V S[t] M v(t) = arg max v(t\u22121)\u2208V S[t\u22121] ,v(t)\u2208V S[t] \u2212 1 i H v(t) \u2212 H v(t\u2212", "formula_coordinates": [4.0, 93.53, 408.45, 162.53, 43.92]}, {"formula_id": "formula_4", "formula_text": "arg max t 1 i max v(t)\u2208V S[t] H v(t) \u2212 max v(t\u22121)\u2208V S[t\u22121] H v(t\u22121) .(3)", "formula_coordinates": [4.0, 78.65, 533.67, 211.62, 30.87]}, {"formula_id": "formula_5", "formula_text": "V S[t] .", "formula_coordinates": [4.0, 265.15, 691.98, 25.12, 10.87]}, {"formula_id": "formula_6", "formula_text": "arg max v(t)\u2208V S[t] \u2212 1 l v(t) i\u2208v(t) P (i) log P (i),(4)", "formula_coordinates": [4.0, 112.81, 743.12, 177.46, 23.99]}, {"formula_id": "formula_7", "formula_text": "min v\u2208V S[t] 1 lv i\u2208v P (i) log P (i), s.t. P (i) = Token(i) i\u2208v Token(i) , lv = i\u2208v len(i) |v| .", "formula_coordinates": [4.0, 323.71, 548.37, 185.4, 51.36]}, {"formula_id": "formula_8", "formula_text": "min v\u2208V S[t] 1 lv i\u2208v P (i) log P (i) \u2264 1 l T i\u2208T P (i) log P (i). (5", "formula_coordinates": [5.0, 79.1, 136.81, 207.68, 23.63]}, {"formula_id": "formula_9", "formula_text": ")", "formula_coordinates": [5.0, 286.78, 142.89, 3.48, 7.77]}, {"formula_id": "formula_10", "formula_text": "i\u2208T P (i) log P (i) = i\u2208T j\u2208C P (i, j) log P (i) = i\u2208T j\u2208C P (i, j) log P (i, j) L 1 + i\u2208T j\u2208C P (i, j)(\u2212 log P (j|i)) L 2 . (6)", "formula_coordinates": [5.0, 82.08, 278.11, 208.19, 100.68]}, {"formula_id": "formula_11", "formula_text": "L2 = P , D = i j P (i, j)D(i, j).(7)", "formula_coordinates": [5.0, 106.13, 498.53, 184.14, 17.7]}, {"formula_id": "formula_12", "formula_text": "min P \u2208R m\u00d7n P , D \u2212 \u03b3H(P ).(8)", "formula_coordinates": [5.0, 128.9, 582.51, 161.37, 13.84]}, {"formula_id": "formula_13", "formula_text": "D(i, j) = \u2212 log P (j|i) = +\u221e, if j / \u2208 i \u2212 log P (j|i) = \u2212 log 1 len(i) , otherwise", "formula_coordinates": [5.0, 313.74, 103.58, 204.14, 22.28]}, {"formula_id": "formula_14", "formula_text": "| j P (i, j) \u2212 P (i)| \u2264 ,(9)", "formula_coordinates": [5.0, 368.59, 240.42, 156.95, 17.7]}, {"formula_id": "formula_16", "formula_text": "arg min P \u2208R |C|\u00d7|T| \u2212H(P ) + P , D , s.t. i P (i, j) = P (j), | j P (i, j) \u2212 P (i)| \u2264 ,", "formula_coordinates": [5.0, 315.31, 350.71, 202.21, 41.48]}, {"formula_id": "formula_17", "formula_text": "=", "formula_coordinates": [13.0, 151.86, 159.56, 8.49, 9.57]}, {"formula_id": "formula_18", "formula_text": "=", "formula_coordinates": [13.0, 151.86, 190.95, 8.49, 9.57]}, {"formula_id": "formula_19", "formula_text": "L 1 +", "formula_coordinates": [13.0, 215.55, 190.95, 72.46, 40.22]}, {"formula_id": "formula_20", "formula_text": "L 2 .", "formula_coordinates": [13.0, 349.58, 190.95, 74.58, 40.22]}], "doi": ""}