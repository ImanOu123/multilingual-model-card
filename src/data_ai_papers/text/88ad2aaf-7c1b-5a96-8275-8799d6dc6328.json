{"title": "Unsupervised Semantic Parsing", "authors": "Hoifung Poon; Pedro Domingos", "pub_date": "", "abstract": "We present the first unsupervised approach to the problem of learning a semantic parser, using Markov logic. Our USP system transforms dependency trees into quasi-logical forms, recursively induces lambda forms from these, and clusters them to abstract away syntactic variations of the same meaning. The MAP semantic parse of a sentence is obtained by recursively assigning its parts to lambda-form clusters and composing them. We evaluate our approach by using it to extract a knowledge base from biomedical abstracts and answer questions. USP substantially outperforms TextRunner, DIRT and an informed baseline on both precision and recall on this task.", "sections": [{"heading": "Introduction", "text": "Semantic parsing maps text to formal meaning representations. This contrasts with semantic role labeling (Carreras and Marquez, 2004) and other forms of shallow semantic processing, which do not aim to produce complete formal meanings. Traditionally, semantic parsers were constructed manually, but this is too costly and brittle. Recently, a number of machine learning approaches have been proposed (Zettlemoyer and Collins, 2005;Mooney, 2007). However, they are supervised, and providing the target logical form for each sentence is costly and difficult to do consistently and with high quality. Unsupervised approaches have been applied to shallow semantic tasks (e.g., paraphrasing (Lin and Pantel, 2001), information extraction (Banko et al., 2007)), but not to semantic parsing.\nIn this paper we develop the first unsupervised approach to semantic parsing, using Markov logic (Richardson and Domingos, 2006). Our USP system starts by clustering tokens of the same type, and then recursively clusters expressions whose subexpressions belong to the same clusters. Experiments on a biomedical corpus show that this approach is able to successfully translate syntactic variations into a logical representation of their common meaning (e.g., USP learns to map active and passive voice to the same logical form, etc.). This in turn allows it to correctly answer many more questions than systems based on TextRunner (Banko et al., 2007) and DIRT (Lin and Pantel, 2001).\nWe begin by reviewing the necessary background on semantic parsing and Markov logic. We then describe our Markov logic network for unsupervised semantic parsing, and the learning and inference algorithms we used. Finally, we present our experiments and results.", "publication_ref": ["b2", "b18", "b13", "b10", "b1", "b16", "b1", "b10"], "figure_ref": [], "table_ref": []}, {"heading": "Background", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Semantic Parsing", "text": "The standard language for formal meaning representation is first-order logic. A term is any expression representing an object in the domain. An atomic formula or atom is a predicate symbol applied to a tuple of terms. Formulas are recursively constructed from atomic formulas using logical connectives and quantifiers. A lexical entry defines the logical form for a lexical item (e.g., a word). The semantic parse of a sentence is derived by starting with logical forms in the lexical entries and recursively composing the meaning of larger fragments from their parts. In traditional approaches, the lexical entries and meaning-composition rules are both manually constructed. Below are sample rules in a definite clause grammar (DCG) for parsing the sentence: \"Utah borders Idaho\".\nV erb [\u03bby\u03bbx.borders(x, y)\n] \u2192 borders N P [Utah] \u2192 U tah N P [Idaho] \u2192 Idaho V P [rel(obj)] \u2192 V erb[rel] N P [obj] S[rel(obj)] \u2192 N P [obj] V P [rel]\nThe first three lines are lexical entries. They are fired upon seeing the individual words. For example, the first rule applies to the word \"borders\" and generates syntactic category Verb with the meaning \u03bby\u03bbx.borders(x, y) that represents the nextto relation. Here, we use the standard lambdacalculus notation, where \u03bby\u03bbx.borders(x, y) represents a function that is true for any (x, y)pair such that borders(x, y) holds. The last two rules compose the meanings of sub-parts into that of the larger part. For example, after the first and third rules are fired, the fourth rule fires and generates V P [\u03bby\u03bbx.borders(x, y)(Idaho)]; this meaning simplifies to \u03bbx.borders(x, Idaho) by the \u03bb-reduction rule, which substitutes the argument for a variable in a functional application.\nA major challenge to semantic parsing is syntactic variations of the same meaning, which abound in natural languages. For example, the aforementioned sentence can be rephrased as \"Utah is next to Idaho,\"\"Utah shares a border with Idaho,\" etc. Manually encoding all these variations into the grammar is tedious and error-prone. Supervised semantic parsing addresses this issue by learning to construct the grammar automatically from sample meaning annotations (Mooney, 2007). Existing approaches differ in the meaning representation languages they use and the amount of annotation required. In the approach of Zettlemoyer and Collins (2005), the training data consists of sentences paired with their meanings in lambda form. A probabilistic combinatory categorial grammar (PCCG) is learned using a loglinear model, where the probability of the final logical form L and meaning-derivation tree T conditioned on the sentence S is P (L,\nT |S) = 1 Z exp ( i w i f i (L, T, S)).\nHere Z is the normalization constant and f i are the feature functions with weights w i . Candidate lexical entries are generated by a domain-specific procedure based on the target logical forms.\nThe major limitation of supervised approaches is that they require meaning annotations for example sentences. Even in a restricted domain, doing this consistently and with high quality requires nontrivial effort. For unrestricted text, the complexity and subjectivity of annotation render it essentially infeasible; even pre-specifying the target predicates and objects is very difficult. Therefore, to apply semantic parsing beyond limited domains, it is crucial to develop unsupervised methods that do not rely on labeled meanings.\nIn the past, unsupervised approaches have been applied to some semantic tasks, but not to semantic parsing. For example, DIRT (Lin and Pantel, 2001) learns paraphrases of binary relations based on distributional similarity of their arguments; TextRunner (Banko et al., 2007) automatically extracts relational triples in open domains using a self-trained extractor; SNE applies relational clustering to generate a semantic network from TextRunner triples (Kok and Domingos, 2008). While these systems illustrate the promise of unsupervised methods, the semantic content they extract is nonetheless shallow and does not constitute the complete formal meaning that can be obtained by a semantic parser.\nAnother issue is that existing approaches to semantic parsing learn to parse syntax and semantics together. 1 The drawback is that the complexity in syntactic processing is coupled with semantic parsing and makes the latter even harder. For example, when applying their approach to a different domain with somewhat less rigid syntax, Zettlemoyer and Collins (2007) need to introduce new combinators and new forms of candidate lexical entries. Ideally, we should leverage the enormous progress made in syntactic parsing and generate semantic parses directly from syntactic analysis.", "publication_ref": ["b13", "b18", "b10", "b1", "b8", "b19"], "figure_ref": [], "table_ref": []}, {"heading": "Markov Logic", "text": "In many NLP applications, there exist rich relations among objects, and recent work in statistical relational learning (Getoor and Taskar, 2007) and structured prediction (Bakir et al., 2007) has shown that leveraging these can greatly improve accuracy. One of the most powerful representations for this is Markov logic, which is a probabilistic extension of first-order logic (Richardson and Domingos, 2006). Markov logic makes it possible to compactly specify probability distributions over complex relational domains, and has been successfully applied to unsupervised coreference resolution (Poon and Domingos, 2008) and other tasks. A Markov logic network (MLN) is a set of weighted first-order clauses. Together with a set of constants, it defines a Markov network with one node per ground atom and one feature per ground clause. The weight of a feature is the weight of the first-order clause that originated it. The probability of a state x in such a network is given by the log-linear model P (x) = 1 Z exp ( i w i n i (x)), where Z is a normalization constant, w i is the weight of the ith formula, and n i is the number of satisfied groundings.", "publication_ref": ["b0", "b16", "b15"], "figure_ref": [], "table_ref": []}, {"heading": "Unsupervised Semantic Parsing with Markov Logic", "text": "Unsupervised semantic parsing (USP) rests on three key ideas. First, the target predicate and object constants, which are pre-specified in supervised semantic parsing, can be viewed as clusters of syntactic variations of the same meaning, and can be learned from data. For example, borders represents the next-to relation, and can be viewed as the cluster of different forms for expressing this relation, such as \"borders\", \"is next to\", \"share the border with\"; Utah represents the state of Utah, and can be viewed as the cluster of \"Utah\", \"the beehive state\", etc. Second, the identification and clustering of candidate forms are integrated with the learning for meaning composition, where forms that are used in composition with the same forms are encouraged to cluster together, and so are forms that are composed of the same sub-forms. This amounts to a novel form of relational clustering, where clustering is done not just on fixed elements in relational tuples, but on arbitrary forms that are built up recursively.\nThird, while most existing approaches (manual or supervised learning) learn to parse both syntax and semantics, unsupervised semantic parsing starts directly from syntactic analyses and focuses solely on translating them to semantic content. This enables us to leverage advanced syntactic parsers and (indirectly) the available rich resources for them. More importantly, it separates the complexity in syntactic analysis from the semantic one, and makes the latter much easier to perform. In particular, meaning composition does not require domain-specific procedures for generating candidate lexicons, as is often needed by supervised methods.\nThe input to our USP system consists of dependency trees of training sentences. Compared to phrase-structure syntax, dependency trees are the more appropriate starting point for semantic processing, as they already exhibit much of the relation-argument structure at the lexical level.\nUSP first uses a deterministic procedure to convert dependency trees into quasi-logical forms (QLFs). The QLFs and their sub-formulas have natural lambda forms, as will be described later. Starting with clusters of lambda forms at the atom level, USP recursively builds up clusters of larger lambda forms. The final output is a probability distribution over lambda-form clusters and their compositions, as well as the MAP semantic parses of training sentences.\nIn the remainder of the section, we describe the details of USP. We first present the procedure for generating QLFs from dependency trees. We then introduce their lambda forms and clusters, and show how semantic parsing works in this setting. Finally, we present the Markov logic network (MLN) used by USP. In the next sections, we present efficient algorithms for learning and inference with this MLN.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Derivation of Quasi-Logical Forms", "text": "A dependency tree is a tree where nodes are words and edges are dependency labels. To derive the QLF, we convert each node to an unary atom with the predicate being the lemma plus POS tag (below, we still use the word for simplicity), and each edge to a binary atom with the predicate being the dependency label. For example, the node for Utah becomes Utah(n 1 ) and the subject dependency becomes nsubj(n1, n2). Here, the n i are Skolem constants indexed by the nodes. The QLF for a sentence is the conjunction of the atoms for the nodes and edges, e.g., the sentence above will become borders(n\n1 ) \u2227 Utah(n 2 ) \u2227 Idaho(n 3 ) \u2227 nsubj(n 1 , n 2 ) \u2227 dobj(n 1 , n 3 ).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Lambda-Form Clusters and Semantic", "text": "Parsing in USP Given a QLF, a relation or an object is represented by the conjunction of a subset of the atoms. For example, the next-to relation is represented by borders(n 1 ) \u2227 nsubj(n 1 , n 2 ) \u2227 dobj(n 1 , n 3 ), and the states of Utah and Idaho are represented by Utah(n 2 ) and Idaho(n 3 ). The meaning composition of two sub-formulas is simply their conjunction. This allows the maximum flexibility in learning. In particular, lexical entries are no longer limited to be adjacent words as in Zettlemoyer and Collins (2005), but can be arbitrary fragments in a dependency tree.\nFor every sub-formula F , we define a corresponding lambda form that can be derived by replacing every Skolem constant n i that does not appear in any unary atom in F with a unique lambda variable x i . Intuitively, such constants represent objects introduced somewhere else (by the unary atoms containing them), and correspond to the arguments of the relation represented by F . For example, the lambda form for borders(n\n1 ) \u2227 nsubj(n 1 , n 2 ) \u2227 dobj(n 1 , n 3 ) is \u03bbx 2 \u03bbx 3 . borders(n 1 ) \u2227 nsubj(n 1 , x 2 ) \u2227 dobj(n 1 , x 3 ).\nConceptually, a lambda-form cluster is a set of semantically interchangeable lambda forms. For example, to express the meaning that Utah borders Idaho, we can use any form in the cluster representing the next-to relation (e.g., \"borders\", \"shares a border with\"), any form in the cluster representing the state of Utah (e.g., \"the beehive state\"), and any form in the cluster representing the state of Idaho (e.g., \"Idaho\"). Conditioned on the clusters, the choices of individual lambda forms are independent of each other.\nTo handle variable number of arguments, we follow Davidsonian semantics and further decompose a lambda form into the core form, which does not contain any lambda variable (e.g., borders(n 1 )), and the argument forms, which contain a single lambda variable (e.g., \u03bbx 2 .nsubj(n 1 , x 2 ) and \u03bbx 3 .dobj(n 1 , x 3 )). Each lambda-form cluster may contain some number of argument types, which cluster distinct forms of the same argument in a relation. For example, in Stanford dependencies, the object of a verb uses the dependency dobj in the active voice, but nsubjpass in passive.\nLambda-form clusters abstract away syntactic variations of the same meaning. Given an instance of cluster T with arguments of argument types\nA 1 , \u2022 \u2022 \u2022 , A k , its abstract lambda form is given by \u03bbx 1 \u2022 \u2022 \u2022 \u03bbx k .T(n) \u2227 k i=1 A i (n, x i ).\nGiven a sentence and its QLF, semantic parsing amounts to partitioning the atoms in the QLF, dividing each part into core form and argument forms, and then assigning each form to a cluster or an argument type. The final logical form is derived by composing the abstract lambda forms of the parts using the \u03bb-reduction rule. 2", "publication_ref": ["b18"], "figure_ref": [], "table_ref": []}, {"heading": "The USP MLN", "text": "Formally, for a QLF Q, a semantic parse L partitions Q into parts p 1 , p 2 , \u2022 \u2022 \u2022 , p n ; each part p is assigned to some lambda-form cluster c, and is further partitioned into core form f and argument forms f 1 , \u2022 \u2022 \u2022 , f k ; each argument form is assigned to an argument type a in c. The USP MLN defines a joint probability distribution over Q and L by modeling the distributions over forms and arguments given the cluster or argument type.\nBefore presenting the predicates and formulas in our MLN, we should emphasize that they should not be confused with the atoms and formulas in the QLFs, which are represented by reified constants and variables.\nTo model distributions over lambda forms, we introduce the predicates Form(p, f!) and ArgForm(p, i, f!), where p is a part, i is the index of an argument, and f is a QLF subformula. Form(p, f) is true iff part p has core form f, and ArgForm(p, i, f) is true iff the ith argument in p has form f. 3 The \"f!\" notation signifies that each part or argument can have only one form.\nTo model distributions over arguments, we introduce three more predicates: ArgType(p, i, a!) signifies that the ith argument of p is assigned to argument type a; Arg(p, i, p \u2032 ) signifies that the ith argument of p is p \u2032 ; Number(p, a, n) signifies that there are n arguments of p that are assigned to type a. The truth value of Number(p, a, n) is determined by the ArgType atoms.\nUnsupervised semantic parsing can be captured by four formulas:\np \u2208 +c \u2227 Form(p, +f) ArgType(p, i, +a) \u2227 ArgForm(p, i, +f) Arg(p, i, p \u2032 ) \u2227 ArgType(p, i, +a) \u2227 p \u2032 \u2208 +c \u2032 Number(p, +a, +n)\nAll free variables are implicitly universally quantified. The \"+\" notation signifies that the MLN contains an instance of the formula, with a separate weight, for each value combination of the variables with a plus sign. The first formula models the mixture of core forms given the cluster, and the others model the mixtures of argument forms, argument types, and argument numbers, respectively, given the argument type.\nTo encourage clustering and avoid overfitting, we impose an exponential prior with weight \u03b1 on the number of parameters. 4 The MLN above has one problem: it often clusters expressions that are semantically opposite. For example, it clusters antonyms like \"elderly/young\", \"mature/immature\". This issue also occurs in other semantic-processing systems (e.g., DIRT). In general, this is a difficult open problem that only recently has started to receive some attention (Mohammad et al., 2008). Resolving this is not the focus of this paper, but we describe a general heuristic for fixing this problem. We observe that the problem stems from the lack of negative features for discovering meanings in contrast. In natural languages, parallel structures like conjunctions are one such feature. 5 We thus introduce an exponential prior with weight \u03b2 on the number of conjunctions where the two conjunctive parts are assigned to the same cluster. To detect conjunction, we simply used the Stanford dependencies that begin with \"conj\". This proves very effective, fixing the majority of the errors in our experiments.", "publication_ref": ["b12"], "figure_ref": [], "table_ref": []}, {"heading": "Inference", "text": "Given a sentence and the quasi-logical form Q derived from its dependency tree, the conditional probability for a semantic parse L is given by P r(L|Q) \u221d exp ( i w i n i (L, Q)). The MAP semantic parse is simply arg max L i w i n i (L, Q). Enumerating all L's is intractable. It is also unnecessary, since most partitions will result in parts whose lambda forms have no cluster they can be assigned to. Instead, USP uses a greedy algorithm to search for the MAP parse. First we introduce some definitions: a partition is called \u03bb-reducible from p if it can be obtained from the current partition by recursively \u03bb-reducing the part containing p with one of its arguments; such a partition is Algorithm 1 USP-Parse(MLN, QLF)\nForm parts for individual atoms in QLF and assign each to its most probable cluster repeat for all parts p in the current partition do for all partitions that are \u03bb-reducible from p and feasible do Find the most probable cluster and argument type assignments for the new part and its arguments end for end for Change to the new partition and assignments with the highest gain in probability until none of these improve the probability return current partition and assignments called feasible if the core form of the new part is contained in some cluster. For example, consider the QLF of \"Utah borders Idaho\" and assume that the current partition is \u03bbx\n2 x 3 .borders(n 1 ) \u2227 nsubj(n 1 , x 2 ) \u2227 dobj(n 1 , x 3 ), Utah(n 2 ), Idaho(n 3 ).\nThen the following partition is \u03bb-reducible from the first part in the above partition:\n\u03bbx 3 .borders(n 1 ) \u2227 nsubj(n 1 , n 2 ) \u2227 Utah(n 2 ) \u2227 dobj(n 1 , x 3 ), Idaho(n 3 ).\nWhether this new partition is feasible depends on whether the core form of the new part \u03bbx 3 .borders(n 1 ) \u2227 nsubj(n 1 , n 2 ) \u2227 Utah(n 2 ) \u2227 dobj(n 1 , x 3 ) (i.e. borders(n 1 ) \u2227 nsubj(n 1 , n 2 ) \u2227 Utah(n 2 )) is contained in some lambda-form cluster.\nAlgorithm 1 gives pseudo-code for our algorithm. Given part p, finding partitions that are \u03bbreducible from p and feasible can be done in time O(ST ), where S is the size of the clustering in the number of core forms and T is the maximum number of atoms in a core form. We omit the proof here but point out that it is related to the unordered subtree matching problem which can be solved in linear time (Kilpelainen, 1992). Inverted indexes (e.g., from p to eligible core forms) are used to further improve the efficiency. For a new part p and a cluster that contains p's core form, there are k m ways of assigning p's m arguments to the k argument types of the cluster. For larger k and m, this is very expensive. We therefore approximate it by assigning each argument to the best type, independent of other arguments. This algorithm is very efficient, and is used repeatedly in learning.", "publication_ref": ["b6"], "figure_ref": [], "table_ref": []}, {"heading": "Learning", "text": "The learning problem in USP is to maximize the log-likelihood of observing the QLFs obtained from the dependency trees, denoted by Q, summing out the unobserved semantic parses:\nL \u03b8 (Q) = log P \u03b8 (Q) = log L P \u03b8 (Q, L)\nHere, L are the semantic parses, \u03b8 are the MLN parameters, and P \u03b8 (Q, L) are the completion likelihoods. A serious challenge in unsupervised learning is the identifiability problem (i.e., the optimal parameters are not unique) (Liang and Klein, 2008). This problem is particularly severe for log-linear models with hard constraints, which are common in MLNs. For example, in our USP MLN, conditioned on the fact that p \u2208 c, there is exactly one value of f that can satisfy the formula p \u2208 c \u2227 Form(p, f), and if we add some constant number to the weights of p \u2208 c \u2227 Form(p, f) for all f, the probability distribution stays the same. 6 The learner can be easily confused by the infinitely many optima, especially in the early stages. To address this problem, we impose local normalization constraints on specific groups of formulas that are mutually exclusive and exhaustive, i.e., in each group, we require that k i=1 e w i = 1, where w i are the weights of formulas in the group. Grouping is done in such a way as to encourage the intended mixture behaviors. Specifically, for the rule p \u2208 +c \u2227 Form(p, +f), all instances given a fixed c form a group; for each of the remaining three rules, all instances given a fixed a form a group. Notice that with these constraints the completion likelihood P (Q, L) can be computed in closed form for any L. In particular, each formula group contributes a term equal to the weight of the currently satisfied formula. In addition, the optimal weights that maximize the completion likelihood P (Q, L) can be derived in closed form using empirical relative frequencies. E.g., the optimal weight of p \u2208 c \u2227 Form(p, f) is log(n c,f /n c ), where n c,f is the number of parts p that satisfy both p \u2208 c and Form(p, f), and n c is the number of parts p that satisfy p \u2208 c. 7 We leverage this fact for efficient learning in USP. 6 Regularizations, e.g., Gaussian priors on weights, alleviate this problem by penalizing large weights, but it remains true that weights within a short range are roughly equivalent. 7 To see this, notice that for a given c, the total contribution to the completion likelihood from all groundings in its formula group is f wc,fnc,f. In addition, f nc,f = nc Another major challenge in USP learning is the summation in the likelihood, which is over all possible semantic parses for a given dependency tree. Even an efficient sampler like MC-SAT (Poon and Domingos, 2006), as used in Poon & Domingos (2008), would have a hard time generating accurate estimates within a reasonable amount of time. On the other hand, as already noted in the previous section, the lambda-form distribution is generally sparse. Large lambda-forms are rare, as they correspond to complex expressions that are often decomposable into smaller ones. Moreover, while ambiguities are present at the lexical level, they quickly diminish when more words are present. Therefore, a lambda form can usually only belong to a small number of clusters, if not a unique one. We thus simplify the problem by approximating the sum with the mode, and search instead for the L and \u03b8 that maximize log P \u03b8 (Q, L). Since the optimal weights and log-likelihood can be derived in closed form given the semantic parses L, we simply search over semantic parses, evaluating them using log-likelihood.\nAlgorithm 2 gives pseudo-code for our algorithm. The input consists of an MLN without weights and the QLFs for the training sentences. Two operators are used for updating semantic parses. The first is to merge two clusters, denoted by MERGE(C 1 , C 2 ) for clusters C 1 , C 2 , which does the following: and there is the local normalization constraint f e wc,f = 1. The optimal weights wc,f are easily derived by solving this constrained optimization problem.\n1. Create a new cluster C and add all core forms in C 1 , C 2 to C;\n2. Create new argument types for C by merging those in C 1 , C 2 so as to maximize the loglikelihood;\n3. Remove C 1 , C 2 .\nHere, merging two argument types refers to pooling their argument forms to create a new argument type. Enumerating all possible ways of creating new argument types is intractable. USP approximates it by considering one type at a time and either creating a new type for it or merging it to types already considered, whichever maximizes the loglikelihood. The types are considered in decreasing order of their numbers of occurrences so that more information is available for each decision. MERGE clusters syntactically different expressions whose meanings appear to be the same according to the model. The second operator is to create a new cluster by composing two existing ones, denoted by COMPOSE(C R , C A ), which does the following:\n1. Create a new cluster C; 2. Find all parts r \u2208 C R , a \u2208 C A such that a is an argument of r, compose them to r(a) by \u03bb-reduction and add the new part to C;\n3. Create new argument types for C from the argument forms of r(a) so as to maximize the log-likelihood.\nCOMPOSE creates clusters of large lambda-forms if they tend to be composed of the same subforms (e.g., the lambda form for \"is next to\"). These lambda-forms may later be merged with other clusters (e.g., borders). At learning time, USP maintains an agenda that contains operations that have been evaluated and are pending execution. During initialization, USP forms a part and creates a new cluster for each unary atom u(n). It also assigns binary atoms of the form b(n, n \u2032 ) to the part as argument forms and creates a new argument type for each. This forms the initial clustering and semantic parses. USP then merges clusters with the same core form (i.e., the same unary predicate) using MERGE. 8 At each step, USP evaluates the candidate operations and adds them to the agenda if the improvement is above a threshold. 9 The operation with the highest score is executed, and the parameters are updated with the new optimal values. The QLFs which contain an affected part are reparsed, and operations in the agenda whose score might be affected are re-evaluated. These changes are done very efficiently using inverted indexes. We omit the details here due to space limitations. USP terminates when the agenda is empty, and outputs the current MLN parameters and semantic parses.\nUSP learning uses the same optimization objective as hard EM, and is also guaranteed to find a local optimum since at each step it improves the log-likelihood. It differs from EM in directly optimizing the likelihood instead of a lower bound.", "publication_ref": ["b9", "b14", "b15"], "figure_ref": [], "table_ref": []}, {"heading": "Experiments", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Task", "text": "Evaluating unsupervised semantic parsers is difficult, because there is no predefined formal language or gold logical forms for the input sentences. Thus the best way to test them is by using them for the ultimate goal: answering questions based on the input corpus. In this paper, we applied USP to extracting knowledge from biomedical abstracts and evaluated its performance in answering a set of questions that simulate the information needs of biomedical researchers. We used the GENIA dataset (Kim et al., 2003) as the source for knowledge extraction. It contains 1999 PubMed abstracts and marks all mentions of biomedical entities according to the GENIA ontology, such as cell, protein, and DNA. As a first approximation to the questions a biomedical researcher might ask, we generated a set of two thousand questions on relations between entities. Sample questions are: \"What regulates MIP-1alpha?\", \"What does anti-STAT 1 inhibit?\". To simulate the real information need, we sample the relations from the 100 most frequently used verbs (excluding the auxiliary verbs be, have, and do), and sample the entities from those annotated in GENIA, both according to their numbers of occurrences. We evaluated USP by the number of answers it provided and the accuracy as determined by manual labeling. 10", "publication_ref": ["b7"], "figure_ref": [], "table_ref": []}, {"heading": "Systems", "text": "Since USP is the first unsupervised semantic parser, conducting a meaningful comparison of it with other systems is not straightforward. Standard question-answering (QA) benchmarks do not provide the most appropriate comparison, because they tend to simultaneously emphasize other aspects not directly related to semantic parsing. Moreover, most state-of-the-art QA systems use supervised learning in their key components and/or require domain-specific engineering efforts. The closest available system to USP in aims and capabilities is TextRunner (Banko et al., 2007), and we compare with it. TextRunner is the state-of-the-art system for open-domain information extraction; its goal is to extract knowledge from text without using supervised labels. Given that a central challenge to semantic parsing is resolving syntactic variations of the same meaning, we also compare with RESOLVER (Yates and Etzioni, 2009), a state-of-the-art unsupervised system based on TextRunner for jointly resolving entities and relations, and DIRT (Lin and Pantel, 2001), which resolves paraphrases of binary relations. Finally, we also compared to an informed baseline based on keyword matching. Keyword: We consider a baseline system based on keyword matching. The question substring containing the verb and the available argument is directly matched with the input text, ignoring case and morphology. We consider two ways to derive the answer given a match. The first one (KW) simply returns the rest of sentence on the other side of the verb. The second one (KW-SYN) is informed by syntax: the answer is extracted from the subject or object of the verb, depending on the question. If the verb does not contain the expected argument, the sentence is ignored. TextRunner: TextRunner inputs text and outputs relational triples in the form (R, A 1 , A 2 ), where R is the relation string, and A 1 , A 2 the argument strings. Given a triple and a question, we first match their relation strings, and then match the strings for the argument that is present in the question. If both match, we return the other argument string in the triple as an answer. We report results when exact match is used (TR-EXACT), or when the triple string can contain the question one as a substring (TR-SUB). RESOLVER: RESOLVER (Yates and Etzioni, 2009) inputs TextRunner triples and collectively resolves coreferent relation and argument strings. On the GENIA data, using the default parameters, RESOLVER produces only a few trivial relation clusters and no argument clusters. This is not surprising, since RESOLVER assumes high redundancy in the data, and will discard any strings with fewer than 25 extractions. For a fair comparison, we also ran RESOLVER using all extractions, and manually tuned the parameters based on eyeballing of clustering quality. The best result was obtained with 25 rounds of execution and with the entity multiple set to 200 (the default is 30). To answer questions, the only difference from TextRunner is that a question string can match any string in its cluster. As in TextRunner, we report results for both exact match (RS-EXACT) and substring (RS-SUB). DIRT: The DIRT system inputs a path and returns a set of similar paths. To use DIRT in question answering, we queried it to obtain similar paths for the relation of the question, and used these paths while matching sentences. We first used MINIPAR (Lin, 1998) to parse input text using the same dependencies as DIRT. To determine a match, we first check if the sentence contains the question path or one of its DIRT paths. If so, and if the available argument slot in the question is contained in the one in the sentence, it is a match, and we return the other argument slot from the sentence if it is present. Ideally, a fair comparison will require running DIRT on the GENIA text, but we were not able to obtain the source code. We thus resorted to using the latest DIRT database released by the author, which contains paths extracted from a large corpus with more than 1GB of text. This puts DIRT in a very advantageous position compared with other systems. In our experiments, we used the top three similar paths, as including more results in very low precision. USP: We built a system for knowledge extraction and question answering on top of USP. It generated Stanford dependencies (de Marneffe et al., 2006) from the input text using the Stanford parser, and then fed these to USP-Learn 11 , which produced an MLN with learned weights and the MAP semantic parses of the input sentences. These MAP parses formed our knowledge base (KB). To answer questions, the system first parses the questions 12 using USP-Parse with the learned MLN, and then matches the question parse to parses in the KB by testing subsumption (i.e., a question parse matches a KB one iff the former is subsumed by the latter). When a match occurs, our system then looks for arguments of type in accordance with the question. For example, if the question is \"What regulates MIP-1alpha?\", it searches for the argument type of the relation that contains the argument form \"nsubj\" for subject. If such an argument exists for the relation part, it will be returned as the answer.", "publication_ref": ["b1", "b17", "b10", "b17", "b11", "b3"], "figure_ref": [], "table_ref": []}, {"heading": "Results", "text": "Table 1 shows the results for all systems. USP extracted the highest number of answers, almost doubling that of the second highest (RS-SUB).\nIt obtained the highest accuracy at 88%, and the number of correct answers it extracted is three times that of the second highest system. The informed baseline (KW-SYN) did surprisingly well compared to systems other than USP, in terms of accuracy and number of correct answers. TextRunner achieved good accuracy when exact match is used (TR-EXACT), but only obtained a fraction of the answers compared to USP. With substring match, its recall substantially improved, but precision dropped more than 20 points. RE-SOLVER improved the number of extracted answers by sanctioning more matches based on the clusters it generated. However, most of those additional answers are incorrect due to wrong clustering. DIRT obtained the second highest number of correct answers, but its precision is quite low because the similar paths contain many errors.", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_1"]}, {"heading": "Qualitative Analysis", "text": "Manual inspection shows that USP is able to resolve many nontrivial syntactic variations without user supervision. It consistently resolves the syntactic difference between active and passive voices. It successfully identifies many distinct argument forms that mean the same (e.g., \"X stimulates Y\" \u2248 \"Y is stimulated with X\", \"expression of X\" \u2248 \"X expression\"). It also resolves many nouns correctly and forms meaningful groups of relations. Here are some sample clusters in core forms: {investigate, examine, evaluate, analyze, study, assay} {diminish, reduce, decrease, attenuate} {synthesis, production, secretion, release} {dramatically, substantially, significantly} An example question-answer pair, together with the source sentence, is shown below:\nQ: What does IL-13 enhance? A: The 12-lipoxygenase activity of murine macrophages.\nSentence: The data presented here indicate that (1) the 12-lipoxygenase activity of murine macrophages is upregulated in vitro and in vivo by IL-4 and/or IL-13, . . .", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Conclusion", "text": "This paper introduces the first unsupervised approach to learning semantic parsers. Our USP system is based on Markov logic, and recursively clusters expressions to abstract away syntactic variations of the same meaning. We have successfully applied USP to extracting a knowledge base from biomedical text and answering questions based on it.\nDirections for future work include: better handling of antonyms, subsumption relations among expressions, quantifier scoping, more complex lambda forms, etc.; use of context and discourse to aid expression clustering and semantic parsing; more efficient learning and inference; application to larger corpora; etc.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgements", "text": "We thank the anonymous reviewers for their comments. This ", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Predicting Structured Data", "journal": "MIT Press", "year": "2007", "authors": "G Bakir; T Hofmann; B B Sch\u00f6lkopf"}, {"ref_id": "b1", "title": "Open information extraction from the web", "journal": "AAAI Press", "year": "2007", "authors": "Michele Banko; Michael J Cafarella; Stephen Soderland; Matt Broadhead; Oren Etzioni"}, {"ref_id": "b2", "title": "Introduction to the CoNLL-2004 shared task: Semantic role labeling", "journal": "", "year": "2004", "authors": "Xavier Carreras; Luis Marquez"}, {"ref_id": "b3", "title": "Generating typed dependency parses from phrase structure parses", "journal": "", "year": "2006", "authors": "Marie-Catherine De Marneffe; Bill Maccartney; Christopher D Manning"}, {"ref_id": "b4", "title": "Learning a compositional semantic parser using an existing syntactic parser", "journal": "", "year": "2009", "authors": "Ruifang Ge; Raymond J Mooney"}, {"ref_id": "b5", "title": "Introduction to Statistical Relational Learning", "journal": "MIT Press", "year": "2007", "authors": ""}, {"ref_id": "b6", "title": "Tree Matching Problems with Applications to Structured Text databases", "journal": "", "year": "1992", "authors": "Pekka Kilpelainen"}, {"ref_id": "b7", "title": "GENIA corpus -a semantically annotated corpus for bio-textmining", "journal": "Bioinformatics", "year": "2003", "authors": "Jin-Dong Kim; Tomoko Ohta; Yuka Tateisi; Jun'ichi Tsujii"}, {"ref_id": "b8", "title": "Extracting semantic networks from text via relational clustering", "journal": "Springer", "year": "2008", "authors": "Stanley Kok; Pedro Domingos"}, {"ref_id": "b9", "title": "Analyzing the errors of unsupervised learning", "journal": "", "year": "2008", "authors": "Percy Liang; Dan Klein"}, {"ref_id": "b10", "title": "DIRT -discovery of inference rules from text", "journal": "ACM Press", "year": "2001", "authors": "Dekang Lin; Patrick Pantel"}, {"ref_id": "b11", "title": "Dependency-based evaluation of MINIPAR", "journal": "", "year": "1998", "authors": "Dekang Lin"}, {"ref_id": "b12", "title": "Computing word-pair antonymy", "journal": "", "year": "2008", "authors": "Saif Mohammad; Bonnie Dorr; Graeme Hirst"}, {"ref_id": "b13", "title": "Learning for semantic parsing", "journal": "Springer", "year": "2007", "authors": "Raymond J Mooney"}, {"ref_id": "b14", "title": "Sound and efficient inference with probabilistic and deterministic dependencies", "journal": "AAAI Press", "year": "2006", "authors": "Hoifung Poon; Pedro Domingos"}, {"ref_id": "b15", "title": "Joint unsupervised coreference resolution with Markov logic", "journal": "", "year": "2008", "authors": "Hoifung Poon; Pedro Domingos"}, {"ref_id": "b16", "title": "Markov logic networks. Machine Learning", "journal": "", "year": "2006", "authors": "M Richardson; P Domingos"}, {"ref_id": "b17", "title": "Unsupervised methods for determining object and relation synonyms on the web", "journal": "Journal of Artificial Intelligence Research", "year": "2009", "authors": "Alexander Yates; Oren Etzioni"}, {"ref_id": "b18", "title": "Learning to map sentences to logical form: Structured classification with probabilistic categorial grammers", "journal": "AUAI Press", "year": "2005", "authors": "Luke S Zettlemoyer; Michael Collins"}, {"ref_id": "b19", "title": "Online learning of relaxed CCG grammars for parsing to logical form", "journal": "", "year": "2007", "authors": "Luke S Zettlemoyer; Michael Collins"}], "figures": [{"figure_label": "1", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "Comparison of question answering results on the GENIA dataset.", "figure_data": "# Total # Correct AccuracyKW1506745%KW-SYN876777%TR-EXACT292379%TR-SUB1528153%RS-EXACT532445%RS-SUB1968141%DIRT1599459%USP33429588%"}], "formulas": [{"formula_id": "formula_0", "formula_text": "] \u2192 borders N P [Utah] \u2192 U tah N P [Idaho] \u2192 Idaho V P [rel(obj)] \u2192 V erb[rel] N P [obj] S[rel(obj)] \u2192 N P [obj] V P [rel]", "formula_coordinates": [2.0, 91.22, 130.84, 180.15, 65.15]}, {"formula_id": "formula_1", "formula_text": "T |S) = 1 Z exp ( i w i f i (L, T, S)).", "formula_coordinates": [2.0, 73.34, 686.92, 217.05, 27.57]}, {"formula_id": "formula_2", "formula_text": "1 ) \u2227 Utah(n 2 ) \u2227 Idaho(n 3 ) \u2227 nsubj(n 1 , n 2 ) \u2227 dobj(n 1 , n 3 ).", "formula_coordinates": [3.0, 307.46, 633.65, 218.24, 25.41]}, {"formula_id": "formula_3", "formula_text": "1 ) \u2227 nsubj(n 1 , n 2 ) \u2227 dobj(n 1 , n 3 ) is \u03bbx 2 \u03bbx 3 . borders(n 1 ) \u2227 nsubj(n 1 , x 2 ) \u2227 dobj(n 1 , x 3 ).", "formula_coordinates": [4.0, 72.14, 284.68, 218.32, 38.97]}, {"formula_id": "formula_4", "formula_text": "A 1 , \u2022 \u2022 \u2022 , A k , its abstract lambda form is given by \u03bbx 1 \u2022 \u2022 \u2022 \u03bbx k .T(n) \u2227 k i=1 A i (n, x i ).", "formula_coordinates": [4.0, 72.14, 698.2, 218.21, 26.49]}, {"formula_id": "formula_5", "formula_text": "p \u2208 +c \u2227 Form(p, +f) ArgType(p, i, +a) \u2227 ArgForm(p, i, +f) Arg(p, i, p \u2032 ) \u2227 ArgType(p, i, +a) \u2227 p \u2032 \u2208 +c \u2032 Number(p, +a, +n)", "formula_coordinates": [4.0, 315.38, 589.96, 201.98, 51.59]}, {"formula_id": "formula_6", "formula_text": "2 x 3 .borders(n 1 ) \u2227 nsubj(n 1 , x 2 ) \u2227 dobj(n 1 , x 3 ), Utah(n 2 ), Idaho(n 3 ).", "formula_coordinates": [5.0, 307.46, 334.36, 218.24, 38.97]}, {"formula_id": "formula_7", "formula_text": "\u03bbx 3 .borders(n 1 ) \u2227 nsubj(n 1 , n 2 ) \u2227 Utah(n 2 ) \u2227 dobj(n 1 , x 3 ), Idaho(n 3 ).", "formula_coordinates": [5.0, 307.46, 388.6, 218.24, 25.41]}, {"formula_id": "formula_8", "formula_text": "L \u03b8 (Q) = log P \u03b8 (Q) = log L P \u03b8 (Q, L)", "formula_coordinates": [6.0, 114.62, 148.84, 133.24, 26.49]}, {"formula_id": "formula_9", "formula_text": "3. Remove C 1 , C 2 .", "formula_coordinates": [7.0, 80.78, 141.88, 80.49, 11.85]}], "doi": ""}