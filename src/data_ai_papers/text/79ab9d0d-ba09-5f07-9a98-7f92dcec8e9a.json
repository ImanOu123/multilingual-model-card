{"title": "Foundations of Declarative Data Analysis Using Limit Datalog Programs", "authors": "Mark Kaminski; Bernardo Cuenca Grau; Egor V Kostylev; Boris Motik; Ian Horrocks", "pub_date": "2017-11-12", "abstract": "Motivated by applications in declarative data analysis, we study Datalog Z -an extension of positive Datalog with arithmetic functions over integers. This language is known to be undecidable, so we propose two fragments. In limit Datalog Z predicates are axiomatised to keep minimal/maximal numeric values, allowing us to show that fact entailment is CONEXPTIME-complete in combined, and CONP-complete in data complexity. Moreover, an additional stability requirement causes the complexity to drop to EXPTIME and PTIME, respectively. Finally, we show that stable Datalog Z can express many useful data analysis tasks, and so our results provide a sound foundation for the development of advanced information systems.", "sections": [{"heading": "Introduction", "text": "Analysing complex datasets is currently a hot topic in information systems. The term 'data analysis' covers a broad range of techniques that often involve tasks such as data aggregation, property verification, or query answering. Such tasks are currently often solved imperatively (e.g., using Java or Scala) by specifying how to manipulate the data, and this is undesirable because the objective of the analysis is often obscured by evaluation concerns. It has recently been argued that data analysis should be declarative [Alvaro et al., 2010;Markl, 2014;Seo et al., 2015;Shkapsky et al., 2016]: users should describe what the desired output is, rather than how to compute it. For example, instead of computing shortest paths in a graph by a concrete algorithm, one should (i) describe what a path length is, and (ii) select only paths of minimum length. Such a specification is independent of evaluation details, allowing analysts to focus on the task at hand. An evaluation strategy can be chosen later, and general parallel and/or incremental evaluation algorithms can be reused 'for free'.\nAn essential ingredient of declarative data analysis is an efficient language that can capture the relevant tasks, and Datalog is a prime candidate since it supports recursion. Apart from recursion, however, data analysis usually also requires integer arithmetic to capture quantitative aspects of data (e.g., the length of a shortest path). Research on combining the two dates back to the '90s [Mumick et al., 1990;Kemp and Stuckey, 1991;Beeri et al., 1991;Van Gelder, 1992;Consens and Mendelzon, 1993;Ganguly et al., 1995;Ross and Sagiv, 1997], and is currently experiencing a revival [Faber et al., 2011;Mazuran et al., 2013]. This extensive body of work, however, focuses primarily on integrating recursion and arithmetic with aggregate functions in a coherent semantic framework, where technical difficulties arise due to nonmonotonicity of aggregates. Surprisingly little is known about the computational properties of integrating recursion with arithmetic, apart from that a straightforward combination is undecidable [Dantsin et al., 2001]. Undecidability also carries over to the above formalisms and practical Datalogbased systems such as BOOM [Alvaro et al., 2010], DeALS [Shkapsky et al., 2016], Myria [Wang et al., 2015], SociaLite [Seo et al., 2015], Overlog [Loo et al., 2009], Dyna [Eisner and Filardo, 2011], and Yedalog [Chin et al., 2015].\nTo develop a sound foundation for Datalog-based declarative data analysis, we study Datalog Z -negation-free Datalog with integer arithmetic and comparisons. Our main contribution is a new limit Datalog Z fragment that, like the existing data analysis languages, is powerful and flexible enough to naturally capture many important analysis tasks. However, unlike Datalog Z and the existing languages, reasoning with limit programs is decidable, and it becomes tractable in data complexity under an additional stability restriction.\nIn limit Datalog Z , all intensional predicates with a numeric argument are limit predicates. Instead of keeping all numeric values for a given tuple of objects, such predicates keep only the minimal (min) or only the maximal (max) bounds of numeric values entailed for the tuple. For example, if we encode a weighted directed graph using a ternary predicate edge, then rules ( 1) and (2), where sp is a min limit predicate, compute the cost of a shortest path from a given source node v 0 to every other node.\n\u2192 sp(v 0 , 0)\n(1) sp(x, m) \u2227 edge(x, y, n) \u2192 sp(y, m + n)\n(2)\nIf these rules and a dataset entail a fact sp(v, k), then the cost of a shortest path from v 0 to v is at most k; hence, sp(v, k ) holds for each k \u2265 k since the cost of a shortest path is also at most k . Rule (2) intuitively says that, if x is reachable from v 0 with cost at most m and x, y is an edge of cost n, then v is reachable from v 0 with cost at most m + n. This is different from Datalog Z , where there is no implicit semantic con-nection between sp(v, k) and sp(v, k ), and such semantic connections allow us to prove decidability of limit Datalog Z . We provide a direct semantics for limit predicates based on Herbrand interpretations, but we also show that this semantics can be axiomatised in standard Datalog Z . Our formalism can thus be seen as a fragment of Datalog Z , from which it inherits well-understood properties such as monotonicity and existence of a least fixpoint model [Dantsin et al., 2001].\nOur contributions are as follows. First, we introduce limit Datalog Z programs and argue that they can naturally capture many relevant data analysis tasks. We prove that fact entailment in limit Datalog Z is undecidable, but, after restricting the use of multiplication, it becomes CONEXPTIME-and CONP-complete in combined and data complexity, respectively. To achieve tractability in data complexity (which is very important for robust behaviour on large datasets), we additionally introduce a stability restriction and show that this does not prevent expressing the relevant analysis tasks.\nThe proofs of all results are given in the appendix of this paper.", "publication_ref": ["b0", "b4", "b4", "b2", "b2", "b0", "b4", "b3", "b0", "b0", "b4", "b2", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "Preliminaries", "text": "In this section, we recapitulate the well-known definitions of Datalog with integers, which we call Datalog Z . Syntax A vocabulary consists of predicates, objects, object variables, and numeric variables. Each predicate has an integer arity n, and each position 1 \u2264 i \u2264 n is of either object or numeric sort. An object term is an object or an object variable. A numeric term is an integer, a numeric variable, or of the form s 1 + s 2 , s 1 \u2212 s 2 , or s 1 \u00d7 s 2 where s 1 and s 2 are numeric terms, and +, \u2212, and \u00d7 are the standard arithmetic functions. A constant is an object or an integer. The magnitude of an integer is its absolute value. A standard atom is of the form B(t 1 , . . . , t n ), where B is a predicate of arity n and each t i is a term whose type matches the sort of position i of B. A comparison atom is of the form (s 1 < s 2 ) or (s 1 \u2264 s 2 ), where < and \u2264 are the standard comparison predicates, and s 1 and s 2 are numeric terms. A rule r is of the form i \u03b1 i \u2227 j \u03b2 j \u2192 \u03b1, where \u03b1 (i) are standard atoms, \u03b2 j are comparison atoms, and each variable in r occurs in some \u03b1 i . Atom h(r) = \u03b1 is the head of r; sb(r) = i \u03b1 i is the standard body of r; cb(r) = j \u03b2 j is the comparison body of r; and b(r) = sb(r) \u2227 cb(r) is the body of r. A ground instance of r is obtained from r by substituting all variables by constants. A (Datalog Z ) program P is a finite set of rules. Predicate B is intensional (IDB) in P if B occurs in P in the head of a rule whose body is not empty; otherwise, B is extensional (EDB) in P. A term, atom, rule, or program is ground if it contains no variables. A fact is a ground, function-free, standard atom. Program P is a dataset if h(r) is a fact and b(r) = \u2205 for each r \u2208 P. We often say that P contains a fact \u03b1 and write \u03b1 \u2208 P, which actually means \u2192 \u03b1 \u2208 P. We write a tuple of terms as t, and we often treat conjunctions and tuples as sets and write, say, \u03b1 i \u2208 sb(r), |t|, and t i \u2208 t. Semantics A (Herbrand) interpretation I is a (not necessarily finite) set of facts. Such I satisfies a ground atom \u03b1, written I |= \u03b1, if (i) \u03b1 is a standard atom and evaluating the arithmetic functions in \u03b1 produces a fact in I, or (ii) \u03b1 is a comparison atom and evaluating the arithmetic functions and comparisons produces true. The notion of satisfaction is extended to conjunctions of ground atoms, rules, and programs as in first-order logic, where each rule is universally quantified. If I |= P, then I is a model of program P; and P entails a fact \u03b1, written P |= \u03b1, if I |= \u03b1 holds whenever I |= P. Complexity In this paper we study the computational properties of checking P |= \u03b1. Combined complexity assumes that both P and \u03b1 are part of the input. In contrast, data complexity assumes that P is given as P \u222a D for P a program and D a dataset, and that only D and \u03b1 are part of the input while P is fixed. Unless otherwise stated, all numbers in the input are coded in binary, and the size P of P is the size of its representation. Checking P |= \u03b1 is undecidable even if the only arithmetic function in P is + [Dantsin et al., 2001]. Presburger arithmetic is first-order logic with constants 0 and 1, functions + and \u2212, equality, and the comparison predicates < and \u2264, interpreted over all integers Z. The complexity of checking sentence validity (i.e., whether the sentence is true in all models of Presburger arithmetic) is known when the number of quantifier alternations and/or the number of variables in each quantifier block are fixed [Berman, 1980;Gr\u00e4del, 1988;Sch\u00f6ning, 1997;Haase, 2014].", "publication_ref": ["b0", "b1"], "figure_ref": [], "table_ref": []}, {"heading": "Limit Programs", "text": "Towards introducing a decidable fragment of Datalog Z for data analysis, we first note that the undecidability proof of (plain) Datalog Z outlined by Dantsin et al. [2001] uses atoms with at least two numeric terms. Thus, to motivate introducing our fragment, we first prove that undecidability holds even if atoms contain at most one numeric term. The proof uses a reduction from the halting problem for deterministic Turing machines. To ensure that each standard atom in P has at most one numeric term, combinations of a time point and a tape position are encoded using a single integer. Theorem 1. For P a Datalog Z program and \u03b1 a fact, checking P |= \u03b1 is undecidable even if P contains no \u00d7 or \u2212 and each standard atom in P has at most one numeric term.\nWe next introduce limit Datalog Z , where limit predicates keep bounds on numeric values. This language can be seen as either a semantic or a syntactic restriction of Datalog Z . Definition 2. In limit Datalog Z , a predicate is either an object predicate with no numeric positions, or a numeric predicate where only the last position is numeric. A numeric predicate is either an ordinary numeric predicate or a limit predicate, and the latter is either a min or a max predicate. Atoms with object predicates are object atoms, and analogously for other types of atoms/predicates. A Datalog Z rule r is a limit (Datalog Z ) rule if (i) b(r) = \u2205, or (ii) each atom in sb(r) is an object, ordinary numeric, or limit atom, and h(r) is an object or a limit atom. A limit (Datalog Z ) program P is a program containing only limit rules; and P is homogeneous if it does not contain both min and max predicates.\nIn the rest of this paper we make three simplifying assumptions. First, numeric atoms occurring in a rule body are function-free (but comparison atoms and the head can contain arithmetic functions). Second, each numeric variable in a rule occurs in at most one standard body atom. Third, distinct rules in a program use different variables. The third assumption is clearly w.l.o.g. because all variables are universally quantified so their names are immaterial. Moreover, the first two assumptions are w.l.o.g. as well since, for each rule, there exists a logically equivalent rule that satisfies these assumptions. In particular, we can replace an atom such as A(t, m 1 + m 2 ) with conjunction\nA(t, m) \u2227 I(m 1 ) \u2227 I(m 2 ) \u2227 (m \u2264 m 1 + m 2 ) \u2227 (m 1 + m 2 \u2264 m)\nwhere m is a fresh variable and I is a fresh predicate axiomatised to hold on all integers as follows:\n\u2192 I(0) I(m) \u2192 I(m + 1) I(m) \u2192 I(m \u2212 1)\nAlso, we can replace atoms\nA 1 (t 1 , m) \u2227 A 2 (t 2 , m) with con- junction A 1 (t 1 , m) \u2227 A 2 (t 2 , m ) \u2227 (m \u2264 m ) \u2227 (m \u2264 m),\nwhere m is a fresh variable. Intuitively, a limit fact B(a, k) says that the value of B for a tuple of objects a is at least k (if B is max) or at most k (if B is min). For example, a fact sp(v, k) in our shortest path example from Section 1 says that node v is reachable from v 0 via a path with cost at most k. To capture this intended meaning, we require interpretations I to be closed for limit predicates-that is, whenever I contains a limit fact \u03b1, it also contains all facts implied by \u03b1 according to the predicate type. In our example, this captures the observation that the existence of a path from v 0 to v of cost at most k implies the existence of such a path of cost at most k for each k \u2265 k. Definition 3. An interpretation I is limit-closed if, for each limit fact B(a, k) \u2208 I where B is a min (resp. max) predicate, B(a, k ) \u2208 I holds for each integer k with k \u2264 k (resp. k \u2264 k). An interpretation I is a model of a limit program P if I |= P and I is limit-closed. The notion of entailment is modified to take into account only limit-closed models.\nThe semantics of limit predicates in a limit Datalog Z program P can be axiomatised explicitly by extending P with the following rules, where Z is a fresh predicate. Thus, limit Datalog Z can be seen as a syntactic fragment of Datalog Z .\n\u2192 Z(0) Z(m) \u2192 Z(m + 1) Z(m) \u2192 Z(m \u2212 1) B(x, m) \u2227 Z(n) \u2227 (m \u2264 n) \u2192 B(x, n) for each min predicate B in P B(x, m) \u2227 Z(n) \u2227 (n \u2264 m) \u2192 B(x, n)\nfor each max predicate B in P Each limit program can be reduced to a homogeneous program; however, for the sake of generality, in our technical results we do not require programs to be homogeneous. Proposition 4. For each limit program P and fact \u03b1, a homogeneous program P and fact \u03b1 can be computed in linear time such that P |= \u03b1 if and only if P |= \u03b1 .\nIntuitively, program P in Proposition 4 is obtained by replacing all min (or all max) predicates in P by fresh max (resp. min) predicates and negating their numeric arguments.\nIn Section 1 we have shown that limit Datalog Z can compute the cost of shortest paths in a graph. We next present further examples of data analysis tasks that our formalism can handle. In all examples, we assume that all objects in the input are arranged in an arbitrary linear order using facts first(a 1 ), next(a 1 , a 2 ), . . . , next(a n\u22121 , a n ); we use this order to simulate aggregation by means of recursion. Example 5. Consider a social network where agents are connected by the 'follows' relation. Agent a s introduces (tweets) a message, and each agent a i retweets the message if at least k ai agents that a i follows tweet the message, where k ai is a positive threshold uniquely associated with a i . Our goal is to determine which agents tweet the message eventually. To achieve this using limit Datalog Z , we encode the network structure in a dataset D tw containing facts follows(a i , a j ) if a i follows a j , and ordinary numeric facts th(a i , k ai ) if a i 's threshold is k ai . Program P tw , containing rules (3)-( 8), encodes message propagation, where nt is a max predicate.\n\u2192 tw (a s )\n(3) follows(x, y ) \u2227 first(y) \u2192 nt(x, y, 0) (4) follows(x, y) \u2227 first(y) \u2227 tw (y) \u2192 nt(x, y, 1) (5) nt(x, y , m) \u2227 next(y , y) \u2192 nt(x, y, m) (6) nt(x, y , m) \u2227 next(y , y) follows(x, y) \u2227 tw (y) \u2227 \u2192 nt(x, y, m + 1) (7) th(x, m) \u2227 nt(x, y, n) \u2227 (m \u2264 n) \u2192 tw (x) (8) Specifically, P tw \u222a D tw |= tw (a i ) iff a i tweets the message. Intuitively, nt(a i , a j , m\n) is true if, out of agents {a 1 , . . . , a j } (according to the order), at least m agents that a i follows tweet the message. Rules (4) and (5) initialise nt for the first agent in the order; nt is a max predicate, so if the first agent tweets the message, rule (5) 'overrides' rule (4). Rules (6) and (7) recurse over the order to compute nt as stated above. Example 6. Limit Datalog Z can also solve the problem of counting paths between pairs of nodes in a directed acyclic graph. We encode the graph in the obvious way as a dataset D cp that uses object predicates node and edge. Program P cp , consisting of rules (9)-( 14) where np and np are max predicates, then counts the paths.\nnode\n(x) \u2192 np(x, x, 1) (9) node(x) \u2227 node(y) \u2227 first(z) \u2192 np (x, y, z, 0) (10) edge(x, z) np(z, y, m) \u2227 first(z) \u2227 \u2192 np (x, y, z, m) (11) np (x, y, z , m) \u2227 next(z , z) \u2192 np (x, y, z, m) (12) np (x, y, z , m) \u2227 next(z , z) edge(x, z) \u2227 np(z, y, n) \u2227 \u2192 np (x, y, z, m + n) (13) np (x, y, z, m) \u2192 np(x, y, m) (14) Specifically, P cp \u222a D cp |= np(a i , a j , k) iff at least k paths exist from node a i to node a j . Intuitively, np (a i , a j , a k , m\n) is true if m is at least the sum of the number of paths from each a \u2208 {a 1 , . . . , a k } (according to the order) to a j for which there exists an edge from a i to a . Rule (9) says that each node has one path to itself. Rule (10) initialises aggregation by saying that, for the first node z, there are zero paths from x to y, and rule (11) overrides this if there exists an edge from x to z. Finally, rule (12) propagates the sum for x to the next z in the order, and rule (13) overrides this if there is an edge from x to z by adding the number of paths from z and z to y.\nExample 7. Assume that, in the graph from Example 6, each node a i is associated with a bandwidth b ai limiting the number of paths going through a i to at most b ai . To count the paths compliant with the bandwidth requirements, we extend D cp to dataset D bcp that additionally contains an ordinary numeric fact bw (a i , b ai ) for each node a i , and we define P bcp by replacing rule (14) in P cp with the following rule.\nnp (x, y, z, m) \u2227 bw (z, n) \u2227 (m \u2264 n) \u2192 np(x, y, m) Then, P bcp \u222a D bcp |= np(a i , a j , k) iff there exist at least k paths from node a i to node a j , where the bandwidth requirement is satisfied for all nodes on each such path.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Fixpoint Characterisation of Entailment", "text": "Programs are often grounded to eliminate variables and thus simplify the presentation. In limit Datalog Z , however, numeric variables range over integers, so a grounding can be infinite. Thus, we first specialise the notion of a grounding. Definition 8. A rule r is semi-ground if each variable in r is a numeric variable that occurs in r in a limit body atom. A limit program P is semi-ground if all of its rules are semi-ground. The semi-grounding of P contains, for each r \u2208 P, each rule obtained from r by replacing each variable not occurring in r in a numeric argument of a limit atom with a constant of P.\nObviously, P |= \u03b1 if and only if P |= \u03b1 for P the semigrounding of P. We next characterise entailment of limit programs by pseudo-interpretations, which compactly represent limit-closed interpretations. If a limit-closed interpretation I contains B(b, k) where B is a min predicate, then either the limit value \u2264 k exists such that B(b, ) \u2208 I and B(b, k ) \u2208 I for k < , or B(b, k ) \u2208 I holds for all k \u2264 k, and dually for B a max predicate. Thus, to characterise the value of B on a tuple of objects b in I, we just need the limit value, or information that no such value exists. Definition 9. A pseudo-interpretation J is a set of facts over integers extended with a special symbol \u221e such that k = k holds for all limit facts B(b, k) and B(b, k ) in I.\nLimit-closed interpretations correspond naturally and oneto-one to pseudo-interpretations, so we can recast the notions of satisfaction and model using pseudo-interpretations. Unlike for interpretations, the number of facts in a pseudo-model of a semi-ground limit program P can be bounded by |P|. Definition 10. A limit-closed interpretation I corresponds to a pseudo-interpretation J if I contains exactly all object and ordinary numeric facts of J, and, for each limit predicate B, each tuple of objects b, and each integer , (i) B(b, k) \u2208 I for all k if and only if B(b, \u221e) \u2208 J, and (ii) B(b, ) \u2208 I and B(b, k) \u2208 I for all k < (resp. < k) and B is a min (resp. max) predicate if and only if B(b, ) \u2208 J.\nLet J and J be pseudo-interpretations corresponding to interpretations I and I . Then, J satisfies a ground atom \u03b1, written J |= \u03b1, if I |= \u03b1; J is a pseudo-model of a program P, written J |= P, if I |= P; finally, J J holds if I \u2286 I . Example 11. Let I be the interpretation consisting of A(1), A(2), B(a, k) for k \u2264 5, and B(b, k) for k \u2208 Z, where A is an ordinary numeric predicate, B is a max predicate, and a and b are objects. Then, {A(1), A(2), B(a, 5), B(b, \u221e)} is the pseudo-interpretation corresponding to I.\nWe next introduce the immediate consequence operator T P of a limit program P on pseudo-interpretations. We assume for simplicity that P is semi-ground. To apply a rule r \u2208 P to a pseudo-interpretation J while correctly handling limit atoms, operator T P converts r into a linear integer constraint C(r, J) that captures all ground instances of r applicable to the limit-closed interpretation I corresponding to J. If C(r, J) has no solution, r is not applicable to J. Otherwise, h(r) is added to J if it is not a limit atom; and if h(r) is a min (max) atom B(b, m), then the minimal (maximal) solution for m in C(r, J) is computed, and J is updated such that the limit value of B on b is at least (at most) -that is, the application of r to J keeps only the 'best' limit value. Definition 12. For P a semi-ground limit program, r \u2208 P, and J a pseudo-interpretation, C(r, J) is the conjunction of comparison atoms containing (i) cb(r); (ii) (0 < 0) if an object or ordinary numeric atom \u03b1 \u2208 sb(r) exists with \u03b1 \u2208 J, or a limit atom B(b, s) \u2208 sb(r) exists with B(b, ) \u2208 J for each ; and (iii) ( \u2264 s) (resp. (s \u2264 )) for each min (resp. max) atom B(b, s) \u2208 sb(r) with B(b, ) \u2208 J and = \u221e. Rule r is applicable to J if C(r, J) has an integer solution.\nAssume r is applicable to J. If h(r) is an object or ordinary numeric atom, let hd(r, J) = h(r). If h(r) = B(b, s) is a min (resp. max) atom, the optimum value opt(r, J) is the smallest (resp. largest) value of s in all solutions to C(r, J), or \u221e if no such bound on the value of s in the solutions to C(r, J) exists; moreover, hd(r, J) = B(b, opt(r, J)).\nOperator T P (J) maps J to the smallest (w.r.t. ) pseudointerpretation satisfying hd(r, J) for each r \u2208 P applicable to J. Finally, T 0 P = \u2205, and T n P = T P (T n\u22121 P ) for n > 0. Example 13. Let r be A(x) \u2227 (2 \u2264 x) \u2192 B(x + 1) with A and B max predicates. Then, C(r, \u2205) = (2 \u2264 x) \u2227 (0 < 0) does not have a solution, and therefore rule r is not applicable to the empty pseudo-interpretation. Moreover, for J = {A(3)}, conjunction C(r, J) = (2 \u2264 x) \u2227 (x \u2264 3) has two solutions-{x \u2192 2} and {x \u2192 3}-and therefore rule r is applicable to J. Finally, B is a max predicate, and so opt(r, J) = max{2 + 1, 3 + 1} = 4, and hd(r, J) = B(4). Consequently, T {r} (J) = {B(4)}.\nLemma 14. For each semi-ground limit program P, operator T P is monotonic w.r.t. . Moreover, J |= P if and only if T P (J) J for each pseudo-interpretation J.\nMonotonicity ensures existence of the closure T \u221e P of Pthe least pseudo-interpretation such that T n P T \u221e P for each n \u2265 0. The following theorem characterises entailment and provides a bound on the number of facts in the closure. Theorem 15. For P a semi-ground limit program and \u03b1 a fact, P |= \u03b1 if and only if T \u221e P |= \u03b1; also, |T \u221e P | \u2264 |P|; and J |= P implies T \u221e P J for each pseudo-interpretation J. The proofs for the first and the third claim of Theorem 15 use the monotonicity of T P analogously to plain Datalog. The second claim holds since, for each n \u2265 0, each pair of distinct facts in T n P must be derived by distinct rules in P.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Decidability of Entailment: Limit-Linearity", "text": "We now start our investigation of the computational properties of limit Datalog Z . Theorem 15 bounds the cardinality of the closure of a semi-ground program, but it does not bound the magnitude of the integers occurring in limit facts; in fact, integers can be arbitrarily large. Moreover, due to multiplication, checking rule applicability requires solving nonlinear inequalities over integers, which is undecidable. Theorem 16. For P a semi-ground limit program and \u03b1 a fact, checking P |= \u03b1 and checking applicability of a rule of P to a pseudo-interpretation are both undecidable.\nThe proof of Theorem 16 uses a straightforward reduction from Hilbert's tenth problem.\nChecking rule applicability is undecidable due to products of variables in inequalities; however, for linear inequalities that prohibit multiplying variables, the problem can be solved in NP, and in polynomial time if we bound the number of variables. Thus, to ensure decidability, we next restrict limit programs so that their semi-groundings contain only linear numeric terms. All our examples satisfy this restriction. Definition 17. A limit rule r is limit-linear if each numeric term in r is of the form s 0 + n i=1 s i \u00d7 m i , where (i) each m i is a distinct numeric variable occurring in a limit body atom of r, (ii) term s 0 contains no variable occurring in a limit body atom of r, and (iii) each s i with i \u2265 1 is a term constructed using multiplication \u00d7, integers, and variables not occurring in limit body atoms of r. A limit-linear program contains only limit-linear rules. 1 In the rest of this section, we show that entailment for limitlinear programs is decidable and provide tight complexity bounds. Our upper bounds are obtained via a reduction to the validity of Presburger formulas of a certain shape. Lemma 18. For P a semi-ground limit-linear program and \u03b1 a fact, there exists a Presburger sentence \u03d5 = \u2200x\u2203y. n i=1 \u03c8 i that is valid if and only if P |= \u03b1. Each \u03c8 i is a conjunction of possibly negated atoms. Moreover, |x| + |y| and each \u03c8 i are bounded polynomially by P + \u03b1 . Number n is bounded polynomially by |P| and exponentially by max r\u2208P r . Finally, the magnitude of each integer in \u03d5 is bounded by the maximal magnitude of an integer in P and \u03b1.\nThe reduction in Lemma 18 is based on three main ideas. First, for each limit atom B(b, s) in a semi-ground program P, we use a Boolean variable def Bb to indicate that an atom of the form B(b, ) exists in a pseudo-model of P, a Boolean variable fin Bb to indicate whether the value of is finite, and an integer variable val Bb to capture if it is finite. Second, each rule of P is encoded as a universally quantified Presburger formula by replacing each standard atom with its encoding. Finally, entailment of \u03b1 from P is encoded as a sentence stating that, in every pseudo-interpretation, either some rule in P is not satisfied, or \u03b1 holds; this requires universal quantifiers to quantify over all models, and existential quantifiers to negate the (universally quantified) program.\nLemma 19 bounds the magnitude of integers in models of Presburger formulas from Lemma 18. These bounds follow from recent deep results on semi-linear sets and their connection to Presburger arithmetic [Chistikov and Haase, 2016]. 2 Lemma 19. Let \u03d5 = \u2200x\u2203y. n i=1 \u03c8 i be a Presburger sentence where each \u03c8 i is a conjunction of possibly negated atoms of size at most k mentioning at most variables, a is the maximal magnitude of an integer in \u03d5, and m = |x|. Then, \u03d5 is valid if and only if \u03d5 is valid over models where each integer variable assumes a value whose magnitude is bounded by\n(2 O( log ) \u2022 a k ) n2 \u2022O(m 4 ) .\nLemmas 18 and 19 provide us with bounds on the size of counter-pseudo-models for entailment. Theorem 20. For P a semi-ground limit-linear program, D a dataset, and \u03b1 a fact, P \u222a D |= \u03b1 if and only if a pseudomodel J of P \u222a D exists where J |= \u03b1, |J| \u2264 |P \u222a D|, and the magnitude of each integer in J is bounded polynomially by the largest magnitude of an integer in P \u222a D, exponentially by |P|, and double-exponentially by max r\u2208P r .\nBy Theorem 20, the following nondeterministic algorithm decides P |= \u03b1:\n1. compute the semi-grounding P of P; 2. guess a pseudo-interpretation J that satisfies the bounds given in Theorem 20; 3. if T P (J) J (so J |= P ) and J |= \u03b1, return true.\nStep 1 requires exponential (polynomial in data) time, and it does not increase the maximal size of a rule. Hence, Step 2 is nondeterministic exponential (polynomial in data), and Step 3 requires exponential (polynomial in data) time to solve a system of linear inequalities. Theorem 21 proves that these bounds are both correct and tight. Theorem 21. For P a limit-linear program and \u03b1 a fact, deciding P |= \u03b1 is CONEXPTIME-complete in combined and CONP-complete in data complexity.\nThe upper bounds in Theorem 21 follow from Theorem 20, CONP-hardness in data complexity is shown by a reduction from the square tiling problem, and CONEXPTIME-hardness in combined complexity is shown by a similar reduction from the succinct version of square tiling.", "publication_ref": ["b6", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "Tractability of Entailment: Stability", "text": "Tractability in data complexity is important on large datasets, so we next present an additional stability condition that brings the complexity of entailment down to EXPTIME in combined and PTIME in data complexity, as in plain Datalog.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Cyclic Dependencies in Limit Programs", "text": "The fixpoint of a plain Datalog program can be computed in PTIME in data complexity. However, for P a limit-linear program, a na\u00efve computation of T \u221e P may not terminate since repeated application of T P can produce larger and larger numbers. Thus, we need a way to identify when the numeric argument of a limit fact A(a, ) diverges-that is, grows or decreases without a bound; moreover, to obtain a procedure tractable in data complexity, divergence should be detected after polynomially many steps. Example 22 illustrates that this can be achieved by analysing cyclic dependencies. Example 22. Let P c contain facts A(0) and B(0), and rules A(m) \u2192 B(m) and B(m) \u2192 A(m + 1), where A and B are max predicates. Applying the first rule copies the value of A into B, and applying the second rule increases the value of A; thus, both A and B diverge in T \u221e Pc . The existence of a cyclic dependency between A and B, however, does not necessarily lead to divergence. Let program P c be obtained from P c by adding a max fact C(5) and replacing the first rule with A(m) \u2227 C(n) \u2227 (m \u2264 n) \u2192 B(m). While a cyclic dependency between A and B still exists, the increase in the values of A and B is bounded by the value of C, which is independent of A or B; thus, neither A nor B diverge in T \u221e P c . In the rest of this section, we extend <, +, and \u2212 to \u221e by defining k < \u221e, \u221e + k = \u221e, and \u221e \u2212 k = \u221e for each integer k. We formalise cyclic dependencies as follows. Definition 23. For each n-ary limit predicate B and each tuple b of n \u2212 1 objects, let v Bb be a node unique for B and b. The value propagation graph of a semi-ground limitlinear program P and a pseudo-interpretation J is the directed weighted graph G J P = (V, E, \u00b5) defined as follows. 1. For each limit fact B(b, ) \u2208 J, we have v Bb \u2208 V. 2. For each rule r \u2208 P applicable to J with the head of the form A(a, s) where v Aa \u2208 V and each body atom B(b, m) of r where v Bb \u2208 V and variable m occurs in term s, we have v Bb , v Aa \u2208 E; such r is said to produce the edge v Bb , v Aa in E. 3. For each r \u2208 P and each edge e = v Bb , v Aa \u2208 E produced by r, \u03b4 e r (J) = \u221e if opt(r, J) = \u221e; otherwise,\n\u03b4 e r (J) = \uf8f1 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f2 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f3 opt(r, J) \u2212 if B and A are max, = \u221e \u2212opt(r, J) \u2212 if B is max, A is min, = \u221e \u2212opt(r, J) + if B and A are min, = \u221e opt(r, J) + if B is min, A is max, = \u221e opt(r, J) if = \u221e\nwhere is such that B(b, ) \u2208 J. The weight of each edge e \u2208 E is then given by \u00b5(e) = max{\u03b4 e r (J) | r \u2208 P produces e}. A positive-weight cycle in G J P is a cycle for which the sum of the weights of the contributing edges is greater than 0.\nIntuitively, G J P describes how, for each limit predicate B and objects b such that B(b, ) \u2208 J, operator T P propagates to other facts. The presence of a node v Bb in V indicates that B(b, ) \u2208 J holds for some \u2208 Z \u222a {\u221e}; this can be uniquely identified given v Bb and J. An edge e = v Bb , v Aa \u2208 E indicates that at least one rule r \u2208 P is applicable to J where h(r) = A(a, s), B(b, m) \u2208 sb(r), and m occurs in s; moreover, applying r to J produces a fact A(a, ) where satisfies + \u00b5(e) \u2264 if both A and B are max predicates, and analogously for the other types of A and B. In other words, edge e indicates that the application of T P to J will propagate the value of v Bb to v Aa while increasing it by at least \u00b5(e). Thus, presence of a positive-weight cycle in G J P indicates that repeated rule applications might increment the values of all nodes on the cycle.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Stable Programs", "text": "As Example 22 shows, the presence of a positive-weight cycle in G J P does not imply the divergence of all atoms corresponding to the nodes in the cycle. This is because the weight of such a cycle may decrease after certain rule applications and so it is no longer positive.\nThis motivates the stability condition, where edge weights in G J P may only grow but never decrease with rule application. Hence, once the weight of a cycle becomes positive, it will remain positive and thus guarantee the divergence of all atoms corresponding to its nodes. Intuitively, P is stable if, whenever a rule r \u2208 P is applicable to some J, rule r is also applicable to each J with larger limit values, and applying r to such J further increases the value of the head. Definition 24 defines stability as a condition on G J P . Please note that, for all pseudo-interpretations J and J with J J and G J P = (V, E, \u00b5) and G J P = (V , E , \u00b5 ) the corresponding value propagation graphs, we have E \u2286 E . Definition 24. A semi-ground limit-linear program P is stable if, for all pseudo-interpretations J and J with J J ,\nG J P = (V, E, \u00b5), G J P = (V , E , \u00b5 ),\nand each e \u2208 E, 1. \u00b5(e) \u2264 \u00b5 (e), and 2. e = v Bb , v Aa and B(b, \u221e) \u2208 J imply \u00b5(e) = \u221e. A limit-linear program is stable if its semi-grounding is stable. Example 25. Program P c from Example 22 is stable, while P c is not: for J = {A(0), C(0)} and\nJ = {A(1), C(0)}, we have J J , but \u00b5( v A , v B ) = 0 and \u00b5 ( v A , v B ) = \u22121.\nFor each semi-ground program P and each integer n, we have T n P T n+1 P , and stability ensures that edge weights only grow after rule application. Thus, recursive application of the rules producing edges involved in a positive-weight cycle leads to divergence, as shown by the following lemma. Lemma 26. For each semi-ground stable program P, each pseudo-interpretation J with J T \u221e P , and each node v Aa on a positive-weight cycle in G J P , we have A(a, \u221e) \u2208 T \u221e P . Algorithm 1 uses this observation to deterministically compute the fixpoint of P. The algorithm iteratively applies T P ; however, after each step, it computes the corresponding value propagation graph (line 4) and, for each A(a, ) where node v Aa occurs on a positive-weight cycle (line 5), it replaces with \u221e (line 6). By Lemma 26, this is sound. Moreover, since the algorithm repeatedly applies T P , it necessarily derives each fact from T \u221e P eventually. Finally, Lemma 27 shows that the algorithm terminates in time polynomial in the number of rules in a semi-ground program. Intuitively, the proof of the lemma shows that, without introducing a new edge or a new positive weight cycle in the value propagation graph, repeated application of T P necessarily converges in O(|P| 2 ) steps; moreover, the number of edges in G J P is at most quadratic |P|, and so a new edge or a new positive weight cycle can be introduced at most O(|P| 2 ) many times. Lemma 27. When applied to a semi-ground stable program P, Algorithm 1 terminates after at most 8|P| 6 iterations of the loop in lines 2-8.\nLemmas 26 and 27 imply the following theorem. Theorem 28. For P a semi-ground stable program, D a dataset, and \u03b1 a fact, Algorithm 1 decides P \u222a D |= \u03b1 in time polynomial in P \u222a D and exponential in max r\u2208P r .\nSince the running time is exponential in the maximal size of a rule, and semi-grounding does not increase rule sizes, Algorithm 1 Entailment for Semi-Ground Stable Programs Input: semi-ground stable program P, fact \u03b1 Output:\ntrue if P |= \u03b1 1: J \u2022 \u2022 = \u2205 2: repeat 3: J \u2022 \u2022 = J 4: G J P \u2022 \u2022 = (V, E, \u00b5) 5:\nfor each vAa \u2208 V in a positive-weight cycle in G J P do 6: replace A(a, ) in J with A(a, \u221e) 7: J \u2022 \u2022 = TP (J) 8: until J = J 9: return true if J |= \u03b1 and false otherwise Algorithm 1 combined with a semi-grounding preprocessing step provides an exponential time decision procedure for stable, limit-linear programs. This upper bound is tight since entailment in plain Datalog is already EXPTIME-hard in combined and PTIME-hard in data complexity.\nTheorem 29. For P a stable program and \u03b1 a fact, checking P |= \u03b1 is EXPTIME-complete in combined and PTIMEcomplete in data complexity.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Type-Consistent Programs", "text": "Unfortunately, the class of stable programs is not recognisable, which can again be shown by a reduction from Hilbert's tenth problem.\nProposition 30. Checking stability of a limit-linear program P is undecidable.\nWe next provide a sufficient condition for stability that captures programs such as those in Examples 5 and 6. Intuitively, Definition 31 syntactically prevents certain harmful interactions. In the second rule of program P c from Example 22, numeric variable m occurs in a max atom and on the lefthand side of a comparison atom (m \u2264 n); thus, if the rule is applicable for some value of m, it is not necessarily applicable for each m \u2265 m, which breaks stability.\nDefinition 31. A semi-ground limit-linear rule r is type- consistent if -each numeric term t in r is of the form k 0 + n i=1 k i \u00d7 m i where k 0 is an integer and each k i , 1 \u2264 i \u2264 n, is a nonzero integer, called the coefficient of variable m i in t; -if h(r) = A(\na, s) is a limit atom, then each variable occurring in s with a positive (resp. negative) coefficient also occurs in a (unique) limit body atom or r that is of the same (resp. different) type (i.e., min vs. max) as h(r); and -for each comparison (s 1 < s 2 ) or (s 1 \u2264 s 2 ) in r, each variable occurring in s 1 with a positive (resp. negative) coefficient also occurs in a (unique) min (resp. max) body atom, and each variable occurring in s 2 with a positive (resp. negative) coefficient also occurs in a (unique) max (resp. min) body atom of r. A semi-ground limit-linear program is type-consistent if all of its rules are type-consistent. Moreover, a limit-linear program P is type-consistent if the program obtained by first semi-grounding P and then simplifying all numeric terms as much as possible is type-consistent.\nThe first condition of Definition 31 ensures that each variable occurring in a numeric term contributes to the value of the term. For example, it disallows terms such as 0 \u2022 x and x \u2212 x, since a rule with such a term in the head may violate the second condition. Moreover, the second condition of Definition 31 ensures that, if the value of a numeric variable x occurring in the head 'increases' w.r.t. the type of the body atom introducing x (i.e., x increases if it occurs in a max body atom and decreases otherwise), then so does the value of the numeric term in the head; this is essential for the first condition of stability (cf. Definition 24). Finally, the third condition of Definition 31 ensures that comparisons cannot be invalidated by 'increasing' the values of the variables involved, which is required for both conditions of stability.\nType consistency is a purely syntactic condition that can be checked by looking at one rule and one atom at a time. Hence, checking type consistency is feasible in LOGSPACE. Proposition 32. Each type-consistent limit-linear program is stable.\nProposition 33. Checking whether a limit-linear program is type-consistent can be accomplished in LOGSPACE.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Conclusion and Future Work", "text": "We have introduced several decidable/tractable fragments of Datalog with integer arithmetic, thus obtaining a sound theoretical foundation for declarative data analysis. We see many challenges for future work. First, our formalism should be extended with aggregate functions. While certain forms of aggregation can be simulated by iterating over the object domain, as in our examples in Section 3, such a solution may be too cumbersome for practical use, and it relies on the existence of a linear order over the object domain, which is a strong theoretical assumption. Explicit support for aggregation would allow us to formulate tasks such as the ones in Section 3 more intuitively and without relying on the ordering assumption. Second, it is unclear whether integer constraint solving is strictly needed in Step 7 of Algorithm 1: it may be possible to exploit stability of P to compute T P (J) more efficiently. Third, we shall implement our algorithm and apply it to practical data analysis problems. Fourth, it would be interesting to establish connections between our results and existing work on data-aware artefact systems [Damaggio et al., 2012;Koutsos and Vianu, 2017], which faces similar undecidability issues in a different formal setting.\nA Proofs for Section 3 Theorem 1. For P a Datalog Z program and \u03b1 a fact, checking P |= \u03b1 is undecidable even if P contains no \u00d7 or \u2212 and each standard atom in P has at most one numeric term.\nProof. We prove the claim by presenting a reduction of the halting problem for deterministic Turing machines on the empty tape. Let M be an arbitrary deterministic Turing machine with finite alphabet \u0393 containing the blank symbol , the finite set of states S containing the initial state s and the halting state h, and transition function \u03b4 : S \u00d7 \u0393 \u2192 S \u00d7 \u0393 \u00d7 {L, R}. We assume that M works on a tape that is infinite to the right, that it starts with the empty tape and the head positioned on the leftmost cell, and that it never moves the head off the left edge of the tape.\nWe encode each time point i \u2265 0 using an integer 2 i , and we index tape positions using zero-based integers; thus, at time i, each position j \u2265 2 i is necessarily empty, so we can encode a combination of a time point i and tape position j with 0 \u2264 j < 2 i using a single integer 2 i + j. We use this idea to encode the state of the execution of M using the following facts:\n\u2022 Num(k) is true for each positive number k;\n\u2022 Time(k) is true if k = 2 i and so k encodes a time point i;\n\u2022 Tape(a, 2 i + j) says that symbol a occupies position j of the tape at time i, and it will be defined for each 0 \u2264 j < 2 i ;\n\u2022 Pos(2 i + j) says that the head points to position j of the tape at time i;\n\u2022 State(q, 2 i ) says that the machine is in state q at time i; and\n\u2022 Halts is a propositional variable saying that the machine has halted.\nWe next give a Datalog Z program P M that simulates the behaviour of M on the empty tape. We represent each alphabet symbol a \u2208 \u0393 using an object constant a, and we represent each state q \u2208 S using an object constant q. Furthermore, we abbreviate (s \u2264 t) \u2227 (t < u) as (s \u2264 t < u). Finally, we abbreviate conjunction (s \u2264 t) \u2227 (t \u2264 s) as (s . = t), and disjunction (s < t) \u2228 (t > s) as (s . = t). Strictly speaking, disjunctions are not allowed in rule bodies; however, each rule with a disjunction in the body of the form \u03d5 \u2227 (s . = t) \u2192 \u03b1 corresponds to rules \u03d5 \u2227 (s < t) \u2192 \u03b1 and \u03d5 \u2227 (t < s) \u2192 \u03b1, so we use the former form for the sake of clarity. With these considerations in mind, program P M contains rules ( 15)-( 24).\n\u2192 Num(1) (15) Num(x) \u2192 Num(x + 1) (16) \u2192 Time(1) (17) Time(x) \u2192 Time(x + x) (18) \u2192 Tape( , 1) (19) \u2192 Pos(1) (20) \u2192 State(s, 1) (21) State(h, x) \u2192 Halts (22) Time(x) \u2227 Tape(v, y) \u2227 Pos(z) \u2227 (x \u2264 y < x + x) \u2227 (x \u2264 z < x + x) \u2227 (y . = z) \u2192 Tape(v, x + y) (23) Time(x) \u2227 Num(u) \u2227 (x + x + x \u2264 u + u < x + x + x + x) \u2192 Tape( , u)(24)\nMoreover, for each alphabet symbol a \u2208 \u0393 and all states q, q \u2208 S such that \u03b4(q, a) = (q , a , D) where D \u2208 {L, R} is a direction, P M contains rules ( 25)-(28).\nTime(x) \u2227 State(q, x) \u2227 Tape(a, y) \u2227 Pos(y) \u2227 (x \u2264 y < x + x) \u2192 Tape(a , x + y) (25) Time(x) \u2227 State(q, x) \u2227 Tape(a, y) \u2227 Pos(y) \u2227 (x \u2264 y < x + x) \u2192 State(q , x + x) (26) Time(x) \u2227 State(q, x) \u2227 Tape(a, y) \u2227 Pos(y) \u2227 Num(u) (x \u2264 y < x + x) \u2227 (x + y . = u + 1) \u2227 \u2192 Pos(u) if D = L (27) Time(x) \u2227 State(q, x) \u2227 Tape(a, y) \u2227 Pos(y) \u2227 Num(u) (x \u2264 y < x + x) \u2227 (x + y + 1 . = u) \u2227 \u2192 Pos(u) if D = R (28)\nRules ( 15)-( 16) initialise Num so that it holds of all positive integers, and rules ( 17)-( 18) initialise Time so that it holds for each integer k = 2 i . Rules ( 19)-( 21) initialise the state of the M at time i = 0. Rule (22) derives Halts if at any point the Turing machine enters the halting state h. The remaining rules encode the evolution of the state of M , and they are based on the following idea: if variable x encodes a time point i using value 2 i , then variable y encodes a position j for time point i if x \u2264 y < x + x holds; moreover, for such y, position j at time point i + 1 is encoded as 2 i+1 + j = 2 i + 2 i + j and can be obtained as x+y, and the encodings of positions j \u22121 and j +1 can be obtained as x + y \u2212 1 and x + y + 1, respectively. Since our goal is to prove undecidability by just using +, we simulate subtraction by looking for a value u such that x + y = u + 1. With these observations in mind, one can see that rule (23) copies the unaffected part of the tape from time point i to time point i + 1. Moreover, rule (24) pads the tape by filling each location j with 1.5 \u00d7 2 i \u2264 j < 2 \u00d7 2 i with the blank symbol; since division is not supported in our language, we express this condition as 3 \u00d7 2 i \u2264 2 \u00d7 j < 2 \u00d7 2 \u00d7 2 i . Finally, rule (25) updates the tape at the position of the head; rule (26) updates the state; and rules ( 27) and ( 28) move the head left and right, respectively. Consequently, we have P M |= Halts if and only if M halts on the empty tape. Proposition 4. For each limit program P and fact \u03b1, a homogeneous program P and fact \u03b1 can be computed in linear time such that P |= \u03b1 if and only if P |= \u03b1 .\nProof. Let P be an arbitrary limit program. Without loss of generality, we construct a program P containing only max predicates. For each min predicate A, let A be a fresh max predicate uniquely associated with A. We construct P from P by modifying each rule r \u2208 P as follows:\n1. if h(r) = A(t, s) where A is a min predicate, replace the head of r with A (t, \u2212s); 2. for each body atom A(t, n) \u2208 sb(r) where A is a min predicate and n is a variable, replace the atom with A (t, m) where m is a fresh variable, and replace all other occurrences of n in the rule with \u2212m;\n3. for each body atom A(t, k) \u2208 sb(r) where A is a min predicate and k is an integer, replace the atom with A (t, \u2212k).\nFinally, if \u03b1 = A(a, k) is a min fact, let \u03b1 = A(a, \u2212k); otherwise, let \u03b1 = \u03b1. Now consider an arbitrary interpretation I, and let I be the interpretation obtained from I by replacing each min fact A(a, k) with A (a, \u2212k); it is straightforward to see that I |= P if and only if I |= P , and that I |= \u03b1 if and only if I |= \u03b1 . Thus, P |= \u03b1 if and only if P |= \u03b1 .", "publication_ref": ["b2"], "figure_ref": [], "table_ref": []}, {"heading": "B Proofs for Section 4", "text": "We use the standard notion of substitutions-sort-compatible partial mappings of variables to constants. For \u03d5 a formula and \u03c3 a substitution, \u03d5\u03c3 is the formula obtained by replacing each free variable x in \u03d5 on which \u03c3 is defined with \u03c3(x). Proposition B.1. For each semi-ground rule r = \u03d5 \u2192 \u03b1, each pseudo-interpretation J, and each mapping \u03c3 of the variables of r to integers, \u03c3 is an integer solution to C(r, J) if and only if J |= \u03d5\u03c3.\nProof. (\u21d2) Assume that \u03c3 is an integer solution to C(r, J). We consider each atom \u03b2 \u2208 \u03d5 and show that J |= \u03b2\u03c3 holds.\n\u2022 If \u03b2 is a comparison atom, the claim is straightforward due to \u03b2 \u2208 C(r, J).\n\u2022 If \u03b2 is an object atom or an ordinary numeric atom, \u03b2 is ground and we have \u03b2 \u2208 J and J |= \u03b2; otherwise, (0 < 0) \u2208 C(r, J) would hold and so \u03c3 could not be a solution to C(r, J).\n\u2022 If \u03b2 is a max atom B(b, s), since (0 < 0) \u2208 C(r, J), either B(b, ) \u2208 J for some integer \u2208 Z and (s \u2264 ) \u2208 C(r, J), or B(b, \u221e) \u2208 J. In the former case, since \u03c3 is a solution to C(r, J), we have s\u03c3 \u2264 , and, since B is a max predicate, J |= B(b, s\u03c3) holds. In the latter case, J |= B(b, s\u03c3) holds due to {B(b, s\u03c3)} {B(b, \u221e)}.\n\u2022 If \u03b2 is a min atom, the proof is analogous to the previous case.\nThe proof of the (\u21d0) direction is analogous and we omit it for the sake of brevity.\nDefinition B.2. Given a limit-closed interpretation I and a program P, let I P (I) = {\u03b3 | i \u03b1 i \u2192 \u03b2 is a ground instance of a rule in P such that I |= i \u03b1 i and \u03b3 is a fact such that {\u03b3} {\u03b2}}.\nLet I 0 P = \u2205, let I n P = I P (I n\u22121 P ) for n > 0, and let I \u221e P = n\u22650 I n P . Lemma B.3. For each program P, operator I P is monotonic w.r.t. \u2286; moreover, for I an interpretation, I |= P if and only if I P (I) = I, and I |= P implies I \u221e P \u2286 I. Proof. Operator I P is the standard immediate consequence operator of Datalog, but applied to the program P obtained by extending P with the rules from Section 3 encoding the semantics of limit predicates. Thus, all claims of this lemma hold in the usual way [Dantsin et al., 2001].\nLemma B.4. For each limit-closed interpretation I and the corresponding pseudo-interpretation J, and for each semi-ground limit program P, interpretation I P (I) corresponds to the pseudo-interpretation T P (J).\nProof. It suffices to show that, for each fact \u03b1, the following claims hold:\n\u2022 Assume \u03b1 \u2208 I P (I). Then, a rule r = \u03d5 \u2192 \u03b1 \u2208 P and a grounding \u03c3 of r exist such that I |= \u03d5\u03c3; the head of r must be \u03b1 since P is semi-ground. But then, J |= \u03d5\u03c3 holds as well, so Proposition B.1 ensures that \u03c3 is a solution to C(r, J); moreover, hd(r, J) = \u03b1, and thus we have \u03b1 \u2208 T P (J). \u2022 Assume \u03b1 \u2208 T P (J). Then, there exist a rule r = \u03d5 \u2192 \u03b1 \u2208 P and an integer solution \u03c3 to C(r, J). Proposition B.1 then ensures J |= \u03d5\u03c3, and so I |= \u03d5\u03c3 holds as well. Thus, we have \u03b1\u03c3 = \u03b1 \u2208 I P (I).\n(Claim 2) Consider an arbitrary max fact \u03b1 of the form A(a, k); the proof for a min fact is analogous.\n\u2022 Assume \u03b1 \u2208 I P (I). Then, a rule r = \u03d5 \u2192 A(a, s) \u2208 P and a grounding \u03c3 of r exist such that I |= \u03d5\u03c3 and \u03b1 = A(a, s\u03c3). But then, J |= \u03d5\u03c3 holds as well, so Proposition B.1 ensures that \u03c3 is a solution to C(r, J); moreover, s\u03c3 \u2264 opt(r, J), and therefore we have {\u03b1} {hd(r, J)} = {A(a, opt(r, J))} T P (J). \u2022 Assume {\u03b1} T P (J). Then, there exist a rule r = \u03d5 \u2192 A(a, s) \u2208 P and an integer solution \u03c3 to C(r, J) such that {\u03b1} {hd(r, J)} = {A(a, s\u03c3)} where s\u03c3 = opt(r, J). Proposition B.1 then ensures J |= \u03d5\u03c3, and so I |= \u03d5\u03c3 holds as well. Thus, \u03b3 \u2208 I P (I) holds for each fact \u03b3 with {\u03b3} {A(a, s\u03c3)}, so we have \u03b1 \u2208 I P (I).\n(Claim 3) Consider an arbitrary max fact \u03b1 of the form A(a, \u221e); the proof for a min fact is analogous. In the following, let S = {A(a, k) | k \u2208 Z}.\n\u2022 Assume S \u2286 I P (I). Program P contains only finitely many rules, so the infinitely many facts of S in I P (I) are produced by a rule r = \u03d5 \u2192 A(a, s) \u2208 P and an infinite sequence (\u03c3 i ) i\u22650 of groundings of r such that, for each i, we have I |= \u03d5\u03c3 i and s\u03c3 i < s\u03c3 i+1 . But then, J |= \u03d5\u03c3 i , so Proposition B.1 ensures that \u03c3 i satisfies C(r, J) for each i \u2265 0; therefore, opt(r, J) = \u221e and \u03b1 \u2208 T P (J) holds. \u2022 Assume A(a, \u221e) \u2208 T P (J). Then, a rule r = \u03d5 \u2192 A(a, s) \u2208 P exists such that opt(r, J) = \u221e, so an infinite sequence (\u03c3 i ) i\u22650 of solutions to C(r, J) exists such that s\u03c3 i < s\u03c3 i+1 for each i \u2265 0. Proposition B.1 ensures J |= \u03d5\u03c3 i for each i \u2265 0, and so I |= \u03d5\u03c3 i as well. Thus, for each k \u2208 Z, some i \u2265 0 exists such that k \u2264 s\u03c3 i , and therefore we have {A(a, k)} {A(a, s\u03c3 i )}; consequently, S \u2286 I P (I) holds.\nLemma 14. For each semi-ground limit program P, operator T P is monotonic w.r.t. . Moreover, J |= P if and only if T P (J) J for each pseudo-interpretation J.\nProof. Immediate from Lemmas B.3 and B.4.\nTheorem 15. For P a semi-ground limit program and \u03b1 a fact, P |= \u03b1 if and only if T \u221e P |= \u03b1; also, |T \u221e P | \u2264 |P|; and J |= P implies T \u221e P J for each pseudo-interpretation J.\nProof. By inductively applying Lemma B.4, for each n \u2265 0, the limit-closed interpretation I n P clearly corresponds to the pseudo-interpretation T n P . Thus, I \u221e P and T \u221e P also correspond on all object and ordinary numeric facts. Now consider an arbitrary n-ary max predicate A and a tuple of n \u2212 1 objects a, and for M = {k | A(a, k) \u2208 I \u221e P } consider the following cases. \u2022 M = \u2205. Then, for each n \u2265 0 and each k \u2208 Z, we have A(a, k) \u2208 I n P , which implies A(a, k) \u2208 T n P and A(a, \u221e) \u2208 T n P . Finally, T \u221e P is the least (w.r.t. ) fixpoint of T P , so A(a, k) \u2208 T \u221e P and A(a, \u221e) \u2208 T \u221e P holds as well. \u2022 There exists = max M . Then, there exists n \u2265 0 such that A(a, ) \u2208 I n P , and A(a, ) \u2208 I m P for each > and m \u2265 0; but then, A(a, ) \u2208 T n P , and A(a, ) \u2208 T m P for each > and m \u2265 0; finally, T \u221e P is the least (w.r.t. ) fixpoint of operator T P , so A(a, ) \u2208 T \u221e P holds. \u2022 M = Z. Then, for each k \u2208 Z, there exists n \u2265 0 such that A(a, k) \u2208 I n P , and so T n P |= A(a, k) holds; but then, A(a, \u221e) \u2208 T n P holds as well. Analogous reasoning holds for min predicates, so I \u221e P corresponds to T \u221e P . But then, the first and the third claim of this theorem follow straightforwardly from Lemma B.3. Moreover, pseudo-interpretations contain at most one fact per combination of a limit predicate and a tuple of objects (of corresponding arity), and program P is semi-ground so each rule in P produces at most one fact in T \u221e P , which implies the second claim of this theorem.\nC Proofs for Section 5\nTheorem 16. For P a semi-ground limit program and \u03b1 a fact, checking P |= \u03b1 and checking applicability of a rule of P to a pseudo-interpretation are both undecidable.\nProof. We present a reduction from Hilbert's tenth problem, which is to determine whether, given a polynomial P (x 1 , . . . , x n ) over variables x 1 , . . . , x n , equation P (x 1 , . . . , x n ) = 0 has integer solutions. It is well known that the problem remains undecidable even if the solutions must be nonnegative integers, so we use that variant in this proof. For each such polynomial P , let P P be the program containing rules ( 29)-( 30) for A a unary min predicate and B a nullary object predicate; it is obvious that P P |= B if and only if P (x 1 , . . . , x n ) = 0 has a nonnegative integer solution.\n\u2192 A(0) (29) n i=1 A(x i ) \u2227 (P (x 1 , . . . , x n ) \u2264 0) \u2227 (P (x 1 , . . . , x n ) \u2265 0) \u2192 B (30\n)\nMoreover, rule ( 30) is applicable to J = {A(0)} if and only if P (x 1 , . . . , x n ) = 0 has a nonnegative integer solution.\nAlthough Presburger arithmetic does not have propositional variables, these can clearly be axiomatised using numeric variables. Hence, in the rest of this section we use propositional variables in Presburger formulas for the sake of clarity. Definition C.1. For each n-ary object predicate A, each (n + 1)-ary ordinary numeric predicate B, each (n + 1)-ary limit predicate C, each n-tuple of objects a, and each integer k, let def Aa , def Bak , def Ca and fin Ca be distinct propositional variables, and let val Ca a distinct integer variable. Moreover, let C be \u2264 (resp. \u2265) if C is a max (resp. min) predicate.\nFor P a semi-ground program, Pres(P) = r\u2208P Pres(r) is the Presburger formula where Pres(r) = \u2200y.r for y all numeric variables in r and r is obtained by replacing each atom \u03b1 in r with its encoding Pres(\u03b1) defined as follows:\n\u2022 Pres(\u03b1) = \u03b1 if \u03b1 is a comparison atom;\n\u2022 Pres(\u03b1) = def Aa if \u03b1 is an object atom of the form A(a);\n\u2022 Pres(\u03b1) = def Bak if \u03b1 is an ordinary numeric atom of the form B(a, k); and\n\u2022 Pres(\u03b1) = def Ca \u2227 (\u00acfin Ca \u2228 s C val Ca ) if \u03b1 is a limit atom of the form C(a, s).\nLet J be a pseudo-interpretation, and let \u00b5 be an assignment of Boolean and integer variables. Then, J corresponds to \u00b5 if all of the following conditions hold for all A, B, C, and a as specified above, for each integer k \u2208 Z:\n\u2022 \u00b5(def Aa ) = true if and only if A(a) \u2208 J;\n\u2022 \u00b5(def Bak ) = true if and only if B(a, k) \u2208 J;\n\u2022 \u00b5(def Ca ) = true if and only if C(a, \u221e) \u2208 J or there exists \u2208 Z such that C(a, ) \u2208 J;\n\u2022 \u00b5(fin Ca ) = true and \u00b5(val Ca ) = k if and only if C(a, k) \u2208 J.\nNote that k in Definition C.1 ranges over all integers (which excludes \u221e), \u00b5(val Ca ) is an equal to some integer k, and J is a pseudo-interpretation and thus cannot contain both C(a, \u221e) and C(a, k); thus, C(a, \u221e) \u2208 J implies \u00b5(fin Ca ) = false.\nAlso note that each assignment \u00b5 corresponds to precisely one J; however, each J corresponds to infinitely many assignments \u00b5 since Definition C.1 does not restrict the value of variables other than def Aa , def Bak , def Ca , fin Ca , and val Ca . Moreover, two assignments corresponding to the same pseudo-interpretation may differ on the value of val Ca if fin Ca is set to false in both assignments, and they can differ on the values of fin Ca and val Ca if def Ca is set to false in both assignments.\nLemma C.2. Let J be a pseudo-interpretation and let \u00b5 be a variable assignment such that J corresponds to \u00b5. Then, 1. J |= \u03b1 if and only if \u00b5 |= Pres(\u03b1) for each ground atom \u03b1, and 2. J |= r if and only if \u00b5 |= Pres(r) for each semi-ground rule r.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Proof. (Claim 1)", "text": "We consider all possible forms of \u03b1.\n\u2022 \u03b1 is a comparison atom. Then, the truth of \u03b1 is independent from J so the claim is immediate.\n\u2022 \u03b1 = A(a) is an object fact. Then, Pres(\u03b1) = def Aa , and \u00b5(def Aa ) = true if and only if def Aa \u2208 J, so the claim holds.\n\u2022 \u03b1 = B(a, k) is an ordinary numeric fact. The proof is analogous to the case of object facts.\n\u2022 \u03b1 = C(a, k) is a limit fact. If J |= \u03b1, then either C(a, \u221e) \u2208 J or an integer exists such that C(a, ) \u2208 J and k C ; either way, \u00b5(def Ca ) = true holds; moreover, \u00b5(fin Ca ) = false holds in the former and \u00b5(val Ca ) = holds in the latter case; thus, \u00b5 |= Pres(r) clearly holds. The converse direction is analogous so we omit it for the sake of brevity.\n(Claim 2) Let r be an arbitrary semi-ground rule, and let I be the limit-closed interpretation corresponding to J. By definition, J |= r if and only if I |= r, and the latter is equivalent to I |= r for each ground instance r of r by the semantics of universal quantification in first-order logic; but then, the latter claim is equivalent to J |= r for each ground instance r of r. Now note that, by construction, we have Pres(\u03b2\u03c3) = Pres(\u03b2)\u03c3 for each semi-ground atom \u03b2 and each grounding \u03c3, and thus Pres(r\u03c3) = Pres(r)\u03c3. Finally, groundings of r can be equivalently seen as variable assignments to universally quantified numeric variables in Pres(r), so Claim 2 follows immediately from Claim 1.\nLemma 18. For P a semi-ground limit-linear program and \u03b1 a fact, there exists a Presburger sentence \u03d5 = \u2200x\u2203y. n i=1 \u03c8 i that is valid if and only if P |= \u03b1. Each \u03c8 i is a conjunction of possibly negated atoms. Moreover, |x| + |y| and each \u03c8 i are bounded polynomially by P + \u03b1 . Number n is bounded polynomially by |P| and exponentially by max r\u2208P r . Finally, the magnitude of each integer in \u03d5 is bounded by the maximal magnitude of an integer in P and \u03b1.\nProof. Lemma C.2 immediately implies that P |= \u03b1 if and only if the sentence \u03d5 0 = \u2200x. Pres(\u03b1) \u2228 \u00acPres(P) is valid, where x contains all variables def Aa , def Bak , def Ca , fin Ca , and val Ca occurring in Pres(P) or Pres(\u03b1). Clearly, |x| is polynomially bounded by P + \u03b1 , and the magnitude of each integer in \u03d5 0 is bounded by the maximum magnitude of an integer in P and \u03b1. Let \u03d5 1 be the sentence obtained from \u03d5 0 by converting each top-level conjunct of Pres(P) into form \u2200y i .\u03c7 i where \u03c7 i is in CNF. Formulae \u03d5 0 and \u03d5 1 are equivalent, and \u03d5 1 is of the form \u03d5 1 = \u2200x. Pres(\u03b1) \u2228 \u00ac n i=1 \u2200y i . i j=1 \u03c7 j i , where n = |P| and, for each rule r i \u2208 P, integer i is exponentially bounded by r i , and \u03c7 j i and |y i | are linearly bounded by r i . By moving all quantifiers to the front of the formula and pushing negations inwards, we finally obtain formula \u03d5 2 = \u2200x\u2203y.Pres(\u03b1) \u2228 n i=1 i j=1 \u03c8 j i , where y = n i=1 y i and each \u03c8 j i is the negation-normal form of \u00ac\u03c7 j i . Formula \u03d5 2 is of the required form, |y| is bounded polynomially by P , number n i=1 i is bounded polynomially by n = |P| and exponentially by max r\u2208P r , and \u03c8 j i is bounded linearly by P .\nLemma 19. Let \u03d5 = \u2200x\u2203y. n i=1 \u03c8 i be a Presburger sentence where each \u03c8 i is a conjunction of possibly negated atoms of size at most k mentioning at most variables, a is the maximal magnitude of an integer in \u03d5, and m = |x|. Then, \u03d5 is valid if and only if \u03d5 is valid over models where each integer variable assumes a value whose magnitude is bounded by\n(2 O( log ) \u2022 a k ) n2 \u2022O(m 4 ) .\nProof. Let m = |y|. Each \u03c8 i can be seen as a system of linear inequalities\nS i = (A i x \u2264 c i ) such that |x| \u2264 , |c i | \u2264 k,\nand where the maximal magnitude of all numbers in A and c i is bounded by a k . By Proposition 3 of Chistikov and Haase [2016] (adapted from the work by von zur Gathen and Sieveking [1978]), the set of solutions to S i can be represented by a semi-linear set i \u2208Ni L(b i , P i ) where b i \u2208 Z , P i \u2286 Z , |N i | \u2264 2 , and the magnitude of all integers in b i and P i is bounded by 2 O( log ) \u2022 a k . Consequently, disjunction n i=1 \u03c8 i corresponds to a semi-linear set j\u2208M L(b j , P j ) where b j \u2208 Z m+m , P j \u2286 Z m+m , |M | \u2264 n2 , and the magnitude of each integer in b j and P j is still bounded by 2 O( log ) \u2022 a k . Formula \u2203y. n i=1 \u03c8 i then corresponds to the projection of j\u2208M L(b j , P j ) on the variables in x, which is a semi-linear set of the form j\u2208M L(b j , P j ) where each b j \u2208 Z m is a projection of b j on x, and each P j \u2286 Z m is a projection of P j on x. Now, Theorem 21 by Chistikov and Haase [2016] implies that the satisfying assignments to the formula \u03d5 = \u00ac\u2203y. n i=1 \u03c8 i can be represented as a semi-linear set j \u2208M L(c j , Q j ) where the magnitude of each integer in each c j and Q j is bounded by\nb = (2 O( log ) \u2022 a k ) n2 \u2022O(m 4 )\n. Since \u03d5 has a satisfying assignment if and only if it has a satisfying assignment involving only numbers from some c j , it follows that \u03d5 is satisfiable if and only if it is satisfiable over models where the absolute value of every integer variable is bounded by b. This implies the claim of this lemma since \u03d5 is valid if and only if \u03d5 is unsatisfiable.\nTheorem 20. For P a semi-ground limit-linear program, D a dataset, and \u03b1 a fact, P \u222a D |= \u03b1 if and only if a pseudo-model J of P \u222a D exists where J |= \u03b1, |J| \u2264 |P \u222a D|, and the magnitude of each integer in J is bounded polynomially by the largest magnitude of an integer in P \u222a D, exponentially by |P|, and double-exponentially by max r\u2208P r .\nProof. The \u21d0 direction is trivial. For the \u21d2 direction assume that P \u222a D |= \u03b1 holds, and let D be obtained from D by removing each fact that does not unify with an atom in P or \u03b1; clearly, we have P \u222a D |= \u03b1. Let \u03d5 = \u2200x\u2203y. n i=1 \u03c8 i be the Presburger sentence from Lemma 18 for P \u222a D and \u03b1. Sentence \u03d5 is not valid and it satisfies the following conditions.\n\u2022 Number m = |x| is polynomial in P \u222a D , which, in turn, is bounded by |P \u222a D | \u2022 max r\u2208P\u222aD r . Moreover, D contains only facts that unify with atoms in P and \u03b1, so m can be bounded further, namely linearly in the product cs, for c = |P| and s = max r\u2208P P . \u2022 Number n is linear in the product of c and 2 s . \u2022 The size, and hence the number of variables in each \u03c8 i , are linear in s. Let a be the maximal magnitude of an integer in P \u222a D (and thus in \u03d5 as well). By Lemma 19, an assignment \u00b5 exists such that \u00b5 |= \u03d5 and the magnitude of each integer variable is bounded by\nb = (2 O(s log s) \u2022 a O(s 2 ) ) O(c\u20222 s )\u20222 O(s) \u2022O((cs) 4 )\n. Clearly, b is polynomial in a, exponential in c, and doubly-exponential in s, as required. Moreover, clearly \u00b5 |= Pres(P \u222a D ) and \u00b5 |= Pres(\u03b1). Now let J be the pseudo-model corresponding to \u00b5; by Lemma C.2, we have J |= P \u222a D and J |= \u03b1. By construction, the magnitude of each integer in J is bounded by b. Furthermore, let J be the restriction of J to the facts that unify with the head of at least one rule in P \u222a D ; clearly, we still have J |= P \u222a D and J |= \u03b1. Finally, |J| \u2264 |P \u222a D | holds by our construction, which implies our claim.\nLemma C.3. For each semi-ground, limit-linear program P, pseudo-interpretation J, and dataset D, there exists a polynomial p such that T P\u222aD (J) can be computed in nondeterministic polynomial time in P + D + J , and in deterministic polynomial time in P + D + J p(max r\u2208P r ) .\nProof. Let S = {hd(r, J) | rule r \u2208 P \u222a D is applicable to J}. Program P is semi-ground, and therefore P \u222a D is semiground as well; thus, each rule of P \u222a D can contribute at most one fact to S, so we have |S| \u2264 |P| + |D|. By Definition 12, T P\u222aD (J) is the smallest (w.r.t. ) pseudo-interpretation such that T P\u222aD (J) |= S, so we can compute T P\u222aD (J) as the set containing each object and ordinary numeric fact in S, each fact A(a, \u221e) \u2208 S for A a limit predicate, each fact A(a, ) \u2208 S such that A is a min (resp. max) predicate and A(a, k) \u2208 S implies k = \u221e and k \u2265 (resp. k \u2264 ). To complete the proof of this lemma, we next argue that set S can be computed within the required time bounds. Consider an arbitrary rule r \u2208 P \u222a D, and let J be the subset of J containing all facts that unify with a body atom in r; note that |J | \u2264 r . Rule r is applicable to J if and only if conjunction C(r, J ) has an integer solution. By construction, C(r, J ) is linear in r + J , the number of variables in C(r, J ) and r is the same, |C(r, J )| is linear in r , and the magnitude of each integer in C(r, J ) is exponentially bounded in r + J . But then, checking whether C(r, J) has an integer solution is in NP w.r.t. r + J , and in PTIME w.r.t. J p( r ) for some polynomial p, as we argue next.\n\u2022 We first consider the former claim. Let a be the maximal magnitude of an integer in C(r, J ). Conjunction C(r, J ) contains only the numbers from r and J , whose magnitude is at most 2 r and 2 J , respectively; thus, we have a \u2264 2 r + J . Moreover, the results by Papadimitriou [1981] show that there exists a polynomial p 1 such that the magnitude of an integer in a solution to C(r, J ) can be bounded by b = a p1( r ) , and so there exists a polynomial p 2 such that b \u2264 2 p2( r + J ) . The binary representation of b thus requires at most r + J bits, and so we can guess it in polynomial time. \u2022 We next consider the latter claim. By Theorem 5.4 of Kannan [1987], checking satisfiability of C(r, J) over Z is fixedparameter tractable in the number n of variables in r-that is, there exists a polynomial p 3 such that a solution to C(r, J) can be computed in time O(( r + J ) \u2022 2 p3(n) ). Since n \u2264 r clearly holds, there exists a polynomial p 4 such that the satisfiability of C(r, J) can be checked in time that is thus J p4( r ) . Now assume that r is applicable to J. Then hd(r, J) = h(r) if h(r) is an object atom, so we assume that h(r) = A(a, s) is a limit atom and argue that opt(r, J) can be computed within the required time bounds using the following two steps.\n1. Depending on whether A is a min or a max predicate, we check whether there is a smallest/largest value for s in all solutions to C(r, J)-that is, we check whether the integer linear program 'minimise/maximise s subject to C(r, J)' is bounded. Byrd et al. [1987] showed that this amounts to checking boundedness of the corresponding linear relaxation, which in turn can be reduced to checking linear feasibility and can be solved in deterministic polynomial time in r + J .\n2. If the above problem is bounded, we compute its optimal solution, which can be reduced to polynomially many (in r + J ) feasibility checks, as shown by Papadimitriou [1981] (Corollary 2 with binary search). Each such feasibility check is in NP w.r.t. r + J , and in PTIME w.r.t. J p( r ) . Thus, hd(r, J) can be computed in nondeterministic polynomial time in r + J , and in deterministic polynomial time in J p( r ) , which implies our claim.\nLemma C.4. Deciding P |= \u03b1 is CONP-hard in data complexity for P a limit-linear program and \u03b1 a fact.\nProof. An instance T of the square tiling problem is given by an integer N coded in unary, a set T = {t 0 , . . . , t M \u22121 } of M tiles, and two compatibility relations H \u2286 T \u00d7 T and V \u2286 T \u00d7 T . The problem is to determine whether there exists a tiling \u03c4 : {0, . . . , N \u2212 1} 2 \u2192 T of an N \u00d7 N square such that \u03c4 (i, j), \u03c4 (i + 1, j) \u2208 H holds for all 0 \u2264 i < N \u2212 1 and 0 \u2264 j < N , and \u03c4 (i, j), \u03c4 (i, j + 1) \u2208 V holds for all 0 \u2264 i < N and 0 \u2264 j < N \u2212 1, which is known to be NP-complete. Thus, to prove the claim of this lemma, we reduce the complement of the problem by presenting a fixed program P tiling and a dataset D T (that depends on T ), and showing that T has no solution if and only if P tiling \u222a D T |= noSolution.\nOur encoding uses object EDB predicates succ, incompatibleH , and incompatibleV ; ordinary numeric EDB predicates shift, tileNo, numTiles, and maxTiling; nullary object IDB predicate noSolution; unary min IDB predicate I; and unary max IDB predicate tiling. Program P tiling contains rules (31)-( 35), where (s\n. = t) abbreviates (s \u2264 t) \u2227 (t \u2264 s). \u2192 I(0) (31) \u2192 tiling(0) (32) tiling(n) \u2227 numTiles(nt) shift(x, y, s) \u2227 tileNo(u, t) \u2227 I(m 1 ) \u2227 I(m 2 ) \u2227 (n . = m 1 \u00d7 nt \u00d7 s + t \u00d7 s + m 2 ) \u2227 (m 2 < s) succ(x, x ) shift(x , y, s ) \u2227 tileNo(u , t ) \u2227 I(m 1 ) \u2227 I(m 2 ) \u2227 (n . = m 1 \u00d7 nt \u00d7 s + t \u00d7 s + m 2 ) \u2227 (m 2 < s ) incompatibleH (u, u ) \u2227 \u2227 \u2227 \u2227 \u2192 tiling(n + 1) (33\n)\ntiling(n) \u2227 numTiles(nt) shift(x, y, s) \u2227 tileNo(u, t) \u2227 I(m 1 ) \u2227 I(m 2 ) \u2227 (n . = m 1 \u00d7 nt \u00d7 s + t \u00d7 s + m 2 ) \u2227 (m 2 < s) succ(y, y ) shift(x, y , s ) \u2227 tileNo(u , t ) \u2227 I(m 1 ) \u2227 I(m 2 ) \u2227 (n . = m 1 \u00d7 nt \u00d7 s + t \u00d7 s + m 2 ) \u2227 (m 2 < s ) incompatibleV (u, u ) \u2227 \u2227 \u2227 \u2227 \u2192 tiling(n + 1) (34\n)\ntiling(n) \u2227 maxTiling(m) \u2227 (m < n) \u2192 noSolution (35)\nDataset D T contains facts ( 36)-( 42), where g 0 , . . . , g N \u22121 are fresh objects, and t i for 0 \u2264 i < M are distinct objects corresponding to the tiles in T . Since N is coded in unary, although numbers M N 2 \u2212 1 and M i+N j are exponential in N , they can be computed in polynomial time and represented using polynomially many bits.\n\u2192 numTiles(M ) (36) \u2192 tileNo(t i , i) for each 0 \u2264 i < M (37) \u2192 incompatibleH (t i , t j ) for each 0 \u2264 i, j < M such that (t i , t j ) / \u2208 H (38) \u2192 incompatibleV (t i , t j ) for each 0 \u2264 i, j < M such that (t i , t j ) / \u2208 V (39) \u2192 maxTiling(M N 2 \u2212 1) (40) \u2192 succ(g i , g i+1 ) for each 0 \u2264 i < N \u2212 1 (41) \u2192 shift(g i , g j , M i+N j ) for each 0 \u2264 i, j < N (42\n)\nOur reduction uses the following idea. Facts (37) associate each tile t i with an integer i where 0 \u2264 i < M ; hence, in the rest of this discussion, we do not distinguish a tile from its number. This allows us to represent each tiling \u03c4 using a number 0\u2264i,j<N \u03c4 (i, j) \u00d7 M i+N j . Thus, given a number n that encodes a tiling, number t with 0 \u2264 t < M corresponds to the tile assigned to position (i,\nj) if n = m 1 \u00d7 M \u00d7 M i+N j + t \u00d7 M i+N j + m 2\nfor some integers m 1 and m 2 where 0 \u2264 m 2 < M i+N j . Thus, if numeric variable n is assigned such an encoding of a tiling and numeric variable s is assigned the factor M i+N j corresponding to a position (i, j), then conjunction\ntileNo(u, t) \u2227 I(m 1 ) \u2227 I(m 2 ) \u2227 (n . = m 1 \u00d7 nt \u00d7 s + t \u00d7 s + m 2 ) \u2227 (m 2 < s)\nis true if and only if u is assigned the tile object corresponding to position (i, j) in the tiling encoded by n. To complete the construction, we represent each position (i, j) by a pair of objects (g i , g j ), each of which is associated with the corresponding factor M i+N j using facts (42). Facts ( 41) provide an ordering on g i , which allows us to identify adjacent positions. Finally, fact (40) records the maximal number that encodes a tiling as we outlined earlier. Program P tiling then simply checks through all tilings: rule ( 32) ensures that the tiling encoded as 0 is checked; moreover, for each n such that tiling(n) holds, rules ( 33) and ( 34) derive tiling(n + 1) if either the horizontal or the vertical compatibility requirement is violated for the tiling encoded by n. Finally, rule (35) detects that no solution exists if tiling(M N 2 ) is derived.\nLemma C.5. Deciding P |= \u03b1 is CONEXPTIME-hard for P a limit-linear program and \u03b1 a fact.\nProof. We present a reduction from the succinct square tiling problem. An instance T of the problem is given by an integer N coded in unary, a set T containing M tiles, and horizontal and vertical compatibility relations H and V , respectively, as in the proof of Lemma C.4; however, the objective is to tile a square of 2 N \u00d7 2 N positions, which is known to be NEXPTIMEcomplete. Thus, to prove the claim of this lemma, we reduce the complement of the problem by presenting a program P T and showing that T has no solution if and only if P T |= noSolution.\nThe main idea behind our reduction is similar to Lemma C.4. Program P T contains rules ( 43)-( 45) that associate each tile with a number using an ordinary numeric predicate tileNo, and encode the horizontal and vertical incompatibility relations using the object predicates incompatibleH and incompatibleV .\n\u2192 tileNo(t i , i) for each 0 \u2264 i < M (43) \u2192 incompatibleH (t i , t j ) for each 0 \u2264 i, j < M such that (t i , t j ) / \u2208 H (44) \u2192 incompatibleV (t i , t j ) for each 0 \u2264 i, j < M such that (t i , t j ) / \u2208 V(45)\nThe main difference to Lemma C.4 is that, in order to obtain a polynomial encoding, we cannot represent a position (i, j) in the grid explicitly using a pair of objects. Instead, we encode each position using a pair (i, j) where i and j are N -tuples of objects0 and1. If we read0 and1 as representing numbers 0 and 1, respectively, then each i and j can be seen as a binary number in [0, 2 N \u2212 1]. By a slight abuse of notation, we often identify a tuple over0 and1 with the number it encodes and use tuples in arithmetic expressions. While positions can be encoded using N bits, we will also need to ensure distance between positions, which requires N + 1 bits. In the rest of this proof,0 and1 stand for tuples0, . . . ,0 and1, . . . ,1, respectively, whose length is often implicit from the context where these tuples occur. Similarly, x, x , y, and y are tuples of distinct variables whose length will also be clear from the context.\nTo axiomatise an ordering on numbers with N bits, program P T contains rules ( 46)-( 49), where B is a unary object predicate, succ is a 2N -ary object predicate, and succ is a (2N + 2)-ary object predicate. Rules ( 46)-( 48) ensure P T |= succ(i, j) where i and j encode numbers with N bits such that j = 1 + i; in particular, rule (48) encodes binary incrementation, where x10 = 1 + x10 holds for each position k and each k-tuple of zeros and ones x. Rules ( 46)-( 47) and ( 49) ensure an analogous property for succ , but for numbers with N + 1 bits.\n\u2192 B (0) (46) \u2192 B (1)(47)\nk i=1 B (x i ) \u2192 succ(x,0,1, x,1,0) for each 0 \u2264 k < N where |x| = k and |1| = |0| = N \u2212 k \u2212 1 (48) k i=1 B (x i ) \u2192 succ (x,0,1, x,1,0) for each 0 \u2264 k < N + 1 where |x| = k and |1| = |0| = N \u2212 k (49)\nAnalogously to the proof of Lemma C.4, we encoded tilings using numbers in [0, M 2 2N \u2212 1]. To compute the maximum number encoding a tiling, program P T contains rules ( 50)-( 53), where maxTiling is a unary min predicate, and auxT is a (2N + 1)-ary min predicate. Auxiliary rules ( 50)-( 52) multiply M with itself as many times as there are grid positions, so we have P T |= auxT (i, j, M 1+i+2 N \u2022j ) for each position (i, j). Consequently, rule (53) ensures that, for all s, we have\nP T |= maxTiling(s) if and only if s \u2265 M 2 2N \u2212 1. \u2192 auxT (0,0, M ) (50) auxT (x, y, n) \u2227 succ(x, x ) \u2192 auxT (x , y, M \u00d7 n) (51) auxT (1, y, n) \u2227 succ(y, y ) \u2192 auxT (0, y , M \u00d7 n) (52) auxT (1,1, n) \u2192 maxTiling(n \u2212 1)(53)\nUnlike in the proof of Lemma C.4, we cannot include shift factors explicitly into P T since this would make the encoding exponential; moreover, we could precompute shift factors using rules similar to (50)-( 52), but then we would need to use values from limit predicates in multiplication, which would not produce a limit-linear program. Therefore, we check tilings using a different approach. As in the proof of Lemma C.4, our construction ensures that, for all s, we have P T |= tiling(s) if and only if each tiling n with 0 \u2264 n \u2264 s does not satisfy the compatibility relations. Given a tiling encoded by n and a position (i, j), let\ns n,i,j = n M i+j\u20222 N .\nProgram P T contains rules ( 54)-( 57) where shiftedTiling is a max predicate of arity 2N + 1 and I is a unary min predicate. These rules ensure that, for each i, j, and tiling n such that P T |= tiling(n), we have P T |= shiftedTiling(i, j, s n,i,j ). To understand how this is achieved, we order the grid positions as follows:\n(0, 0), (1, 0), . . . , (2 N \u2212 1, 0), (0, 1), (1, 1), . . . , (2 N \u2212 1, 1), . . . . . . , (0, 2 N \u2212 1), (1, 2 N \u2212 1), . . . , (2 N \u2212 1, 2 N \u2212 1)\nNow consider an arbitrary position (i, j) and its successor (i , j ) in the ordering. The encoding of a tiling using an integer n ensures s n,i,j = M \u00d7 s n,i ,j + t holds, where 0 \u2264 t < M is the number of the tile that n assigns to position (i, j). Thus, rule (55) ensures that position (0,0) satisfies the mentioned property, rule (56) handles adjacent positions of the form (i, j) and (i + 1, j), and rule (57) handles adjacent positions of the form (1, j) and (0, j + 1).\n\u2192 I (0) (54) tiling(n) \u2192 shiftedTiling(0,0, n) (55) shiftedTiling(x, y, n) \u2227 succ(x, x ) \u2227 I ( ) \u2227 I (m) \u2227 ( < M ) \u2227 (n . = M \u00d7 m + ) \u2192 shiftedTiling(x , y, m) (56) shiftedTiling(1, y, n) \u2227 succ(y, y ) \u2227 I ( ) \u2227 I (m) \u2227 ( < M ) \u2227 (n . = M \u00d7 m + ) \u2192 shiftedTiling(0, y , m)(57)\nNote that, for all n and n with n < n and each position (i, j), we have s n,i,j < s n ,i,j . Thus, since shiftedTiling is a max predicate, the limit value for s in shiftedTiling(i, j, s) will always correspond to the limit value for n in tiling(n). Checking horizontal compatibility is now easy, but checking vertical compatibility requires dividing s n,i,j by M 2 N , which would make the reduction exponential. Hence, P T checks compatibility using rules ( 58)-( 61), where conflict is a max predicate of arity 3N + 3. These rules ensure that, for each i, j, d, u, and tiling n such that P T |= tiling(n) and the position that precedes (i, j) by distance d in the ordering cannot be labelled in n with tile u, we have P T |= conflict(i, j, d, u, s n,i,j ). To this end, assume that (x, y) is labelled with tile u ; now if (u, u ) \u2208 H and x =0 (i.e., the predecessor x of x exists), then rule (58) says that the position preceding (x, y) by01 (i.e., the position to the left) cannot be labelled with u; moreover, if (u, u ) \u2208 V and y =0 (i.e., the predecessor y of y exists), then rule (59) says that the position preceding (x, y) by10 = 2 N (i.e., the position above) cannot be labelled with u. Moreover, rule (60) propagates such constraints from position (i, j) to (i \u2212 1, j) while reducing the distance by one, and rule (61) does so for positions (0, j) and (1, j \u2212 1).\nshiftedTiling(x, y, m) \u2227 succ(x , x) \u2227 incompatibleH (u, u ) \u2227 tileNo(u , t ) I ( ) \u2227 (m . = M \u00d7 + t ) \u2227 \u2192 conflict(x, y,01, u, m)(58)\nshiftedTiling(x, y, m) \u2227 succ(y , y) \u2227 incompatibleV (u, u ) \u2227 tileNo(u , t ) I ( ) \u2227 (m . = M \u00d7 + t ) \u2227 \u2192 conflict(x, y,10, u, m)(59)\nshiftedTiling(x, y, m) \u2227 succ(x, x ) \u2227 conflict(x , y, z , u, m ) \u2227 succ (z, z ) I ( ) \u2227 ( < M ) \u2227 (m . = M \u00d7 m + ) \u2227 \u2192 conflict(x, y, z, u, m)(60)\nshiftedTiling(1, y, m) \u2227 succ(y, y ) \u2227 conflict(0, y , z , u, m ) \u2227 succ (z, z ) I ( ) \u2227 ( < M ) \u2227 (m . = M \u00d7 m + ) \u2227 \u2192 conflict(1, y, z, u, m)(61)\nProgram P T also contains rules ( 62)-( 64) where invalid is a (2N + 1)-ary max predicate. These rules ensure that, for each i, j, and each tiling n such that P T |= tiling(n) and there exists a position (i , j ) that comes after (i, j) in the position order such that n does not satisfy the compatibility relations between (i , j ) and its horizontal or vertical successor, we have P T |= invalid (i, j, s n,i,j ). Rule ( 62) determines invalidity at position (x, y) for conflicts with zero distance, and rules ( 63) and ( 64) propagate this information to preceding positions analogously to rules (60) and (61).\nconflict(x, y,0, u, m) \u2227 tileNo(u, t) \u2227 I ( ) \u2227 (m . = M \u00d7 + t) \u2192 invalid (x, y, m) (62) shiftedTiling(x, y, m) \u2227 succ(x, x ) \u2227 invalid (x , y, m ) I ( ) \u2227 ( < M ) \u2227 (m . = M \u00d7 m + ) \u2227 \u2192 invalid (x, y, m)(63)\nshiftedTiling(1, y, m) \u2227 succ(y, y ) \u2227 invalid (0, y , m ) I ( ) \u2227 ( < M ) \u2227 (m . = M \u00d7 m + ) \u2227 \u2192 invalid (1, y, m)(64)\nFinally, program P T contains rules ( 65)-( 67) where tiling is a unary max predicate and noSolution is a nullary predicate. Rule ( 65) ensures that tiling encoded by 0 is checked. Based on our discussion from the previous paragraph, for each invalid tiling n such that P T |= tiling(n), we have P T |= invalid (0,0, s0 ,0,n ); moreover, s0 ,0,n = n so, if P T |= invalid (0,0, n) holds, then rule ( 66) ensures that tiling encoded by n + 1 is considered; atom (m . = n) is needed in the rule since no numeric variable is allowed to occur in more than one standard body atom. If we exhaust all available tilings, rule (67) determines that no solution exists, just as in the proof of Lemma C.4.\n\u2192 tiling(0) (65) invalid (0,0, m) \u2227 tiling(n) \u2227 (m . = n) \u2192 tiling(n + 1) (66) tiling(n) \u2227 maxTiling(m) \u2227 (m < n) \u2192 noSolution (67)\nBased on our discussion of the consequences of P T , we conclude that instance T of the succinct tiling problem does not have a solution if and only if P T |= noSolution.\nProposition C.6. For J a pseudo-interpretation and \u03b1 a fact, J |= \u03b1 if and only if {\u03b1} J.\nProof. Consider an arbitrary pseudo-interpretation J and the corresponding limit-closed interpretation I. If J |= \u03b1, then \u03b1 \u2208 I, so there exists a fact \u03b1 \u2208 J such that such that {\u03b1} {\u03b1 }, which implies {\u03b1} J. Moreover, if {\u03b1} J, then there exists a fact \u03b1 \u2208 J such that {\u03b1} {\u03b1 } and, since I is limit-closed, we have \u03b1 \u2208 I, which implies J |= \u03b1.\nTheorem 21. For P a limit-linear program and \u03b1 a fact, deciding P |= \u03b1 is CONEXPTIME-complete in combined and CONPcomplete in data complexity.\nProof. Lemmas C.4 and C.5 prove hardness. Moreover, the following nondeterministic algorithm decides P \u222a D |= \u03b1 in time polynomial in D + \u03b1 , and exponential in P + D + \u03b1 .\n1. Compute the semi-grounding P of P.\n2. Guess a pseudo-interpretation J over the signature of P \u222a D such that the number of facts in J and the absolute values of all integers in J are bounded as in Theorem 20.\n3. Check that J is a pseudo-model of P \u222a D; if not, return false. 4. Return false if J |= \u03b1 and true otherwise. Correctness of the algorithm follows from Theorem 20, so we next argue about its complexity. The mentioned data complexity holds by the following observations.\n\u2022 In step 1, P , |P |, and the time required to compute P are all polynomial in D and constant in \u03b1 .\n\u2022 Since |P | is polynomial in D and constant in \u03b1 , and max r\u2208P r is constant in D and \u03b1 , the magnitude of the integers in J is exponentially bounded in \u03b1 + D by Theorem 20; thus, the number of bits needed to represent each integer in J is polynomial in \u03b1 + D . Furthermore, we have |J| \u2264 |D| + |P |, and |D| + |P | is polynomial in D and constant in \u03b1 ; thus, J can be guessed in step 2 in nondeterministic polynomial time in \u03b1 + D . \u2022 By Lemma 14, checking that J is a pseudo-model of P \u222a D amounts to checking T P \u222aD (J) = J. By Lemma C.3, T P \u222aD (J) can be computed in deterministic polynomial time in J + D and hence in D (as J is polynomial in D ). Hence, step 3 requires deterministic polynomial time in \u03b1 + D . \u2022 By Proposition C.6, step 4 amounts to checking {\u03b1} J, which can be done in time polynomial in J and \u03b1 , and hence polynomial in D + \u03b1 as well. Finally, the mentioned combined complexity holds by the following observations.\n\u2022 In step 1, P , |P |, and time required to compute P are all exponential in P + D and constant in \u03b1 .\n\u2022 Since |P | is exponential in P + D and constant in \u03b1 , and max r\u2208P r is linear in P and constant in D + \u03b1 , the magnitude of the integers in J is doubly exponentially bounded in P + D + \u03b1 by Theorem 20; thus, the number of bits needed to represent each integer in J is exponential in P + D + \u03b1 . Furthermore, we have |J| < |D| + |P |, and |D| + |P | is exponential in P + D and constant in \u03b1 ; thus, J can be guessed in step 2 in nondeterministic exponential time in P + D + \u03b1 .\n\u2022 By Lemma 14, checking that J is a pseudo-model of P \u222aD amounts to checking T P \u222aD (J) = J. By Lemma C.3, polynomial p exists such that T P \u222aD (J) can be computed in deterministic polynomial time in P + D + J p(max r\u2208P r ) , which, in turn, is bounded by O(2 P + D ) + D + O(2 ( P + D )p(max r\u2208P r ) ). Hence, step 3 requires deterministic exponential time in P + D + \u03b1 .\n\u2022 By Proposition C.6, step 4 amounts to checking {\u03b1} J, which can be done in time polynomial in J and \u03b1 , and hence in time exponential in P + D + \u03b1 .", "publication_ref": ["b1", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "D Proofs for Section 6", "text": "For arbitrary value propagation graph G J P = (V, E, \u00b5), a path in G J P is a nonempty sequence \u03c0 = v 1 , . . . , v n of nodes from V such that v i , v i+1 \u2208 E holds for each 0 \u2264 i < n; such \u03c0 starts in v 1 and ends in v n . We define |\u03c0| = n; moreover, by a slight abuse of notation, we sometimes write \u03c0 \u2229 X = \u2205 or v i \u2208 \u03c0, where we identify \u03c0 with the set of its nodes. A path \u03c0 is simple if all of its nodes are pair-wise distinct. A path \u03c0 is a cycle if v n = v 1 .\nDefinition D.1. Given a semi-ground, limit linear program P, a pseudo-interpretation J, value propagation graph G J P = (V, E, \u00b5), and a path \u03c0 = v 1 , . . . , v n in G J P , the weight \u00b5(\u03c0) of \u03c0 is defined as\n\u00b5(\u03c0) = n\u22121 i=1 \u00b5( v i , v i+1 ).\nLemma D.2. Let P be a semi-ground and stable limit-linear program, let J be a pseudo-model of P, let G J P = (V, E, \u00b5), and let v Aa , v Bb \u2208 V be nodes such that v Ab is reachable from v Ba by a path \u03c0. Then, for each k \u2208 Z such that J |= B(b, k),\n\u2022 J |= A(a, k + \u00b5(\u03c0)) if A and B are both max predicates; Proof. We consider the case when A and B are both max predicates; the remaining cases are analogous. We proceed by induction on the length of \u03c0. The base case (\u03c0 is empty) is immediate. For the inductive step, assume that \u03c0 = \u03c0 , v Aa where \u03c0 is a path starting at v Bb and ending in node v Cc . Then, there exists an edge e = v Cc , v Aa \u2208 E, and e is produced by a rule r = C(c, n) \u2227 \u03d5 \u2192 A(a, s) \u2208 P such that n is a variable occurring in s, and \u03c3 is a grounding of r such that 1. J |= (C(c, n) \u2227 \u03d5)\u03c3, and 2. \u03b4 e r (J) = \u00b5(e) = \u00b5( v Cc , v Aa ). We next consider the case when C is a max predicate; the case when C is a min predicate is analogous. Let be such that C(c, ) \u2208 J. We have the following possibilities.\n\u2022 J |= A(a, \u2212k \u2212 \u00b5(\u03c0)) if A is a min predicate\n\u2022 If opt(r, J) and are both integers (i.e., they are not \u221e), we have \u00b5(e) = opt(r, J) \u2212 .\n\u2022 If opt(r, J) = \u221e, then \u00b5(e) = \u221e by Definition 23.\n\u2022 If = \u221e, then \u00b5(e) = \u221e by Definition 24 and the fact that P is stable, and moreover opt(r, J) = \u221e by Definition 23. Now for an arbitrary k \u2208 Z such that J |= B(b, k), we consider the following two cases.\n\u2022 \u00b5(e) = \u221e. The inductive hypothesis holds for \u03c0 , so J |= C(c, k + \u00b5(\u03c0 )) and thus k + \u00b5(\u03c0 ) \u2264 . Consequently, we have \u00b5(\u03c0) = \u00b5(\u03c0 ) + \u00b5(e) = \u00b5(\u03c0 ) + opt(r, J) \u2212 \u2264 opt(r, J) \u2212 k, and so k + \u00b5(\u03c0) \u2264 opt(r, J) holds. Moreover, J |= P implies T P (J) = J by Lemma 14; thus, Proposition C.6 and the definition of T P imply J |= A(a, k + \u00b5(\u03c0)).\n\u2022 \u00b5(e) = \u221e. Clearly, \u00b5(\u03c0) = \u221e. Moreover, J |= P implies T P (J) = J by Lemma 14; thus, opt(r, J) = \u221e, Proposition C.6, and the definition of T P imply J |= A(a, \u221e).\nLemma 26. For each semi-ground stable program P, each pseudo-interpretation J with J T \u221e P , and each node v Aa on a positive-weight cycle in G J P , we have A(a, \u221e) \u2208 T \u221e P .\nProof. Let G J P = (V, E, \u00b5), let J = T \u221e P , and let G J P = (V , E , \u00b5 ). Now assume for the sake of a contradiction that there exist a cycle \u03c0 in G J P and a node v Aa \u2208 \u03c0 such that \u00b5(\u03c0) > 0 and J |= A(a, \u221e). Rule applicability is monotonic w.r.t. , so \u03c0 is still a cycle in G J P , and, since P is stable, we have \u00b5 (\u03c0) \u2265 \u00b5(\u03c0) > 0. We consider the case when A is a max predicate; the remaining case is analogous. Now v Aa \u2208 V \u2286 V implies that A(a, k) \u2208 J for some k; moreover, J |= A(a, \u221e) implies k = \u221e. But then, Lemma D.2 implies J |= A(a, k + \u00b5 (\u03c0)); moreover, \u00b5 (\u03c0) > 0 implies that k + \u00b5 (\u03c0) is either \u221e or it is an integer larger than k; either way, this contradicts our assumption that A(a, k) \u2208 J .\nLemma 27. When applied to a semi-ground stable program P, Algorithm 1 terminates after at most 8|P| 6 iterations of the loop in lines 2-8.\nProof. For J a pseudo-interpretation, A an (n + 1)-ary limit predicate, and a an n-tuple of objects such such that A(a, ) \u2208 J, let val(J, Aa) = if = \u221e or A is a max predicate and \u2208 Z, and val(J, Aa) = \u2212 if A is a min predicate and \u2208 Z; moreover, let R(J, Aa) be the set containing each rule r \u2208 P that is applicable to J and where h(r) is of the form A(a, s). By monotonicity of Datalog Z , we have R(J, Aa) \u2286 R(J , Aa) for each J and J such that J J . Moreover, for each edge e = v Bb , v Aa \u2208 E generated by a rule r \u2208 R(J, Aa), Definition 23 ensures that the following property holds:\nval(J, Bb) + \u00b5(e) \u2265 val(T {r} (J), Aa) ( * )\nTo prove this lemma, we first show the following auxiliary claim.\nClaim (\u2666). For each n \u2265 0 determining the pseudo-interpretation J = T n P and the value propagation graph G J P = (V, E, \u00b5), each n \u2265 1 determining the pseudo-interpretation J = T n+n P and the value propagation graph G J P = (V , E , \u00b5 ), each set of nodes X \u2286 V, and each node v Aa \u2208 V of such that 1. E = E ; 2. val(J , Bb) = \u221e holds for each node v Bb \u2208 V that occurs in G J P in a positive-weight cycle; 3. v Aa \u2208 X; 4. val(J , Aa) < val(T P (J ), Aa); 5. |\u03c0| \u2264 n holds for each simple path \u03c0 in G J P that ends in v Aa and satisfies \u03c0 \u2229 X = \u2205; 6. for each node v Bb \u2208 X, there exists a path \u03c0 in G J P that starts in v Aa and ends in v Bb ; one of the following holds:\n(i) val(J , Cc) + \u00b5 (\u03c0) \u2265 val(T P (J ), Aa) for some node v Cc \u2208 X and path \u03c0 in G J P starting in v Cc and ending in v Aa ; (ii) R(J, Cc) R(J , Cc) for some node v Cc \u2208 V.\nProof. For arbitrary n, we prove the claim by induction on n . For the base case n = 1, consider an arbitrary set X \u2286 V and vertex v Aa \u2208 V that satisfy properties 1-6 of (\u2666). We distinguish two cases.\n\u2022 There exists an edge e = v Bb , v Aa \u2208 E such that val(J , Bb) + \u00b5 (e) = val(T P (J ), Aa). Now either v Bb \u2208 X or v Bb = v Aa holds: if that were not the case, path \u03c0 = v Ba , v Aa would be a simple path in G J P such that |\u03c0| = 2, which would contradict property 5. We next show that v Bb = v Aa is impossible. For the sake of a contradiction, assume that v Bb = v Aa holds, and thus we have val(J , Aa) + \u00b5 (e) = val(T P (J ), Aa). By property 4, this implies val(J , Aa) + \u00b5 (e) > val(J , Aa), and hence \u00b5 (e) > 0. Consequently, path \u03c0 is a positive-weight cycle in G J P , and so, by property 2, we have val(J, Aa) = \u221e, which, in turn, contradicts property 4. Consequently, we have v Bb \u2208 X. But then, since, by assumption, val(J , Bb) + \u00b5 (e) = val(T P (J ), Aa), part (i) of the claim holds for v Cc = v Bb .\n\u2022 For each edge v Bb , v Aa \u2208 E we have val(J , Bb) + \u00b5 (e) < val(T P (J ), Aa). Then, for each rule r \u2208 P that generates an edge e = v Bb , v Aa , property ( * ) ensures val(T {r} (J ), Aa) < val(T P (J ), Aa). Since val(T P (J ), Aa) = max r\u2208P,h(r)=A(a,s) val(T {r} (J ), Aa), a rule r \u2208 P exists that satisfies val(T P (J ), Aa) = val(T {r} (J ), Aa) but does not generate an edge in E ending in v Aa . Clearly, h(r) is of the form A(a, s) and r is applicable to J , so r \u2208 R(J , Aa) holds. Moreover, r is semi-ground; hence, if s were to contain a variable, this variable would occur in a limit body atom of r, and so r would generate an edge in E; consequently, s is ground. Finally, if r were applicable to J, then {A(a, s)} J and so val(J , Aa) \u2265 val({A(a, s)}, Aa) = val(T P (J ), Aa), which contradicts property 4. Consequently, we have r / \u2208 R(J, Aa), and so part (ii) of the claim holds for v Cc = v Aa .\nFor the inductive step, we assume that (\u2666) holds for n \u2212 1 \u2265 1, each set X \u2286 V, and each node v Aa \u2208 V; and we consider an arbitrary set X \u2286 V and vertex v Aa \u2208 V that satisfy properties 1-6 of (\u2666). By property 4, there exists a rule r \u2208 P such that val(J , Aa) < val(T P (J ), Aa) = val(T {r} (J ), Aa). Now if r does not generate an edge in E, then in exactly the same way as in the base case we conclude that part (ii) of claim (\u2666) holds for v Cc = v Aa ; consequently, in the rest of this proof we assume that r generates at least one edge in E. Let J = T n+n \u22121 P and let G J P = (V , E , \u00b5 ). Then, E = E = E by property 1, and val(T {r} (J ), Aa) \u2264 val(J , Aa) < val(T {r} (J ), Aa), so there exists an edge e = v Bb , v Aa \u2208 E such that val(J , Bb) < val(J , Bb). Furthermore, since val(J , Aa) < val(T {r} (J ), Aa), if v Ba were equal to v Aa , then path v Aa , v Aa would be a positive-weight cycle containing v Aa , which contradicts property 2; hence, we have v Bb = v Aa and so path v Bb , v Aa is simple. Now if v Bb \u2208 X holds, then, since r generates e and and val(T {r} (J ), Aa) = val(T P (J ), Aa), by property ( * ), we have val(J , Bb) + \u00b5 (e) \u2265 val(T P (J ), Aa)-that is, part (i) of the claim holds for v Cc = v Bb . Therefore, in the rest of this proof we assume v Bb / \u2208 X. We now distinguish two cases. \u2022 v Bb is reachable from v Aa in G J P . We next show that the set X \u222a {v Aa } and node v Bb satisfy properties 5 and 6 of the inductive hypothesis for n \u2212 1. For property 5, note that, since v Bb is the direct predecessor of v Aa in G J P , each simple path \u03c0 in G J P that ends in v Bb and does not involve v Aa can be extended to the simple path \u03c0, v Aa that ends in v Aa . Thus, we have max{|\u03c0| | \u03c0 is a simple path in G J P ending in v Bb and \u03c0 \u2229 (X \u222a {v Aa }) = \u2205} < max{|\u03c0| | \u03c0 is a simple path in G J P ending in v Aa and \u03c0 \u2229 X = \u2205}. Property 5 for X, v Aa , and n ensures max{|\u03c0| | \u03c0 is a simple path in G J P ending in v Aa and \u03c0 \u2229 X = \u2205} \u2264 n , which in turn implies max{|\u03c0| | \u03c0 is a simple path in G J P ending in v Bb and \u03c0 \u2229 (X \u222a {v Aa }) = \u2205} \u2264 n \u2212 1. Property 6 holds for X and v Aa ; moreover, there exists a path from v Bb to v Aa via the edge e, so the property also holds for the set X \u222a {v Aa } and node v Bb . Property 3 (v Bb / \u2208 X \u222a {v Aa }) and property 4 (val(J , Bb) < val(J , Bb)) have already been established for X \u222a {v Aa }, v Bb , and n \u2212 1; moreover, properties 1 and 2 do not depend on X, v Aa , and n . Thus, we can apply the inductive hypothesis and conclude that one of the following holds:\n(i) val(J , Cc) + \u00b5 (\u03c0) \u2265 val(J , Bb) holds for some node v Cc \u2208 X \u222a {v Aa } and path \u03c0 in G J P that starts in v Cc and ends in v Bb ; (ii) R(J, Cc) R(J , Cc) holds for some node v Cc \u2208 V. If (ii) is true, then case (ii) of claim (\u2666) holds since R(J , Cc) \u2286 R(J , Cc). Thus, we next assume that case (i) holds, and we show that then part (i) of claim (\u2666) holds for v Cc , X, and v Aa . We first show that v Cc = v Aa . For contradiction, assume v Cc = v Aa . Then val(J , Aa) + \u00b5 (\u03c0) \u2265 val(J , Bb). Moreover, since r generates e, by property ( * ) and property 4, we have val(J , Bb) + \u00b5 (e) \u2265 val(T {r} (J ), Aa) = val(T P (J ), Aa) > val(J , Aa).\nConsequently, val(J , Aa) + \u00b5 (\u03c0) + \u00b5 (e) > val(J , Aa). Moreover, val(J , Aa) \u2265 val(J , Aa) holds since T P is monotonic, and \u00b5 (\u03c0) > \u00b5 (\u03c0) holds since P is stable. By these observations, we have val(J , Aa) + \u00b5 (\u03c0) + \u00b5 (e) > val(J , Aa); that is, \u00b5 (\u03c0) + \u00b5 (e) > 0. But then \u03c0, v Aa is a positive-weight cycle in G J P , and so we have val(J , Aa) = \u221e, which contradicts property 4. Thus, we have v Cc \u2208 X. Then, from val(J , Cc) + \u00b5 (\u03c0) \u2265 val(J , Bb) and val(J , Bb) + \u00b5 (e) \u2265 val(T {r} (J ), Aa) = val(T P (J ), Aa) we conclude val(J , Cc) + \u00b5 (\u03c0) + \u00b5 (e) \u2265 val(T P (J ), Aa) as in the case for v Cc = v Aa . Since \u00b5 (\u03c0) + \u00b5 (e) = \u00b5 (\u03c0, v Aa ), part (i) of claim (\u2666) holds for v Cc , X, and v Aa . \u2022 v Bb is not reachable from v Aa in G J P . Then, by property 6, v Bb is not reachable in G J P from any node in X; otherwise, v Bb would also be reachable in G J P from v Aa via some node in X. Thus, no simple path in G J P ending in v Bb involves v Aa or a node in X-that is, each such path can be extended to a simple path ending in v Aa . Now property 5 ensures max{|\u03c0| | \u03c0 is a path in G J P ending in v Aa and \u03c0 \u2229 X = \u2205} \u2264 n , which implies max{|\u03c0| | \u03c0 is a path in G J P ending in v Bb } \u2264 n \u2212 1. Thus, property 5 of the inductive hypothesis for n \u2212 1 holds for the set \u2205 and node v Bb . Moreover, property 6 holds vacuously for \u2205, properties 3 and 4 have already been established for v Bb , and properties 1 and 2 hold by assumption. Thus, we can apply the inductive hypothesis for n \u2212 1 to \u2205 and v Bb , and so one of the following holds:\n(i) val(J , Cc) + \u00b5 (\u03c0) \u2265 val(J , Bb) for some node v Cc \u2208 \u2205 and path \u03c0 in G J P that starts in v Cc and ends in v Bb ; (ii) R(J, Cc) R(J , Cc) for some node v Cc in G J P . Clearly, (i) is trivially false, so (ii) holds. But then, case (ii) of claim (\u2666) holds since R(J , Cc) \u2286 R(J , Cc).\nNote that, for each n \u2265 0 and each simple path \u03c0 in G \n\u2022 (m + 1) \u2022 (m 2 + 1) \u2022 (m 2 + 1) \u2264 8m 6\n, where the first factor is given by Claim (\u2666), the second factor comes from the first case above, the third factor comes from second case, and the fourth factor comes from the third case . Hence, Algorithm 1 reaches a fixpoint after at most 8m 6 iterations of the main loop.\nTheorem 28. For P a semi-ground stable program, D a dataset, and \u03b1 a fact, Algorithm 1 decides P \u222a D |= \u03b1 in time polynomial in P \u222a D and exponential in max r\u2208P r .\nProof. Partial correctness follows by Lemma 26, while termination follows by Lemma 27. Moreover, the number of iterations of the main loop of Algorithm 1 is polynomially bounded in |P \u222a D|, and hence J in each such iteration is bounded by P \u222aD . Consequently, lines 7 and 4 of Algorithm 1 require time that is worst-case exponential in max r\u2208P r and polynomial in P \u222a D by Lemma C.3. Moreover, lines 3, 6, and the check in line 8 require time polynomial in J and hence in P \u222a D . Finally, we argue that the check for positive-weight cycles in line 5 is feasible in time polynomial in P \u222a D . Let G be the graph obtained from G J P by negating all weights. Then, a maximal-weight path from v v1 to v v2 in G J P corresponds to the least-weight path from v v1 to v v2 in G . Thus, detecting whether a node occurs in G J P in at least one positive-weight cycle reduces to detecting whether the node occurs in G on a negative cycle (i.e., on a cycle with a negative sum of weights), which can be solved in polynomial time using, for example, a variant of the Floyd-Warshall algorithm [Hougardy, 2010].\nTheorem 29. For P a stable program and \u03b1 a fact, checking P |= \u03b1 is EXPTIME-complete in combined and PTIME-complete in data complexity.\nProof. The EXPTIME lower bound in combined complexity and the PTIME lower bound in data complexity are inherited from plain Datalog [Dantsin et al., 2001]. The PTIME upper bound in data is immediate by Theorem 28. For the EXPTIME upper bound in combined complexity, note that, for P = P 0 \u222aD the semi-grounding of P = P 0 \u222aD over constants in P, we have that P is exponentially bounded in P , whereas max r\u2208P 0 r = max r\u2208P0 r . Hence, by Theorem 28, running Algorithm 1 on P gives us an exponential-time decision procedure for P |= \u03b1.\nProposition 30. Checking stability of a limit-linear program P is undecidable.\nProof. We present a reduction from Hilbert's tenth problem, which is to determine whether, given a polynomial P (x 1 , . . . , x n ) over variables x 1 , . . . , x n , equation P (x 1 , . . . , x n ) = 0 has integer solutions. For each such polynomial P , we can assume without loss of generality that P is of the form j (c j \u00d7 n i=1 x kj,i i ) for c j \u2208 Z and k j,i \u2265 0. Now let P P be the program containing the following rule, where B is a unary max predicate, and A 1 , . . . , A n are distinct unary ordinary numeric predicates:\nA 1 (x 1 ) \u2227 \u2022 \u2022 \u2022 \u2227 A n (x n ) \u2227 (P (x 1 , . . . , x n ) \u2264 0) \u2227 (P (x 1 , . . . , x n ) \u2265 0) \u2227 B(m) \u2227 (m \u2264 0) \u2192 B(m + 1)(68)\nNote that rule (68) is limit-linear since variables x 1 , . . . , x n do not occurs in a limit atom in the rule. We show that P P is stable if and only if P (x 1 , . . . , x n ) = 0 has no integer solutions. Assume that P (x 1 , . . . , x n ) = 0 has no integer solutions. Then, for each grounding \u03c3 of ( 68), at least one of the first two comparison atoms in the rule is not satisfied, and so P P is trivially stable since, for each pseudo-interpretation J, the value propagation graph G J P does not contain any edges.\nAssume that substitution \u03c3 exists such that P (\u03c3(x 1 ), . . . , \u03c3(x n )) = 0 holds, and let J 1 and J 2 be the following pseudointerpretations with the corresponding value propagation graphs: J 1 = {A 1 (\u03c3(x 1 )), . . . , A 1 (\u03c3(x n ))} \u222a {B(0)} G J1\nP P = (V 1 , E 1 , \u00b5 1 )(69)\nJ 2 = {A 1 (\u03c3(x 1 )), . . . , A 1 (\u03c3(x n ))} \u222a {B(1)} G J2 P P = (V 2 , E 2 , \u00b5 2 ) (70)\nThen, we clearly have J 1 J 2 and e = v B , v B \u2208 E 1 = E 2 ; however, \u00b5 1 (e) = 1 and \u00b5 2 (e) = 0. Consequently, program P P is not stable.\nLemma D.3. For each pseudo-interpretation J and each semi-ground type-consistent rule r, if r is applicable to J and it contains a limit body atom B(b, n) \u2208 sb(r) such that B(b, \u221e) \u2208 J and variable n occurs in h(r), then opt(r, J) = \u221e.\nProof. Consider an arbitrary pseudo-interpretation J and rule r applicable to J that contains a limit body atom B(b, n) \u2208 sb(r) with B(b, \u221e) \u2208 J and n occurring in h(r). We consider the case when h(r) = A(a, s) for A a max predicate and variable n occurs in s with a negative coefficient; the cases when A is a min predicate and/or n occurs in s with a positive coefficient are analogous. Then, term s has the form \u00d7 n + t for some negative integer and term t not containing n. Moreover, r is type-consistent, so B is a min predicate. Since r is applicable to J, conjunction C(r, J) has a solution \u03c3. We next show that opt(r, J) = \u221e holds, for which it suffices to argue that, for each k \u2208 Z, conjunction C(r, J) has a solution \u03c3 such that s\u03c3 \u2265 k.\nLet k 0 = s\u03c3 and let \u03c3 be the grounding of C(r, J) such that \u03c3 (n) = \u03c3(n) \u2212 |k \u2212 k 0 | and \u03c3 (m) = \u03c3(m) for each variable m = n. Since B(b, \u221e) \u2208 J, we have J |= B(b, \u03c3 (n)). Moreover, r is type-consistent, \u03c3 satisfies all comparison atoms in the body of r, B is a min predicate, and \u03c3 (n) \u2264 \u03c3(n), so \u03c3 also satisfies all comparison atoms in the body of r. Hence, \u03c3 is a solution to C(r, J). Then, the following calculation implies the claim of this lemma:\ns\u03c3 = \u00d7 (\u03c3(n) \u2212 |k \u2212 k 0 |) + t\u03c3 = ( \u00d7 \u03c3(n) + t\u03c3) \u2212 \u00d7 |k \u2212 k 0 | = k 0 \u2212 \u00d7 |k \u2212 k 0 | \u2265 k 0 + |k \u2212 k 0 | \u2265 k.\nLemma D.4. For each type-consistent, limit-linear rule r with h(r) = A(t, s), each limit body atom B(t , n) \u2208 sb(r) such that n occurs in s, each semi-grounding \u03c3 of r such that n \u2208 dom(\u03c3), and all pseudo-interpretations J 1 and J 2 such that J 1 J 2 and r\u03c3 is applicable to J 1 , we have \u03b4 e r\u03c3 (J 1 ) \u2264 \u03b4 e r\u03c3 (J 2 ) where e = v Bt \u03c3 , v At\u03c3 . Proof. Consider arbitrary r, B(t , n), \u03c3, J 1 , J 2 , and e as stated in the lemma. We consider the case when A is a max and B is a min predicate; the remaining cases are analogous. Let \u03d5 be the body of r and let \u03c3 be a semi-grounding of r. Moreover, the claim is trivial if \u03b4 e r\u03c3 (J 2 ) = \u221e, so we next assume \u03b4 e r\u03c3 (J 2 ) = \u221e. Due to J 1 J 2 , each solution to C(r\u03c3, J 1 ) is a solution to C(r\u03c3, J 2 ) as well, so therefore \u03b4 e r\u03c3 (J 1 ) = \u221e holds. By Definition 23, we then have opt(r\u03c3, J 1 ) = \u221e and opt(r\u03c3, J 2 ) = \u221e. But then, by Lemma D.3, there exist k 1 , k 2 \u2208 Z such that B(t \u03c3, k 1 ) \u2208 J 1 and B(t \u03c3, k 2 ) \u2208 J 2 ; since B is a min predicate, we have k 2 \u2264 k 1 ; moreover, by Definition 23 we have \u03b4 e r\u03c3 (J 1 ) = opt(r, J 1 ) + k 1 and \u03b4 e r\u03c3 (J 2 ) = opt(r, J 2 ) + k 2 . Rule r is type-consistent, so variable n occurs negatively in s; thus, s\u03c3 is of the form s \u00d7 n + s where s is a ground product evaluating to a negative integer and s does not mention n. Moreover, opt(r\u03c3, J 1 ) = \u221e, so there exists a grounding \u03c3 1 of r\u03c3 such that J 1 |= \u03d5\u03c3\u03c3 1 and opt(r\u03c3, J 1 ) = s\u03c3\u03c3 1 = s \u00d7 k 1 + s \u03c3 1 = \u03b4 e r\u03c3 (J 1 ) \u2212 k 1 . Let \u03c3 2 be the substitution such that \u03c3 2 (n) = k 2 and \u03c3 2 (m) = \u03c3 1 (m) for m = n. Clearly, J 2 satisfies all object and numeric atoms in \u03d5\u03c3\u03c3 2 . Then, we have the following: \u03b4 e r\u03c3 (J 2 ) = opt(r\u03c3, J 2 ) + k 2 \u2265 s\u03c3\u03c3 2 + k 2 = s \u00d7 n\u03c3 2 + s \u03c3 2 + k 2 = s \u00d7 k 2 + s \u03c3 1 + k 2 Furthermore, we have already established s \u00d7 k 1 + s \u03c3 1 = \u03b4 e r\u03c3 (J 1 ) \u2212 k 1 , which implies the following: \u03b4 e r\u03c3 (J 2 ) \u2265 s \u00d7 k 2 \u2212 s \u00d7 k 1 + \u03b4 e r\u03c3 (J 1 ) \u2212 k 1 + k 2 = (s + 1) \u00d7 (k 2 \u2212 k 1 ) + \u03b4 e r\u03c3 (J 1 ) But then, s < 0 and k 2 \u2264 k 1 clearly imply \u03b4 e r\u03c3 (J 2 ) \u2265 \u03b4 e r\u03c3 (J 1 ), as required. Proposition 32. Each type-consistent limit-linear program is stable.\nProof. For P a type-consistent program and \u03c3 a semi-grounding of P, condition 1 of Definition 24 follows by Lemma D.4, and condition 2 of Definition 24 follows by Lemma D.3. Proposition 33. Checking whether a limit-linear program is type-consistent can be accomplished in LOGSPACE.\nProof. Let P be a limit-linear program. We can check whether P is type-consistent by considering each rule r \u2208 P independently. Note that the first type consistency condition is satisfied for every semi-ground limit-linear rule where all numeric terms are simplified as much as possible; thus, no semi-grounding of r (with constants from P) where all numeric terms are simplified as much as possible can violate the first condition of Definition 31. Thus, it suffices to check whether a semi-grounding of r (with constants from P) can violate the second or the third condition. In both cases, it suffices to consider at most one atom \u03b1 at a time (a limit head atom A(a, s) for the second condition or a comparison atom s 1 < s 2 or s 1 \u2264 s 2 for the third condition). In \u03b1, we consider at most one numeric term s at a time (s \u2208 {s 1 , s 2 } for the third condition), where s is of the form t 0 + n i=1 t i \u00d7 m i and t i , for i \u2265 1, are terms constructed from integers, variables not occurring in limit atoms, and multiplication. Moreover, for each such s, we consider each variable m occurring in s.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgments", "text": "We thank Christoph Haase for explaining to us his results on Presburger arithmetic and semi-linear sets as well as for providing a proof for Lemma 19. Our work has also benefited from discussions with Michael Benedikt. This research was supported by the Royal Society and the EPSRC projects DBOnto, MaSI 3 , and ED 3 .", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "", "text": "By assumption, m occurs in s, so we have m i = m for some i. For the second condition of Definition 31, we need to check that, if the limit body atom B(s, m i ) introducing m i has the same (different) type as the head atom, then term t i can only be grounded to positive (negative) integers or zero. For the third condition, we need to check that, if s = s 1 and the limit body atom B(s, m i ) introducing m i is min (max), then term t i can only be grounded to positive (negative) integers or 0, and dually for the case s = s 2 . Hence, in either case, it suffices to check whether term t i can be semi-grounded so that it evaluates to a positive integer, a negative integer, or zero. We next discuss how this can be checked in logarithmic space. Let t i = t 1 i \u00d7 \u2022 \u2022 \u2022 \u00d7 t k i , where each t j i is an integer or a variable not occurring in a limit atom, and assume without loss of generality that we want to check whether t i can be grounded to a positive integer; this is the case if and only if one of the following holds:\n\u2022 all t j i are integers whose product is positive; \u2022 the product of all integers in t i is positive and P contains a positive integer;\n\u2022 the product of all integers in t i is positive, P contains a negative integer, and the total number of variable occurrences in t i is even; \u2022 the product of all integers in t i is negative, P contains a negative integer, and the total number of variable occurrences in t i is odd; or\n\u2022 the product of all integers in t i is negative, P contains both positive and negative integers, and some variable t j i has an odd number of occurrences in t i .\nEach of these conditions can be verified using a constant number of pointers into P and binary variables. This clearly requires logarithmic space, and it implies our claim.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "BOOM analytics: exploring data-centric, declarative programming for the cloud", "journal": "Eisner and Filardo", "year": "1980", "authors": "[ References;  Alvaro"}, {"ref_id": "b1", "title": "Christoph Haase. Subclasses of Presburger arithmetic and the weak EXP hierarchy", "journal": "Kannan", "year": "1987", "authors": "Erich Gr\u00e4del;  Gr\u00e4del ; Ravi Kannan"}, {"ref_id": "b2", "title": "Inderpal Singh Mumick, Hamid Pirahesh, and Raghu Ramakrishnan. The magic of duplicates and aggregates", "journal": "ACM", "year": "1981", "authors": "; Stuckey; B David; Peter J Kemp; Adrien Stuckey; Victor Koutsos;  Vianu ; Boon Thau; Tyson Loo;  Condie; N Minos; David E Garofalakis; Joseph M Gay; Petros Hellerstein; Raghu Maniatis; Timothy Ramakrishnan; Ion Roscoe; ; Stoica;  Mumick"}, {"ref_id": "b3", "title": "Uwe Sch\u00f6ning. Complexity of presburger arithmetic with fixed quantifier dimension", "journal": "J. Comput. System Sci", "year": "1997", "authors": "; Sagiv; A Kenneth; Yehoshua Ross;  Sagiv"}, {"ref_id": "b4", "title": "SociaLite: An efficient graph query language based on datalog", "journal": "", "year": "1992", "authors": ""}, {"ref_id": "b5", "title": "Jingjing Wang, Magdalena Balazinska, and Daniel Halperin. Asynchronous and fault-tolerant recursive datalog evaluation in shared-nothing engines", "journal": "", "year": "1978", "authors": " Zur Gathen; ; Sieveking;  Wang"}, {"ref_id": "b6", "title": "if \u03b1 is an object fact or ordinary numeric fact, then \u03b1 \u2208 I P (I) if and only if \u03b1 \u2208 T", "journal": "P (J)", "year": "", "authors": ""}, {"ref_id": "b7", "title": "A(a, k) where k is an integer, then \u03b1 \u2208 I P (I) if and only if {\u03b1} T P (J); and 3. if \u03b1 is a limit fact of the form A(a, \u221e), then {A(a, k) | k \u2208 Z} \u2286 I P (I) if and only", "journal": "", "year": "", "authors": ""}, {"ref_id": "b8", "title": "Consider an arbitrary object fact \u03b1 of the form A(a); the proof for ordinary numeric facts is analogous", "journal": "", "year": "", "authors": ""}], "figures": [{"figure_label": "", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "and B is a max predicate;\u2022 J |= A(a, k \u2212 \u00b5(\u03c0)) if A and B are both min predicates; and\u2022 J |= A(a, \u2212k + \u00b5(\u03c0))if A is a max predicate and B is a min predicate.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "P, |\u03c0| is bounded by the number of nodes in G T n P P , which is in turn bounded by m = |P|. Therefore, claim (\u2666) for n = m and X = \u2205 ensures that, for each n \u2265 0 such that T n+m P = \u221e for some node v Cc that occurs in G T n+m P P in a positive weight cycle (so the value of the fact corresponding to v Cc is set to \u221e in the next iteration of the main loop of the algorithm), for some node v Cc in GT n P P .For each n \u2265 0, the size of the set R(T n P , Cc) for each node v Cc and the number of nodes in GT n P P are both bounded by m, and the number of edges in G T n P P is bounded by m 2 . Thus, the number of iterations of the main loop is bounded by m", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "A(t, m) \u2227 I(m 1 ) \u2227 I(m 2 ) \u2227 (m \u2264 m 1 + m 2 ) \u2227 (m 1 + m 2 \u2264 m)", "formula_coordinates": [3.0, 71.69, 151.26, 207.62, 20.61]}, {"formula_id": "formula_1", "formula_text": "\u2192 I(0) I(m) \u2192 I(m + 1) I(m) \u2192 I(m \u2212 1)", "formula_coordinates": [3.0, 64.29, 207.69, 222.41, 8.74]}, {"formula_id": "formula_2", "formula_text": "A 1 (t 1 , m) \u2227 A 2 (t 2 , m) with con- junction A 1 (t 1 , m) \u2227 A 2 (t 2 , m ) \u2227 (m \u2264 m ) \u2227 (m \u2264 m),", "formula_coordinates": [3.0, 54.0, 224.88, 243.0, 20.61]}, {"formula_id": "formula_3", "formula_text": "\u2192 Z(0) Z(m) \u2192 Z(m + 1) Z(m) \u2192 Z(m \u2212 1) B(x, m) \u2227 Z(n) \u2227 (m \u2264 n) \u2192 B(x, n) for each min predicate B in P B(x, m) \u2227 Z(n) \u2227 (n \u2264 m) \u2192 B(x, n)", "formula_coordinates": [3.0, 58.41, 501.64, 234.17, 46.1]}, {"formula_id": "formula_4", "formula_text": "(3) follows(x, y ) \u2227 first(y) \u2192 nt(x, y, 0) (4) follows(x, y) \u2227 first(y) \u2227 tw (y) \u2192 nt(x, y, 1) (5) nt(x, y , m) \u2227 next(y , y) \u2192 nt(x, y, m) (6) nt(x, y , m) \u2227 next(y , y) follows(x, y) \u2227 tw (y) \u2227 \u2192 nt(x, y, m + 1) (7) th(x, m) \u2227 nt(x, y, n) \u2227 (m \u2264 n) \u2192 tw (x) (8) Specifically, P tw \u222a D tw |= tw (a i ) iff a i tweets the message. Intuitively, nt(a i , a j , m", "formula_coordinates": [3.0, 315.0, 227.25, 243.0, 119.56]}, {"formula_id": "formula_5", "formula_text": "(x) \u2192 np(x, x, 1) (9) node(x) \u2227 node(y) \u2227 first(z) \u2192 np (x, y, z, 0) (10) edge(x, z) np(z, y, m) \u2227 first(z) \u2227 \u2192 np (x, y, z, m) (11) np (x, y, z , m) \u2227 next(z , z) \u2192 np (x, y, z, m) (12) np (x, y, z , m) \u2227 next(z , z) edge(x, z) \u2227 np(z, y, n) \u2227 \u2192 np (x, y, z, m + n) (13) np (x, y, z, m) \u2192 np(x, y, m) (14) Specifically, P cp \u222a D cp |= np(a i , a j , k) iff at least k paths exist from node a i to node a j . Intuitively, np (a i , a j , a k , m", "formula_coordinates": [3.0, 315.0, 474.06, 243.0, 132.15]}, {"formula_id": "formula_6", "formula_text": "(2 O( log ) \u2022 a k ) n2 \u2022O(m 4 ) .", "formula_coordinates": [5.0, 363.7, 121.88, 107.31, 11.94]}, {"formula_id": "formula_7", "formula_text": "\u03b4 e r (J) = \uf8f1 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f2 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f4 \uf8f3 opt(r, J) \u2212 if B and A are max, = \u221e \u2212opt(r, J) \u2212 if B is max, A is min, = \u221e \u2212opt(r, J) + if B and A are min, = \u221e opt(r, J) + if B is min, A is max, = \u221e opt(r, J) if = \u221e", "formula_coordinates": [6.0, 61.83, 344.06, 231.9, 64.14]}, {"formula_id": "formula_8", "formula_text": "G J P = (V, E, \u00b5), G J P = (V , E , \u00b5 ),", "formula_coordinates": [6.0, 315.0, 237.32, 144.43, 12.47]}, {"formula_id": "formula_9", "formula_text": "J = {A(1), C(0)}, we have J J , but \u00b5( v A , v B ) = 0 and \u00b5 ( v A , v B ) = \u22121.", "formula_coordinates": [6.0, 315.0, 297.01, 243.0, 20.61]}, {"formula_id": "formula_10", "formula_text": "true if P |= \u03b1 1: J \u2022 \u2022 = \u2205 2: repeat 3: J \u2022 \u2022 = J 4: G J P \u2022 \u2022 = (V, E, \u00b5) 5:", "formula_coordinates": [7.0, 57.78, 80.06, 86.2, 60.93]}, {"formula_id": "formula_11", "formula_text": "Definition 31. A semi-ground limit-linear rule r is type- consistent if -each numeric term t in r is of the form k 0 + n i=1 k i \u00d7 m i where k 0 is an integer and each k i , 1 \u2264 i \u2264 n, is a nonzero integer, called the coefficient of variable m i in t; -if h(r) = A(", "formula_coordinates": [7.0, 54.0, 485.65, 243.0, 64.23]}, {"formula_id": "formula_12", "formula_text": "\u2192 Num(1) (15) Num(x) \u2192 Num(x + 1) (16) \u2192 Time(1) (17) Time(x) \u2192 Time(x + x) (18) \u2192 Tape( , 1) (19) \u2192 Pos(1) (20) \u2192 State(s, 1) (21) State(h, x) \u2192 Halts (22) Time(x) \u2227 Tape(v, y) \u2227 Pos(z) \u2227 (x \u2264 y < x + x) \u2227 (x \u2264 z < x + x) \u2227 (y . = z) \u2192 Tape(v, x + y) (23) Time(x) \u2227 Num(u) \u2227 (x + x + x \u2264 u + u < x + x + x + x) \u2192 Tape( , u)(24)", "formula_coordinates": [9.0, 99.93, 358.98, 458.07, 135.51]}, {"formula_id": "formula_13", "formula_text": "Time(x) \u2227 State(q, x) \u2227 Tape(a, y) \u2227 Pos(y) \u2227 (x \u2264 y < x + x) \u2192 Tape(a , x + y) (25) Time(x) \u2227 State(q, x) \u2227 Tape(a, y) \u2227 Pos(y) \u2227 (x \u2264 y < x + x) \u2192 State(q , x + x) (26) Time(x) \u2227 State(q, x) \u2227 Tape(a, y) \u2227 Pos(y) \u2227 Num(u) (x \u2264 y < x + x) \u2227 (x + y . = u + 1) \u2227 \u2192 Pos(u) if D = L (27) Time(x) \u2227 State(q, x) \u2227 Tape(a, y) \u2227 Pos(y) \u2227 Num(u) (x \u2264 y < x + x) \u2227 (x + y + 1 . = u) \u2227 \u2192 Pos(u) if D = R (28)", "formula_coordinates": [9.0, 117.47, 532.9, 440.53, 76.06]}, {"formula_id": "formula_14", "formula_text": "\u2192 A(0) (29) n i=1 A(x i ) \u2227 (P (x 1 , . . . , x n ) \u2264 0) \u2227 (P (x 1 , . . . , x n ) \u2265 0) \u2192 B (30", "formula_coordinates": [11.0, 410.75, 695.2, 147.25, 8.96]}, {"formula_id": "formula_15", "formula_text": ")", "formula_coordinates": [12.0, 553.85, 57.48, 4.15, 8.64]}, {"formula_id": "formula_16", "formula_text": "(2 O( log ) \u2022 a k ) n2 \u2022O(m 4 ) .", "formula_coordinates": [13.0, 54.0, 259.06, 107.31, 11.94]}, {"formula_id": "formula_17", "formula_text": "S i = (A i x \u2264 c i ) such that |x| \u2264 , |c i | \u2264 k,", "formula_coordinates": [13.0, 374.24, 279.9, 183.76, 9.68]}, {"formula_id": "formula_18", "formula_text": "b = (2 O( log ) \u2022 a k ) n2 \u2022O(m 4 )", "formula_coordinates": [13.0, 54.0, 401.69, 121.88, 11.94]}, {"formula_id": "formula_19", "formula_text": "b = (2 O(s log s) \u2022 a O(s 2 ) ) O(c\u20222 s )\u20222 O(s) \u2022O((cs) 4 )", "formula_coordinates": [13.0, 338.99, 594.83, 179.81, 11.96]}, {"formula_id": "formula_20", "formula_text": ". = t) abbreviates (s \u2264 t) \u2227 (t \u2264 s). \u2192 I(0) (31) \u2192 tiling(0) (32) tiling(n) \u2227 numTiles(nt) shift(x, y, s) \u2227 tileNo(u, t) \u2227 I(m 1 ) \u2227 I(m 2 ) \u2227 (n . = m 1 \u00d7 nt \u00d7 s + t \u00d7 s + m 2 ) \u2227 (m 2 < s) succ(x, x ) shift(x , y, s ) \u2227 tileNo(u , t ) \u2227 I(m 1 ) \u2227 I(m 2 ) \u2227 (n . = m 1 \u00d7 nt \u00d7 s + t \u00d7 s + m 2 ) \u2227 (m 2 < s ) incompatibleH (u, u ) \u2227 \u2227 \u2227 \u2227 \u2192 tiling(n + 1) (33", "formula_coordinates": [14.0, 60.07, 541.41, 497.93, 105.39]}, {"formula_id": "formula_21", "formula_text": ")", "formula_coordinates": [14.0, 553.85, 616.74, 4.15, 8.64]}, {"formula_id": "formula_22", "formula_text": "tiling(n) \u2227 numTiles(nt) shift(x, y, s) \u2227 tileNo(u, t) \u2227 I(m 1 ) \u2227 I(m 2 ) \u2227 (n . = m 1 \u00d7 nt \u00d7 s + t \u00d7 s + m 2 ) \u2227 (m 2 < s) succ(y, y ) shift(x, y , s ) \u2227 tileNo(u , t ) \u2227 I(m 1 ) \u2227 I(m 2 ) \u2227 (n . = m 1 \u00d7 nt \u00d7 s + t \u00d7 s + m 2 ) \u2227 (m 2 < s ) incompatibleV (u, u ) \u2227 \u2227 \u2227 \u2227 \u2192 tiling(n + 1) (34", "formula_coordinates": [14.0, 60.07, 653.01, 493.78, 52.62]}, {"formula_id": "formula_23", "formula_text": ")", "formula_coordinates": [14.0, 553.85, 675.57, 4.15, 8.64]}, {"formula_id": "formula_24", "formula_text": "tiling(n) \u2227 maxTiling(m) \u2227 (m < n) \u2192 noSolution (35)", "formula_coordinates": [15.0, 310.05, 57.16, 247.95, 8.96]}, {"formula_id": "formula_25", "formula_text": "\u2192 numTiles(M ) (36) \u2192 tileNo(t i , i) for each 0 \u2264 i < M (37) \u2192 incompatibleH (t i , t j ) for each 0 \u2264 i, j < M such that (t i , t j ) / \u2208 H (38) \u2192 incompatibleV (t i , t j ) for each 0 \u2264 i, j < M such that (t i , t j ) / \u2208 V (39) \u2192 maxTiling(M N 2 \u2212 1) (40) \u2192 succ(g i , g i+1 ) for each 0 \u2264 i < N \u2212 1 (41) \u2192 shift(g i , g j , M i+N j ) for each 0 \u2264 i, j < N (42", "formula_coordinates": [15.0, 129.49, 112.74, 428.51, 99.2]}, {"formula_id": "formula_26", "formula_text": ")", "formula_coordinates": [15.0, 553.85, 202.61, 4.15, 8.64]}, {"formula_id": "formula_27", "formula_text": "j) if n = m 1 \u00d7 M \u00d7 M i+N j + t \u00d7 M i+N j + m 2", "formula_coordinates": [15.0, 196.08, 252.09, 204.79, 11.22]}, {"formula_id": "formula_28", "formula_text": "tileNo(u, t) \u2227 I(m 1 ) \u2227 I(m 2 ) \u2227 (n . = m 1 \u00d7 nt \u00d7 s + t \u00d7 s + m 2 ) \u2227 (m 2 < s)", "formula_coordinates": [15.0, 145.67, 285.68, 320.67, 15.3]}, {"formula_id": "formula_29", "formula_text": "\u2192 tileNo(t i , i) for each 0 \u2264 i < M (43) \u2192 incompatibleH (t i , t j ) for each 0 \u2264 i, j < M such that (t i , t j ) / \u2208 H (44) \u2192 incompatibleV (t i , t j ) for each 0 \u2264 i, j < M such that (t i , t j ) / \u2208 V(45)", "formula_coordinates": [15.0, 130.15, 504.32, 427.85, 37.55]}, {"formula_id": "formula_30", "formula_text": "\u2192 B (0) (46) \u2192 B (1)(47)", "formula_coordinates": [15.0, 139.08, 695.2, 418.92, 8.96]}, {"formula_id": "formula_31", "formula_text": "k i=1 B (x i ) \u2192 succ(x,0,1, x,1,0) for each 0 \u2264 k < N where |x| = k and |1| = |0| = N \u2212 k \u2212 1 (48) k i=1 B (x i ) \u2192 succ (x,0,1, x,1,0) for each 0 \u2264 k < N + 1 where |x| = k and |1| = |0| = N \u2212 k (49)", "formula_coordinates": [16.0, 96.45, 71.31, 461.55, 31.24]}, {"formula_id": "formula_32", "formula_text": "P T |= maxTiling(s) if and only if s \u2265 M 2 2N \u2212 1. \u2192 auxT (0,0, M ) (50) auxT (x, y, n) \u2227 succ(x, x ) \u2192 auxT (x , y, M \u00d7 n) (51) auxT (1, y, n) \u2227 succ(y, y ) \u2192 auxT (0, y , M \u00d7 n) (52) auxT (1,1, n) \u2192 maxTiling(n \u2212 1)(53)", "formula_coordinates": [16.0, 54.0, 158.32, 504.0, 75.71]}, {"formula_id": "formula_33", "formula_text": "s n,i,j = n M i+j\u20222 N .", "formula_coordinates": [16.0, 262.92, 301.81, 86.17, 22.66]}, {"formula_id": "formula_34", "formula_text": "(0, 0), (1, 0), . . . , (2 N \u2212 1, 0), (0, 1), (1, 1), . . . , (2 N \u2212 1, 1), . . . . . . , (0, 2 N \u2212 1), (1, 2 N \u2212 1), . . . , (2 N \u2212 1, 2 N \u2212 1)", "formula_coordinates": [16.0, 72.46, 369.26, 467.09, 10.81]}, {"formula_id": "formula_35", "formula_text": "\u2192 I (0) (54) tiling(n) \u2192 shiftedTiling(0,0, n) (55) shiftedTiling(x, y, n) \u2227 succ(x, x ) \u2227 I ( ) \u2227 I (m) \u2227 ( < M ) \u2227 (n . = M \u00d7 m + ) \u2192 shiftedTiling(x , y, m) (56) shiftedTiling(1, y, n) \u2227 succ(y, y ) \u2227 I ( ) \u2227 I (m) \u2227 ( < M ) \u2227 (n . = M \u00d7 m + ) \u2192 shiftedTiling(0, y , m)(57)", "formula_coordinates": [16.0, 72.28, 439.86, 485.72, 54.68]}, {"formula_id": "formula_36", "formula_text": "shiftedTiling(x, y, m) \u2227 succ(x , x) \u2227 incompatibleH (u, u ) \u2227 tileNo(u , t ) I ( ) \u2227 (m . = M \u00d7 + t ) \u2227 \u2192 conflict(x, y,01, u, m)(58)", "formula_coordinates": [16.0, 92.06, 633.58, 465.94, 19.96]}, {"formula_id": "formula_37", "formula_text": "shiftedTiling(x, y, m) \u2227 succ(y , y) \u2227 incompatibleV (u, u ) \u2227 tileNo(u , t ) I ( ) \u2227 (m . = M \u00d7 + t ) \u2227 \u2192 conflict(x, y,10, u, m)(59)", "formula_coordinates": [16.0, 91.54, 659.74, 466.46, 19.96]}, {"formula_id": "formula_38", "formula_text": "shiftedTiling(x, y, m) \u2227 succ(x, x ) \u2227 conflict(x , y, z , u, m ) \u2227 succ (z, z ) I ( ) \u2227 ( < M ) \u2227 (m . = M \u00d7 m + ) \u2227 \u2192 conflict(x, y, z, u, m)(60)", "formula_coordinates": [16.0, 90.13, 685.88, 467.87, 19.75]}, {"formula_id": "formula_39", "formula_text": "shiftedTiling(1, y, m) \u2227 succ(y, y ) \u2227 conflict(0, y , z , u, m ) \u2227 succ (z, z ) I ( ) \u2227 ( < M ) \u2227 (m . = M \u00d7 m + ) \u2227 \u2192 conflict(1, y, z, u, m)(61)", "formula_coordinates": [17.0, 90.45, 54.88, 467.55, 19.97]}, {"formula_id": "formula_40", "formula_text": "conflict(x, y,0, u, m) \u2227 tileNo(u, t) \u2227 I ( ) \u2227 (m . = M \u00d7 + t) \u2192 invalid (x, y, m) (62) shiftedTiling(x, y, m) \u2227 succ(x, x ) \u2227 invalid (x , y, m ) I ( ) \u2227 ( < M ) \u2227 (m . = M \u00d7 m + ) \u2227 \u2192 invalid (x, y, m)(63)", "formula_coordinates": [17.0, 131.1, 139.39, 426.9, 40.31]}, {"formula_id": "formula_41", "formula_text": "shiftedTiling(1, y, m) \u2227 succ(y, y ) \u2227 invalid (0, y , m ) I ( ) \u2227 ( < M ) \u2227 (m . = M \u00d7 m + ) \u2227 \u2192 invalid (1, y, m)(64)", "formula_coordinates": [17.0, 159.78, 185.92, 398.22, 19.97]}, {"formula_id": "formula_42", "formula_text": "\u2192 tiling(0) (65) invalid (0,0, m) \u2227 tiling(n) \u2227 (m . = n) \u2192 tiling(n + 1) (66) tiling(n) \u2227 maxTiling(m) \u2227 (m < n) \u2192 noSolution (67)", "formula_coordinates": [17.0, 190.53, 287.77, 367.47, 38.11]}, {"formula_id": "formula_43", "formula_text": "\u00b5(\u03c0) = n\u22121 i=1 \u00b5( v i , v i+1 ).", "formula_coordinates": [18.0, 253.54, 313.08, 104.93, 30.32]}, {"formula_id": "formula_44", "formula_text": "\u2022 J |= A(a, \u2212k \u2212 \u00b5(\u03c0)) if A is a min predicate", "formula_coordinates": [18.0, 63.96, 395.3, 193.55, 8.85]}, {"formula_id": "formula_45", "formula_text": "val(J, Bb) + \u00b5(e) \u2265 val(T {r} (J), Aa) ( * )", "formula_coordinates": [19.0, 226.33, 227.43, 331.67, 10.06]}, {"formula_id": "formula_46", "formula_text": "\u2022 (m + 1) \u2022 (m 2 + 1) \u2022 (m 2 + 1) \u2264 8m 6", "formula_coordinates": [21.0, 64.96, 294.38, 160.26, 10.31]}, {"formula_id": "formula_47", "formula_text": "A 1 (x 1 ) \u2227 \u2022 \u2022 \u2022 \u2227 A n (x n ) \u2227 (P (x 1 , . . . , x n ) \u2264 0) \u2227 (P (x 1 , . . . , x n ) \u2265 0) \u2227 B(m) \u2227 (m \u2264 0) \u2192 B(m + 1)(68)", "formula_coordinates": [21.0, 92.95, 634.51, 465.05, 9.65]}, {"formula_id": "formula_48", "formula_text": "P P = (V 1 , E 1 , \u00b5 1 )(69)", "formula_coordinates": [22.0, 406.08, 87.26, 151.92, 11.7]}, {"formula_id": "formula_49", "formula_text": "s\u03c3 = \u00d7 (\u03c3(n) \u2212 |k \u2212 k 0 |) + t\u03c3 = ( \u00d7 \u03c3(n) + t\u03c3) \u2212 \u00d7 |k \u2212 k 0 | = k 0 \u2212 \u00d7 |k \u2212 k 0 | \u2265 k 0 + |k \u2212 k 0 | \u2265 k.", "formula_coordinates": [22.0, 80.15, 297.68, 451.7, 9.65]}], "doi": ""}