{"title": "Polynomial-Time Algorithms for Counting and Sampling Markov Equivalent DAGs *", "authors": "Marcel Wien\u00f6bst; Max Bannach; Maciej Li\u015bkiewicz", "pub_date": "2020-12-17", "abstract": "Counting and sampling directed acyclic graphs from a Markov equivalence class are fundamental tasks in graphical causal analysis. In this paper, we show that these tasks can be performed in polynomial time, solving a long-standing open problem in this area. Our algorithms are effective and easily implementable. Experimental results show that the algorithms significantly outperform state-of-the-art methods.", "sections": [{"heading": "Introduction", "text": "Graphical modeling plays a key role in causal theory, allowing to express complex causal phenomena in an elegant, mathematically sound way. One of the most popular graphical models are directed acyclic graphs (DAGs), which represent direct causal influences between random variables by directed edges (Spirtes, Glymour, and Scheines 2000;Pearl 2009;Koller and Friedman 2009). They are commonly used in empirical sciences to discover and understand causal effects. However, in practice, the underlying DAG is usually unknown, since, typically, no single DAG explains the observational data. Instead, the statistical properties of the data are maintained by a number of different DAGs, which constitute a Markov equivalence class (MEC, for short). Therefore, these DAGs are indistinguishable on the basis of observations alone Pearl 1990, 1992;Heckerman, Geiger, and Chickering 1995).\nIt is of great importance to investigate model learning and to analyze causal phenomena using MECs directly rather than the DAGs themselves. Consequently, this has led to intensive studies on Markov equivalence classes of DAGs and resulted in a long and successful track record. Our work contributes to this line of research by providing the first polynomial-time algorithms for counting and for uniform sampling Markov equivalent DAGs -two important primitives in both theoretical and experimental studies.\nFinding the graphical criterion for two DAGs to be Markov equivalent (Verma and Pearl 1990) and providing the graph-theoretic characterization of MECs as so-called CPDAGs (Andersson, Madigan, and Perlman 1997) mark key turning points in this research direction. In particular, they have contributed to the progress of computational methods in this area. Important advantages of the modeling with CPDAGs are demonstrated by algorithms that learn causal structures from observational data (Verma and Pearl 1992;Meek 1995Meek , 1997Spirtes, Glymour, and Scheines 2000;Chickering 2002a,b); and that analyze causality based on a given MEC, rather than a single DAG (Maathuis, Kalisch, and B\u00fchlmann 2009;van der Zander and Li\u015bkiewicz 2016;Perkovic et al. 2017). Algorithms that ignore Markov equivalence may lead to incorrect solutions.\nA key characteristic of an MEC is its size, i. e., the number of DAGs in the class. It indicates uncertainty of the causal model inferred from observational data and it serves as an indicator for the performance of recovering true causal effects. Moreover, the feasibility of causal inference methods is often highly dependent on the size of the MEC; e. g., to estimate the average causal effects from observational data for a given CPDAG, as proposed by Maathuis, Kalisch, and B\u00fchlmann (2009), one has to consider all DAGs in the class. Furthermore, computing the size of a Markov equivalence class is commonly used as a subroutine in practical algorithms. For example, when actively designing interventions, in order to identify the underlying true DAG in a given MEC, the size of the Markov equivalence subclass is an important metric to select the best intervention target (He and Geng 2008;Hauser and B\u00fchlmann 2012;Shanmugam et al. 2015;Ghassami et al. 2018Ghassami et al. , 2019.\nThe first algorithmic approaches for counting the number of Markov equivalent DAGs relied on exhaustive search (Meek 1995;Madigan et al. 1996) based on the graphical characterization of Verma and Pearl (1990). The methods are computationally expensive as the size of an MEC represented by a CPDAG may be superexponential in the number of vertices of the graph. More recently, He, Jia, and Yu (2015) proposed to partition the MEC by fixing root variables in any undirected component of the CPDAG. This yields a recursive strategy for counting Markov equivalent DAGs, which forms the basis of several \"root-picking\" algorithms (He, Jia, and Yu 2015;Ghassami et al. 2019;Ganian, Hamm, and Talvitie 2020). As an alternative approach, recent methods utilize dynamic programming on the clique tree representation of chordal graphs and techniques from intervention design (Talvitie and Koivisto 2019;Ah-madiTeshnizi, Salehkaleybar, and Kiyavash 2020).\nThe main drawback of the existing counting algorithms is that they have exponential worst-case run time. Moreover, as our experiments show, the state-of-the-art algorithms (Talvitie and Koivisto 2019; Ganian, Hamm, and Talvitie 2020;AhmadiTeshnizi, Salehkaleybar, and Kiyavash 2020) perform inadequately in practice on a wide range of instances.\nThe main achievement of our paper is the first polynomial-time algorithm for counting and for sampling Markov equivalent DAGs. The counting algorithm, called Clique-Picking, explores the clique tree representation of a chordal graph, but it avoids the use of computationally intractable dynamic programming on the clique tree. The Clique-Picking algorithm is effective, easy to implement, and our experimental results show that it significantly outperforms the state-of-the-art methods. Moreover, we show that, using the algorithm in a preprocessing phase, uniform sampling of Markov equivalent DAGs can be performed in linear time.\nWe prove that our results are tight in the sense that counting Markov equivalent DAGs that encode additional background knowledge is intractable under standard complexitytheoretic assumptions. This justifies the exponential time approaches by Meek (1995) and Ghassami et al. (2019).\nThe next section contains preliminaries on graphs and MECs. In Sec. 3, we present the ideas of our novel approach, and Sec. 4 explains how to avoid overcounting using minimal separators. Section 5 contains our algorithm and in Sec. 6 we analyze its time complexity and formally present the main results of the paper. Finally, Sec. 7 shows our experimental results. Due to space constraints, proofs are relocated to the appendix. We provide short proof sketches for the most important results in the main text.", "publication_ref": ["b28", "b21", "b16", "b15", "b31", "b1", "b32", "b19", "b20", "b28", "b17", "b30", "b22", "b17", "b14", "b12", "b27", "b9", "b10", "b19", "b18", "b31", "b13", "b13", "b10", "b8", "b29", "b8", "b0", "b19", "b10"], "figure_ref": [], "table_ref": []}, {"heading": "Preliminaries", "text": "A graph G = (V G , E G ) consists of a set of vertices V G and a set of edges E G \u2286 V G \u00d7 V G . Throughout the paper, whenever the graph G is clear from the context, we will drop the subscript in this and analogous notations. An edge u \u2212 v is undirected if (u, v), (v, u) \u2208 E G and directed u \u2192 v if (u, v) \u2208 E G and (v, u) \u2208 E G . Graphs which contain undirected and directed edges are called partially directed. Directed acyclic graphs (DAGs) contain only directed edges and no directed cycle. We refer to the neighbors of a vertex u in G as N G (u) and denote the induced subgraph of G on a set\nC \u2286 V by G[C]. The graph union G \u222a H includes edges present in G or in H 1 .\nThe skeleton of a partially directed graph G is the undirected graph that results from ignoring edge directions. A vstructure in a partially directed graph G is an ordered triple of vertices (a, b, c) which induce the subgraph a \u2192 b \u2190 c.\nA clique is a set K of pairwise adjacent vertices. We denote the set of all maximal cliques of G by \u03a0(G). In a connected graph, we call a set S \u2286 V an a-b-separator for two nonadjacent vertices a, b \u2208 V if a and b are in different connected components in G[V \\ S]. If no proper subset of S separates a and b we call S a minimal a-b-separator. We say a set S is a minimal separator if it is a minimal a-b-separator for any two vertices 2 . We denote the set of all minimal separators of a graph G by \u2206(G). An undirected graph is called chordal if no subset of four or more vertices induces an undirected cycle. For every chordal graph on n vertices we have |\u03a0(G)| \u2264 n (Dirac 1961). Furthermore, it is well-known that a graph G is chordal if, and only if, all its minimal separators are cliques.\nA Markov equivalence class (MEC) consists of DAGs encoding the same set of conditional independence relations among the variables. Due to Verma and Pearl (1990), we know that two DAGs are Markov equivalent if, and only if, they have the same skeleton and the same v-structures. An MEC can be represented by a CPDAG (completed partially directed acyclic graph), which is the union graph of the DAGs in the equivalence class it represents. The undirected components of a CPDAG are undirected and connected chordal graphs (UCCGs) (Andersson, Madigan, and Perlman 1997).\nAn orientation of a partially directed graph G is obtained by replacing each undirected edge with a directed one. Such an orientation is called acyclic if it does not contain a directed cycle and moral if it does not create a new v-structure (sometimes called immorality). In the following, we will only consider acyclic moral orientations (AMOs). For a partially ordered graph G, we denote by AMO(G) the set of all AMOs and by #AMO(G) the number of AMOs of G. In particular, if G is a CPDAG representing an MEC then #AMO(G) is the size of the class. In this paper, we also refer to the computational problem of counting the number of AMOs for a given CPDAG as #AMO.\nIn case we have an induced subgraph a \u2192 b \u2212 c in a partially directed graph, the edge between b and c is oriented b \u2192 c in all AMOs. This is known as the first Meek rule (Meek 1995).\nFor a CPDAG G, the AMOs of each UCCG of G can be chosen independently of the other UCCGs and the directed part of G (Andersson, Madigan, and Perlman 1997). Thus,\n#AMO(G) = H is UCCG in G #AMO(H).\nHence, the problem #AMO of counting the number of DAGs in an MEC reduces to counting the number of AMOs in a UCCG (Gillispie and Perlman 2002;He and Geng 2008).\nAn AMO \u03b1 of a graph G can be represented by a (not necessarily unique) linear ordering of the vertices. Such a topological ordering \u03c4 represents \u03b1 if for each edge u \u2192 v in \u03b1, u precedes v in \u03c4 . We denote all topological orderings representing an AMO \u03b1 of a graph G by top G (\u03b1) = {\u03c4 1 , . . . , \u03c4 }. Note that every AMO of a UCCG contains exactly one source vertex, i. e., a vertex with no incoming edges.\nThe s-orientation G s of a UCCG G is the union of all AMOs of G with unique source vertex s. We view sorientations from the equivalent perspective of being the union of all AMOs that can be represented by a topological ordering starting with s. The undirected components of G s are UCCGs and can be oriented independently (He, Jia, and Yu 2015). This observation enables recursive strategies for counting AMOs: the \"root-picking\" approaches (He, Jia, and Yu 2015;Ghassami et al. 2019;Talvitie and Koivisto 2019;Ganian, Hamm, and Talvitie 2020) that pick each vertex s as source and recurse on the UCCGs of the s-orientation. Because these UCCGs can be oriented independently, the number of AMOs is obtained by alternately summing over the number of AMOs for each source vertex s and multiplying the number of AMOs for each independent UCCG.", "publication_ref": ["b6", "b31", "b1", "b19", "b1", "b11", "b14", "b13", "b13", "b10", "b29", "b8"], "figure_ref": [], "table_ref": []}, {"heading": "Lexicographic BFS and AMOs", "text": "We introduce the core ideas of our algorithm for #AMO and a linear-time algorithm for finding the UCCGs of the sorientations and their generalization, the \u03c0(K)-orientations. We do this by connecting AMOs with so-called perfect elimination orderings (PEOs). A linear ordering of the vertices is a PEO if for each vertex v, the neighbors of v that occur after v form a clique. A graph is chordal if, and only if, it has a PEO (Fulkerson and Gross 1965). Lemma 1. A topological ordering \u03c4 of the vertices of a UCCG G represents an AMO if, and only if, it is the reverse of a perfect elimination ordering.\nPerfect elimination orderings can be computed in linear time with the Lexicographic BFS algorithm (Rose, Tarjan, and Lueker 1976) to which we will refer as LBFS. A modified version of this algorithm is presented as Algorithm 1. When called with K = \u2205 (and ignoring the lines 7-10), it coincides with a normal LBFS. The modifications and the meaning of K will become clear later on.\ninput : A UCCG G = (V, E) and a clique K \u2286 V . output: C G (K). 1 S \u2190 sequence of sets initialized with (K, V \\ K) 2 \u03c4 \u2190 empty list, L \u2190 \u2205 3 while S is non-empty do 4 X \u2190 first non-empty set of S 5 v \u2190 arbitrary vertex from X 6 Add vertex v to the end of \u03c4 . 7 if v is neither in a set in L nor in K then 8 L \u2190 L \u222a {X} 9 Output the undirected components of G[X]. end X \u2190 X \\ {v} Denote the current S by (S 1 , . . . , S k ). Replace each S i by S i \u2229 N (v), S i \\ N (v).\nRemove all empty sets from S. end Algorithm 1: A modified version of the Lexicographic BFS (Rose, Tarjan, and Lueker 1976) for computing the set C G (K). If the algorithm is executed with K = \u2205, the algorithm performs a normal LBFS with corresponding traversal ordering \u03c4 , which is the reverse of a PEO.\nLBFS runs in linear time (i. e., O(|V | + |E|)) when S is implemented as a doubly-linked list with a pointer to each vertex and the beginning of each set. The algorithm can be viewed as a fine-grained graph traversal compared to classical breadth-first search (BFS), where the vertices are visited only by increasing distance to the start vertex. LBFS keeps this property, but introduces additional constraints on the ordering \u03c4 , in which the vertices are visited (\u03c4 is called an LBFS ordering). These constraints guarantee that \u03c4 is the reverse of a PEO. Hence, by Lemma 1, \u03c4 represents an AMO. Corollary 1. Every LBFS ordering \u03c4 of the vertices of a UCCG G represents an AMO.\nIt holds even further that each AMO can be represented by at least one LBFS ordering. Lemma 2. Every AMO of a UCCG G can be represented by an LBFS ordering.\nEach LBFS ordering starts with a maximal clique, because as long as there is a vertex which can enlargen the current clique, the first set of S is made up solely of such vertices. Lemma 3. Every LBFS ordering starts with a maximal clique.\nThese observations lead to the first idea in our algorithm for #AMO. We have seen that every AMO can be represented by an LBFS ordering (Lemma 2) and every LBFS ordering starts with a maximal clique (Lemma 3). It follows: Corollary 2. Every AMO can be represented by a topological ordering which starts with a maximal clique.\nThis means that for us, it is sufficient to consider topological orderings that start with a maximal clique. Therefore, we generalize the definition of s-orientations: We consider permutations \u03c0 of a clique K, as each \u03c0(K) represents a distinct AMO of the subgraph induced by K. Definition 1. Let G = (V, E) be a UCCG, K be a clique in G, and let \u03c0(K) be a permutation of K.\n1. The \u03c0(K)-orientation of G, also denoted G \u03c0(K) , is the union of all AMOs of G that can be represented by a topological ordering beginning with \u03c0(K). 2. Let G K denote the union of \u03c0(K)-orientations of G over all \u03c0, i. e., let\nG K = \u03c0 G \u03c0(K) . 3. Denote by C G (\u03c0(K)) the undirected connected compo- nents of G \u03c0(K) [V \\ K] and let C G (K) denote the undi- rected connected components of G K [V \\ K].\nFigure 1 shows an example \u03c0(K)-orientation of G: For a graph G in (a), a clique K = {1, 2, 3, 4}, and a permutation (4, 3, 2, 1), graph G (4,3,2,1) is presented in (c). It is the union of two DAGs which are AMOs of G, whose topological orderings begin with 4, 3, 2, 1. The first DAG can be represented by topological ordering 4, 3, 2, 1, 5, 6, 7 and the second one by 4, 3, 2, 1, 6, 5, 7. In Fig. 1, we also compare the (4, 3, 2, 1)-orientation with an s-orientation, for s = 4, shown in (b). The undirected components of the orientations are indicated by the colored regions. By orienting whole cliques at once, we get significantly smaller undirected components in the resulting \u03c0(K)-orientation than in the s-orientation (e. g., {5, 6} compared to {1, 2, 3, 5, 6}). Finally, (d) illustrates graph G {1,2,3,4} .\nThe undirected components of the \u03c0(K)-orientation are chordal graphs, which can be oriented independently, yielding the following recursive formula:  G (4,3,2,1) in (c), and G {1,2,3,4} in (d). The undirected components in G (4) and G (4,3,2,1) are indicated by the colored regions and the vertices put at the beginning of the topological ordering by a rectangle (all edges from the rectangle point outwards). Edges inside the rectangle in (c) are dashed, as they have no influence on the further edge directions outside the rectangle.\nLemma 4. The undirected connected components in C G (\u03c0(K)) are chordal and it holds that:\n#AMO(G \u03c0(K) ) = H\u2208C G (\u03c0(K)) #AMO(H).\nThe crucial observation is that the undirected components C G (\u03c0(K)) are independent of the permutation \u03c0. This means no matter how the vertices {1, 2, 3, 4} are permuted, if the whole clique is put at the beginning of the topological ordering, no further edge orientations will be influenced. Informally, this is because all edges from the clique K to other vertices are directed outwards no matter the permutation \u03c0. We formalize this observation in the following: Proposition 1. Let G be a UCCG and K be a clique of G. For each permutation \u03c0(K) it is true that all edges of G \u03c0(K) coincide with the edges of G K , excluding the edges connecting the vertices in K. Hence, C G (\u03c0(K)) = C G (K) and it holds that:\n\u03c0 over K #AMO(G \u03c0(K) ) = |K|! \u00d7 H \u2208 C G (K) #AMO(H).\nThis is the key property that allows us to efficiently deal with whole cliques at once, instead of considering single vertices one-by-one. As each permutation \u03c0(K) represents a distinct AMO of G[K], this formula indeed computes the number of AMOs, which can be represented by a topological ordering with clique K at the beginning. However, we are not done yet, as there are some further obstacles we need to overcome in order to obtain a polynomial-time algorithm for #AMO, which are dealt with in the following sections.\nBefore that, we leverage the connection between AMOs and LBFS orderings one more time, to propose a linear-time algorithm for computing C G (K) -the full Algorithm 1. This algorithm performs an LBFS and, whenever a vertex could be picked for the first time, the corresponding first set in S is appended to L and the undirected components of the set are output (lines 7-10). For instance, in the example above, after the vertices in K are visited, we have S = ({5, 6}, {7}). As {5, 6} is currently the first set of S and vertices 5 and 6 are not in any set in L yet (L is still empty), the set {5, 6} is appended to L and 5 \u2212 6 is output as an element of C G (K). Theorem 1. For a chordal graph G and a clique K, Algorithm 1 computes C G (K) in time O(|V | + |E|). Sketch of Proof. When a set is appended to L, each vertex of this set could have been the next chosen vertex in line 6. Thus, all edges between the vertices in a set in L may occur as either u \u2192 v (if u is chosen next) or as u \u2190 v (if v is chosen next) in an AMO having K at the beginning of the LBFS ordering. As a \u03c0(K)-orientation of G is the union of all corresponding AMOs, we have u \u2212 v.\nIf, on the other hand, u and v are neighbors but not in the same set in L, the edge between them is oriented u \u2192 v in G K , assuming u is visited before v. This is due to an inductive argument by which u \u2192 v follows from iterative application of the first Meek rule.\nBoth cases dealt with in the proof sketch can be seen in Fig. 1. The edge 5 \u2212 6 remains undirected as either vertex could be chosen first in Algorithm 1, while we have 5 \u2192 7, because the first Meek rule applies to \u2192 5 \u2212 7.\nWe note that this algorithm could also be used for finding the UCCGs of the s-orientations of a chordal graph in linear time, which improves upon prior work (He, Jia, and Yu 2015;Ghassami et al. 2019;Talvitie and Koivisto 2019).", "publication_ref": ["b7", "b24", "b24", "b13", "b10", "b29"], "figure_ref": ["fig_0", "fig_0", "fig_0"], "table_ref": []}, {"heading": "Counting AM-Orientations with Minimal Separators and Maximal Cliques", "text": "Using the insights from the previous section, we would like to count the AMOs of a chordal graph G with the following recursive procedure based on Proposition 1: Pick a maximal clique K, consider all its permutations at once, and take the product of the recursively computed number of AMOs of the UCCGs of C G (K). By Corollary 2, we will count every AMO in this way, if we compute the sum over all maximal cliques. Unfortunately, we will count some orientations multiple times, as a single AMO can be represented by multiple topological orderings. For instance, assume we have two maximal cliques K 1 and K 2 with\nK 1 \u2229 K 2 = S such that K 1 \\ S is separated from K 2 \\ S in G[V \\ S].\nA topological ordering that starts with S can proceed with either K 1 \\ S or K 2 \\ S and result in the same AMO.\nExample 1. Consider the following chordal graph (left) with maximal cliques K 1 = {1, 2, 3} and K 2 = {2, 3, 4}. A possible AMO of the graph is shown on the right. The AMO has two topological orderings: \u03c4 1 = (3, 2, 1, 4) and \u03c4 2 = (3, 2, 4, 1) starting with K 1 and K 2 , respectively. Hence, if we count all topological orderings starting with K 1 and all topological orderings starting with K 2 , we will count the AMO twice. However, \u03c4 1 and \u03c4 2 have 3, 2 as common prefix and K 1 \u2229 K 2 = {2, 3} is a minimal separator of the graph -a fact that we will use in the following. Lemma 5. Let \u03b1 be an AMO of a chordal graph G and \u03c4 1 , \u03c4 2 be two topological orderings that represent \u03b1. Then \u03c4 1 and \u03c4 2 have a common prefix S \u2208 \u2206(G) \u222a \u03a0(G).\nNote that this lemma implies that all topological orderings that correspond to an AMO have a common prefix, which is a minimal separator or maximal clique.\nThe combinatorial function \u03c6, as defined below, plays an important role to avoid overcounting. Definition 2. For a set S and a collection R of subsets of S, we define \u03c6(S, R) as the number of all permutations of S that do not have a set S \u2208 R as prefix. Example 2. Consider the set S = {2, 3, 4, 5} and the collection R = {2, 3}, {2, 3, 5} . Then \u03c6(S, R) = 16 since there are 16 permutations of {2, 3, 4, 5} that neither start with {2, 3} nor {2, 3, 5} -e. g., (3, 2, 4, 5) and (2, 5, 3, 4) are forbidden as they start with {2, 3} and {2, 3, 5}, respectively; but (3, 5, 4, 2) is allowed.\nIn this paper, we always consider sets S \u2208 \u2206(G) \u222a \u03a0(G) and collections R \u2286 \u2206(G). Therefore, we can use the abbreviation\n\u03c6(S) = \u03c6 S, { S | S \u2208 \u2206(G) \u2227 S S } . Proposition 2. Let G be a UCCG. Then: #AMO(G) = S\u2208\u2206(G)\u222a\u03a0(G) \u03c6(S) \u00d7 H \u2208 C G (S)", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "#AMO(H).", "text": "Sketch of Proof. By Lemma 5, every AMO can be represented by a topological ordering that starts with a vertex set S \u2208 \u2206(G) \u222a \u03a0(G). The definition of \u03c6(S) and an induction over the product yields the claim.\nExample 3. We consider the following chordal graph with two minimal separators and three maximal cliques:\nG = 1 2 3 4 5 6 \u2206(G) = {2, 3}, {2, 3, 5} \u03a0(G) = {1, 2, 3}, {2, 3, 4, 5}, {2, 3, 5, 6}\nTo compute #AMO(G) using Proposition 2, we need the following values. Note that the resulting subgraphs H are trivial, except for the case S = {2, 3} and S = {1, 2, 3}. In these cases, we obtain the induced path on {4, 5, 6}, which has three possible AMOs.\nS \u2208 \u2206(G) \u222a \u03a0(G) \u03c6(S) H\u2208C G (S) #AMO(H) {2, 3} 2 3 {2, 3, 5} 4 1 {1, 2, 3} 4 3 {2, 3, 4, 5} 16 1 {2, 3, 5, 6} 16 1 Using Proposition 2 we can compute #AMO(G) as follows: #AMO(G) = 2 \u2022 3 + 4 \u2022 1 + 4 \u2022 3 + 16 \u2022 1 + 16 \u2022 1 = 54.\nWe remark that we do not have discussed how to compute \u03c6(S) yet -for this example, this can be done by naive enumeration. In general, however, this is a non-trivial task. We tackle this issue in the next section.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "The Clique-Picking Algorithm", "text": "In the previous section, we showed how to count AMOs by using minimal separators in order to avoid overcounting. It is rather easy to check that we can compute \u03c6(S, R) in time exponential in |R| using the inclusion-exclusion principle. However, our goal is polynomial time and, thus, we have to restrict the collection R. Lemma 6. Let S be a set and R = {X 1 , . . . , X } be a collection of subsets of S with X 1 X 2 \u2022 \u2022 \u2022 X . Then:\n\u03c6(S, R) = |S|! \u2212 i=1 |S \\ X i |! \u2022 \u03c6(X i , {X 1 , . . . , X i\u22121 }).\nObserve that this formula can be evaluated in polynomial time with respect to |S| and , as all occurring subproblems have the form \u03c6(X i , {X 1 , . . . , X i\u22121 }) and, thus, there are at most of them. The goal of this section is to develop a version of Proposition 2 based on this lemma.\nTo achieve this goal, we rely on the strong structural properties that chordal graphs entail: A rooted clique tree of a UCCG G is a triple (T, r, \u03b9) such that (T, r) is a rooted tree and \u03b9 : V T \u2192 \u03a0(G) a bijection between the nodes of T and the maximal cliques of G such that {\nx | v \u2208 \u03b9(x) } is connected in T for all v \u2208 V G . In slight abuse of no- tation, we denote, for a set C \u2286 V G , by \u03b9 \u22121 (C) the sub- tree { x | C \u2286 \u03b9(x) }.\nWe denote the children of a node v in a tree T by children T (v). It is well-known that (i) every chordal graph has a rooted clique tree (T, r, \u03b9) that can be computed in linear time, and (ii) a set S \u2208 V G is a minimal separator if, and only if, there are two adjacent nodes x, y \u2208 V T with \u03b9(x) \u2229 \u03b9(y) = S (Blair and Peyton 1993).\nWe wish to interleave the structure provided by the clique tree with a formula for computing #AMO. For this sake, let us define the forbidden prefixes for a node v in a clique tree. Definition 3. Let G be a UCCG, T = (T, r, \u03b9) a rooted clique tree of G, v a node in T and r = x 1 , x 2 , . . . , x p = v the unique r-v-path. We define the set FP(v, T ) to contain all sets \u03b9(\nx i ) \u2229 \u03b9(x i+1 ) \u2286 \u03b9(v) for 1 \u2264 i < p. Lemma 7. We can order the elements of the set FP(v, T ) as X 1 X 2 \u2022 \u2022 \u2022 X .\nBy combining the lemma with Lemma 6, we deduce that \u03c6(\u03b9(v), FP(v, T )) can be evaluated in polynomial time for nodes v of the clique tree. We are left with the task of developing a formula for #AMO in which all occurrences of \u03c6 are of this form. It is quite easy to come up with such formulas that count every AMO at least once -but, of course, we have to ensure that we count every AMO exactly once.\nTo ensure this property, we introduce for every AMO \u03b1 a partial order \u227a \u03b1 on the maximal cliques. Then we prove that there is a unique minimal element with respect to this order, and deduce a formula for #AMO that counts \u03b1 only \"at this minimal element\". To get started, we need a technical definition and some auxiliary lemmas that give us more control over the rooted clique tree. Definition 4. An S-flower for a minimal separator S is a maximal set\nF \u2286 { K | K \u2208 \u03a0(G) \u2227 S \u2286 K } such that\nExample 4. The {2, 3}-flowers of the graph from Example 3 are {{1, 2, 3}} and {{2, 3, 4, 5}, {2, 3, 5, 6}}. Lemma 8. An S-flower F is a connected subtree in a rooted clique tree (T, r, \u03b9). Lemma 9. For any minimal separator S, the bouquet B(S) is a partition of \u03b9 \u22121 (S).\nSince for a S \u2208 \u2206(G) the subtree \u03b9 \u22121 (S) of (T, r, \u03b9) is connected, Lemma 8 and Lemma 9 give rise to the following order on S-flowers F 1 , F 2 \u2208 B(S): F 1 \u227a T F 2 if F 1 contains a node on the unique path from F 2 to the root of T . Lemma 10. There is a unique least S-flower in B(S) with respect to \u227a T .\nThe lemma states that for every AMO \u03b1 there is a flower F at which we want to count \u03b1. We have to be sure that this is possible, i. e., that a clique in F can be used to generate \u03b1. Lemma 11. Let \u03b1 be an AMO such that every topological ordering that represents \u03b1 has the minimal separator S as prefix. Then every F \u2208 B(S) contains a clique K such that there is a \u03c4 \u2208 top(\u03b1) starting with K.\nWe use \u227a T to define, for a fixed AMO \u03b1, a partial order \u227a \u03b1 on the set of maximal cliques, which are at the beginning of some \u03c4 \u2208 top(\u03b1), as follows:\nK 1 \u227a \u03b1 K 2 if, and only if, (i) K 1 \u2229 K 2 = S \u2208 \u2206(G), (ii) K 1 and K 2 are in S-flowers F 1 , F 2 \u2208 B(S)\n, respectively, and (iii) F 1 \u227a T F 2 . Proposition 3. Let G be a UCCG and T = (T, r, \u03b9) be a rooted clique tree of G. Then:\n#AMO(G) = v \u2208 V T \u03c6(\u03b9(v), FP(v, T )) \u00d7 H \u2208 C G (\u03b9(v))", "publication_ref": ["b2"], "figure_ref": [], "table_ref": []}, {"heading": "#AMO(H).", "text": "Sketch of Proof. First, prove that for every AMO \u03b1 there is a unique least K \u2208 \u03a0(G) with respect to \u227a \u03b1 . Let x be the node of the clique tree with \u03b9(x) = K, we deduce that \u03b1 is counted in \u03c6(\u03b9(x), FP(x, T )), but is blocked in all other nodes y by some set in FP(y, T ).\nAlgorithm 2 evaluates this formula, utilizing memoization to avoid recomputations. Traversing the clique tree with a BFS allows for simple computation of FP. Theorem 2. For an input UCCG G, Algorithm 2 returns the number of AMOs of G. Example 5. We consider a rooted clique tree (T, r, \u03b9) for the graph G from Example 3. The root is labeled with r and the function \u03b9 is visualized in blue. The edges of the clique tree are labeled with the corresponding minimal separators.\nr {1, 2, 3} {2, 3, 4, 5} {2, 3, 5, 6} {2, 3} {2, 3, 5} \u03c6 {1, 2, 3}, \u2205 \u03c6 {2, 3, 4, 5}, {2, 3} \u03c6 {2, 3, 5, 6}, {2, 3}, {2, 3, 5} = 6 = 20 = 16\nAlgorithm 2 traverses the tree T from the root r to the bottom and computes the values shown at the right. The only case in which we obtain a non-trivial subgraph is for S = {1, 2, 3} (an induced path on {4, 5, 6}). Therefore: Since clique trees can be computed in linear time (Blair and Peyton 1993), an iteration of the algorithm runs in polynomial time due to Lemma 6 and 7. We prove in the next section that Algorithm 2 performs at most 2 \u2022 |\u03a0(G)| \u2212 1 recursive calls, which implies overall polynomial run time. Sketch of Proof. We observe that there is a bijection between S-flowers of G and distinct UCCGs. The linear bound follows, as a separator S, that has a bouquet of size k, is associated with k \u2212 1 edges of the clique tree. Therefore, we have at most |\u03a0(G)| \u2212 1 \u2212 (k \u2212 1) further separators and the maximum number of flowers is obtained if the quotient k/(k \u2212 1) is maximized -which is the case for k = 2.\n#AMO(G) = 6 \u2022 3 + 20 \u2022 1 + 16 \u2022 1 = 54. input : A UCCG G = (V, E). output: #AMO(G). 1 function count(G, memo) 2 if G \u2208 memo then 3 return memo[G] 4 end 5 T = (T, r, \u03b9) \u2190 a rooted clique tree of G 6 sum \u2190 0 7 Q \u2190 queue with single element r 8 while Q is not empty do 9 v \u2190 pop(Q) 10 push(Q, children(v)) 11 prod \u2190 1 12 foreach H \u2208 C G (\u03b9(v)) do 13 prod \u2190 prod \u2022 count(H, memo) 14 end 15 sum \u2190 sum + \u03c6(\u03b9(v), FP(v, T )) \u2022 prod", "publication_ref": ["b2"], "figure_ref": [], "table_ref": []}, {"heading": "The Complexity of #AMO", "text": "We are now able to bound the run time of Clique-Picking: As one would expect, the Clique-Picking algorithm canwith slight modifications -also be used to sample Markov equivalent DAGs uniformly at random. Hence, this problem can be solved in polynomial time, too. Sketch of Proof. We sample the AMOs recursively: Draw a clique K proportional to the number of AMOs counted at this clique; uniformly draw a permutation of K that does not start with a forbidden prefix; recurse on subgraphs.\nWe summarize the findings of this section: 3 Theorem 5. The problems #AMO and uniform sampling from a Markov equivalence class are in P.\nThe following theorem shows that Theorem 5 is tight in the sense that counting Markov equivalent DAGs that encode additional background knowledge (e. g., that are represented as so-called PDAGs or MPDAGs) is not in P under standard complexity-theoretic assumptions. Theorem 6. The problem of counting the number of AMOs is #P-complete for PDAGs and MPDAGs.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Experimental Evaluation of Clique-Picking", "text": "We evaluate the practical performance of the Clique-Picking algorithm by comparing it to three state-of-the-art algorithms for #AMO. AnonMAO (Ganian, Hamm, and Talvitie 2020) is the best root-picking method; TreeMAO (Talvitie and Koivisto 2019) utilizes dynamic programming on the clique tree; and LazyIter (AhmadiTeshnizi, Salehkaleybar, and Kiyavash 2020) combines techniques from intervention design with dynamic programming.\nFigure 2 shows the run time of the four algorithms on random chordal graphs -details of the random graph generation and further experiments can be found in the supplementary material 4 . We chose the random subtree intersection method (left plot in Fig. 2) as it generates a broad range of chordal graphs (Seker et al. 2017); and we complemented these with random interval graphs (right plot) as AnonMAO runs provably in polynomial time on this subclass of chordal graphs (Ganian, Hamm, and Talvitie 2020).\nThe Clique-Picking algorithm outperforms its competitors in both settings. For the subtree intersection graphs, it solves all instances in less than a minute, while the other solvers are not able to solve instances with more than 1024 vertices. The large instances of the interval graphs are more challenging, as they are denser and have more maximal cliques. However, Clique-Picking is still able to solve all instances, while the best competitor, AnonMAO, can not handle graphs with 256 or more vertices.", "publication_ref": ["b26", "b8"], "figure_ref": ["fig_4", "fig_4"], "table_ref": []}, {"heading": "Conclusion", "text": "We presented the first polynomial-time algorithms for counting and sampling Markov equivalent DAGs. Our novel Clique-Picking approach utilizes the clique tree without applying cumbersome dynamic programming on it. As a result, the algorithm is not only of theoretical but also of high practical value, being the fastest algorithm by a large margin.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Appendix", "text": "Part I", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Detailed Proofs", "text": "We present the detailed proofs that are missing within the main paper. This part of the appendix is structured as the main paper, i. e., for every section of the paper (that contains lemmas or theorems) there is a section here that contains the corresponding detailed proofs. For the reader's convenience, we repeated the statements of the lemmas and theorems and, if appropriate, recall some central definitions. Some of the proofs require additional auxiliary lemmas that did not appear within the main text. These new lemmas are marked with a .", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Proofs of Section 3: Lexicographic BFS and AMOs", "text": "Claim of Lemma 1. A topological ordering \u03c4 of the vertices of a UCCG G represents an AMO if, and only if, it is the reverse of a perfect elimination ordering.\nProof. For the first direction, assume \u03c4 is a topological ordering representing an AMO. By definition of AMOs, there can not be a v-structure and, thus, if two vertices x, y \u2208 N (u) precede u in \u03c4 , they need to be neighbors. This implies that the neighbors of u preceding u in \u03c4 form a clique. Thus, the reverse of \u03c4 is a perfect elimination ordering.\nFor the second direction, assume \u03c1 is a perfect elimination ordering and orient the edges according to the topological ordering that is the reverse of \u03c1. Clearly, the orientation is acyclic. Moreover, there can be no v-structure, as two vertices x, y preceding u in the reverse of \u03c1 are neighbors. Thus, the reverse of \u03c1 represents an AMO.\nClaim of Corollary 1. Every LBFS ordering \u03c4 of a UCCG G represents an AMO.\nProof. Follows immediately from Lemma 1 and the fact that an LBFS always outputs a PEO when performed on a chordal graph (Rose, Tarjan, and Lueker 1976).\nIn order to prove the next lemmas of the main paper, we require further auxiliary lemmas and definitions. A state X of the LBFS algorithm is a tuple (V (X ), S(X )), where V (X ) is the sequence of already visited vertices at some point of the algorithm and S(X ) the current sequence of sets after the last vertex in V (X ) has been processed. From now on, the term preceding neighbors of v at state X (denoted by P X (v)) describes the set N (v) \u2229 V (X ), i. e., all neighbors of v which were visited before v at state X of the LBFS. Lemma 12. In a state X of the LBFS algorithm performed on a chordal graph G, two unvisited vertices u and v are in the same set if, and only if, the preceding neighbors of u and v are identical, i. e., P X (u) = P X (v). These preceding neighbors form a clique.\nProof. The second statement follows from the fact that the LBFS algorithm produces a valid PEO for chordal graphs. Thus, when a vertex w is visited, all preceding neighbors form a clique. This also holds for subsets of these neighbors and, hence, for every state X .\nLet us now prove the first statement. First, observe that P X (u) = P X (v) implies that u and v are in the same set. For each visited vertex, the sets are partitioned as described in line 13 of Algorithm 1. As this visited vertex is either a neighbor of u and v or of neither of them, these vertices are put in the same set.\nWe show the other direction by contradiction. Assume u and v are in the same set, but the sets of preceding neighbors differ, i. e., P X (u) = P X (v). Moreover, assume without loss of generality that x is the earliest visited vertex that is (i) in exactly one of these sets and that (ii) is a neighbor of u but not v. When x is visited, u and v are in the same set by the argument above (the sets of preceding neighbors of u and v are identical in this state) and, according to the partitioning in line 13, u and v are put in different sets in S. As no sets are joined in the LBFS, it follows that u and v stay in different sets and, thus, are not in the same set. A contradiction.\nDue to this result, we will also refer to the preceding neighbors of a set S \u2208 S(X ) at state X as P X (S), which means the preceding neighbors of any node in S.\nLemma 13. Let X be the state of an LBFS performed on a chordal graph G = (V, E), and let S 1 , S 2 \u2208 S(X ) such that S 1 precedes S 2 in S(X ) and such that there are vertices u \u2208 S 1 and v \u2208 S 2 with {u, v} \u2208 E. Then P X (S 1 ) P X (S 2 ).\nProof. Assume for the sake of contradiction that there is a vertex x \u2208 P X (S 2 ) \\ P X (S 1 ). Let u \u2208 S 1 and v \u2208 S 2 be the vertices with edge u \u2212 v.\nVertex v is visited after u by the LBFS, as S 2 succeeds S 1 . Since x was already visited as well, we have that the preceding neighbors of v (when v is visited) do not form a clique. This contradicts the fact that the LBFS ordering is the reverse of a PEO.\nClaim of Lemma 2. Every AMO of a UCCG G can be represented by an LBFS ordering.\nProof. We show how the LBFS algorithm can be used to obtain a topological ordering that represents an AMO \u03b1.\nThe LBFS algorithm can freely choose a vertex from the first set. We restrict the algorithm to choose a vertex that has no incoming edges in \u03b1 from an unvisited vertex. If such a vertex always exists, we obtain a topological ordering which represents \u03b1.\nIt is left to show that such a vertex indeed exists. We prove this by induction, where the base case is the source vertex of \u03b1, which can be chosen, as all vertices are in the first set. Assume the first k \u2212 1 vertices were chosen from the (at that state) first set. We show that it is possible to pick a kth vertex from the first set, which has no incoming edges from an unvisited vertex.\nLet X = (V (X ), S(X )) be the state when picking the kth vertex and assume, for the sake of contradiction, that there is no such vertex in the first set of S(X ). This means, for all vertices x in the first set X of S(X ), an unvisited vertex z exists with x \u2190 z in \u03b1. There has to be at least one z that is not in X, as otherwise there would be a cycle in \u03b1. This z is in a later set than x, and there is an edge between x and z. We deduce P X (z) P X (x) with Lemma 13.\nLet u \u2208 P X (x) \\ P X (z) be a preceding neighbor of x but not z. The edge between u and v is correctly directed u \u2192 x by induction hypothesis. However, if \u03b1 would contain the edge x \u2190 z, then there would be a v-structure in \u03b1, as there is no edge between u and z. A contradiction.\nClaim of Lemma 3. Every LBFS ordering starts with a maximal clique.\nProof. At the beginning of the LBFS, an arbitrary vertex u is chosen. In the subsequent steps, as long as there exists a vertex that is adjacent to all previously visited vertices, all vertices in the first set in S(X ) have this property (in line 13 of Algorithm 1 they are put in front sets of previously visited vertices).\nClaim of Corollary 2. Every AMO can be represented by a topological ordering which starts with a maximal clique.\nProof. By Lemma 3, every LBFS ordering starts with a maximal clique. The statement follows from the fact that every AMO can be represented by an LBFS ordering (Lemma 2).\nFor the sake of readability, we repeat the following definition from the main paper: Definition 1. Let G be a UCCG over V , K be a clique in G, and let \u03c0(K) be a permutation of K.\n1. The \u03c0(K)-orientation of G, also denoted G \u03c0(K) , is the union of all AMOs of G that can be represented by a topological ordering beginning with \u03c0(K). 2. Let G K denote the union of \u03c0(K)-orientations of G over all \u03c0, i. e., let\nG K = \u03c0 G \u03c0(K) . 3. Denote by C G (\u03c0(K)) the undirected connected compo- nents of G \u03c0(K) [V \\ K] and let C G (K) denote the undi- rected connected components of G K [V \\ K].\nWe introduce a linear-time algorithm for finding the undirected components of G \u03c0(K) . Algorithm 3 proceeds as Algorithm 1 in the main paper, with the exception that it makes sure that the vertices of the clique K are visited in order \u03c0(K). In this way, the algorithm characterizes exactly the \u03c0(K)-orientation, which makes the proofs cleaner compared to showing the correctness of Algorithm 1 directly. Afterward, in Proposition 1, we observe that indeed the permutation \u03c0(K) does not influence orientations beyond the initial clique. This will allow us to immediately conclude the correctness of Algorithm 1 from the main paper (Theorem 1).\ninput : A UCCG G, clique K, and permutation \u03c0(K). output:  Proof. We first show that the edges between vertices in any set in L are correctly left undirected, i. e., they are undirected in G \u03c0 (K) . Note that by definition of G \u03c0(K) an edge u \u2212 v is undirected, if there are AMOs represented by topological orderings that have \u03c0(K) at the beginning and orient u \u2192 v and u \u2190 v, respectively. Note that the algorithm starts with vertices in K in the order \u03c0(K). By Corollary 1, the LBFS ordering will always represent an AMO with these properties.\nC G (\u03c0(K)). 1 S \u2190 sequence of sets initialized with (K, V \\ K) 2 \u03c4 \u2190 empty list, L \u2190 \u2205 3 while S is non-empty do 4 X \u2190 first non-empty set of S 5 if X \u2286 K then 6 v \u2190 the first vertex of X in \u03c0(K)", "publication_ref": ["b24"], "figure_ref": [], "table_ref": []}, {"heading": "17", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Replace each", "text": "S i by S i \u2229 N (v), S i \\ N (v).\nWhenever, in a certain state X (after the initial clique K has been visited), the algorithm chooses from the first set X \u2208 S(X ), it can choose the vertex arbitrarily. For any two neighbors u and v in X, there is an AMO with u \u2192 v (if we choose u as first vertex) and one with u \u2190 v (if we choose v). Thus, the edge between u and v is undirected in G \u03c0(K) . Hence, when a set X is appended to L in line 12 of Algorithm 3, edges in G \u03c0(K) [X] are undirected.\nWe show that all remaining edges are oriented in the way given by the LBFS ordering \u03c4 in G \u03c0 (K) . Clearly, the internal edges of K are oriented correctly. We prove the correctness of the remaining edges by induction: For each vertex u, we show that the edge to every vertex v, which comes after it in the LBFS and is not in the same set in L, is directed as K) . This means that every AMO of G whose topological ordering starts with \u03c0(K) contains the edge u \u2192 v.\nu \u2192 v in G \u03c0(\nThis holds for K, as edges to vertices that are not in K are always directed outwards from K. Assume the stated property holds for all previous vertices in the LBFS ordering \u03c4 , we show it also holds for vertex v. Let X be the state of the LBFS before the first vertex from the set of v in L was visited. For any subsequent vertex w, which is not in the same set in L as v, there is a preceding neighbor u of v at state X , which is not a preceding neighbor of w at state X . Otherwise w would have been in the same set at state X by Lemma 12 and, thereby, be in the same set in L as v. But then we have u \u2192 v\u2212w, with the correctness of edge u \u2192 v following from the induction hypothesis (u cannot be in the same set in L as v by definition of X ). By the first Meek rule, it follows that v \u2192 w is in every AMO of G \u03c0(K) .\nThe sets in L do not necessarily induce connected subgraphs. Thus, the algorithm returns the connected components of these sets, which are exactly the undirected connected components of G \u03c0(k) .\nFor the run time observe that the algorithm can be implemented in linear time with the same techniques used to implement the standard LBFS.\nWe need further vocabulary to prove the next lemma. Let H \u2208 C G (\u03c0(K)) be returned by Algorithm 3. We denote the set of preceding neighbors of the vertices in H at state X out , the state when H was output, by P out (H). Note that this is a slight abuse of notation as H is not a set in S but a graph. Claim of Lemma 4. The undirected components in C G (\u03c0(K)) are chordal and it holds that:\n#AMO(G \u03c0(K) ) = H\u2208C G (\u03c0(K))", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "#AMO(H).", "text": "Proof. The chordality of the graphs in C G (\u03c0(K)) follows from the correctness of Algorithm 3 (Lemma 14) and the fact that the undirected components returned by Algorithm 3 are induced subgraphs of G.\nThe second part, i. e., the recursive formula, follows from the property that each component H in C G (\u03c0(K)) can be oriented independently of the directed part of G \u03c0(K) . To prove this, we have to show that whenever a vertex u is a parent of vertex v \u2208 V H , then u is a parent of all vertices in H. This fact was proven for CPDAGs as Lemma 10 by He and Geng (2008) and the property then follows analogously for the UCCGs of the \u03c0(K)-orientation as in Theorem 4 and Theorem 5 of the same paper.\nBy Lemma 14, the parents of a vertex v \u2208 V H in the \u03c0(K)-orientation are the vertices in P out (H). All vertices in this set are neighbors of v, considered before v and not in the same set in L. All other neighbors of v are visited later or are in the same set in L as v and can, thus, not be parents. The set P out (H) is by definition the same for each vertex in H.\nClaim of Proposition 1. Let G be a UCCG and K be a clique of G. For each permutation \u03c0(K) it is true that all edges of G \u03c0(K) coincide with the edges of G K , excluding the edges connecting the vertices in K. Hence, C G (\u03c0(K)) = C G (K) and it holds that:\n\u03c0 over K #AMO(G \u03c0(K) ) = |K|! \u00d7 H \u2208 C G (K)", "publication_ref": ["b14"], "figure_ref": [], "table_ref": []}, {"heading": "#AMO(H).", "text": "Proof. We prove the statement by showing that, for two arbitrary permutations \u03c0(K) and \u03c0 (K), the edges in G \u03c0(K) and G \u03c0 (K) coincide, excluding the edges connecting the vertices in K.\nThe graph G \u03c0(K) is defined as the union of all AMOs, which can be represented by a topological ordering starting with \u03c0(K). Take such an AMO \u03b1 and, in a corresponding topological ordering \u03c4 , replace \u03c0(K) by \u03c0 (K) obtaining a new topological ordering \u03c4 . The orientation \u03b1 represented by \u03c4 is, by definition, acyclic and, moreover, moral. For the latter property, assume for a contradiction, that there is a vstructure (immorality) a \u2192 b \u2190 c. Because \u03b1 is moral and only edge directions internal in K have been changed in \u03b1 , it has to hold that either 1. two vertices of a, b, c are in K (w.l.o.g. assume these are a and b), but then we have b \u2192 c \u2208 K and not b \u2190 c, or 2. all three vertices are in K, but then a \u2192 b \u2190 c is no induced subgraph.\nHence, such a v-structure can not exist and \u03b1 is moral as well. The reverse direction follows equivalently. Therefore, the union of all AMOs, which can be represented by a topological ordering \u03c4 starting with \u03c0 (K), yields the exact same graph as for G \u03c0(K) , excluding the internal edges in K. Proof. By Lemma 14, Algorithm 3 correctly computes the UCCGs of the \u03c0(K)-orientation. As these UCCGs are identical for each orientation \u03c0(K) and Algorithm 1 proceeds just as Algorithm 3, with the only difference that the former makes no restriction on the order the vertices in K are visited (thus visiting them in arbitrary permutation \u03c0 (K)), the correctness follows.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Proofs of Section 4: Counting MA-Orientations with Minimal Separators and Maximal Cliques", "text": "Claim of Lemma 5. Let \u03b1 be an AMO of a chordal graph G and \u03c4 1 , \u03c4 2 be two topological orderings that represent \u03b1. Then \u03c4 1 and \u03c4 2 have a common prefix S \u2208 \u2206(G) \u222a \u03a0(G).\nProof. Assume by Corollary 2 that \u03c4 1 starts with the maximal clique K 1 and \u03c4 2 with the maximal clique K 2 . Since every AMO of a UCCG has a unique source, \u03c4 1 and \u03c4 2 start with the same vertex and, hence, K 1 \u2229 K 2 = S = \u2205.\nWe first show that \u03c4 1 and \u03c4 2 have to start with S. Assume for a contradiction that in \u03c4 1 there is a vertex u \u2208 S before a v \u2208 S. The edge between u and v is directed as u \u2192 v in \u03b1, but as v \u2208 K 2 and u \u2208 K 2 , the ordering \u03c4 2 implies u \u2190 v.\nIf K 1 = K 2 then S \u2208 \u03a0(G) and we are done. We prove that otherwise S is a minimal separator in G that separates P 1 = K 1 \\ S from P 2 = K 2 \\ S. Note that the minimality follows by definition. It remains to show that S indeed separates P 1 and P 2 . For a contradiction, let\nx 1 \u2208 P 1 \u2212 x 2 \u2212 \u2022 \u2022 \u2022 \u2212 x k\u22121 \u2212 x k \u2208 P 2 be a shortest P 1 -P 2 - path in G[V \\ S] with x i \u2208 K 1 \u222a K 2 for i \u2208 {2, . . . , k \u2212 1}.\nAccording to \u03c4 1 , we have the edge x 1 \u2192 x 2 in \u03b1. Since we consider a shortest path, x i\u22121 \u2212 x i \u2212 x i+1 is always an induced subgraph and, thus, an iterative application of the first Meek rule implies x k\u22121 \u2192 x k . However, \u03c4 2 would imply the edge\nx k\u22121 \u2190 x k in \u03b1. A contradiction.\nWe repeat the following definition from the main text: Definition 2. For a set S and a collection R of subsets of S, we define \u03c6(S, R) as the number of all permutations of S that do not have a set S \u2208 R as prefix. Claim of Proposition 2. Let G be a UCCG. Then:\n#AMO(G) = S\u2208\u2206(G)\u222a\u03a0(G) \u03c6(S) \u00d7 H \u2208 C G (S)", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "#AMO(H).", "text": "Proof. By the choice of S and the definition of C G (S), everything counted by the formula is a topological ordering representing an AMO. We argue that every AMO \u03b1 is counted exactly once. Let S \u2208 \u2206(G) \u222a \u03a0(G) be the smallest common prefix of all topological orderings in top(\u03b1)which is well-defined by Lemma 5. First observe that, by the minimality of S, \u03b1 is counted at the term for S: There is no other prefixS S of the topological orderings with S \u2208 \u2206(G) andS \u2208 \u03c6(S).\nOn the other hand, S is the only term in the sum at which we can count \u03b1, as for any largerS with S S that is a prefix of some \u03c4 \u2208 top(\u03b1), we have S is considered in \u03c6(S).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Proofs of Section 5:", "text": "The Clique-Picking Algorithm Claim of Lemma 6. Let S be a set and R = {X 1 , . . . , X } be a collection of subsets of S with X 1 X 2 \u2022 \u2022 \u2022 X . Then:\n\u03c6(S, R) = |S|! \u2212 i=1 |S \\ X i |! \u2022 \u03c6(X i , {X 1 , . . . , X i\u22121 }).\nProof. We prove the statement by induction over with the base case \u03c6(S, \u2205) = |S|!. Consider a set S and a collection R = {X 1 , . . . , X } of subsets of S. We can compute \u03c6(S, R) by taking \u03c6(S, {X 1 , . . . , X \u22121 }) (the number of permutations of S that do not start with X 1 , . . . , X \u22121 ) and by subtracting the number of permutations that start with X but none of the other X i , i. e.,\n\u03c6(S, R) = \u03c6(S, {X 1 , . . . , X \u22121 }) \u2212 |S \\ X |! \u2022 \u03c6(X , {X 1 , . . . , X \u22121 }).\nInserting the induction hypothesis, we obtain:\n\u03c6(S, R) = |S|! \u2212 \u22121 i=1 |S \\ X i |! \u2022 \u03c6(X i , {X 1 , . . . , X i\u22121 }) \u2212 |S \\ X |! \u2022 \u03c6(X , {X 1 , . . . , X \u22121 }) = |S|! \u2212 i=1 |S \\ X i |! \u2022 \u03c6(X i , {X 1 , . . . , X i\u22121 }).\nRecall, for the following proof, the definition of a forbidden prefix: Definition 3. Let G be a UCCG, T = (T, r, \u03b9) a rooted clique tree of G, v a node in T and r = x 1 , x 2 , . . . , x p = v the unique r-v-path. We define the set FP(v, T ) to contain all sets \u03b9(\nx i ) \u2229 \u03b9(x i+1 ) \u2286 \u03b9(v) for 1 \u2264 i < p.\nClaim of Lemma 7. We can order the elements of the set\nFP(v, T ) as X 1 X 2 \u2022 \u2022 \u2022 X .\nProof. The ordering of the sets is given by the natural order along the path from the root r to node v. The sets in\nFP(v, T ) satisfy \u03b9(x i ) \u2229 \u03b9(x i+1 ) \u2286 \u03b9(v)\n. By the definition of a clique tree, we have \u03b9(x i ) \u2229 \u03b9(x i+1 ) \u2286 \u03b9(y) for each y that lies on the x i -v-path in T . Hence, each such y can only add supersets of \u03b9(\nx i ) \u2229 \u03b9(x i+1 ) to FP(v, T ).\nRecall the definition of S-flowers and bouquets: Definition 4. An S-flower for a minimal separator S is a maximal set\nF \u2286 { K | K \u2208 \u03a0(G) \u2227 S \u2286 K } such that K\u2208F K is connected in G[V \\ S].\nThe bouquet B(S) of a minimal separator S is the set of all S-flowers. Claim of Lemma 8. An S-flower F is a connected subtree in a rooted clique tree (T, r, \u03b9).\nProof. Assume for a contradiction that F is not connected in T . Then there are cliques K 1 , K 2 \u2208 F that are connected by the unique path K 1 \u2212K \u2212 \u2022 \u2022 \u2022 \u2212 K 2 withK \u2208 F . Since \u03b9 \u22121 (S) is connected, we have S \u2286K. By the maximality of F , we have K 1 \u2229K = S. But then S separates K 1 \\S from K 2 \\ S, which contradicts the definition of S-flowers.\nClaim of Lemma 9. For any minimal separator S, the bouquet B(S) is a partition of \u03b9 \u22121 (S).\nProof. For each x \u2208 \u03b9 \u22121 (S), the maximal clique \u03b9(x) is in some S-flower by definition. However, no maximal clique can be in two S-flowers, as these flowers would then be in\nthe same connected component in G[V \\ S].\nClaim of Lemma 10. There is a unique least S-flower in B(S) with respect to \u227a T . Proof. Assume, there is no unique least S-flower. Then there are two minimal S-flowers which are incomparable. However, by Lemma 8 and 9, and the definition of the partial order, there has to be another S-flower closer to the root and, thus, lesser given the partial order. A contradiction.\nClaim of Lemma 11. Let \u03b1 be an AMO such that every topological ordering that represents \u03b1 has the minimal separator S as prefix. Then every F \u2208 B(S) contains a clique K such that there is a \u03c4 \u2208 top(\u03b1) starting with K.\nProof. Let \u03c4 be a topological ordering representing \u03b1 that starts with S. By Proposition 2, there is at least one clique K with S \u2286 K such that \u03c4 has the form \u03c4 = (S, K \\ S, V \\ K). Let F \u2208 B(S) be the flower containing K and F = F be another S-flower with some\nK \u2208 F . Observe that K \\ S is disconnected from K \\ S in G[V \\ S].\nTherefore, there is a topological ordering of the form (S, K \\ S, V \\ K ) that represents \u03b1 as well.\nClaim of Proposition 3. Let G be a UCCG and T = (T, r, \u03b9) be a rooted clique tree of G. Then:\n#AMO(G) = v \u2208 V T \u03c6(\u03b9(v), FP(v, T )) \u00d7 H \u2208 C G (\u03b9(v))", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "#AMO(H).", "text": "Proof. We have to show that every AMO \u03b1 is counted exactly once. Recall that top(\u03b1) = {\u03c4 1 , . . . , \u03c4 } is the set of topological orderings that represent \u03b1, and that the rooted clique tree (T, r, \u03b9) implies a partial order \u227a T on flowers, which in return defines partial order \u227a \u03b1 on the set of maximal cliques that are at the beginning of some \u03c4 \u2208 top(\u03b1).\nClaim 1. There is a unique least maximal clique K \u2208 \u03a0(G) with respect to \u227a \u03b1 .\nProof. Let top (\u03b1) \u2286 top(\u03b1) be an arbitrary subset of the topological orderings that represent \u03b1 and let \u00b5 be the number of different maximal cliques with which elements in top (\u03b1) start. We prove the claim by induction over \u00b5. In the base case, all elements in top (\u03b1) start with the same set S \u2208 \u03a0(G) and, of course, this is the unique least maximal clique. For \u00b5 > 1 we observe that, by Lemma 5, all \u03c4 \u2208 top (\u03b1) start with the same S \u2208 \u2206(G).\nConsider the bouquet B(S), which is partially ordered by \u227a T . Lemma 10 states that there is a unique least Sflower F \u2208 B(S) with respect to \u227a T , and by the definition of \u227a \u03b1 the maximal cliques occurring in F precede the others. Therefore, we reduce top (\u03b1) to the set top (\u03b1) of topological orderings that start with a maximal clique in F . This set is non-empty by Lemma 11 and contains, by the induction hypothesis, a unique least maximal clique.\nWe complete the proof by showing that the formula counts \u03b1 at the term for the unique least maximal clique K from the previous claim. To see this, we need to prove that (i) \u03b1 can be counted at the clique K (i. e., there is no set S \u2208 FP(\u03b9 \u22121 (K), T ) preventing \u03b1 from being counted), and (ii) that \u03b1 is not counted somewhere else (i. e., there is some S \u2208 FP(\u03b9 \u22121 (K ), T ) for all other K \u2208 \u03a0(G) that can be at the beginning of some \u03c4 \u2208 top(\u03b1)).\nClaim 2. Let \u03b1 be an AMO and K \u2208 \u03a0(G) be the least maximal clique (with respect to \u227a \u03b1 ) that is a prefix of some \u03c4 \u2208 top(\u03b1). Then there is no S \u2208 \u2206(G) with S \u2208 FP(\u03b9 \u22121 (K), T ) that is a prefix of \u03c4 .\nProof. Assume for a contradiction that there would be such a S \u2208 \u2206(G) and let F \u2208 B(S) be the S-flower containing K. Since S \u2208 FP(\u03b9 \u22121 (K), T ), there is another flower F \u2208 B(S) with F \u227a T F . Lemma 11 tells us that there is another clique K \u2208 F that is at the beginning of some \u03c4 \u2208 top(\u03b1). However, then we have K \u227a \u03b1 K -contradicting the minimality of K.\nClaim 3. Let \u03c4 1 , \u03c4 2 \u2208 top(\u03b1) be two topological orderings starting with\nK 1 , K 2 \u2208 \u03a0(G), respectively. If K 1 \u227a \u03b1 K 2 then K 1 \u2229 K 2 = S \u2208 FP(\u03b9 \u22121 (K 2 ), T ).\nProof. Since K 1 and K 2 correspond to \u03c4 1 , \u03c4 2 \u2208 top(\u03b1), we have K 1 \u2229 K 2 = S \u2208 \u03a0(G) \u222a \u2206(G) by Lemma 5 -in fact, S is a prefix of \u03c4 1 and \u03c4 2 . As we assume K 1 \u227a \u03b1 K 2 , we have K 1 = K 2 and, thus, S \u2208 \u2206(G). Let F 1 , F 2 \u2208 B(S) be the S-flowers containing K 1 and K 2 , respectively. The order K 1 \u227a \u03b1 K 2 implies F 1 \u227a T F 2 (item (iii) in the definition of \u227a \u03b1 ), meaning that F 1 contains some node of (T, r, \u03b9) that is on the unique path from F 2 to the root of T . But then, by the definition of S-flowers and Lemma 9, the first edge on this path that leads to a node in F 1 connects two nodes x, y with \u03b9(x) \u2229 \u03b9(y) = S. Hence, S \u2208 FP(\u03b9 \u22121 (K 2 ), T ).\nThis completes the proof of Proposition 3. The correctness of the algorithm follows from Proposition 3, as it traverses the clique tree with a BFS in order to compute the sets FP(v, T ) and evaluate this formula.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Proofs of Section 6: The Complexity of #AMO", "text": "Recall that for H \u2208 C G (\u03c0(K)), we defined P out (H) to be the set of preceding neighbors of the vertices of H at state X out when H was output during Algorithm 3. Now, we consider H \u2208 C G (K). We use the same notation to refer to the preceding neighbors in the analogously defined state in Algorithm 1. In fact, as P out (H) is independent of the permutation \u03c0(K) (Proposition 1), it will be the same set.\nWe denote the previously visited vertices at X out , which are not in P out (H), by W , i. e., W = V (X out ) \\ P out (H). Lemma 15. Let G be a chordal graph, K \u2208 \u03a0(G), and H \u2208 C G (K). Then, P out (H) separates V H from W = V (X out ) \\ P out (H) and is a minimal separator of G.\nProof. The set P out (H) is a proper subset of all previously visited vertices (V H is not part of the maximal clique K Algorithm 1 starts with). Since P out (H) contains all visited neighbors of V H , it separates V H from W . To see this, assume for sake of contradiction that there is a path from v \u2208 V H to w \u2208 W in G without a vertex in P out (H). Consider the shortest such path and let y be the first vertex with successor z preceding it in the LBFS ordering produced by\nAlgorithm 1: v\u2212\u2022 \u2022 \u2022\u2212x\u2212y\u2212z\u2212\u2022 \u2022 \u2022\u2212w. Then {x, z} \u2208 E G ,\nas the LBFS computes a PEO. Hence, the path is not the shortest path and, thus, y cannot exist. Since there can be no direct edge from v to w, the set P out is indeed a separator.\nWe prove that there is a vertex in W , which is a neighbor of all vertices in P out (H). Consider the vertex in P out (H), which is visited last (denoted by p). When vertex p is processed, it has to have a neighbor x \u2208 W , which was previously visited, else p would be part of H. This is because the preceding neighbors would be identical to the ones of the vertices in H (i. e., P out (H) \\ {p}), meaning by Lemma 12 that p would be in the same set in S. It would follow that either p and the vertices in H are appended to L when p is visited or were already appended to L previously. In both cases, p would be in V H , which is a contradiction.\nHence, such a vertex x has to exist. Moreover, x has to be connected to all vertices in P out (H) because of the PEO property (all preceding neighbors of a vertex form a clique).\nFrom the first part of the proof, we know that x and y \u2208 H are separated by P out (H). As both x and y are fully connected to P out (H), it follows that this set is also a minimal x \u2212 y separator.\nLemma 16. Let G be a chordal graph for which the number of AMOs is computed with the function count in Algorithm 2. Let H be any chordal graph for which count is called in the recursion (for H = G). Then V H = F \\ S for some S-flower F in G with S \u2208 \u2206(G).\nProof. Let S H be the union of all sets P out (G) forG on the recursive call stack from the input graph G to currently considered subgraph H. We define P out (G) = \u2205 for convenience.\nLet H = G, we show by induction that\n(i) S H is a min- imal separator in G, (ii) S H is fully connected to V H in G, and (iii) V H = F \\ S H for some S H -flower F .\nIn the base case, H \u2208 C G (K) for some clique K \u2208 \u03a0(G). By Lemma 15, S H is a minimal separator in G, which is by definition connected to all vertices in H. Hence, as H is connected, V H \u2286 F \\ S H holds for an S H -flower F . We show the equality by contradiction. Assume there is a vertex v \u2208 F \\ S but not in V H . Then v can neither be a vertex in W nor the neighbor of a vertex in W , as by the definition of flowers there has to be a path from v to V H in G[V G \\ S H ] -this would violate that V H is separated from W by S H (Lemma 15). Moreover, v is a neighbor of all vertices in S H . Hence, we have P out (v) = P out (H) = S H and v \u2208 V H . A contradiction.\nAssume count is called with a graph H \u2208 C G (K) for some graph G and K \u2208 \u03a0(G ). By induction hypothesis, we have that S G is a minimal separator in G and fully connected to V G . Moreover, V G = F \\ S G for some F -flower of S G . Now, P out (H) is by Lemma 15 a minimal separator in G for some vertices x and y. As x and y are connected to every vertex in S G , it follows that\nS H = S G \u222a P out (H) is a minimal x-y separator in G. Fur- thermore, S H is fully connected to V H in G and it can be easily seen that V H \u2286 F \\ S H . To show equality, observe that every vertex v in F \\ S H is in V G (if it is not sepa- rated from V H by S H in G, it is clearly not separated from V H by S G in G, hence v is in F \\ S G = V G )\n. Thus, the same argument as in the base case applies and the statement follows.\nClaim of Proposition 4. Let G be a UCCG. The number of distinct UCCGs explored by count is bounded by 2|\u03a0(G)| \u2212 1.\nProof. By Lemma 16, it remains to bound the number of flowers in G. Each flower is associated with a minimal separator S and there are at most |\u03a0(G)| \u2212 1 such separators, as they are associated with the edges of the clique tree (Blair and Peyton 1993). Let r (which is initially |\u03a0(G)| \u2212 1) be an upper bound for the number of remaining separators. Now consider separator S. If B(S) has k flowers, S can be found on at least k \u2212 1 edges of the clique tree, namely the edges between the flowers (by Proposition 9 the flowers partition the bouquet and by definition of flowers, the intersection of cliques from two S-flowers has to be a subset of S). Thus, we have at most r \u2212 (k \u2212 1) remaining separators. The maximum number of flowers is obtained when the quotient k/(k \u2212 1) is maximal. This is the case for k = 2. It follows that there are at most 2(|\u03a0(G)| \u2212 1) flowers.\nWhen bounding the number of explored UCCGs, we additionally take into account the input graph and obtain as bound For the computation of \u03c6(S, FP(v, T )), note that FP can be computed straightforwardly: Traverse the clique tree with a BFS, keep track of the nodes on the path from root r to any visited node, compute FP with its definition.\n2(|\u03a0(G)| \u2212 1) + 1 = 2|\u03a0(G)| \u2212 1.\nThe function \u03c6 can be evaluated with the formula from Lemma 6. There are O(|S|) subproblems and for each a sum over O(|S|) terms has to be computed (as l is always smaller than |S|). Because S is a clique, the effort is in O(|E|).\nWith Pe(K, FP) we denote the set of permutations of clique K without a prefix in FP and with #Pe(K, FP) its size (which coincides with \u03c6(K, FP)). Lemma 17. Algorithm 4 samples a permutation \u03c0 \u2208 Pe(K, FP) uniformly at random. Proof. We show this by induction over the size of the clique K. In the base case, we have a singleton K = {v} and \u03c0 = (v) will be chosen with probability 1 = 1/#Pe(K, FP).\nLet K be a clique with |K| > 1. Then the algorithm will choose a vertex v and, recursively, find a uniform permutation for the remaining cliqueK = K \\ v (regarding new forbidden prefixesFP). ThisFP contains only sets X i , . . . , X \u2208 FP that contain v, as the other forbidden prefixes cannot occur with v being picked first. Hence, FP = {X i \\ v, . . . , X \\ v} with i being the smallest index such that v \u2208 X i . For the probability Pr(v \u03c0 | K, FP) that the first vertex v is chosen according to a permutation \u03c0 (given some K and FP), it holds that:\nPr(v \u03c0 | K, FP) = #Pe(K \\ v \u03c0 ,FP) #Pe(K, FP) . input : Clique K, list FP = (X 1 , X 2 , . . . , X ) with X 1 X 2 \u2022 \u2022 \u2022 X . output: Permutation \u03c0. 1 function drawperm(K, FP, memo) 2 foreach v \u2208 K do 3 if v in X then 4 Let i be smallest such that v \u2208 X i . 5 wt(v) \u2190 \u03c6(K \\ v, {X i \\ v, . . . , X \\ v}) 6 else 7 wt(v) \u2190 \u03c6(K \\ v, \u2205) 8 end 9 end v \u2190 drawvertex(wt) if v in X then Let i be smallest such that v \u2208 X i . 13FP \u2190 {X i \\ v, . . . , X \\ v} else 15FP \u2190 \u2205 end if |K \\ v| = 0 then return (v) else return concat(v, drawperm(K \\ v,FP))\nend end Algorithm 4: The algorithm returns a uniform permutation of clique K under the constraint that the permutation does not start with a set in FP. This is due to the fact that drawvertex samples v proportional to the weights wt(v), which is the number of permutations without forbidden prefix inFP that start with v. Now, we want to compute Pr(\u03c0 | K, FP), i. e., the probability that the vertices in K with forbidden prefixes FP are permuted according to (some not forbidden) \u03c0. For this, we make use of the induction hypothesis:\nPr(\u03c0 | K \\ v \u03c0 ,FP) = 1 #Pe(K \\ v \u03c0 ,FP)\nwith\u03c0 being the remaining part of permutation \u03c0 after removing v \u03c0 . Note in particular thatFP is valid because\nX i \\ v \u03c0 \u2282 X i+1 \\ v \u03c0 \u2022 \u2022 \u2022 \u2282 X \\ v \u03c0\nand hence the induction hypothesis applies. We conclude: FP) .\nPr(\u03c0 | K, FP) = Pr(v \u03c0 | K, FP) \u2022 Pr(\u03c0 | K \\ v \u03c0 ,FP) = #Pe(K \\ v \u03c0 ,FP) #Pe(K, FP) \u2022 #Pe(K \\ v \u03c0 ,FP) = 1 #Pe(K,\nClaim of Theorem 4. There is an algorithm that, given a connected chordal graph G, uniformly samples AMOs of Proof. We first prove that Algorithm 5 samples uniformly and will take care of the run time afterwards. Denote with Pr(\u03c4 \u03b1 (G)) the probability that we draw a topological ordering \u03c4 of the vertices in G that represents \u03b1. We show the theorem by induction, similarly to the proof of Theorem 2. For the base case of a single clique K, the algorithm returns a uniformly sampled AMO, as FP is empty and drawperm returns a uniformly sampled permutation. It follows that for each AMO \u03b1:\nPr(\u03c4 \u03b1 (G)) = 1/|K|! = 1/#AMO(G). For an arbitrary graph G, let K \u03b1 be the unique clique at which \u03b1 is considered (such a clique exists by the proof of Proposition 3) with forbidden prefixes FP, and \u03c0 \u03b1 the corresponding permutation of K \u03b1 . The term Pr(K \u03b1 | FP) describes the probability that K \u03b1 is drawn:\nPr(\u03c4 \u03b1 (G)) = Pr(K \u03b1 | FP)Pr(\u03c0 \u03b1 | K \u03b1 , FP) H\u2208C G (K\u03b1) Pr(\u03c4 \u03b1[H] (H)) = #Pe(K \u03b1 , FP) H\u2208C G (K\u03b1) #AMO(H) #AMO(G) \u2022 #Pe(K \u03b1 , FP) H\u2208C G (K\u03b1) #AMO(H) = 1 #AMO(G)\n.\nFor the second step, we make use of the following facts. By induction hypothesis we have #AMO(G) as K \u03b1 is picked with probability proportional to the number of AMOs that are considered at clique K \u03b1 (function drawclique in Algorithm 5); and by Lemma 17: FP) .\nPr(\u03c0 \u03b1 | K \u03b1 , FP) = 1 #Pe(K \u03b1 ,\nWe discuss the run time of Algorithm 5. Assuming a sampling generator has been initialized during precount, the function drawclique can be performed in O(1) with the Alias Method (Vose 1991). Assuming, furthermore, pointers to the subproblems H \u2208 C G (K), there is no additional effort in obtaining those. Since only O(|V |) subproblems are considered, these steps take O(|V |) time in total.\nHence, drawperm is the most expensive step and it remains to bound its cost. For each place in the permutation \u03c0, which is build, the algorithm goes once through all vertices v and assigns the values wt. We assume that the values for \u03c6 are precomputed. This is feasible as \u03c6 only depends on two parameters: the size of the current K and the index i of the remaining forbidden prefixes X i , . . . , X . Assuming such precomputations, drawperm can be implemented in time O(|K| 2 ) for a clique K. In total, the run time is bounded by O(|V | + |E|) (each vertex is placed once in a permutation \u03c0 and the cost are bounded by |K|, which is linear in the number of neighbors of this vertex).\nFor the precomputation of \u03c6, it is possible to calculate all \u03c6-values in time O(|V | \u2022 |E|) by dynamic programming (similarly as in the proof of Theorem 3). To see this, note that \u03c6 can also be expressed as:\n\u03c6(S, R) = |S|!\u2212 i=1 |X i |!\u2022\u03c6(S\\X i , {X i+1 \\X i , . . . , X \\X i }).\nHence, we have, for each subproblem and clique, an effort of O(|V | \u2022 |E|). Since \u03c6 is the costliest precomputation, we conclude that preprocessing takes in total:\nO(|\u03a0(G)| 2 \u2022 |V | \u2022 |E|).\nWe note that, while preprocessing requires an additional factor |V | compared to Clique-Picking in theory, we observed that the sets FP are usually so small that its influence is negligible for most practical cases. Claim of Theorem 5. The problems #AMO and uniform sampling from a Markov equivalence class are in P.\nProof. We begin by proving the statement for #AMO. It is well-known that this problem reduces to counting AMOs of UCCGs (He, Jia, and Yu 2015). This is the problem the Clique-Picking algorithm solves. By Theorem 3, it performs polynomially many arithmetic operations. Since #AMO(G) is bounded above by n! (let n be |V |), all operations run in polynomial time because the involved numbers can be represented by polynomially many bits:\nn! \u2264 n n = (2 log n ) n = 2 n\u2022log n .\nWe analyze the complexity of the uniform sampling problem. By Theorem 4, sampling is possible in linear time assuming a modified version of Clique-Picking was performed as preprocessing step. This preprocessing can be performed in polynomial time. Moreover, the bit complexity of sampling is still polynomial (by a similar argument as above).\nPartially directed acyclic graphs (PDAGs) are, as the name suggests, partially directed graphs without directed cycles. Maximally oriented PDAGs (MPDAGs) are PDAGs such that none of the four Meek rules (Meek 1995) can be applied. Both graph types are usually used in graphical modeling to represent background knowledge. Claim of Theorem 6. The problem of counting the number of AMOs is #P-complete for PDAGs and MPDAGs.\nProof. Note that, clearly, both problems are in #P.\nWe reduce the #P-hard problem of counting the number of topological orderings of a DAG (Brightwell and Winkler 1991) to counting the number of AMOs of a PDAG. Since we can exhaustively apply all Meek rules in polynomial time (Meek 1995) without changing the number of AMOs, this implies that the problem of counting AMOs is #P-complete for PDAGs and MPDAGs.\nGiven a DAG G = (V, E), we construct the PDAG G as follows: G has the same set of vertices V as G and we add all edges from G to G . We insert an undirected edge for all pairs of remaining nonadjacent vertices in G .\nEach AMO of G can be represented by exactly one linear ordering of V (because G is complete) and each topological ordering of G is a linear ordering as well. We prove in two directions that a linear ordering of V is an AMO of G if, and only if, it is a topological ordering of G.\n\u21d2) If a linear ordering \u03c4 represents an AMO of G , the edges in G are correctly reproduced. Hence, it is a topological ordering of G. \u21d0) If a linear ordering \u03c4 is a topological ordering of G, the orientation of G according to it is, by definition, acyclic and reproduces the directed edges in G . As G is complete, there can be no v-structures. Hence, \u03c4 represents an AMO of G .\nNotably, the reason Clique-Picking cannot be used to solve these counting problems can be directly connected to the hardness proof. Intuitively, these problems can be reduced to the setting that, when counting AMOs in UCCGs, some edge orientations in the chordal component are predetermined by background knowledge. Hence, in the Clique-Picking algorithm, when counting the number of permutations for a clique K, we have to count only those consistent with the background knowledge. But this is equivalent to the problem of counting the number of topological orderings.", "publication_ref": ["b2", "b33", "b13", "b19", "b3", "b19"], "figure_ref": [], "table_ref": []}, {"heading": "Part II", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Experimental Evaluation of the Clique-Picking Algorithm", "text": "We evaluated the practical performance of the Clique-Picking algorithm in a series of experiments. For this, we compared Clique-Picking, denoted (cp) in the following, with the state-of-the-art root picking algorithm AnonMAO (am) (Ganian, Hamm, and Talvitie 2020), a solver known as TreeMAO that performs dynamic programming on a tree decomposition (tw) (Talvitie and Koivisto 2019), and a recently proposed algorithm, which combines concepts from intervention design with dynamic programming, called LazyIter (li) (AhmadiTeshnizi, Salehkaleybar, and Kiyavash 2020). With these three competitors, we cover all currently known ways to approach the problem of counting Markov equivalent DAGs.\nWe omitted the classic root-picking algorithm (He, Jia, and Yu 2015) as well as MemoMAO (Talvitie and Koivisto 2019), as AnonMAO is an improved version of these algorithms, which has been shown to clearly outperform them in previous experiments (Ganian, Hamm, and Talvitie 2020).\nAll our experiments were performed on a desktop computer equipped with 14 GB of RAM and an Intel Core i7 X980 with 6 cores of 3.33 Ghz each. The system runs Ubuntu 20.04 LTS, 64bit. The Clique-Picking algorithm was compiled with gcc 9.3.0 using g++ -std=c++11 -O3 -march=native -lgmp -lgmpxx. The dynamic program and the solver using tree decomposition were compiled with the same version of gcc and the makefiles provided by the authors. For the Python solver LazyIter we used PyPy 7.3.1 (compiled with gcc 9.3.0 for Python 3.6.9) in order to obtain a compiled and comparable version.", "publication_ref": ["b8", "b29", "b13", "b8"], "figure_ref": [], "table_ref": []}, {"heading": "Generation of Random Chordal Graphs", "text": "As input for the solvers, we use various classes of random chordal graphs, which we explain in detail in the following. The results of our experiments can be found in Fig. 4 and Fig. 5. Beside the time used by the solvers, we also present the number of maximal cliques as well as the density |E|/ |V | 2 that the graphs of the various random graph models have. In Fig. 3, the reader finds a cumulative plot over all experiments performed.", "publication_ref": [], "figure_ref": ["fig_14"], "table_ref": []}, {"heading": "Random Subtree Intersections", "text": "The first family of random chordal graphs that we study is due to Seker et al. (2017). It is based on the characterization of chordal graphs as intersection graph of subtrees (take a tree, some subtrees of this tree, and build the intersection graph of these subtrees -the result is a chordal graph). The family is generated by an algorithm that obtains two parameters as input: n the number of vertices and k, a density parameter. In the first phase, a random tree on n vertices is generated with the algorithm of Rodionov and Choo (2004). Afterward, n subtrees are sampled randomly with the following procedure: Initialize the subtree to some random vertex v, then grow it by adding a random neighbor of the tree until the subtree reaches a size s randomly drawn from {1, . . . , 2k \u22121}. Finally, we take the intersection graph of these n subtrees, which is a chordal graph on n vertices.\nWe performed three experiments on this graph class. In each experiment we choose n = 2 i for i \u2208 {4, . . . , 12} and k as either k = log n (Fig. 4.A), k = 2 log n (Fig. 4.B), or k = \u221a n (Fig. 4.C). In each case, we generated ten random graphs for every value of n and took the mean time used by the algorithms. As mentioned above, we also display the number of maximal cliques in the graph and the mean density of the graphs, i. e. |E|/ |V | 2 . Our solver (cp) clearly performs best, solving even the largest instances with 4096 vertices in a short amount of time. This also holds for denser graphs, e. g. with k = \u221a n. We can observe that the run time of (cp) only increases slowly for higher densities. The solver (am) can be clearly distinguished as second best, however, for larger and even moderately dense graphs the method timeouts, i. e., graphs with more than 256 vertices are infeasible for k = 2 log n and k = \u221a n. The remaining methods (tw) and (li) perform comparably poorly and are only able to solve graphs with less than 100 vertices. Interestingly, the run time of both algorithms has an extremely high variance. For the case of (tw), this might be explained by the fact that the run time depends superexponentially on the size of the largest clique (denoted c) including a factor c! \u2022 2 c \u2022 c 2 .", "publication_ref": ["b26", "b23"], "figure_ref": ["fig_14", "fig_14", "fig_14"], "table_ref": []}, {"heading": "Random Interval Graphs", "text": "The next class of random chordal graphs that we consider are random interval graphs. An interval graph is the intersection graph of a set of intervals. It is well-known that interval graphs are a subclass of chordal graphs and, thus, they are well-suited as input for our experiments. The solver (am) was proven to run in polynomial time on interval graphs (Ganian, Hamm, and Talvitie 2020), which makes for an interesting comparison.\nWe generate random interval graphs with the algorithm by Scheinerman (1988), which simply draws 2n random variables in [0, 1], pairs these as intervals, and build the intersection graph of these intervals.\nAs in the previous section, we generated for every value i \u2208 {4, . . . , 12} ten random interval graphs on 2 i vertices. We ran all algorithms on these instances and built the mean of their runtime for each i. The results can be found in Fig. 4.D.\nThe instances of this test set are the densest ones that we considered during our experiments, with about two thirds of the possible edges being present in the graph. We observe that (tw) and (li) are only able to solve the smallest instances. The (am) algorithm manages to solve instances up to 128 vertices, but timeouts for larger ones. While, as mentioned above, the run time of (am) is bounded by a polynomial for this class of graphs, the degree of the polynomial appears to be too large for practical use. In contrast, the (cp) algorithm manages to solve all instances, though it has to be noted that it takes significant time (around 10 minutes) for the largest ones with 4096 vertices. An explanation for this is the higher number of maximal cliques compared to the first set of experiments. Recall that the number of recursively explored subgraphs is bounded by 2 \u2022 |\u03a0(G)| \u2212 1. Since the graphs are dense, these subgraphs are also relatively large.", "publication_ref": ["b8", "b25"], "figure_ref": ["fig_14"], "table_ref": []}, {"heading": "Random Perfect Elimination Orderings", "text": "Another characterization of chordal graphs is based on perfect elimination orderings, which we have discussed in Section 3. Recall that a perfect elimination ordering of a graph G = (V, E) is a permutation \u03c0 of its vertices such that for each v \u2208 V the set { w | \u03c0(v) < \u03c0(w) } is a clique. It is well-known that a graph is chordal if, and only if, it has a perfect elimination ordering (Blair and Peyton 1993). This leads to a simple randomized algorithm to generate chordal graphs: Start with a graph of n isolated vertices v 1 , . . . , v n ; iterate over the vertices in this order and for every\nv i initial- ize a set S = { v j | v j \u2208 N (v i ) \u2227 j > i }.\nRandomly choose a size s and, while |S| < s, add some further vertices v j with j > i to S; finally make S a clique and adjacent to v i . This algorithm (as well as other refined versions of it) tends to produce quite dense graphs (Seker et al. 2017). Therefore, we use constant size bounds for the set S rather than a function that grows with n. More precisely, we run the algorithm with a parameter k and let it pick for every vertex a size bound s \u2208 {k/2, . . . , 2k} at random. Note that this does not imply that the degree is bounded by 2k.\nWe performed the same experiments as in the previous sections on this graph class for k = 2 and k = 4. The results can be found in Fig. 4.E and Fig. 4.F, respectively.\nThe instances generated with this method are quite interesting, because they have significantly different properties than, for example, the ones generated with the subtree intersection method. In particular, there is a large number of maximal cliques. Hence, these test sets contain some of the hardest instances for (cp). Still, the algorithm outperforms the other methods by a large margin. Only for the largest graphs with 4096 vertices and density parameter k = 4, there are some instances that (cp) could not solve within 30 minutes.\nNotably, the (am) algorithm, which again takes the second place, performs worse on these instances compared to the ones generated with the subtree intersection method, too. For instance in Fig. 4.E the graphs are sparser than in Fig. 4.A, but (am) still takes more time; the same holds for Fig. 4.F and Fig. 4.B. This makes sense, as the number of subproblems of (am) was shown to depend on the size of the clique tree as well (Ganian, Hamm, and Talvitie 2020). The other two methods are less affected by the increase of maximal cliques and perform similar to the other experiments.", "publication_ref": ["b2", "b26", "b8"], "figure_ref": ["fig_14", "fig_14", "fig_14", "fig_14", "fig_14", "fig_14"], "table_ref": []}, {"heading": "Random Tree Thickening", "text": "In this section, we mimic the experiments performed by He, Jia, and Yu (2015), Talvitie and Koivisto (2019), and Ganian, Hamm, and Talvitie (2020). He, Jia, and Yu (2015) proposed the following way of generating random chordal graphs with n vertices and kn edges, which we call random tree thickening. We start with a random tree on n vertices, which is generated by the Rodionov-Choo-Algorithm (Rodionov and Choo 2004). Then, as long as the graph in construction has less than kn edges, we repeatedly pick two non-adjacent vertices at random and connect them by an edge if the resulting graph is still chordal.\nThe advantage of this way of generating random chordal graphs is that we have fine control over the density of the generated graphs. However, the sketched algorithm is by far the slowest random chordal graph generator and becomes infeasible for larger values of n. We have therefore restricted the experiments in this sections to graphs with n = 2 i vertices for i \u2208 {4, . . . , 10}. As density parameter k we used k = 3 (Fig. 5.A), k = log n (Fig. 5.B), and k = \u221a n (Fig. 5.C).\nAs the instances generated with this method are comparatively small and sparse, they are easy instances for (cp), which solves them all in seconds. For the other methods, the same insights as before hold.", "publication_ref": ["b13", "b29", "b8", "b13", "b23"], "figure_ref": [], "table_ref": []}, {"heading": "Summary of the Experiments", "text": "The results of our experiments reveal that the Clique-Picking approach is superior to all state-of-the-art strategies for counting MAOs of chordal graphs by orders of magnitudes. In particular, the Clique-Picking algorithm even outperforms other solvers on instances on which they should naturally perform quite strong: It is not only faster on dense, but also sparse instances, and while (am) runs in polynomial time on interval graphs, it is still much slower than Clique-Picking on these graphs.\nWe summarize our experiments in Fig. 3, which contains a cumulative distribution function plot over all experiments that we performed. Overall. we produced 750 random chordal graphs for the experiments in this section.\nAs seen in the previous sections, the solvers (tw) and (li) take the last places in our competition. It has to be noted that (li) even produced incorrect answers for a few instances (we double-checked these by brute-force enumeration). The (am) solver takes second place solving 72% of the instances, struggling in particular with larger and denser graphs.\nFrom the 750 graphs, there were only six which the Clique-Picking algorithm could not solve in 30 minutes (these were dense graphs generated by the random elimination ordering algorithm with k = 4, which have a relatively large number of maximal cliques). Moreover, (cp) was also extremely fast in solving most of the instances, almost 700 of them were solved in one minute or less (most of them in a few seconds), while the second-best method (am) solved significantly less instances even in the whole 30 minutes. This shows that the Clique-Picking algorithm is not only of theoretical value, but currently the by far most practical algorithm for counting Markov equivalent DAGs.  The same plots as in Fig. 4 for the random graphs from Section 9.4.", "publication_ref": [], "figure_ref": ["fig_14"], "table_ref": []}, {"heading": "Acknowledgements", "text": "This work was supported by the Deutsche Forschungsgemeinschaft (DFG) grant LI634/4-2.\nThe authors thank Paula Arnold for her help in setting up the experiments.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "LazyIter: A Fast Algorithm for Counting Markov Equivalent DAGs and Designing Experiments", "journal": "", "year": "2020", "authors": "A Ahmaditeshnizi; S Salehkaleybar; N Kiyavash"}, {"ref_id": "b1", "title": "A Characterization of Markov Equivalence Classes for Acyclic Digraphs", "journal": "The Annals of Statistics", "year": "1997", "authors": "S A Andersson; D Madigan; M D Perlman"}, {"ref_id": "b2", "title": "An Introduction to Chordal Graphs and Clique Trees", "journal": "Springer", "year": "1993", "authors": "J R Blair; B Peyton"}, {"ref_id": "b3", "title": "Counting Linear Extensions is #P-Complete", "journal": "", "year": "1991", "authors": "G R Brightwell; P Winkler"}, {"ref_id": "b4", "title": "Learning Equivalence Classes of Bayesian-Network Structures", "journal": "Journal of Machine Learning Research", "year": "2002", "authors": "D M Chickering"}, {"ref_id": "b5", "title": "Optimal Structure Identification With Greedy Search", "journal": "Journal of Machine Learning Research", "year": "2002", "authors": "D M Chickering"}, {"ref_id": "b6", "title": "On Rigid Circuit Graphs", "journal": "Abhandlungen aus dem Mathematischen Seminar der Universit\u00e4t Hamburg", "year": "1961", "authors": "G A Dirac"}, {"ref_id": "b7", "title": "Incidence Matrices and Interval Graphs", "journal": "Pacific Journal of Mathematics", "year": "1965", "authors": "D Fulkerson; O Gross"}, {"ref_id": "b8", "title": "An Efficient Algorithm for Counting Markov Equivalent DAGs", "journal": "", "year": "2020", "authors": "R Ganian; T Hamm; T Talvitie"}, {"ref_id": "b9", "title": "Budgeted Experiment Design for Causal Structure Learning", "journal": "", "year": "2018", "authors": "A Ghassami; S Salehkaleybar; N Kiyavash; E Bareinboim"}, {"ref_id": "b10", "title": "Counting and Sampling from Markov Equivalent DAGs Using Clique Trees", "journal": "", "year": "2019", "authors": "A Ghassami; S Salehkaleybar; N Kiyavash; K Zhang"}, {"ref_id": "b11", "title": "The Size Distribution for Markov Equivalence Classes of Acyclic Digraph Models", "journal": "Artificial Intelligence", "year": "2002", "authors": "S B Gillispie; M D Perlman"}, {"ref_id": "b12", "title": "Characterization and Greedy Learning of Interventional Markov Equivalence Classes of Directed Acyclic Graphs", "journal": "Journal of Machine Learning Research", "year": "2012", "authors": "A Hauser; P B\u00fchlmann"}, {"ref_id": "b13", "title": "Counting and Exploring Sizes of Markov Equivalence Classes of Directed Acyclic Graphs", "journal": "Journal of Machine Learning Research", "year": "2015", "authors": "Y He; J Jia; B Yu"}, {"ref_id": "b14", "title": "Active Learning of Causal Networks with Intervention Experiments and Optimal Designs", "journal": "Journal of Machine Learning Research", "year": "2008-11", "authors": "Y.-B He; Z Geng"}, {"ref_id": "b15", "title": "Learning Bayesian Networks: The Combination of Knowledge and Statistical Data", "journal": "Machine Learning", "year": "1995", "authors": "D Heckerman; D Geiger; D M Chickering"}, {"ref_id": "b16", "title": "Probabilistic Graphical Models -Principles and Techniques", "journal": "MIT Press", "year": "2009", "authors": "D Koller; N Friedman"}, {"ref_id": "b17", "title": "Estimating High-Dimensional Intervention Effects from Observational Data", "journal": "The Annals of Statistics", "year": "2009", "authors": "M H Maathuis; M Kalisch; P B\u00fchlmann"}, {"ref_id": "b18", "title": "Bayesian Model Averaging and Model Selection for Markov Equivalence Classes of Acyclic Digraphs", "journal": "Communications in Statistics-Theory and Methods", "year": "1996", "authors": "D Madigan; S A Andersson; M D Perlman; C T Volinsky"}, {"ref_id": "b19", "title": "Causal Inference and Causal Explanation with Background Knowledge", "journal": "", "year": "1995", "authors": "C Meek"}, {"ref_id": "b20", "title": "Graphical Models: Selecting Causal and Statistical Models", "journal": "", "year": "1997", "authors": "C Meek"}, {"ref_id": "b21", "title": "Causality", "journal": "Cambridge University Press", "year": "2009", "authors": "J Pearl"}, {"ref_id": "b22", "title": "Complete Graphical Characterization and Construction of Adjustment Sets in Markov Equivalence Classes of Ancestral Graphs", "journal": "Journal of Machine Learning Research", "year": "2017", "authors": "E Perkovic; J Textor; M Kalisch; M H Maathuis"}, {"ref_id": "b23", "title": "On Generating Random Network Structures: Connected Graphs", "journal": "", "year": "2004", "authors": "A S Rodionov; H Choo"}, {"ref_id": "b24", "title": "Algorithmic Aspects of Vertex Elimination on Graphs", "journal": "SIAM Journal on Computing", "year": "1976", "authors": "D J Rose; R E Tarjan; G S Lueker"}, {"ref_id": "b25", "title": "", "journal": "Random Interval Graphs. Combinatorica", "year": "1988", "authors": "E R Scheinerman"}, {"ref_id": "b26", "title": "Linear-Time Generation of Random Chordal Graphs", "journal": "", "year": "2017", "authors": "O Seker; P Heggernes; T Ekim; Z C Taskin"}, {"ref_id": "b27", "title": "Learning Causal Graphs with Small Interventions", "journal": "", "year": "2015", "authors": "K Shanmugam; M Kocaoglu; A G Dimakis; S Vishwanath"}, {"ref_id": "b28", "title": "Causation, Prediction, and Search, Second Edition", "journal": "MIT Press", "year": "2000", "authors": "P Spirtes; C Glymour; R Scheines"}, {"ref_id": "b29", "title": "Counting and Sampling Markov Equivalent Directed Acyclic Graphs", "journal": "", "year": "2019", "authors": "T Talvitie; M Koivisto"}, {"ref_id": "b30", "title": "Separators and Adjustment Sets in Markov Equivalent DAGs", "journal": "", "year": "2016", "authors": "B Van Der Zander; M Li\u015bkiewicz"}, {"ref_id": "b31", "title": "Equivalence and Synthesis of Causal Models", "journal": "", "year": "1990", "authors": "T Verma; J Pearl"}, {"ref_id": "b32", "title": "An Algorithm for Deciding if a Set of Observed Independencies has a Causal Explanation", "journal": "", "year": "1992", "authors": "T Verma; J Pearl"}, {"ref_id": "b33", "title": "A Linear Algorithm For Generating Random Numbers With a Given Distribution", "journal": "IEEE Transactions on Software Engineering", "year": "1991", "authors": "M D Vose"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 1 :1Figure1: For a UCCG G in (a), the figure shows G (4) in (b), G (4,3,2,1) in (c), and G {1,2,3,4} in (d). The undirected components in G (4) and G (4,3,2,1) are indicated by the colored regions and the vertices put at the beginning of the topological ordering by a rectangle (all edges from the rectangle point outwards). Edges inside the rectangle in (c) are dashed, as they have no influence on the further edge directions outside the rectangle.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "The Clique-Picking algorithm computes the number of acyclic moral orientations of a UCCG G.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "We analyze the run time of the Clique-Picking algorithm by bounding the number of connected chordal subgraphs that we encounter. The following proposition shows that this number can be bounded by O(|\u03a0(G)|). Recall that we have |\u03a0(G)| \u2264 |V | in chordal graphs and, thus, we only have to handle a linear number of recursive calls. Proposition 4. Let G be a UCCG. The number of distinct UCCGs explored by count is bounded by 2|\u03a0(G)| \u2212 1.", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "Figure 2 :2Figure2: Experimental results for the solvers Clique-Picking (cp), AnonMAO (am), TreeMAO (tw), and LazyIter (li) on random chordal graphs with n = 16, 32, . . . , 4096 vertices. For the left plot, we used graphs generated with the subtree intersection method and density parameter k = log n; the right plot contains the results for random interval graphs. At the bottom, we present the number of maximal cliques as well as the graph density |E|/ |V | 2 .", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_5", "figure_caption": "Theorem 4. There is an algorithm that, given a connected chordal graph G, uniformly samples AMOs of G in time O(|V | + |E|) after an initial O(\u03a0(G) 2 \u2022 |V | \u2022 |E|) setup.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_6", "figure_caption": "v to the end of \u03c4 . 11 if v is neither in a set in L nor in K then 12 L \u2190 L \u222a {X} 13 Output the undirected components of G[X]. S by (S 1 , . . . , S k ).", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_7", "figure_caption": "18Remove all empty sets from S.19 endAlgorithm 3: The algorithm computes C G (\u03c0(K)).Lemma 14. Algorithm 3 computes the undirected connected components of G \u03c0(K) in time O(|V | + |E|). Moreover, all remaining directed edges in G \u03c0(K) are oriented as given by LBFS ordering \u03c4 .", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_8", "figure_caption": "Thus, C G (\u03c0(K)) = C G (\u03c0 (K)) and, by definition, C G (\u03c0(K)) = C G (K). The recursive formula is immediately implied by this fact and Lemma 4. Claim of Theorem 1. For a chordal graph G and a clique K, Algorithm 1 computes C G (K) in time O(|V | + |E|).", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_9", "figure_caption": "Claim of Theorem 2. For an input UCCG G, Algorithm 2 returns the number of AMOs of G. Proof. Observe that recursive calls are performed in line 13 if C G (\u03b9(v)) = \u2205. The only graphs with C G (S) = \u2205 for all S \u2208 \u03a0(G) are the complete graphs, i. e., the graphs with |\u03a0(G)| = 1. We have |\u03a0(H)| < |\u03a0(G)| for all graphs G and H = G[V \\ S] with S \u2208 \u03a0(G). Hence, we may assume by induction over |\u03a0(G)| that the subproblems are handled correctly -the base case being given by complete graphs.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_10", "figure_caption": "Claim of Theorem 3. The Clique-Picking algorithm runs in time O |\u03a0(G)| 2 \u2022 (|V | + |E|) . Proof. By Proposition 4, count explores O(|\u03a0(G)|) distinct UCCGs. For each of them, the clique tree is computed in time O(|V | + |E|). Afterwards, for each maximal clique, the subproblems are computed by Algorithm 1 in time O(|V | + |E|) by Theorem 1.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_11", "figure_caption": "G in time O(|V | + |E|) after an initial O(\u03a0(G) 2 \u2022 |V | \u2022 |E|) setup. input : A UCCG G. output: AMO of G. 1 function sample(G, memo) 2 (K, FP, C G (K)) \u2190 drawclique(memo[G]) 3 \u03c4 \u2190 drawperm(K, FP, memo) 4 foreach H \u2208 C G (K) do 5 \u03c4 \u2190 concat(\u03c4, sample(H, memo)) \u2190 precount(G) 11 \u03c4 \u2190 sample(G, memo) 12 return AMO of G given by \u03c4Algorithm 5: The algorithm uniformly samples an AMO from a UCCG G. A modified version of Clique-Picking (precount) has to be executed on G in advance.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_12", "figure_caption": "\u03b1 | FP) = #Pe(K \u03b1 , FP) \u2022 H\u2208C G (K\u03b1) #AMO(H)", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_13", "figure_caption": "Figure 3: A cumulative distribution function plot that shows the performance of the four solvers Clique-Picking (cp), AnonMAO (am), TreeMAO (tw), and LazyIter (li) on all 750 random chordal graphs that where used for experiments in this section. The x-axis shows the time in minutes, and the y-axis the number of instances the solver solved (having x minutes per instance).", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_14", "figure_caption": "Figure 4 :4Figure4: Comparison of the solvers Clique-Picking (cp), AnonMAO (am), TreeMAO (tw), and LazyIter (li). The plots show the mean time (dot) as well as the minimum and maximum time (thin lines) each solver needed over ten random graphs. A solver that requires more than 30 minutes or runs out of memory obtains a timeout, which contributes 35 minutes to the mean time. At the bottom of each plot we present the average number of maximal cliques as well as the average density.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_15", "figure_caption": "Figure5: The same plots as in Fig.4for the random graphs from Section 9.4.", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "C \u2286 V by G[C]. The graph union G \u222a H includes edges present in G or in H 1 .", "formula_coordinates": [2.0, 54.0, 533.8, 238.49, 19.91]}, {"formula_id": "formula_1", "formula_text": "#AMO(G) = H is UCCG in G #AMO(H).", "formula_coordinates": [2.0, 361.12, 473.04, 155.27, 20.22]}, {"formula_id": "formula_2", "formula_text": "input : A UCCG G = (V, E) and a clique K \u2286 V . output: C G (K). 1 S \u2190 sequence of sets initialized with (K, V \\ K) 2 \u03c4 \u2190 empty list, L \u2190 \u2205 3 while S is non-empty do 4 X \u2190 first non-empty set of S 5 v \u2190 arbitrary vertex from X 6 Add vertex v to the end of \u03c4 . 7 if v is neither in a set in L nor in K then 8 L \u2190 L \u222a {X} 9 Output the undirected components of G[X]. end X \u2190 X \\ {v} Denote the current S by (S 1 , . . . , S k ). Replace each S i by S i \u2229 N (v), S i \\ N (v).", "formula_coordinates": [3.0, 55.49, 394.56, 216.04, 164.14]}, {"formula_id": "formula_3", "formula_text": "G K = \u03c0 G \u03c0(K) . 3. Denote by C G (\u03c0(K)) the undirected connected compo- nents of G \u03c0(K) [V \\ K] and let C G (K) denote the undi- rected connected components of G K [V \\ K].", "formula_coordinates": [3.0, 319.5, 465.26, 238.5, 46.37]}, {"formula_id": "formula_4", "formula_text": "#AMO(G \u03c0(K) ) = H\u2208C G (\u03c0(K)) #AMO(H).", "formula_coordinates": [4.0, 87.5, 315.72, 171.5, 23.21]}, {"formula_id": "formula_5", "formula_text": "\u03c0 over K #AMO(G \u03c0(K) ) = |K|! \u00d7 H \u2208 C G (K) #AMO(H).", "formula_coordinates": [4.0, 75.08, 499.31, 196.35, 23.21]}, {"formula_id": "formula_6", "formula_text": "K 1 \u2229 K 2 = S such that K 1 \\ S is separated from K 2 \\ S in G[V \\ S].", "formula_coordinates": [4.0, 319.5, 514.29, 238.5, 20.61]}, {"formula_id": "formula_7", "formula_text": "\u03c6(S) = \u03c6 S, { S | S \u2208 \u2206(G) \u2227 S S } . Proposition 2. Let G be a UCCG. Then: #AMO(G) = S\u2208\u2206(G)\u222a\u03a0(G) \u03c6(S) \u00d7 H \u2208 C G (S)", "formula_coordinates": [5.0, 54.0, 312.28, 221.53, 50.32]}, {"formula_id": "formula_8", "formula_text": "G = 1 2 3 4 5 6 \u2206(G) = {2, 3}, {2, 3, 5} \u03a0(G) = {1, 2, 3}, {2, 3, 4, 5}, {2, 3, 5, 6}", "formula_coordinates": [5.0, 57.84, 448.57, 226.23, 43.56]}, {"formula_id": "formula_9", "formula_text": "S \u2208 \u2206(G) \u222a \u03a0(G) \u03c6(S) H\u2208C G (S) #AMO(H) {2, 3} 2 3 {2, 3, 5} 4 1 {1, 2, 3} 4 3 {2, 3, 4, 5} 16 1 {2, 3, 5, 6} 16 1 Using Proposition 2 we can compute #AMO(G) as follows: #AMO(G) = 2 \u2022 3 + 4 \u2022 1 + 4 \u2022 3 + 16 \u2022 1 + 16 \u2022 1 = 54.", "formula_coordinates": [5.0, 54.0, 557.75, 238.42, 100.04]}, {"formula_id": "formula_10", "formula_text": "\u03c6(S, R) = |S|! \u2212 i=1 |S \\ X i |! \u2022 \u03c6(X i , {X 1 , . . . , X i\u22121 }).", "formula_coordinates": [5.0, 323.46, 176.09, 230.58, 19.91]}, {"formula_id": "formula_11", "formula_text": "x | v \u2208 \u03b9(x) } is connected in T for all v \u2208 V G . In slight abuse of no- tation, we denote, for a set C \u2286 V G , by \u03b9 \u22121 (C) the sub- tree { x | C \u2286 \u03b9(x) }.", "formula_coordinates": [5.0, 319.5, 299.72, 238.5, 41.83]}, {"formula_id": "formula_12", "formula_text": "x i ) \u2229 \u03b9(x i+1 ) \u2286 \u03b9(v) for 1 \u2264 i < p. Lemma 7. We can order the elements of the set FP(v, T ) as X 1 X 2 \u2022 \u2022 \u2022 X .", "formula_coordinates": [5.0, 319.5, 467.08, 238.5, 34.55]}, {"formula_id": "formula_13", "formula_text": "F \u2286 { K | K \u2208 \u03a0(G) \u2227 S \u2286 K } such that", "formula_coordinates": [5.0, 371.15, 673.28, 186.85, 8.74]}, {"formula_id": "formula_14", "formula_text": "K 1 \u227a \u03b1 K 2 if, and only if, (i) K 1 \u2229 K 2 = S \u2208 \u2206(G), (ii) K 1 and K 2 are in S-flowers F 1 , F 2 \u2208 B(S)", "formula_coordinates": [6.0, 54.0, 306.98, 238.5, 31.57]}, {"formula_id": "formula_15", "formula_text": "#AMO(G) = v \u2208 V T \u03c6(\u03b9(v), FP(v, T )) \u00d7 H \u2208 C G (\u03b9(v))", "formula_coordinates": [6.0, 63.39, 371.18, 187.72, 21.14]}, {"formula_id": "formula_16", "formula_text": "r {1, 2, 3} {2, 3, 4, 5} {2, 3, 5, 6} {2, 3} {2, 3, 5} \u03c6 {1, 2, 3}, \u2205 \u03c6 {2, 3, 4, 5}, {2, 3} \u03c6 {2, 3, 5, 6}, {2, 3}, {2, 3, 5} = 6 = 20 = 16", "formula_coordinates": [6.0, 57.77, 580.01, 234.61, 55.57]}, {"formula_id": "formula_17", "formula_text": "#AMO(G) = 6 \u2022 3 + 20 \u2022 1 + 16 \u2022 1 = 54. input : A UCCG G = (V, E). output: #AMO(G). 1 function count(G, memo) 2 if G \u2208 memo then 3 return memo[G] 4 end 5 T = (T, r, \u03b9) \u2190 a rooted clique tree of G 6 sum \u2190 0 7 Q \u2190 queue with single element r 8 while Q is not empty do 9 v \u2190 pop(Q) 10 push(Q, children(v)) 11 prod \u2190 1 12 foreach H \u2208 C G (\u03b9(v)) do 13 prod \u2190 prod \u2022 count(H, memo) 14 end 15 sum \u2190 sum + \u03c6(\u03b9(v), FP(v, T )) \u2022 prod", "formula_coordinates": [6.0, 89.05, 57.59, 434.91, 646.56]}, {"formula_id": "formula_18", "formula_text": "G K = \u03c0 G \u03c0(K) . 3. Denote by C G (\u03c0(K)) the undirected connected compo- nents of G \u03c0(K) [V \\ K] and let C G (K) denote the undi- rected connected components of G K [V \\ K].", "formula_coordinates": [11.0, 54.0, 519.92, 238.5, 47.02]}, {"formula_id": "formula_19", "formula_text": "C G (\u03c0(K)). 1 S \u2190 sequence of sets initialized with (K, V \\ K) 2 \u03c4 \u2190 empty list, L \u2190 \u2205 3 while S is non-empty do 4 X \u2190 first non-empty set of S 5 if X \u2286 K then 6 v \u2190 the first vertex of X in \u03c0(K)", "formula_coordinates": [11.0, 320.99, 78.97, 207.65, 74.71]}, {"formula_id": "formula_20", "formula_text": "S i by S i \u2229 N (v), S i \\ N (v).", "formula_coordinates": [11.0, 400.13, 266.26, 114.67, 9.65]}, {"formula_id": "formula_21", "formula_text": "u \u2192 v in G \u03c0(", "formula_coordinates": [11.0, 319.5, 649.33, 58.46, 10.53]}, {"formula_id": "formula_22", "formula_text": "#AMO(G \u03c0(K) ) = H\u2208C G (\u03c0(K))", "formula_coordinates": [12.0, 87.5, 361.25, 122.5, 23.22]}, {"formula_id": "formula_23", "formula_text": "\u03c0 over K #AMO(G \u03c0(K) ) = |K|! \u00d7 H \u2208 C G (K)", "formula_coordinates": [12.0, 75.08, 682.99, 161.24, 23.21]}, {"formula_id": "formula_24", "formula_text": "x 1 \u2208 P 1 \u2212 x 2 \u2212 \u2022 \u2022 \u2022 \u2212 x k\u22121 \u2212 x k \u2208 P 2 be a shortest P 1 -P 2 - path in G[V \\ S] with x i \u2208 K 1 \u222a K 2 for i \u2208 {2, . . . , k \u2212 1}.", "formula_coordinates": [13.0, 54.0, 68.12, 238.5, 20.61]}, {"formula_id": "formula_25", "formula_text": "x k\u22121 \u2190 x k in \u03b1. A contradiction.", "formula_coordinates": [13.0, 89.97, 133.87, 135.76, 9.65]}, {"formula_id": "formula_26", "formula_text": "#AMO(G) = S\u2208\u2206(G)\u222a\u03a0(G) \u03c6(S) \u00d7 H \u2208 C G (S)", "formula_coordinates": [13.0, 70.34, 217.15, 169.75, 21.14]}, {"formula_id": "formula_27", "formula_text": "\u03c6(S, R) = |S|! \u2212 i=1 |S \\ X i |! \u2022 \u03c6(X i , {X 1 , . . . , X i\u22121 }).", "formula_coordinates": [13.0, 57.96, 475.41, 230.58, 19.91]}, {"formula_id": "formula_28", "formula_text": "\u03c6(S, R) = \u03c6(S, {X 1 , . . . , X \u22121 }) \u2212 |S \\ X |! \u2022 \u03c6(X , {X 1 , . . . , X \u22121 }).", "formula_coordinates": [13.0, 69.38, 579.46, 207.74, 23.6]}, {"formula_id": "formula_29", "formula_text": "\u03c6(S, R) = |S|! \u2212 \u22121 i=1 |S \\ X i |! \u2022 \u03c6(X i , {X 1 , . . . , X i\u22121 }) \u2212 |S \\ X |! \u2022 \u03c6(X , {X 1 , . . . , X \u22121 }) = |S|! \u2212 i=1 |S \\ X i |! \u2022 \u03c6(X i , {X 1 , . . . , X i\u22121 }).", "formula_coordinates": [13.0, 57.96, 622.06, 230.58, 80.3]}, {"formula_id": "formula_30", "formula_text": "x i ) \u2229 \u03b9(x i+1 ) \u2286 \u03b9(v) for 1 \u2264 i < p.", "formula_coordinates": [13.0, 358.67, 133.87, 141.83, 9.65]}, {"formula_id": "formula_31", "formula_text": "FP(v, T ) as X 1 X 2 \u2022 \u2022 \u2022 X .", "formula_coordinates": [13.0, 319.5, 159.77, 143.94, 9.65]}, {"formula_id": "formula_32", "formula_text": "FP(v, T ) satisfy \u03b9(x i ) \u2229 \u03b9(x i+1 ) \u2286 \u03b9(v)", "formula_coordinates": [13.0, 319.5, 199.62, 163.63, 9.65]}, {"formula_id": "formula_33", "formula_text": "x i ) \u2229 \u03b9(x i+1 ) to FP(v, T ).", "formula_coordinates": [13.0, 394.91, 232.49, 106.83, 9.65]}, {"formula_id": "formula_34", "formula_text": "F \u2286 { K | K \u2208 \u03a0(G) \u2227 S \u2286 K } such that K\u2208F K is connected in G[V \\ S].", "formula_coordinates": [13.0, 327.8, 276.33, 230.2, 22.11]}, {"formula_id": "formula_35", "formula_text": "the same connected component in G[V \\ S].", "formula_coordinates": [13.0, 319.5, 481.0, 177.49, 8.96]}, {"formula_id": "formula_36", "formula_text": "K \u2208 F . Observe that K \\ S is disconnected from K \\ S in G[V \\ S].", "formula_coordinates": [13.0, 319.5, 684.24, 238.5, 19.92]}, {"formula_id": "formula_37", "formula_text": "#AMO(G) = v \u2208 V T \u03c6(\u03b9(v), FP(v, T )) \u00d7 H \u2208 C G (\u03b9(v))", "formula_coordinates": [14.0, 63.39, 120.22, 187.72, 21.14]}, {"formula_id": "formula_38", "formula_text": "K 1 , K 2 \u2208 \u03a0(G), respectively. If K 1 \u227a \u03b1 K 2 then K 1 \u2229 K 2 = S \u2208 FP(\u03b9 \u22121 (K 2 ), T ).", "formula_coordinates": [14.0, 54.0, 684.24, 238.0, 20.61]}, {"formula_id": "formula_39", "formula_text": "Algorithm 1: v\u2212\u2022 \u2022 \u2022\u2212x\u2212y\u2212z\u2212\u2022 \u2022 \u2022\u2212w. Then {x, z} \u2208 E G ,", "formula_coordinates": [14.0, 319.5, 607.52, 238.5, 9.65]}, {"formula_id": "formula_40", "formula_text": "(i) S H is a min- imal separator in G, (ii) S H is fully connected to V H in G, and (iii) V H = F \\ S H for some S H -flower F .", "formula_coordinates": [15.0, 54.0, 333.45, 238.5, 31.57]}, {"formula_id": "formula_41", "formula_text": "S H = S G \u222a P out (H) is a minimal x-y separator in G. Fur- thermore, S H is fully connected to V H in G and it can be easily seen that V H \u2286 F \\ S H . To show equality, observe that every vertex v in F \\ S H is in V G (if it is not sepa- rated from V H by S H in G, it is clearly not separated from V H by S G in G, hence v is in F \\ S G = V G )", "formula_coordinates": [15.0, 54.0, 575.41, 238.5, 64.45]}, {"formula_id": "formula_42", "formula_text": "2(|\u03a0(G)| \u2212 1) + 1 = 2|\u03a0(G)| \u2212 1.", "formula_coordinates": [15.0, 346.9, 243.46, 142.14, 8.74]}, {"formula_id": "formula_43", "formula_text": "Pr(v \u03c0 | K, FP) = #Pe(K \\ v \u03c0 ,FP) #Pe(K, FP) . input : Clique K, list FP = (X 1 , X 2 , . . . , X ) with X 1 X 2 \u2022 \u2022 \u2022 X . output: Permutation \u03c0. 1 function drawperm(K, FP, memo) 2 foreach v \u2208 K do 3 if v in X then 4 Let i be smallest such that v \u2208 X i . 5 wt(v) \u2190 \u03c6(K \\ v, {X i \\ v, . . . , X \\ v}) 6 else 7 wt(v) \u2190 \u03c6(K \\ v, \u2205) 8 end 9 end v \u2190 drawvertex(wt) if v in X then Let i be smallest such that v \u2208 X i . 13FP \u2190 {X i \\ v, . . . , X \\ v} else 15FP \u2190 \u2205 end if |K \\ v| = 0 then return (v) else return concat(v, drawperm(K \\ v,FP))", "formula_coordinates": [15.0, 363.22, 684.11, 151.07, 22.53]}, {"formula_id": "formula_44", "formula_text": "Pr(\u03c0 | K \\ v \u03c0 ,FP) = 1 #Pe(K \\ v \u03c0 ,FP)", "formula_coordinates": [16.0, 91.1, 481.26, 163.1, 24.47]}, {"formula_id": "formula_45", "formula_text": "X i \\ v \u03c0 \u2282 X i+1 \\ v \u03c0 \u2022 \u2022 \u2022 \u2282 X \\ v \u03c0", "formula_coordinates": [16.0, 101.2, 544.41, 143.35, 9.65]}, {"formula_id": "formula_46", "formula_text": "Pr(\u03c0 | K, FP) = Pr(v \u03c0 | K, FP) \u2022 Pr(\u03c0 | K \\ v \u03c0 ,FP) = #Pe(K \\ v \u03c0 ,FP) #Pe(K, FP) \u2022 #Pe(K \\ v \u03c0 ,FP) = 1 #Pe(K,", "formula_coordinates": [16.0, 62.16, 582.46, 222.18, 66.69]}, {"formula_id": "formula_47", "formula_text": "Pr(\u03c4 \u03b1 (G)) = Pr(K \u03b1 | FP)Pr(\u03c0 \u03b1 | K \u03b1 , FP) H\u2208C G (K\u03b1) Pr(\u03c4 \u03b1[H] (H)) = #Pe(K \u03b1 , FP) H\u2208C G (K\u03b1) #AMO(H) #AMO(G) \u2022 #Pe(K \u03b1 , FP) H\u2208C G (K\u03b1) #AMO(H) = 1 #AMO(G)", "formula_coordinates": [16.0, 322.47, 449.16, 235.32, 97.42]}, {"formula_id": "formula_48", "formula_text": "Pr(\u03c0 \u03b1 | K \u03b1 , FP) = 1 #Pe(K \u03b1 ,", "formula_coordinates": [16.0, 367.24, 684.11, 120.24, 23.23]}, {"formula_id": "formula_49", "formula_text": "\u03c6(S, R) = |S|!\u2212 i=1 |X i |!\u2022\u03c6(S\\X i , {X i+1 \\X i , . . . , X \\X i }).", "formula_coordinates": [17.0, 54.0, 326.39, 249.66, 19.91]}, {"formula_id": "formula_50", "formula_text": "O(|\u03a0(G)| 2 \u2022 |V | \u2022 |E|).", "formula_coordinates": [17.0, 126.65, 391.12, 93.2, 10.81]}, {"formula_id": "formula_51", "formula_text": "n! \u2264 n n = (2 log n ) n = 2 n\u2022log n .", "formula_coordinates": [17.0, 109.57, 580.86, 127.37, 10.81]}, {"formula_id": "formula_52", "formula_text": "v i initial- ize a set S = { v j | v j \u2208 N (v i ) \u2227 j > i }.", "formula_coordinates": [19.0, 54.0, 222.75, 238.5, 20.61]}], "doi": ""}