{"title": "BitFunnel: Revisiting Signatures for Search", "authors": "Bob Goodwin; Microsoft Michael; Hopcroft Microsoft; Dan Luu; Alex Clemmer; Heptio Mihaela; Curmei Microsoft; Sameh Elnikety; Microsoft Yuxiong; He Microsoft", "pub_date": "", "abstract": "Since the mid-90s there has been a widely-held belief that signature files are inferior to inverted files for text indexing. In recent years the Bing search engine has developed and deployed an index based on bit-sliced signatures. This index, known as BitFunnel, replaced an existing production system based on an inverted index. The driving factor behind the shift away from the inverted index was operational cost savings. This paper describes algorithmic innovations and changes in the cloud computing landscape that led us to reconsider and eventually field a technology that was once considered unusable. The BitFunnel algorithm directly addresses four fundamental limitations in bit-sliced block signatures. At the same time, our mapping of the algorithm onto a cluster offers opportunities to avoid other costs associated with signatures. We show these innovations yield a significant efficiency gain versus classic bit-sliced signatures and then compare BitFunnel with Partitioned Elias-Fano Indexes, MG4J, and Lucene.\u2022 Information systems \u2192 Search engine indexing; Probabilistic retrieval models; Distributed retrieval; \u2022 Theory of computation \u2192 Bloom filters and hashing;", "sections": [{"heading": "", "text": "of billions of documents, large main memory systems) motivated us to reconsider signature files.\nIn our signature-based approach, known as BitFunnel, we use a Bloom filter to represent the set of terms in each document as a fixed sequence of bits called a signature. Bloom filters are reasonably space efficient and allow for fast set membership, forming the basis for query processing.\nUsing this approach, however, poses four major challenges. First, determining the matches for a single term requires examining one signature for each document in the corpus. This involves considerably more CPU and memory cycles than the equivalent operation on an inverted index. Second, term frequency follows a Zipfian distribution, implying that signatures must be long to yield an acceptable false positive rate when searching for the rarest terms. Third, the size of web documents varies substantially, implying that signatures must be long to accommodate the longest documents. Fourth, the configuration of signature-based schemes is not a well-understood problem.\nWe develop a set of techniques to address these challenges: (1) we introduce higher rank rows to reduce query execution time; (2) we employ frequency-conscious signatures to reduce the memory footprint; (3) we shard the corpus to reduce the variability in document size; (4) we develop a cost model for system performance; and (5) we use this model to formulate a constrained optimization to configure the system for efficiency.\nThese techniques are used in the Microsoft Bing search engine, which has been running in production for the last four years on thousands of servers. Compared to an earlier production search engine based on inverted lists that it replaced, BitFunnel improved server query capacity by a factor of 10.", "publication_ref": ["b1", "b4"], "figure_ref": [], "table_ref": []}, {"heading": "BACKGROUND AND PRIOR WORK", "text": "We focus on the problem of identifying those documents in a corpus that match a conjunctive query of keywords. We call this the Matching Problem.\nLet corpus C be a set of documents, each of which consists of a set of text terms:\nC = {documents D} D = {terms t }\nDefine query Q as a set of text terms:\nQ = {terms t }\nQuery Q is said to match document D when every term t \u2208 Q is also an element of D. This happens when Q \u2286 D or Q = Q \u2229 D. Define match set M as the set of documents matching Q:\nM = {D \u2208 C | Q = D \u2229 Q }\nThe goal of the Matching Problem is to identify the match set M, given corpus C and query Q.\nIn Sections 2.2-2.4 we examine conservative probabilistic algorithms that never miss a match, but might falsely report matches. The goal for these algorithms is to identify a conservative filter set M \u2032 M \u2286 M \u2032 \u2286 C where the false positive set F = M \u2032 \\ M is small.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Inverted Indexes", "text": "Perhaps the most common approach to the Matching Problem is the inverted index [4,11]. This approach maintains a mapping from each term in the lexicon to the the set of documents containing the term. In other words,\nPostin\u0434s(t) = {D \u2208 C | t \u2208 D}\nWith this approach, M can be formed by intersecting the posting sets associated with the terms in the query:\nM = t \u2208Q Postin\u0434s(t)\nIn practice, the posting sets are usually sorted, allowing fast intersection. They also draw on a large bag of tricks [4,20] to compress and decompress posting sets [17,23] while improving intersection time [6,7]. This is a rich area with ongoing research into novel data structures such as treaps [16] and semi-bitvectors [13].\nInverted indexes find the exact match set, M, every time. Signaturebased approaches [8\u015b10, 15,25], on the other hand, use probabilistic algorithms, based on superimposed coding [1,21,22] and newer approaches, like TopSig [12] to identify a conservative filter set M \u2032 . BitFunnel is based on classical bit-sliced signatures which are, in turn, based on bit-string signatures.", "publication_ref": ["b3", "b10", "b3", "b19", "b16", "b22", "b5", "b6", "b15", "b12", "b14", "b24", "b0", "b20", "b21", "b11"], "figure_ref": [], "table_ref": []}, {"heading": "Bit-String Signatures", "text": "The key idea is that each document in the corpus is represented by its signature. In BitFunnel, the signature is essentially the sequence of bits that make up a Bloom filter representing the set of terms in the document. In constructing the Bloom filter, each term in the document is hashed to a few bit positions, each of which is set to 1.\nLet n denote the number of bit positions in the Bloom filter. Define H (n, t) as a function that returns the set of bit positions in the range [0..n) corresponding to the hashes of term t. Define #\u00bb s t , the signature of term t, as the bit-vector of length-n where bit position i is set to 1 iff i \u2208 H (n, t). We can then define the signature of document D as the logical-or of the signatures of its terms:\n# \u00bb s D = t \u2208D #\u00bb s t\nIn a similar manner, we can define the signature of query Q as the logical-or of the signatures of its terms:\n# \u00bb s Q = t \u2208Q #\u00bb s t Document D is said to be a member of M \u2032 when # \u00bb s Q \u2229 # \u00bb s D = # \u00bb s Q\nGiven the signatures of the documents in the corpus, one can easily compute M \u2032 by identifying those documents whose signatures match the query's signature:\nM \u2032 = {D \u2208 C | # \u00bb s Q \u2229 # \u00bb s D = # \u00bb s Q }\nHere's the pseudocode to search a corpus for documents matching a query:\nM \u2032 = for all D \u2208 C do if # \u00bb s D \u2229 # \u00bb s Q = # \u00bb s Q then M \u2032 = M \u2032 \u222a {D} end if end for\nBit-string signatures are elegant, but their uniform encoding of terms, independent of frequency, leads to poor memory utilization. Section 4.2 explains how BitFunnel uses Frequency Conscious Signatures to improve memory efficiency in signatures.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Bit-Sliced Signatures", "text": "If all of the signatures have the same length and share a common hashing scheme, H (n, t), one can achieve significant performance gains by using a bit-sliced arrangement [9,26,27]. This approach transposes signature vectors from rows to columns in order to allow multiple documents to be searched simultaneously while eliminating the bit masks and shifting necessary to perform Boolean operations on individual bits.\nSuppose we have a corpus C = {A..P } and a query Q. The matrix in Figure 1 shows these documents and the query encoded as bitsliced signatures. Each document corresponds to a column which holds its 16-bit signature. Each row corresponds to a bit position in the document signature.\nIn this example the signature for document B has bit positions 2, 5, 9, and 13 set. The signature for the query Q has bit positions 2, 5, and 9 set. Therefore, document B will match the query. It turns out that document F also matches the query.\nWith the bit-sliced layout, we need only inspect the rows corresponding to bit positions in Q that are set. These rows, which we call the query's rows, are shaded in Figure 1 and isolated in Figure 2. Each bit position in the query's rows corresponds to a document. The document matches if its bit position is set in all of the query's rows. We determine which documents match by intersecting the query's rows and looking for set bits. In Figure 2, columns B and F are the only columns without zeros. Therefore documents B and F are the only matches.\nHere's the bit-sliced algorithm: 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n#\u00bb a = \u223c0 for all i where # \u00bb s Q [i] == 1 do #\u00bb a = #\u00bb a & # \u00bb row i end for M \u2032 = {i | #\u00bb a [i] 0}\n0 A B 0 C D 0 E F 0 G H 0 I J 0 K L 0 M N 0 O P 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 Q 1\n0 A B 0 C D 0 E F 0 G H 0 I J 0 K L 0 M N 0 O P 2 5 9\n0 A B 0 C D 0 E F 0 G H 0 I J 0 K L 0 M N 0 O P 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \n1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 2 \u2229 5 \u2229 9", "publication_ref": ["b8", "b25", "b26"], "figure_ref": ["fig_1", "fig_1", "fig_2", "fig_2"], "table_ref": []}, {"heading": "Bit-Sliced Blocked Signatures", "text": "While bit-sliced signatures offer a significant performance advantage over bit-string signatures, they still suffer from poor performance when searching for rare terms. The problem is that every document's bit position must be scanned, even in the case where only a handful of documents actually match.\nThe idea behind blocked signatures [14] is to create shorter rows by assigning multiple documents to each column in the signature matrix. The number of documents that share a column is called the blocking factor. Shorter rows improve performance because they can be scanned more quickly, but they introduce noise which increases the false positive rate.\nPrior to BitFunnel, bit-sliced block signatures were used primarily as a single-level index into a set of bit-string signature files on disk. At the time the main concern with this approach was reducing the probability of an unsuccessful block match which occurred when a column signature matched the query but none of the documents contained all the terms in the query. Suppose, for example, a column held two documents, one containing the word \u0142dog\" and the other containing the word \u0142cat\". This column would match the query {\u0142do\u0434\", \"cat\"} even though neither document contains both terms. At least one paper proposed a solution to the problem of unsuccessful block matches [14], however [28] argued that blocking increases complexity while offering little benefit. In Section 4.1, we introduce Higher Rank Rows to address these problems.", "publication_ref": ["b13", "b13", "b27"], "figure_ref": [], "table_ref": []}, {"heading": "THE BITFUNNEL SYSTEM", "text": "For the past 4 years, BitFunnel has powered Bing's fresh index of recently crawled documents. During this time the system, which runs on thousands of machines, spread across several data centers, has processed the entire query load sent to Bing.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Architectural Overview", "text": "Bing maintains multiple, georeplicated copies of the web index, each of which is sharded across a cluster of BitFunnel nodes. Figure 3 shows a single cluster. Queries are distributed, round robin, across the cluster. A node, upon receiving a query, parses it into an abstract syntax tree, rewrites the tree into an execution plan and then compiles the plan locally before broadcasting the compiled plan to the rest of the cluster. The nodes in the cluster run the compiled plan in parallel, returning results to the planning node for aggregation. These results are then passed on to other systems that score the matching documents and generate captions to display on the search results web page. ", "publication_ref": [], "figure_ref": ["fig_3"], "table_ref": []}, {"heading": "The Cost of False Positives", "text": "One criticism specific to the signature file approach is the introduction of false positives into the result set. For scenarios like database queries where the identifying exact match set is the goal, the cost of filtering out the false positives can be prohibitive. In the case of web search, the cost of filtering out false positives is negligible. To see why, it is important to understand that the goal of web search is not to find documents matching Boolean expressions of keywords \u015b rather it is to find the documents that best match the user's intent when issuing a query. In Bing, we employ a ranking system that, given a document and a query, will generate a score predicting how well the document matches the user's intent for the query. This system relies on many signals beyond keywords and to some extent its inner workings are opaque to us because it is configured by machine learning.\nIf we had unlimited resources, we could process each query by submitting every single document in the corpus to our ranking oracle and then return the top-n ranked documents. Since we don't have unlimited resources, we insert inexpensive filters upstream of the oracle to discard documents that the oracle would score low. The filters are designed to reject, with high probability, those documents that score low while never rejecting documents that score high. BitFunnel is such a filter.\nIn this context, the performance of BitFunnel is judged by its impact on the end-to-end system. BitFunnel wins when its time savings in the Boolean matching phase is greater than the time the oracle spends scoring false positives.\nWe turn our attention now to a single BitFunnel node to describe the techniques that enable fast query processing.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "BITFUNNEL INNOVATIONS", "text": "In this section, we describe three innovations that address speed and space problems associated with bit-string and bit-sliced signatures.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Higher Rank Rows", "text": "BitFunnel generalizes the idea of blocking so that each term simultaneously hashes to multiple bit-sliced signatures with different blocking factors. The key to making this approach work is the ability to efficiently intersect rows with different blocking factors.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Mapping Columns Across Ranks.", "text": "In BitFunnel, we restrict blocking factors to be powers of 2. We define a concept of row rank, where a row of rank r \u2265 0 has a blocking factor of 2 r .\nThe BitFunnel blocking scheme is specific to the size of the machine word used for the bit-slice operations. Let w be the log 2 of the number of bits in a machine word, so for example, a 64-bit processor would have w = 6. Then the document in column i 0 at rank 0 will be associated with column i r at rank r as follows:\ni r = i 0 2 r +w + (i 0 mod 2 r )(1)\nFigure 4 gives a small example for a 4-bit machine word (w = 2) and ranks 0, 1, and 2. We can see that position 4 at rank 1 is associated with documents {4, 12} while position 0 at rank 2 is associated with documents {0, 4, 8, 12}. Rank 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Note that higher rank rows will, in general, magnify the bit density of their lower rank equivalents. This is because the value of each bit at a higher rank is the logical-or of multiple bits at a lower rank. In order to maintain a constant bit density of d across all signatures in BitFunnel, we must use longer signatures at higher ranks. Therefore, a single row at rank 0 will translate into multiple shorter rows at a higher rank. In most cases, a rank zero row and its higher rank equivalents will consume roughly the same amount of memory. We will derive an expression for the memory consumption in higher rank rows in Section 5.4. Now suppose we have a query, Q, that maps to the three rows shown in Figure 5. To evaluate the query, we need some way of intersecting rows with different ranks. The mapping in Equation ( 1) is designed to make this operation easy and efficient. Rank 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Logically we convert each row to its rank-0 equivalent by concatenating 2 r copies of the row as shown in Figure 6. Then we are free to intersect the rank-0 equivalent rows to produce the result vector. Rank 2 Rank 1 Rank 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 1 1 1 1 1 1 1 1 1 0 1\n0 0 0 0 1 1 1 1 1 1 1 1 0 1\n0 0 0 0 1 1 1 1 1 1 1 1 0 1 0 0 0 0 1 0 1 0 0 0 1 1 0 0 0 0 1 0 1 0 0 0 0 0 1 1\nMatches 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1\nFigure 6: Rank-0 equivalent rows.", "publication_ref": [], "figure_ref": ["fig_5", "fig_7"], "table_ref": []}, {"heading": "Optimizing", "text": "Higher Rank Row Intersection. At a logical level, our approach is to intersect rank-0 equivalent rows. Were we to generate rank-0 equivalents for intersection, we would lose all of the performance gains that come from scanning shorter rows at higher ranks. Mapping (1) was structured specifically to provide opportunities to reuse intermediate results at every rank. As an example, in Figure 6, bits [0..3] of the rank 2 row need only be read once, even though they will be used for positions [4..7], [8..11], and [12..15]. Similarly, the intersection of the first two rows in positions [0..3] will be computed once and used again for positions [8..11]. We will leverage this insight in Section 5.3 where we derive an expression for the expected number of operations required to combine a set of rows with different ranks.\nIn BitFunnel, each term in a query maps to a set of rows that may include higher rank rows.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Frequency Conscious Signatures", "text": "We saw in Section 2.2 how Bloom filter signatures can be used to encode the set of terms in a document. One shortcoming with this approach is inefficient memory usage when terms in the lexicon have widely varying frequencies in the corpus.\nThe problem stems from the fact that, in its classical formulation [1], the Bloom filter is configured with an integer constant, k, which represents the number of hashes for each term 1 . This value of k is the same for all terms in lexicon L. In other words\n|H (n, t)| = k, \u2200 t \u2208L\nTo get an intuition for the problem of the one-size-fits-all k, it helps to think of the quantity of false positives in terms of signalto-noise ratio. Let's consider a single set membership test for t \u2208 D. In the context of the test, define the signal s to be the probability that term t is actually a member of document D. This is just the frequency of t in the corpus.\nDefine noise \u03b1 to be the probability that the Bloom filter will incorrectly report t as a member. Assume the Bloom filter has been configured to have an average bit density of d. Since d is the fraction of the bits expected to be set, we can treat it as the probability that a random bit is set. A set membership test involves probing k bit positions. If all k probes find bits that are set to one, the algorithm will report a match. Therefore the noise is just the probability that k probes all hit ones when t D:\n\u03b1 = (1 \u2212 s)d k\nThe signal-to-noise ratio \u03d5 is then\n\u03d5 = s (1 \u2212 s)d k\nWe can rearrange this and take the ceiling to get an expression for k as a function of d, s, and \u03d5:\nk = lo\u0434 d s (1 \u2212 s)\u03d5\nThis is the minimum value of k that will ensure a signal-to-noise ratio of at least \u03d5. The main take away is that k increases as s decreases. In other words, rare terms require more hashes to ensure a given signal-to-noise level. The following table shows values of k without the ceiling, for select values of s when d = 0.1 and \u03d5 = 10: Now consider a Bloom filter that stores a typical document from the Gov2 corpus 2 . If we were to configure the Bloom filter with k = 2 we could just barely maintain a signal-to-noise ratio of 10 when testing for the term \u0142picture\" which appears with frequency 0.1. To test for the term \u0142rotisserie\", which appears with frequency 0.0001, we would need k = 5 to drive the noise down to a tenth of the signal.\nWith classical Bloom filters, one must configure for the rarest term in the lexicon, even though the vast majority of common terms could be stored more efficiently. Recent work in Weighted Bloom Filters [3] shows that it is possible to adjust the number of hash functions on a term-by-term basis within the same Bloom filter.\nBitFunnel applies these ideas to reduce memory usage and determine the number of rows needed for each term.", "publication_ref": ["b0", "b0", "b2"], "figure_ref": [], "table_ref": []}, {"heading": "Sharding by Document Length", "text": "Bit-sliced signatures have another one-size-fits-all problem resulting from the requirement that all of the document signatures have the same configuration (i.e. their bit lengths, n, must all be the same, and they must all use the same hashing scheme H (n, t)).\nThe problem is that real world documents vary greatly in length. In Wikipedia, for example, the shortest documents have just a handful of unique terms while the longest ones may have many thousands of terms. The dynamic range of document lengths on the internet is even higher because of files containing DNA sequences, phone numbers, and GUIDs. To avoid overfilling our Bloom filters and generating excessive false positives, it is necessary to configure the Bloom filters for the longest document expected, even if such a document is very rare. Unfortunately, such a configuration would waste enough memory as to offset all of the other benefits of the bit-sliced arrangement.\nA workaround [28] suggested in the late 90s was to shard the index into pieces containing documents with similar lengths. This approach was rejected at the time because, on a single machine, the introduction of length sharding would multiply the number of disk seeks by the number of shards.\nThis concern is not a factor when the index is many times larger than the capacity of a single machine. As soon as the index is sharded across a large cluster, one must pay for the overhead of sharding. At this point sharding by document length costs the same as sharding by any arbitrary factor.\nEven on a single machine, the cost of length sharding is greatly reduced on modern hardware where the index can be stored in RAM or on SSD because the access cost is dominated by fixed-sized block transfers (512-bit cache line for RAM, 4096 byte block for SSD), rather than hard disk seeks.\nIn BitFunnel, we partition the corpus according to the number of unique terms in each document such that each instance of BitFunnel manages a shard in which documents have similar sizes.", "publication_ref": ["b27"], "figure_ref": [], "table_ref": []}, {"heading": "PERFORMANCE MODEL AND OPTIMIZATION", "text": "Signature-based approaches have historically been hard to configure because of a large number of design parameters that impact performance [10,26,28]. In this section we present an algorithm that optimizes the BitFunnel configuration, given a desired signalto-noise ratio. The algorithm performs a constrained optimization, over relevant configuration parameters, of a cost function that expresses the system efficiency as DQ, the product of the corpus size D and query processing rate Q. The configuration parameters include the mapping from terms with various frequencies to their corresponding number of rows at each rank. The constraint is a lower limit on the allowable signal-to-noise ratio, \u03d5.\nIn order to develop the cost function and constraint, we derive expressions for the signal-to-noise ratio, query processing speed, and memory consumption in BitFunnel. We then combine these expressions into a cost function and constraint used by the algorithm that identifies an optimized set of blocking factors and hash functions for each equivalence class of terms, based on frequency in the lexicon.", "publication_ref": ["b9", "b25", "b27"], "figure_ref": [], "table_ref": []}, {"heading": "Prerequisites", "text": "Before deriving these fundamental equations, we discuss the impact of row rank on bit densities and noise. We then characterize two different components of noise in rank-0 equivalent rows. This will form the basis for the noise, speed, and storage equations in Sections 5.2, 5.3, and 5.4.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "5.", "text": "1.1 Signal in a Higher Rank Row. Because each bit in a higher rank row corresponds to multiple documents, the bit density contributed by a single term will nearly always be greater in higher rank rows. We can see this in Figure 4 where densities in the rank-0 row and its rank 1 equivalent are 4 16 and 8 16 , respectively. Let s 0 denote the signal in a rank-0 row and s r denote the signal at rank r . We can express s r as a function of s 0 and r . The probability that a bit at rank r is set due to signal is the probability that at least one of the 2 r corresponding rank-0 bits is signal. This is just one minus the probability that all of the 2 r rank-0 bits are zero:\ns r = 1 \u2212 (1 \u2212 s 0 ) 2 r (2)\n5.1.2 Noise in a Rank-0 Equivalent Row. Processing a query in BitFunnel is logically equivalent to intersecting the rank-0 equivalents of each row associated with the query. Converting a rank-r row to its rank-0 equivalent increases noise. The intuition behind this is simple \u00d0 each bit set in a rank-r row means that at least one of 2 r documents is a match. It could be one document or all 2 r \u00d0 we can't tell and this is the source of higher noise.\nLet's look at a simple example. Suppose we have a corpus of 16 documents and would like to search for a term that happens to appear in documents 4 and 8. We hash our term to find its corresponding rows, and we get the set of rows R = {R 2 , R 1 , R 0 } with ranks 2, 1, and 0, respectively. We define the signal, s 0 as the fraction of the bit positions at rank-0 corresponding to a match. In the case of a term that appears in only 2 documents, s 0 = 2 16 . In Figure 7, the green squares labeled 'S' correspond to the signal.  R 2 has one signal bit, so its signal is 1 4 = 4 16 . We've arbitrarily added one noise bit, marked with an 'N' and shaded black. This bit is contributed from another term that also maps to R 2 . The density of R 2 is 2 4 = 8 16 . Row R 1 has two signal bits and two arbitrary noise bits so its signal is 2 8 = 4 16 and its density is 4 8 = 8 16 .\nFinally, in row R 0 , the signal is equal to s 0 because each signal bit maps directly to a single document. As with the other rows, R 0 contains random noise bits from other terms, yielding 8 16 density. To process our query, we intersect the rank-0 equivalents of rows R 2 and R 1 with R 0 . Figure 8 shows how the process of creating rank-0 equivalents increases noise.\n0 0 1 0 2 3 0 4 5 0 6 7 0 8 9 0 10 11 0 12 13 0 14 15 0 0 1 0 2 3 0 4 5 0 6 7 0 8 9 0 10 11 0 12 13 0 14 15 R 2 R 1 R 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Continuing with our example, the signal bit from position 0 in R 2 maps to bit positions 0, 4, 8, and 12 at rank 0. Of these four positions, only positions 4 and 8 correspond to signal bits. The others are noise bits introduced by the construction of the rank-0 equivalent, and they are colored yellow and marked with the letter 'C'. In a similar manner, R 2 bit position 2 introduces noise in rank-0 positions 2, 6, 10, and 14. These bits are colored black and marked with the letter 'U'. In the case of R 2 , we went from a rank-2 row with 1 4 signal and 1 4 noise to a rank-0 row with 2 16 signal and 6 16 noise. The noise increase is entirely due to the signal bits in R 2 . In contrast, the noise bits in R 2 contribute their same density without amplification, and therefore do not increase noise in the rank-0 equivalent row. Now let's look at the rank-0 equivalent of R 1 . We go from a rank-1 row with 2 8 signal and 2 8 noise to a rank-0 row with 2 16 signal and\n0 0 0 0 S U U U U S 0 U 0 0 0 0 S 0 U 0 0 0 0 C 0 U 0 0 0 0 C 0 U 0 0 0 0 0 U U C Results 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 S U S S S S C U U U U\n6\n16 noise. As with R 2 , the noise increase is due entirely to signal in rank-1 row.", "publication_ref": ["b3", "b0", "b1", "b7", "b0", "b1"], "figure_ref": ["fig_5", "fig_10", "fig_11"], "table_ref": []}, {"heading": "Correlated and Uncorrelated", "text": "Noise. We turn to computing the noise resulting from the intersection of a set of the rows. The noise in any rank-0 row is the difference between the row's density and the signal s 0 . If row R has density d, then its rank-0 equivalent has density d because it consists of the concatenation of 2 r copies of the R. Therefore, the noise in R's rank-0 equivalent is d \u2212 s 0 .\nNoise is made up of two components, one which is correlated and one which is not. In Figure 8, uncorrelated noise bits are shaded black while correlated noise bits are colored yellow. Row intersections are very effective at reducing uncorrelated noise, but they have less impact on correlated noise.\nTo better illustrate this, let's look at a simple, but extreme example. Suppose our query matches documents 2 and 13 and consists of the three rank-1 rows depicted in Figure 9. In the rank-0 equivalent uncorrelated. The uncorrelated noise, shown in black and marked with the letter 'U', is completely eliminated in three row intersections, but the correlated noise, shown in yellow and marked with the letter 'C' remains at the same level despite the intersections. Effectively managing the impact of higher rank rows requires an understanding of the correlated noise in rank-0 equivalent rows. In the following we derive expressions for noise components.\nLet n r denote noise in a rank-r row R and n 0 denote noise in its rank-0 equivalent. We express n 0 as a function of r , s 0 , and n r . Row R will contribute n r density due to noise already in R and s r in density due to signal in R. A portion of the density in s r corresponds to bonified signal. The remaining density is correlated noise introduced by the conversion to rank-0. Thus we compute noise at rank-0 by subtracting s 0 from the density contributed by R:\nn 0 = n r + s r \u2212 s 0\nTo compute the correlated noise, we subtract n r from n 0 and substitute\ns r = 1 \u2212 (1 \u2212 s 0 ) 2 r : n 0 \u2212 n r = s r \u2212 s 0 = 1 \u2212 (1 \u2212 s 0 ) 2 r \u2212 s 0 (3)\nNote that the number of correlated noise bits in a rank-0 equivalent is a function of the original rank. The higher the row rank, the greather the contribution in correlated noise to its rank-0 equivalent. Also, correlated noise remaining after intersecting a set of rank-0 equivalents is the correlated noise of the lowest rank row in the set. The other correlated noise is converted to uncorrelated noise.\nIt is important to note that the correlated noise bits in a lower rank equivalent always form a subset of the correlated noise bits in a higher rank equivalent. Our equations for noise and speed in Sections 5.2 and 5.3 make use of this fact.", "publication_ref": [], "figure_ref": ["fig_11"], "table_ref": []}, {"heading": "Signal-to-Noise Ratio", "text": "We're now ready to write expressions for the noise components after a sequence of row intersections. For this derivation, we will perform the intersections in order from high rank to low rank. We will start with an accumulator, a, which has an initial bit density of 1.0 and then intersect in each row in turn.\nLet a i denote the total noise in the accumulator at the end of iteration i. Let c i and u i denote the amount of correlated and uncorrelated noise, respectively, on iteration i and let r i denote the rank. The first iteration is effectively loading the first row into the accumulator so, u 1 = n 1 . The correlated noise in the accumulator is always equal to the correlated noise in the last row intersected, so\nc i = 1 \u2212 (1 \u2212 s 0 ) 2 r i \u2212 s 0\nSince the rows are ordered by non-increasing rank, subsequent rows will never have more correlated noise. In the case where the rank decreases, the amount of correlated noise will decrease. When this happens, some of the correlated noise in the accumulator will become uncorrelated noise, moving forward. This new amount of uncorrelated noise in the accumulator will then be multiplied by the current row's total noise density n i+1 :\nu i+1 = (u i + c i \u2212 c i+1 )n i+1\nAt any given point, the total accumulator noise a i is just the sum of the correlated and uncorrelated noise:\na i = c i + u i\nThe signal-to-noise ratio, \u03d5, on iteration i is then\n\u03d5 i = s 0 a i = s 0 c i + u i(4)", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Query Execution Time", "text": "When modelling running time, we use the number of machine word accesses of unique memory addresses as our proxy for time.\nOn a real computer, row intersections are typically performed in chunks that match the machine register size. As an example, if the machine register size is 64 bits, and the rank-0 rows are 256 bits long, a pairwise row intersection would require 4 register-sized logical-and operations. When intersecting a set of rows, the outer loop is typically over the register-sized chunks in each row and the inner loop is over the set of rows. This ordering of the loops is desirable because intermediate results of row intersections can reside in the accumulator instead of being written to memory. In many cases, the accumulator will become zero in the inner loop before all of the rows have been examined. Since additional intersections cannot change the result, it is possible to break out of the inner loop at this point.\nIn practice, breaking out of the inner loop offers a significant performance improvement. To quantify this impact, we'll focus on the innermost loop which intersects a set of n machine words that reside in memory. Our goal is to write an expression for the expected number of machine words loaded from memory.\nIf we know the probability that a bit remains set after intersecting the first n rows, we can derive a formula for the expected number of machine words accessed when intersecting a set of rows.\nLet N be a random variable denoting the machine words intersected and define P BZ (N > i) to be the probability that a random bit in the accumulator is zero after iteration i. P BZ (N > i) is the probability that the bit was not set by noise and not set by signal:\nP BZ (N > i) = 1 \u2212 s 0 \u2212 a i Define P A (N > i)\nto be the probability that at least one bit in the accumulator remains set after i intersections If b denotes the number of bits in a machine word then\nP A (N > i) = 1 \u2212 (P BZ (N > i)) b\nIf we were to actually perform intersections on the rank-0 equivalent rows, the expected number of machine words accessed during one iteration of the outer loop would be\nE(N ) = n i=1 P A (N > i) = n i=1 1 \u2212 (1 \u2212 s 0 \u2212 a i ) b\nAs we saw in Section 4.1.2, the mapping of columns across ranks is structured in such a way that intermediate results from higher rank intersections can be reused. Since each rank-0 equivalent is just the concatenation of 2 r copies of a rank-r original, we need only load the accumulator once for each of the 2 r machine word positions in the rank-0 equivalent. This reduces the number of machine words accessed in each row by a factor of 2 r i :\nE(N ) = n i=1 1 \u2212 (1 \u2212 s 0 \u2212 a i ) b 2 r i(5)\nA similar approach can be used to model block devices like CPU cache and SSD block transfers, but it is somewhat more involved than substituting a different value for b.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Space Consumption", "text": "We express memory consumption as the number of bits per document required to store a term. Suppose we have a corpus, C, with target bit density, d, and we wish to store a term with signal, s 0 , in some row, q, that has rank r .\nSince the corpus has |C| documents, row q must have |C|2 \u2212r bit positions. Equation (2) shows that a term with frequency s 0 will set s r of these bits. Therefore the term contributes b 1 = s r |C|2 \u2212r set bits to row q. Let b 0 denote the number of zero bits in row q. By definition,\nd = b 1 b 1 + b 0 Rearranging, we get b 0 = b 1 d \u2212 b 1\nTherefore, the total number of bits required in row q to maintain density of d with a signal of s 0 is\nb 0 + b 1 = b 1 d = s r |C| d2 r\nDividing by the corpus size |C| gives the number of bits per document signature: s r d2 r For a set of rows, Q, the total memory consumption per document is therefore\nq \u2208Q s r (q) d2 r (6)", "publication_ref": ["b1"], "figure_ref": [], "table_ref": []}, {"heading": "Choosing Term Configurations", "text": "Given expressions for signal-to-noise ratio, machine word reads, and storage consumed, we can now develop an approach for identifying the optimal row configuration for each term. The problem is a constrained optimization over a cost function parameterized by speed and space. Our constraint is that the signal-to-noise ratio, \u03d5, must exceed some fixed threshold. The cost function is proportional to DQ, the product of the number of documents per unit storage and the number of queries processed per unit of compute. D is inversely proportional to the amount of storage required per document. Q is inversely proportional to the number of machine words accessed while processing a query. Therefore\nDQ \u221d 1 n i=1 1\u2212(1\u2212s 0 \u2212a i ) b 2 r i q \u2208Q s r (q) d(7)\nGiven the small number of possible row configurations, it is easy to enumerate all configurations and choose the one with the highest DQ where \u03d5 exceeds the signal-to-noise threshold. For example, when considering configurations of 0 to 9 rows at each of seven ranks from 0 to 6, we need to examine 10 7 configurations for each s 0 value. If we group s 0 values into, say, 100 buckets correspondiong to IDF values from 0.1 to 10.0 in 0.1 increments, the entire optimization involves 10 9 evaluations of Equation 7. A modern multi-core processor can perform this optimization in a matter of seconds.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "EXPERIMENATAL EVALUATION", "text": "Our experiments are based on the TREC Gov2 corpus. Apache Tikka 3 was used to extract terms, which were then converted to lower case, but not stemmed. Since BitFunnel shards its index by document term count, we selected five representative shards for our tests. Shard A has relatively short documents with term counts ranging from 64 to 127. Shards B, C, D and E have progressively larger documents. Our query log is based the TREC 2006 Efficiency Topics. We removed punctuations from each query and then filtered out those queries that contained terms not in the corpus. 4 The resulting query log contains about 98k queries.\nBitFunnel was implemented in C++14 and compiled with GCC 5.4.1 with the highest optimization level. Experiments were performed on a 4.0GHz 4-core i7-6700 with 32GB of 3.2GHz DDR4 RAM with Ubuntu 14.04 LTS on Windows Subsystem for Linux. BitFunnel was configured with lower bound signal-to-noise ratio \u03d5 = 10.\nThe source code to replicate our experiments is available at http://bitfunnel.org/sigir2017.", "publication_ref": ["b3"], "figure_ref": [], "table_ref": []}, {"heading": "Match Time vs. Quadwords", "text": "In Section 5.3 we developed a model for the number of machine words of row data accessed while processing a query. To verify that our model has predictive power, we examined the relationship between row intersection time and the number of quadwords accessed. Since BitFunnel has a significant per-match overhead that is not part of the row intersection cost model, we modified the code to perform row intersections, but not report matches. A sample of 5000 queries with I DF > 3 were chosen, at random, from our TREC query log, and these queries were run, single-threaded, against corpus D. To control for system variances not in the model, we ran each query 10 times and recorded the median row intersection time. The scatterplot in Figure 11 shows that row intersection time tends to grow as the number of quadwords increases. The correlation is more pronounced at higher IDF values.", "publication_ref": [], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "Impact of Frequency Conscious Signatures and Higher Rank Rows", "text": "This experiment compares the time and space characteristics of (a) bit-sliced signatures configured with classical Bloom filters (BSS); (b) the same, but with Frequency Conscious Signatures as described in Section 4.2 (BSS-FC); and (c) Higher Ranked Rows as described in Section 4.1 and optimized per Section 5.5 (BTFNL). 5 Table 2 examines Corpus D, comparing the three configurations at each of 5 bit densities. The DQ values measure overall system efficiency, expressed as the ratio of QPS to Bits/Posting. We use DQ because it is inversely proportional to the number of servers required, given a particular corpus and a desired QPS  5 The BSS Bloom filter targeted \u03d5 = 0.1 for terms with IDF 4. The BSS-FC and BTFNL configurations set \u03d5 = 0.1 for all terms, regardless of frequency.\nFrequency consciousness reduces storage consumption while increasing speed. For example, at d = 0.15, the BSS configuration uses 46.7 bits per posting while the BSS-FC configuration uses only 14.7. This 3.2x reduction in storage is achieved while yielding a 2.6x increase in speed. The intuition behind the improvement is that frequency consciousness allows each term to have the right number of rows. With classical Bloom filters, every term has the same number of rows, meaning that more common terms get excess rows as a side effect of providing sufficient rows to ensure the target signal-to-noise level for rare terms.\nHigher Rank Rows mainly impact speed. For example, when d = 0.15, BSS-FC runs at 24K queries per second, while BTFNL runs at 57.0K, a 2.4x improvement. The intuition behind the speed up is that higher rank rows can be scanned more quickly than rank-0 rows. Generally speaking, processing a rank-r row involves scanning 1 2 r of the quadwords necessary to process a rank-0 row. The DQ column captures the tradeoff between space and speed. BSS-FC has a DQ of 1,632, while BTFNL has a DQ of 4,163, a 2.6x improvement. Combining frequency consciousness with higher rank rows yields a 21x improvement over that BSS DQ of 194.\nWe found that a density of 0.15 yielded the best DQ for Corpora B, C, and D, while A and E performed best at 0.05 and 0.20, respectively.", "publication_ref": ["b4", "b4", "b0"], "figure_ref": [], "table_ref": ["tab_2"]}, {"heading": "Comparison with Contemporary Indexes", "text": "The version of BitFunnel used by Bing includes a forward index with term frequencies used for BM25F ranking. Because this ranking code was not available to us at the time we designed our experiment, we limited our comparison to conjunctive boolean matching. Our primary comparison system was Partitioned Elias-Fano or PEF [23]. This system is considered state-of-the-art, has excellent performance, and, like BitFunnel, is implemented in C++. We also compared with MG4J's Java implementation of PEF 6 . This implementation was the second fastest system in the SIGIR 2015 RIGOR workshop [18]. Our final comparison was with Lucene 7 , a popular Java-based search engine that outperformed MG4J at the RIGOR workshop, in an apples-to-apples comparison using BM25F.\nEach of these systems was configured to use a memory-mapped index that was non-positional, with scoring disabled. In this configuration, PEF and MG4J pay no runtime penalty associated with term frequencies because the frequencies are stored in a separate data structure that is never consulted. It is unclear whether Lucene pays a cost associated with stepping past term frequency values.\nFor each system we used 8 threads to process the entire 98k query log twice, back-to-back, measuring performance on the second pass. This ensured that relevant portions of the index were paged in, as they would be under continuous production load.\nWe can see from Table 3 that BitFunnel is faster than PEF in all cases, but sometimes this comes at a significant cost, for example in Corpus A, BitFunnel uses 5x as many bits per posting while yielding a false positive rate of 1.62%. Across the 5 corpora, MG4J is slower than PEF, as expected since it implements the same algorithm, but in Java. MG4J is faster than Lucene in all but Corpus C.\nBitFunnel's overall performance relative to PEF improves as document lengths increase. It first surpasses PEF in Corpus C, where it shows 3.2x the QPS of PEF while using only 2.6x the space. Examining DQ, the ratio of QPS to bits-per-posting, we see that BitFunnel outperforms PEF by factors of 1.3, 3.1, and 4.2 in Corpora C, D, and E, respectively, while PEF outperforms BitFunnel by factors of 3.4 and 1.6 in Corpora A and B. These results are consistent with the interpretation that the biggest factor in BitFunnel performance is row length, which is directly proportional to the number of documents in the corpus. As document lengths increase and the corpus size drops, BitFunnel performance improves relative to PEF.\nIt is unclear from these results, the extent to which BitFunnel's performance gains are the result of a careful implementation versus actual algorithmic gains. We can see from PEF vs MG4J that choice of implementation language can have a significant impact on performance. Since BitFunnel compiles each query into x64 machine code, it is likely that some of BitFunnel's gains come from highly optimized query code.", "publication_ref": ["b22", "b5", "b17"], "figure_ref": [], "table_ref": ["tab_3"]}, {"heading": "CONCLUSION", "text": "This work revisits bit-sliced signatures and describes their use in a commercial search engine, which previously used inverted files. Signature-based approaches introduce several challenges and we develop a set of techniques to reduce the memory footprint and to process queries quickly. Furthermore, we derive a performance model that allows expressing the system configuration as an optimization problem. We evaluate the key techniques behind BitFunnel experimentally, and we provide the source code publicly to accelerate advances in this area.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "ACKNOWLEDGMENTS", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "", "text": "We thank the following colleagues for their contributions to BitFunnel: Andrija Antonijevic, Tanj Bennett, Denis Deyneko, Utkarsh Jain, and Fan Wang. We also thank the anonymous reviewers for their feedback which led to an improved experimental section.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Space/time trade-offs in hash coding with allowable errors", "journal": "Commun. ACM", "year": "1970", "authors": "H Burton;  Bloom"}, {"ref_id": "b1", "title": "The Anatomy of a Large-Scale Hypertextual Web Search Engine", "journal": "Computer Networks", "year": "1998", "authors": "Sergey Brin; Lawrence Page"}, {"ref_id": "b2", "title": "Weighted bloom filter", "journal": "IEEE", "year": "2006", "authors": "Jehoshua Bruck; Jie Gao; Anxiao Jiang"}, {"ref_id": "b3", "title": "Information retrieval: Implementing and evaluating search engines", "journal": "Mit Press", "year": "2016", "authors": "Stefan B\u00fcttcher; L A Charles; Gordon V Clarke;  Cormack"}, {"ref_id": "b4", "title": "Scalability Challenges in Web Search Engines", "journal": "Morgan & Claypool Publishers", "year": "2015", "authors": "Barla Berkant; Ricardo A Cambazoglu;  Baeza-Yates"}, {"ref_id": "b5", "title": "Efficient set intersection for inverted indexing", "journal": "ACM Transactions on Information Systems (TOIS)", "year": "2010", "authors": "Shane Culpepper; Alistair Moffat"}, {"ref_id": "b6", "title": "Fast set intersection in memory", "journal": "", "year": "2011", "authors": "Bolin Ding; Arnd Christian K\u00f6nig"}, {"ref_id": "b7", "title": "Access methods for text", "journal": "ACM Computing Surveys (CSUR)", "year": "1985", "authors": "Chris Faloutsos"}, {"ref_id": "b8", "title": "Information retrieval: data structures and algorithms", "journal": "Prentice Hall PTR", "year": "1992", "authors": "Christos Faloutsos"}, {"ref_id": "b9", "title": "Design of a Signature File Method that Accounts for Non-Uniform Occurrence and Query Frequencies", "journal": "", "year": "1985", "authors": "Christos Faloutsos; Stavros Christodoulakis"}, {"ref_id": "b10", "title": "Information retrieval: data structures and algorithms", "journal": "Prentice Hall PTR", "year": "1992", "authors": "Edward Fox; Donna Harman; Ricardo Lee;  Baeza-Yates"}, {"ref_id": "b11", "title": "Topsig: Topology preserving document signatures", "journal": "ACM", "year": "2011", "authors": "Shlomo Geva; Christopher M De Vries"}, {"ref_id": "b12", "title": "Skewed partial bitvectors for list intersection", "journal": "ACM", "year": "2014", "authors": "Andrew Kane; Frank Wm Tompa"}, {"ref_id": "b13", "title": "A signature file scheme based on multiple organizations for indexing very large text databases", "journal": "Journal of the American Society for Information Science", "year": "1990", "authors": "A Kent; Ron Sacks-Davis; Kotagiri Ramamohanarao"}, {"ref_id": "b14", "title": "The Art of Computer Programming", "journal": "Addison-Wesley", "year": "1998", "authors": "E Donald;  Knuth"}, {"ref_id": "b15", "title": "Faster and smaller inverted indices with treaps", "journal": "ACM", "year": "2013", "authors": "Roberto Konow; Gonzalo Navarro; L A Charles; Alejandro Clarke;  L\u00f3pez-Ort\u00edz"}, {"ref_id": "b16", "title": "Decoding billions of integers per second through vectorization", "journal": "Software: Practice and Experience", "year": "2015", "authors": "Daniel Lemire; Leonid Boytsov"}, {"ref_id": "b17", "title": "Toward reproducible baselines: The open-source ir reproducibility challenge", "journal": "Springer", "year": "2016", "authors": "Jimmy Lin; Matt Crane; Andrew Trotman; Jamie Callan; Ishan Chattopadhyaya; John Foley; Grant Ingersoll; Craig Macdonald; Sebastiano Vigna"}, {"ref_id": "b18", "title": "Building a distributed full-text index for the Web", "journal": "", "year": "2001-05-01", "authors": "Sergey Melnik; Sriram Raghavan; Beverly Yang; Hector Garcia-Molina"}, {"ref_id": "b19", "title": "Self-indexing inverted files for fast text retrieval", "journal": "ACM Transactions on Information Systems (TOIS)", "year": "1996", "authors": "Alistair Moffat; Justin Zobel"}, {"ref_id": "b20", "title": "Application of random codes to the gathering of statistical information", "journal": "Ph.D. Dissertation. Massachusetts Institute of Technology", "year": "1948", "authors": "N Calvin;  Mooers"}, {"ref_id": "b21", "title": "Zatocoding applied to mechanical organization of knowledge", "journal": "American documentation", "year": "1951", "authors": "N Calvin;  Mooers"}, {"ref_id": "b22", "title": "Partitioned elias-fano indexes", "journal": "ACM", "year": "2014", "authors": "Giuseppe Ottaviano; Rossano Venturini"}, {"ref_id": "b23", "title": "Maguro, a system for indexing and searching over very large text collections", "journal": "", "year": "2013-02-04", "authors": "Trishul M Knut Magne Risvik; Henry Chilimbi; Karthik Tan; Chris Kalyanaraman;  Anderson"}, {"ref_id": "b24", "title": "Partial-match retrieval via the method of superimposed codes", "journal": "", "year": "1979", "authors": "S Charles;  Roberts"}, {"ref_id": "b25", "title": "Multikey access methods based on superimposed coding techniques", "journal": "ACM Transactions on Database Systems (TODS)", "year": "1987", "authors": "Ron Sacks-Davis; Kotagiri Kent;  Ramamohanarao"}, {"ref_id": "b26", "title": "Bit Transposed Files", "journal": "Citeseer", "year": "1985", "authors": "K T Harry; Hsiu-Fen Wong; Frank Liu; Doron Olken; Linda Rotem;  Wong"}, {"ref_id": "b27", "title": "Inverted files versus signature files for text indexing", "journal": "ACM Transactions on Database Systems (TODS)", "year": "1998", "authors": "Justin Zobel; Alistair Moffat; Kotagiri Ramamohanarao"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 1 :1Figure 1: Layout with bit-sliced signatures, in which each column is a document signature. Q is the signature of the query.", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Figure 2 :2Figure 2: Bit-sliced signature layout. Rows 2, 5, and 9 yield documents B and F .", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Figure 3 :3Figure 3: BitFunnel cluster.", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_5", "figure_caption": "Figure 4 :4Figure 4: Forming higher rank equivalents of a single row.", "figure_data": ""}, {"figure_label": "5", "figure_type": "figure", "figure_id": "fig_7", "figure_caption": "Figure 5 :5Figure 5: Intersecting different rows with different ranks.", "figure_data": ""}, {"figure_label": "7", "figure_type": "figure", "figure_id": "fig_10", "figure_caption": "Figure 7 :7Figure 7: A term maps to three rows with different ranks. Since a row is shared with other terms, it contains signal and noise bits but has constant bit density.", "figure_data": ""}, {"figure_label": "8", "figure_type": "figure", "figure_id": "fig_11", "figure_caption": "Figure 8 :8Figure 8: Noise in rank-0 equivalent rows.", "figure_data": ""}, {"figure_label": "910", "figure_type": "figure", "figure_id": "fig_12", "figure_caption": "Figure 9 :Figure 10 :910Figure 9: Three rank-2 rows.", "figure_data": ""}, {"figure_label": "11", "figure_type": "figure", "figure_id": "fig_13", "figure_caption": "Figure 11 :11Figure 11: Intersection time increases with quadwords.", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "Corpora.   ", "figure_data": "ABCDEMin terms641282561,024 2,048Max terms1272555112,047 4,095Documents (M) 5.870 7.545 3.7260.494 0.157Total terms (M) 4.181 6.524 6.647 10.109 9.697Postings (M)563 1,411 1,268687432Matches/query 1,115 3,561 5,1243,728 3,688Input text (GB)6.85 25.48 21.0222.89 20.26"}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_2", "figure_caption": "Impact of BitFunnel Innovations.", "figure_data": "Treatment Density Bits/Posting kQPSDQBSS0.0580.014.0175BSS0.1050.011.3225BSS0.1546.79.1194BSS0.2040.08.2204BSS0.2536.06.9191BSS-FC0.0523.429.5 1,263BSS-FC0.1016.825.5 1,515BSS-FC0.1514.724.0 1,632BSS-FC0.2013.121.4 1,634BSS-FC0.2512.619.4 1,547BTFNL0.0522.165.2 2,954BTFNL0.1016.057.7 3,595BTFNL0.1513.757.0 4,163BTFNL0.2012.546.7 3,746BTFNL0.2511.941.6 3,510"}, {"figure_label": "3", "figure_type": "table", "figure_id": "tab_3", "figure_caption": "Query Processing Performance.", "figure_data": "BitFunnelPEF MG4J LuceneQPS21,427 14,675 6,8666,310False positives (%)1.620.000.000.00ABits per posting38.437.647.85\u015bDQ5581,921875\u015bQPS8,6745,049 3,6363,011False positives (%)4.320.000.000.00BBits per posting20.727.337.59\u015bDQ419689479\u015bQPS12,7223,959 3,0964,120False positives (%)3.880.000.000.00CBits per posting16.916.636.88\u015bDQ752598450\u015bQPS57,0148,268 5,9003,632False positives (%)2.430.000.000.00DBits per posting13.696.256.28\u015bDQ4,1631,322939\u015bQPS105,782 13,151 7,3494,991False positives (%)2.640.000.000.00EBits per posting11.696.156.15\u015bDQ9,0472,139 1,195\u015b"}], "formulas": [{"formula_id": "formula_0", "formula_text": "C = {documents D} D = {terms t }", "formula_coordinates": [1.0, 391.24, 635.4, 73.83, 22.54]}, {"formula_id": "formula_1", "formula_text": "Q = {terms t }", "formula_coordinates": [1.0, 391.01, 695.03, 51.72, 8.67]}, {"formula_id": "formula_2", "formula_text": "M = {D \u2208 C | Q = D \u2229 Q }", "formula_coordinates": [2.0, 125.63, 120.57, 96.27, 8.67]}, {"formula_id": "formula_3", "formula_text": "Postin\u0434s(t) = {D \u2208 C | t \u2208 D}", "formula_coordinates": [2.0, 119.37, 298.55, 108.74, 8.67]}, {"formula_id": "formula_4", "formula_text": "M = t \u2208Q Postin\u0434s(t)", "formula_coordinates": [2.0, 136.82, 341.48, 74.11, 18.8]}, {"formula_id": "formula_5", "formula_text": "# \u00bb s D = t \u2208D #\u00bb s t", "formula_coordinates": [2.0, 151.9, 636.0, 43.68, 19.79]}, {"formula_id": "formula_6", "formula_text": "# \u00bb s Q = t \u2208Q #\u00bb s t Document D is said to be a member of M \u2032 when # \u00bb s Q \u2229 # \u00bb s D = # \u00bb s Q", "formula_coordinates": [2.0, 151.85, 85.18, 342.26, 621.37]}, {"formula_id": "formula_7", "formula_text": "M \u2032 = {D \u2208 C | # \u00bb s Q \u2229 # \u00bb s D = # \u00bb s Q }", "formula_coordinates": [2.0, 383.41, 178.05, 109.02, 12.23]}, {"formula_id": "formula_8", "formula_text": "M \u2032 = for all D \u2208 C do if # \u00bb s D \u2229 # \u00bb s Q = # \u00bb s Q then M \u2032 = M \u2032 \u222a {D} end if end for", "formula_coordinates": [2.0, 326.83, 226.01, 92.88, 65.4]}, {"formula_id": "formula_9", "formula_text": "#\u00bb a = \u223c0 for all i where # \u00bb s Q [i] == 1 do #\u00bb a = #\u00bb a & # \u00bb row i end for M \u2032 = {i | #\u00bb a [i] 0}", "formula_coordinates": [2.0, 326.83, 653.92, 108.29, 53.33]}, {"formula_id": "formula_10", "formula_text": "0 A B 0 C D 0 E F 0 G H 0 I J 0 K L 0 M N 0 O P 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 Q 1", "formula_coordinates": [3.0, 83.21, 85.75, 199.11, 174.65]}, {"formula_id": "formula_11", "formula_text": "0 A B 0 C D 0 E F 0 G H 0 I J 0 K L 0 M N 0 O P 2 5 9", "formula_coordinates": [3.0, 105.08, 329.58, 177.53, 58.67]}, {"formula_id": "formula_12", "formula_text": "1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 2 \u2229 5 \u2229 9", "formula_coordinates": [3.0, 74.22, 329.58, 208.97, 49.26]}, {"formula_id": "formula_13", "formula_text": "i r = i 0 2 r +w + (i 0 mod 2 r )(1)", "formula_coordinates": [4.0, 128.38, 386.55, 165.66, 20.61]}, {"formula_id": "formula_14", "formula_text": "0 0 0 0 1 1 1 1 1 1 1 1 1 0 1", "formula_coordinates": [4.0, 113.36, 468.47, 130.8, 69.53]}, {"formula_id": "formula_15", "formula_text": "0 0 0 0 1 1 1 1 1 1 1 1 0 1", "formula_coordinates": [4.0, 377.52, 162.23, 130.8, 101.09]}, {"formula_id": "formula_16", "formula_text": "0 0 0 0 1 1 1 1 1 1 1 1 0 1 0 0 0 0 1 0 1 0 0 0 1 1 0 0 0 0 1 0 1 0 0 0 0 0 1 1", "formula_coordinates": [4.0, 377.69, 374.39, 162.32, 27.48]}, {"formula_id": "formula_17", "formula_text": "|H (n, t)| = k, \u2200 t \u2208L", "formula_coordinates": [5.0, 139.81, 137.67, 67.79, 9.75]}, {"formula_id": "formula_18", "formula_text": "\u03b1 = (1 \u2212 s)d k", "formula_coordinates": [5.0, 149.3, 311.45, 47.79, 11.04]}, {"formula_id": "formula_19", "formula_text": "\u03d5 = s (1 \u2212 s)d k", "formula_coordinates": [5.0, 148.16, 342.29, 48.79, 21.63]}, {"formula_id": "formula_20", "formula_text": "k = lo\u0434 d s (1 \u2212 s)\u03d5", "formula_coordinates": [5.0, 135.2, 395.91, 67.79, 20.61]}, {"formula_id": "formula_21", "formula_text": "s r = 1 \u2212 (1 \u2212 s 0 ) 2 r (2)", "formula_coordinates": [6.0, 140.41, 312.34, 153.63, 13.25]}, {"formula_id": "formula_22", "formula_text": "0 0 0 0 S U U U U S 0 U 0 0 0 0 S 0 U 0 0 0 0 C 0 U 0 0 0 0 C 0 U 0 0 0 0 0 U U C Results 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 S U S S S S C U U U U", "formula_coordinates": [6.0, 342.73, 174.75, 198.38, 48.38]}, {"formula_id": "formula_23", "formula_text": "6", "formula_coordinates": [6.0, 320.84, 438.05, 3.38, 7.08]}, {"formula_id": "formula_24", "formula_text": "n 0 = n r + s r \u2212 s 0", "formula_coordinates": [7.0, 142.74, 361.62, 61.5, 9.5]}, {"formula_id": "formula_25", "formula_text": "s r = 1 \u2212 (1 \u2212 s 0 ) 2 r : n 0 \u2212 n r = s r \u2212 s 0 = 1 \u2212 (1 \u2212 s 0 ) 2 r \u2212 s 0 (3)", "formula_coordinates": [7.0, 78.88, 385.92, 215.17, 29.54]}, {"formula_id": "formula_26", "formula_text": "c i = 1 \u2212 (1 \u2212 s 0 ) 2 r i \u2212 s 0", "formula_coordinates": [7.0, 131.08, 679.32, 84.79, 13.25]}, {"formula_id": "formula_27", "formula_text": "u i+1 = (u i + c i \u2212 c i+1 )n i+1", "formula_coordinates": [7.0, 389.03, 168.29, 97.05, 9.5]}, {"formula_id": "formula_28", "formula_text": "a i = c i + u i", "formula_coordinates": [7.0, 416.49, 210.06, 41.7, 9.33]}, {"formula_id": "formula_29", "formula_text": "\u03d5 i = s 0 a i = s 0 c i + u i(4)", "formula_coordinates": [7.0, 404.64, 236.77, 153.56, 21.56]}, {"formula_id": "formula_30", "formula_text": "P BZ (N > i) = 1 \u2212 s 0 \u2212 a i Define P A (N > i)", "formula_coordinates": [7.0, 317.96, 580.77, 164.71, 25.23]}, {"formula_id": "formula_31", "formula_text": "P A (N > i) = 1 \u2212 (P BZ (N > i)) b", "formula_coordinates": [7.0, 380.37, 631.13, 114.17, 12.11]}, {"formula_id": "formula_32", "formula_text": "E(N ) = n i=1 P A (N > i) = n i=1 1 \u2212 (1 \u2212 s 0 \u2212 a i ) b", "formula_coordinates": [7.0, 354.64, 683.62, 165.76, 28.33]}, {"formula_id": "formula_33", "formula_text": "E(N ) = n i=1 1 \u2212 (1 \u2212 s 0 \u2212 a i ) b 2 r i(5)", "formula_coordinates": [8.0, 119.96, 168.78, 174.09, 28.33]}, {"formula_id": "formula_34", "formula_text": "d = b 1 b 1 + b 0 Rearranging, we get b 0 = b 1 d \u2212 b 1", "formula_coordinates": [8.0, 53.8, 362.77, 142.89, 59.39]}, {"formula_id": "formula_35", "formula_text": "b 0 + b 1 = b 1 d = s r |C| d2 r", "formula_coordinates": [8.0, 134.49, 454.0, 76.83, 20.78]}, {"formula_id": "formula_36", "formula_text": "q \u2208Q s r (q) d2 r (6)", "formula_coordinates": [8.0, 156.32, 549.26, 137.73, 25.15]}, {"formula_id": "formula_37", "formula_text": "DQ \u221d 1 n i=1 1\u2212(1\u2212s 0 \u2212a i ) b 2 r i q \u2208Q s r (q) d(7)", "formula_coordinates": [8.0, 361.32, 100.47, 196.88, 30.59]}], "doi": "10.1145/3077136.3080789"}