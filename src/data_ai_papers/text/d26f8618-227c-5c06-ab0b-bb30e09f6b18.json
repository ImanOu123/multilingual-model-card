{"title": "A Formal Study of Information Retrieval Heuristics", "authors": "Hui Fang; Tao Tao; Chengxiang Zhai", "pub_date": "", "abstract": "Empirical studies of information retrieval methods show that good retrieval performance is closely related to the use of various retrieval heuristics, such as TF-IDF weighting. One basic research question is thus what exactly are these \"necessary\" heuristics that seem to cause good retrieval performance. In this paper, we present a formal study of retrieval heuristics. We formally define a set of basic desirable constraints that any reasonable retrieval function should satisfy, and check these constraints on a variety of representative retrieval functions. We find that none of these retrieval functions satisfies all the constraints unconditionally. Empirical results show that when a constraint is not satisfied, it often indicates non-optimality of the method, and when a constraint is satisfied only for a certain range of parameter values, its performance tends to be poor when the parameter is out of the range. In general, we find that the empirical performance of a retrieval formula is tightly related to how well it satisfies these constraints. Thus the proposed constraints provide a good explanation of many empirical observations and make it possible to evaluate any existing or new retrieval formula analytically.", "sections": [{"heading": "INTRODUCTION", "text": "Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. SIGIR'04, July 25-29, 2004, Sheffield, South Yorkshire, UK. Copyright 2004 ACM 1-58113-881-4/04/0007 ...$5.00.\nThe study of retrieval models is central to information retrieval. Many different retrieval models have been proposed and tested, including vector space models [13,12,10], probabilistic models [7,16,15,3,6,5], and logic-based models [17,19,2]. Despite this progress in the development of formal retrieval models, good empirical performance rarely comes directly from a theoretically well-motivated model; rather, heuristic modification of a model is often necessary in order to achieve optimal retrieval performance. Indeed, many empirical studies show that good retrieval performance is closely related to the use of various retrieval heuristics, especially TF-IDF weighting and document length normalization. Many empirically effective retrieval formulas tend to boil down to an explicit or implicit implementation of these retrieval heuristics, even though they may be motivated quite differently [18]. Even the recently developed language modeling approach has been shown to be connected with these heuristics [20]. It thus appears that these heuristics are somehow necessary for achieving good retrieval performance. However, it is unclear at all what exactly are these \"necessary heuristics\" mathematically. A basic research question is then how we can formally define and characterize these necessary retrieval heuristics.\nIn this paper, we present a formal study of retrieval heuristics. We formally define a set of basic desirable constraints that any reasonable retrieval formula should satisfy, and check these constraints on a variety of retrieval formulas, which respectively represent the vector space model (pivoted normalization), the classic probabilistic retrieval model (Okapi), and the recently proposed language modeling approach (Dirichlet prior smoothing). We find that none of these retrieval formulas satisfies all the constraints unconditionally, though some formulas violate more constraints or violate some constraints more \"seriously\" than others. Empirical results show that when a constraint is not satisfied, it often indicates non-optimality of the method, and when a constraint is satisfied only for a certain range of parameter values, its performance tends to be poor when the parameter is out of the range. In general, we find that the empirical performance of a retrieval formula is tightly related to how well it satisfies these constraints. Thus the proposed constraints provide a good explanation of many empirical observations about retrieval methods. Moreover, these constraints make it possible to evaluate any existing or new retrieval formula analytically and suggest how we may further improve a retrieval formula.\nThe rest of the paper is organized as follows. We first present six formal constraints in Section 2. In Section 3, we apply these constraints to a variety of representative retrieval formulas and propose some hypotheses about the performance behavior of these formulas based on the analysis results. We test these hypotheses with systematic experiments in Section 4. Finally, we discuss our findings and future research directions in Section 5.", "publication_ref": ["b12", "b11", "b9", "b6", "b15", "b14", "b2", "b5", "b4", "b16", "b18", "b1", "b17", "b19"], "figure_ref": [], "table_ref": []}, {"heading": "FORMAL DEFINITIONS OF HEURISTIC RETRIEVAL CONSTRAINTS", "text": "In this section, we formally define six intuitive and desirable constraints that any reasonable retrieval formula should satisfy. They capture the commonly used retrieval heuristics, such as TF-IDF weighting, in a formal way, making it possible to apply them to any retrieval formula analytically.\nThese constraints are motivated by the following observations on some common characteristics of typical retrieval formulas. First, most retrieval methods assume a \"bag of words\" (more precisely, \"bag of terms\") representation of both documents and queries. Second, a highly effective retrieval function typically involves a TF part, an IDF part, and a document length normalization part [11,21]. The TF part intends to give a higher score to a document that has more occurrences of a query term, while the IDF part is to penalize words that are popular in the whole collection. The document length normalization is to avoid favoring long documents; long documents generally have more chances to match a query term simply because they contain more words. Finally, different retrieval formulas do differ in their way of combining all these factors, even though their empirical performances may be similar.\nThese observations suggest that there are some \"basic requirements\" that all reasonable retrieval formulas should follow. For example, if a retrieval formula does not penalize common words, then it somehow violates the \"IDF requirement\", thus can be regarded as \"unreasonable.\" However, some of these requirements may compromise each other. For example, while the TF heuristic intends to assign a higher score to a document that has more occurrences of a query term, the document length normalization component may cause a long document with a higher TF to receive a lower score than a short document with a lower TF. Similarly, if two documents match precisely one single, but different query term, the IDF heuristic may allow a document with a lower TF to \"beat\" the one with a much higher TF. A critical question is thus how we can regulate such interactions so that they will all be \"playing a fair game\"? Clearly, in order to answer this question, we must first define what is a \"fair game\", i.e., we must define what exactly is a reasonable retrieval function.\nOur idea is to characterize a reasonable retrieval formula by listing the desirable constraints that any reasonable retrieval formula must satisfy. We now formally define six such desirable constraints. Note that these constraints are necessary, but not necessarily sufficient, and should not be regarded as the only constraints that we want a retrieval function to satisfy; indeed, it is not hard to come up with additional constraints that may also make sense. However, we focus on these six basic constraints in this paper because they capture the major well-known IR heuristics, particularly TF-IDF weighting and length normalization.\nLet us first introduce some notations. We use d or d i to denote a document, q to denote a query, w or w i to represent a query term, and w \u2032 to represent a non-query term. c(w, d) is the count of word w in document d. |d| denotes the length of document d. f denotes a retrieval function, and f (d, q) gives the score of document d with respect to query q. idf (w) denotes any IDF-like discrimination value of a term w.", "publication_ref": ["b10", "b20"], "figure_ref": [], "table_ref": []}, {"heading": "Term Frequency Constraints (TFCs)", "text": "TFC1: Let q = {w} be a query with only one term w. \n) = 1, then f (d 2 , q) \u2212 f (d 1 , q) > f (d 3 , q) \u2212 f (d 2 , q).\nBoth constraints are to capture the desired contribution of the TF of a term to scoring. The first constraint captures the basic TF heuristic, which gives a higher score to a document with more occurrences of a query term when the only difference between two documents is the occurrences of the query term. In other words, the score of retrieval formula will increase with the increase in TF (i.e., the first partial derivative of the formula w.r.t. the TF variable should be positive). The second constraint ensures that the increase in the score due to an increase in TF is smaller for larger TFs (i.e., the second partial derivative w.r.t. the TF variable should be negative). Here, the intuition is that the change in the score caused by increasing TF from 1 to 2 should be larger than that caused by increasing TF from 100 to 101. Interestingly, it can be shown that the TFC2 constraint also implies another desirable property -if two documents have the same total occurrences of all query terms, a higher score will be given to the document covering more distinct query terms. This property can be formalized as follows. Let q be a query and w 1 , w 2 \u2208 q be two query terms. Assume ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Term Discrimination Constraint (TDC)", "text": "TDC: Let q be a query and w 1 , w 2 \u2208 q be two query terms. Assume |d\n1 | = |d 2 |, c(w 1 , d 1 )+c(w 2 , d 1 ) = c(w 1 , d 2 )+ c(w 2 , d 2 ). If idf (w 1 ) \u2265 idf (w 2 ) and c(w 1 , d 1 ) \u2265 c(w 1 , d 2 ), then f (d 1 , q) \u2265 f (d 2 , q).\nThis constraint regulates the interaction between TF and IDF, and accurately describes the effect of using IDF in scoring. It ensures that, given a fixed number of occurrences of query terms, we should favor a document that has more occurrences of discriminative terms (i.e., high IDF terms). Clearly, simply weighting each term with an IDF factor does not ensure that this constraint be satisfied. When applying this constraint, IDF can be any reasonable measure of term discrimination value (usually based on term popularity in a collection).  to favor a document with more occurrence of a query term TFC2 to favor document matching more distinct query terms TFC2 to make sure that the change in the score caused by increasing TF from 1 to 2 is larger than that caused by increasing TF from 100 to 101. TDC to regulate the impact of TF and IDF LNC1 to penalize a long document(assuming equal TF) LNC2, TF-LNC to avoid over-penalizing a long document TF-LNC to regulate the interaction of TF and document length", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Length Normalization Constraints (LNCs)", "text": ") = k \u2022 c(w, d 2 ), then f (d 1 , q) \u2265 f (d 2 , q).\nThe first constraint says that the score of a document should decrease if we add one extra occurrence of a \"nonrelevant word\" (i.e., a word not in the query), thus intends to penalize long documents. The second constraint intends to avoid over-penalizing long documents, as it says that if we concatenate a document with itself k times to form a new document, then the score of the new document should not be lower than the original document. Here, we make the assumption that the redundance issue is not considered.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "TF-LENGTH Constraint (TF-LNC)", "text": "TF-LNC: Let q = {w} be a query with only one term w.\nIf c(w, d 1 ) > c(w, d 2 ) and |d 1 | = |d 2 | + c(w, d 1 ) \u2212 c(w, d 2 ), then f (d 1 , q) > f (d 2 , q).\nThis constraint regulates the interaction between TF and document length. The intuition is that if d 1 is generated by adding more occurrences of the query term to d 2 , the score of d 1 should be higher than d 2 .\nBased on TF-LNC and LNC1, it is not hard to derive the following constraint: Let q = {w} be a query with only one term w. \nf (d 3 , q) \u2265 f (d 1 , q). Since f (d 1 , q) > f (d 2 , q) follows from TF-LNC, it is clear that f (d 3 , q) > f (d 2 , q).\nThis constraint ensures that document d 1 , which has a higher TF for the query term, should have a higher score than d 2 , which has a lower TF, as long as d 1 is not too much longer than d 2 .\nThe first three constraints (i.e. TFCs and TDC) are intended to capture the desired scoring preferences when two documents have equal lengths. The other three constraints are applicable when we have variable document lengths. In Table 1, we summarize the intuitions behind each formalized constraint.\nThese constraints are basic and non-redundant in the sense that none of them can be derived from the others. Formally, suppose C i represents the set of all the retrieval functions satisfying the i-th Constraint, then we can show that \u2200i, j, \u2203e \u2208 C i , such that e \u2208 C i \u2212 C j .\nWe must emphasize that the constraints proposed in this section are necessary constraints for a \"reasonable\" retrieval formula, but not necessarily sufficient, and should not be re-garded as the only constraints that a \"reasonable\" retrieval formula needs to satisfy. Thus when a constraint is violated, we know the retrieval function may not perform well empirically since it is not entirely consistent with our intuitive preferences, but satisfying all the constraints does not necessarily guarantee good performance.", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_0"]}, {"heading": "ANALYSIS OF THREE REPRESENTA-TIVE RETRIEVAL FORMULAS", "text": "In this section, we apply the six constraints defined in the previous section to three specific retrieval formulas, which respectively represent the vector space model, the classical probabilistic retrieval model, and the language modeling approach. Our goal is to see how well each retrieval formula satisfies the proposed constraints. As will be shown, it turns out that none of these retrieval formulas satisfies all the constraints unconditionally, though some models violate more constraints or violate some constraints more \"seriously\" than others. The analysis thus suggests some hypotheses regarding the empirical behavior of these retrieval formulas, which will be tested in the next section.\nThe following notations will be used in this section: c(w, d) is the count of word w in the document d. c(w, q) is the count of word w in the query q. N is the total number of documents in the collection. df (w) is the number of documents that contain the term w. |d| is the length of document d. avdl is the average document length.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Pivoted Normalization Method", "text": "The pivoted normalization retrieval formula [14] is one of the best performing vector space retrieval formulas. In the vector space model, text is represented by a vector of terms. Documents are ranked by the similarity between the query vector and the document vector. According to [14], the pivoted normalization retrieval formula is\nw\u2208q\u2229d 1 + ln(1 + ln(c(w, d))) (1 \u2212 s) + s |d| avdl \u2022 c(w, q) \u2022 ln N + 1 df (w)\nThe results of analyzing the pivoted normalization formula TFCs and LNC1 are easily seen to be satisfied. We now examine some of the non-trivial constraints. First, let us check the TF-LNC constraint. Consider a common case when |d 1 | = avdl. It can be shown that the TF-LNC constraint is equivalent to the following constraint on the parameter s:\ns \u2264 h(c(w, d 1 )) \u2212 h(c(w, d 2 )) (c(w, d 1 ) \u2212 c(w, d 2 )) \u00d7 (1 + h(c(w, d 1 ))) \u00d7 avdl\nwhere h(x) = ln(1 + ln(x)). This means that TF-LNC is satisfied only if s is below a certain upper bound. The TF-LNC constraint thus provides an upper bound for s, which is tighter for a larger c(w, d 1 ).\nNext, we consider the TDC constraint. It can be shown that TDC is equivalent to c(w 2 , d 1 ) \u2265 c(w 1 , d 2 ), which is only conditionally satisfied.\nFinally, we show that the LNC2 leads to an upper bound for parameter s. The LNC2 constraint is equivalent to Therefore, the upper bound of s can be derived as:\n1 + ln(1 + ln(k \u00d7 c(w, d 2 ))) 1 \u2212 s + s k\u00d7|d 2 | avdl \u2022 c(w, q) \u2022 ln N + 1 df (w) \u2265 1 + ln(1 + ln(c(w, d 2 ))) 1 \u2212 s + s |d 2 | avdl \u2022 c(w, q) \u2022 ln N + 1 df (w)\ns \u2264 tf 1 \u2212 tf 2 (k |d 2 | avdl \u2212 1)tf 2 \u2212 ( |d 2 | avdl \u2212 1)tf 1 where tf 1 = 1 + ln(1 + ln(k \u00d7 c(w, d 2 ))), tf 2 = 1 + ln(1 + ln(c(w, d 2 ))).\nIn order to get a sense of what the bound is exactly, consider a common case when |d 2 | = avdl. We have\ns \u2264 1 k \u2212 1 \u00d7 ( tf 1 tf 2 \u2212 1).\nAs shown in the Figure 1, the bound becomes tighter when k increases or when the term frequency is larger. This bound shows that in order to avoid over-penalizing a long document, a reasonable value for s should be generally smallit should be below 0.4 even in the case of a small k, and we know that for a larger k the bound would be even tighter. This analysis thus suggests that the performance can be bad for a large s, which is confirmed by our experiments.", "publication_ref": ["b13", "b13"], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "Okapi Method", "text": "The Okapi formula is another highly effective retrieval formula that represents the classical probabilistic retrieval model [8]. The formula as presented in [14] is 1 w\u2208q\u2229d ln N \u2212 df (w) + 0.5 df (w) + 0.5\n\u00d7 (k 1 + 1) \u00d7 c(w, d) k 1 ((1 \u2212 b) + b |d| avdl ) + c(w, d) \u00d7 (k 3 + 1) \u00d7 c(w, q) k 3 + c(w, q)\nwhere k 1 (between 1.0-2.0), b (usually 0.75), and k 3 (between 0-1000) are constants.\nThe major difference between Okapi and other retrieval formulas is the possibly negative value of the IDF part in the formula, which has been discussed in [9]. It is trivial to show that if df (w) > N/2, the IDF value would be negative.\nWhen the IDF part is positive (which is mostly true for keyword queries), TFCs and LNCs are easily seen to be satisfied. By considering a common case when |d 2 | = avdl, the TF-LNC constraint is shown to be equivalent to b \u2264 avdl c(w,d 2 ) . As we know, the value of b is always smaller than 1. Therefore, TF-LNC can be satisfied unconditionally. Moreover, we can show that TDC is equivalent to c(w 1 , d 2 ) \u2264 c(w 2 , d 1 ), which is the same as the result for the pivoted normalization method.\nAlthough Okapi satisfies some constraints conditionally, unlike in the pivoted normalization method, the conditions do not provide any bound for the parameter b. Therefore, the performance of Okapi can be expected to be less sensitive to the length normalization parameter than the pivoted normalization method, which is confirmed by our experiments.\nWhen the IDF part is negative, the Okapi formula would clearly violate the TFCs, LNCs and TF-LNC, since matching an additional occurrence of a query term could mean decreasing the score. It would satisfy TDC when c(w 1 , d 2 ) > c(w 2 , d 1 ). Since a negative IDF only happens when a query term has a very high document frequency (e.g., when the query is verbose), our analysis suggests that the performance of Okapi may be relatively worse for verbose queries than for keyword queries.\nA simple way to solve the problem of negative IDF is to replace the original IDF in Okapi with the regular IDF in the pivoted normalization formula. This modified Okapi satisfies all the constraints but TDC. We thus hypothesize that the performance of the modified Okapi would perform better than the original Okapi for verbose queries. As will be shown later, this is indeed true according to our experiment results. The results of analyzing the Okapi formula are summarized in Table 3. We distinguish two forms of the formulathe original formula and the one with a modified IDF part. The modification significantly affects the constraint analysis results as discussed above.", "publication_ref": ["b7", "b8"], "figure_ref": [], "table_ref": ["tab_2"]}, {"heading": "Dirichlet Prior Method", "text": "The Dirichlet prior retrieval method is one of the best performing language modeling approaches [20]. This method uses the Dirichlet prior smoothing method to smooth a document language model and then ranks documents according to the likelihood of the query according to the estimated language model of each document. With a notation consistent with those in the pivoted normalization and Okapi formulas, the Dirichlet prior retrieval function is\nw\u2208q\u2229d c(w, q) \u2022 ln(1 + c(w, d) \u00b5 \u2022 p(w|C) ) + |q| \u2022 ln \u00b5 |d| + \u00b5\nwhere, |q| is the query length, and p(w|C) is the probability of a term w given by the collection language model. p(w|C) indicates how popular the term w is in the whole collection, thus is quite similar to the document frequency df (w). The The LNC2 constraint can be shown to be equivalent to c(w, d 2 ) \u2265 |d 2 |\u2022p(w|C), which is usually satisfied for contentcarrying words. If all the query terms are discriminative words, long documents will not be over-penalized. Thus, compared to pivoted normalization, Dirichlet prior appears to have a more robust length normalization mechanism, even though none of them satisfies the LNC2 constraint unconditionally.\nAnother interesting observation is that TDC constraint may lead to some lower bound for parameter \u00b5, as derived below. Assume p(w 1 |C) \u2264 p(w 2 |C) (roughly equivalent to idf (w 1 ) > idf (w 2 ) ). TDC implies\nln(1 + c(w 1 , d 1 ) \u00b5p(w 1 |C) ) + ln(1 + c(w 2 , d 1 ) \u00b5p(w 2 |C) ) + 2ln \u00b5 \u00b5 + |d 1 | \u2265 ln(1 + c(w 1 , d 2 ) \u00b5p(w 1 |C) ) + ln(1 + c(w 2 , d 2 ) \u00b5p(w 2 |C) ) + 2ln \u00b5 \u00b5 + |d 2 |\nAfter some simplification, we can obtain a lower bound for \u00b5:\n\u00b5 \u2265 c(w 1 , d 1 ) \u2212 c(w 2 , d 2 ) p(w 2 |C) \u2212 p(w 1 |C)\nIn order to have a sense of the exact value of this bound, let us consider a common case of w 2 such that p(w 2 |C) = 1 avdl (i.e. w 2 is expected to occur once in a document). We have\n\u00b5 > c(w 1 , d 1 ) \u2212 c(w 2 , d 2 ) p(w 2 |C) = avdl \u00d7 (c(w 1 , d 1 ) \u2212 c(w 2 , d 2 ))\nIt means that for discriminative words with a high term frequency in a document, \u00b5 needs to be sufficiently large (at least as large as the average document length) in order to balance TF and IDF appropriately. In general, the analysis shows that \u00b5 has a lower bound, and a very small \u00b5 might cause poor retrieval performance. This is also confirmed by our experiments. ", "publication_ref": ["b19"], "figure_ref": [], "table_ref": []}, {"heading": "Summary", "text": "We have applied our six constraints to three representative retrieval formulas. The results are summarized in Table 3.4, where a \"Yes\" means the corresponding model satisfies the particular constraint and a \"C x \" means corresponding model satisfies the particular constraint under some particular conditions (irrelevant to parameter setting), and a \"C *\nx \" means the model satisfies the constraint only when the parameter is in some range. The specific conditions are\nC 1 \u21d4 c(w 1 , d 2 ) \u2264 c(w 2 , d 1 ) C * 2 \u21d4 s \u2264 tf 1 \u2212 tf 2 (k |d 2 | avdl \u2212 1)tf 2 \u2212 ( |d 2 | avdl \u2212 1)tf 1 C * 3 \u21d4 s \u2264 (h(c(w, d 1 )) \u2212 h(c(w, d 2 ))) \u00d7 avdl (c(w, d 1 ) \u2212 c(w, d 2 )) \u00d7 (1 + h(c(w, d 1 ))) C * 4 \u21d4 \u00b5 \u2265 c(w 1 , d 1 ) \u2212 c(w 2 , d 2 ) p(w 2 |C) \u2212 p(w 1 |C) > avdl \u00d7 (c(w 1 , d 1 ) \u2212 c(w 2 , d 2 )) C 5 \u21d4 c(w, d 2 ) \u2265 |d 2 | \u2022 p(w|C) C 6 \u21d4 idf (w) \u2265 0 \u21d4 df (w) \u2264 N/2\nBased on the results, we can make several interesting observations:\nFirst, it is surprising that all the methods, including a highly effective TF-IDF model, fail to satisfy the TDC (essentially the IDF heuristics) unconditionally.\nSecond, it is also surprising that the original IDF part of Okapi formula causes the formula to violate almost all constraints, thus we may predict that the Okapi formula may have a worse performance for verbose queries.\nFinally, C 2 , C 3 and C 4 provide an approximate bound for the parameters in pivoted normalization method and Dirichlet prior method. In contrast, by checking the constraints, we have not found any particular bound for the parameter in Okapi. Therefore, we predict that the performance of Okapi is less sensitive to parameter setting than that of the other two methods.", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_2"]}, {"heading": "EXPERIMENTS", "text": "In the previous section, we have examined three representative retrieval formulas analytically. Based on the analysis, we propose some hypotheses about the performance for each retrieval formula. In this section, we test these hypotheses through carefully designed experiments. Our experiment results show that the proposed constraints can both explain the performance difference in various retrieval models and provide an approximate bound for the parameters in a retrieval formula. ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Experiment Design", "text": "As is well-known, retrieval performance can vary significantly from one test collection to another. We thus construct several quite different and representative test collections using the existing TREC test collections.\nTo cover different types of queries, we follow [20] , and vary two factors: query length and verbosity, which gives us four different combinations : short-keyword (SK, keyword title), short-verbose (SV, one sentence description), longkeyword (LK, keyword list), and long-verbose (LV, multiple sentences). The number of queries is usually larger than 50. To cover different types of documents, we construct our document collections by varying several factors, including (1) the type of documents; (2) document length; (3) collection size(varies from 165K documents to 528K documents); and (4) collection homogeneity. Our choice of document collection has been decided to be news articles (AP), technical reports (DOE), government documents (FR), a combination of AP, DOE, and FR (ADF), the Web data used in TREC8(Web), the ad hoc data used in TREC7(Trec7) and the ad hoc data used in TREC8(Trec8). Table 6 shows some document set characteristics, including the number of queries used on the document set, the average number of relevant documents per query, the collection size, the number of documents, the vocabulary size, the mean document length, the standard deviation of document length, and the mean length of relevant documents.\nThe preprocessing of documents and queries is minimum, involving only stemming with the Porter's stemmer. No stop words have been removed, as it would introduce at least one extra parameter (e.g., the number of stop words) into our experiments. On each test collection, for every retrieval method, we vary the retrieval parameter to cover a reasonably wide range of values. This allows us to see a complete picture of how sensitive each method is to its parameter.", "publication_ref": ["b19"], "figure_ref": [], "table_ref": ["tab_5"]}, {"heading": "Parameter Sensitivity", "text": "Based on the analysis in Section 3, we formulate the following hypotheses: (1) The pivoted normalization method is sensitive to the value of parameter s. The analysis of LNC2 suggests that the reasonable value for s should be generally smaller than 0.4 and the performance can be bad for a large s. (2) Okapi is more stable with the change of parameter b.\n(3) The Dirichlet prior method is sensitive to the value of parameter \u00b5. The analysis of TDC shows that \u00b5 has some lower bound, and a very small \u00b5 might cause poor retrieval performance.\nWe now discuss the experiment results. First, let us consider the experiment result for pivoted normalization. The optimal value of s is shown in Table 7. As shown in the table, the optimal value of s to maximize average precision has been found to be indeed quite small in all cases. Moreover, we also see that when s is large, which causes the method not to satisfy the LNC2 constraint, the performance is signifi- cantly worse. In Figure 2, we show how the average precision is influenced by the parameter value in the pivoted normalization method on the AP document set and long-keyword queries; the curves are similar for all other data sets.\nNext, we experiment with the Okapi method. Assume k 1 = 1.2, k 3 = 1000 and b changes from 0.1 to 1.0. The performance of Okapi is indeed more stable compared with the pivoted normalization (shown in Figure 2). By checking the constraints, we have not found any particular bound for the parameter, which may explain why the performance is much less sensitive to the parameter value than in the pivoted normalization method where a bound for parameter s is implied by the LNC2 constraint.  Finally, the optimal values of \u00b5 in Dirichlet are shown in Table 8. We see that these optimal values are all greater than the average document length, also shown in the same table. We further plot how the average precision is influenced by the parameter value in Figure 3. Clearly, when \u00b5 is larger than a specific value, the performance is relatively stable. However, when \u00b5 is small, the performance is noticeably worse. Therefore, in general it seems that the constraints could provide an empirical bound for the parameter in the retrieval  formula and the performance would tend to be poor when the parameter is out of the bound.", "publication_ref": [], "figure_ref": ["fig_6", "fig_6", "fig_3"], "table_ref": ["tab_6", "tab_7"]}, {"heading": "Performance Comparison", "text": "In this subsection, we compare the performance of these three retrieval formulas through systematic experiments. Our goal is to see whether the experiment results are consistent with the analytical results based on formalized heuristics. We form the following hypotheses based on the constraint analysis:(1) For any query type, the performance of Dirichlet prior method is comparable to pivoted normalization method when the retrieval parameters are set to an optimal value. (2) For keyword queries, the performance of Okapi is comparable to the other two retrieval formulas. (3) For verbose queries, the performance of Okapi may be worse than others, due to the possible negative IDF part in the formula. As mentioned in Section 3, when IDF is negative, Okapi violates almost all the constraints. However, if we modify the Okapi formula by replacing the original IDF part with IDF part of the pivoted normalization method, then the formula would satisfy almost all the constraints for any query type, therefore we hypothesize that the modified Okapi formula performs better than the original one for verbose queries.\nIn order to test these hypotheses, we run experiments over seven collections and four query sets by using the pivoted normalization method, the Dirichlet prior method, Okapi and the modified Okapi formula (which replaces the IDF part in Okapi with the IDF part in the pivoted normalization formula). We use average precision as the evaluation measure. The optimal performance for each formula is summarized in Table 9. The results show that for verbose queries, the performance of the Mod-Okapi is significantly better than that of Okapi; the p-values of the Wilcoxin signed rank test are all below 0.013.\nWe see that, indeed, for keyword queries, the performances of three retrieval formulas are comparable. However, for verbose queries, in most cases the performance of Okapi is worse than others, which may be caused by the negative IDF scores for common words. This hypothesis is verified by the performance of the modified Okapi. After replacing the IDF part in Okapi with the IDF part of the pivoted normalization formula, the performance is improved significantly for the verbose queries. See Figure 2 and Figure 4 for plots of these comparisons.\nFrom Figure 4, we may conclude that satisfying more con-   straints appears to be correlated with a better performance. Therefore, the proposed constraints provide a plausible explanation for the performance difference in various retrieval models, and suggest how we may improve a retrieval formula further.", "publication_ref": [], "figure_ref": ["fig_6", "fig_10", "fig_10"], "table_ref": ["tab_8"]}, {"heading": "CONCLUSIONS AND FUTURE WORK", "text": "In this paper, we study the problem of formalizing the necessary heuristics for good retrieval performance. Motivated by some observations on common characteristics of typical retrieval formulas, we formally define six basic constraints that any reasonable retrieval function should satisfy. These constraints correspond to some desirable intuitive heuristics, such as term frequency weighting, term discrimination weighting and document length normalization. We check these six constraints on three representative retrieval formulas analytically and derive specific conditions when a constraint is conditionally satisfied. The constraint analysis suggests many interesting hypotheses about the ex-pected performance behavior of all these retrieval functions. We design experiments to test these hypotheses using different types of queries and different document collections. We find that in many cases the empirical results are indeed consistent with these hypotheses. Specifically, when a constraint is not satisfied, it often indicates non-optimality of the method. This is most evident from the analysis of Okapi formula, based on which we successfully predict the nonoptimality for verbose queries. In some other cases, when a method only satisfies a constraint for a certain range of parameter values, its performance tends to be poor when the parameter is out of this range, which is evident in the analysis of the pivoted normalization and the Dirichlet prior. In general, we find that the empirical performance of a retrieval formula is tightly related to how well they satisfy these constraints. Thus the proposed constraints can provide a good explanation of many empirical observations (e.g., the relatively stable performance of the Okapi formula) and make it possible to evaluate any existing or new retrieval formula analytically, which is extremely valuable for testing new retrieval models. Moreover, when a constraint is not satisfied by a retrieval function, it also suggests a possible way to improve the retrieval formula.\nThere are many interesting future research directions based on this work. First, it will be interesting to repeat all the experiments by removing the stop words with a standard list to see if the way a retrieval formula treats stop words might have an impact on the results. Second, since our constraints do not cover all the desirable properties, it would be interesting to explore additional necessary heuristics for a reasonable retrieval formula. This will help us further understand the performance behavior of different retrieval methods. A more ambitious direction is to develop a constraint-based methodology for studying retrieval models (e.g., along the line of [4]). Third, we will apply these constraints to many other retrieval models proposed in the literature [1] and different smoothing methods for language models as well [20]. Previous work [11,21] has attempted to identify an effective retrieval formula through extensive empirical experiments, but the results are generally inconclusive with some formulas performing better under some conditions. Analysis of formalized retrieval constraints as explored in this paper may shed some light on what these conditions are exactly. Finally, the fact that none of the existing formulas that we have analyzed can satisfy all the constraints unconditionally suggests that it would be very interesting to see how we can improve the existing retrieval methods so that they would satisfy all the constraints, which presumably would perform better empirically than these existing methods.", "publication_ref": ["b3", "b0", "b19", "b10", "b20"], "figure_ref": [], "table_ref": []}, {"heading": "ACKNOWLEDGMENTS", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "", "text": "We thank anonymous reviewers for their useful comments. We also thank Robin Dhamanka and Jing Jiang for their help to improve the English in this paper.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Probabilistic models of information retrieval based on measuring the divergence from randomness", "journal": "ACM Transactions on Information Systems", "year": "2002", "authors": "G Amati; C J V Rijsbergen"}, {"ref_id": "b1", "title": "Language models and uncertain inference in information retrieval", "journal": "", "year": "", "authors": "N Fuhr"}, {"ref_id": "b2", "title": "Probabilistic models in information retrieval", "journal": "The Computer Journal", "year": "1992", "authors": "N Fuhr"}, {"ref_id": "b3", "title": "An impossibility theorem for clustering", "journal": "", "year": "2002", "authors": "J Kleinberg"}, {"ref_id": "b4", "title": "Probabilistic relevance models based on document and query generation", "journal": "Kluwer Academic Publishers", "year": "2003", "authors": "J Lafferty; C Zhai"}, {"ref_id": "b5", "title": "A language modeling approach to information retrieval", "journal": "", "year": "1998", "authors": "J Ponte; W B Croft"}, {"ref_id": "b6", "title": "Relevance weighting of search terms", "journal": "Journal of the American Society for Information Science", "year": "1976", "authors": "S Robertson; K ; Sparck Jones"}, {"ref_id": "b7", "title": "Some simple effective approximations to the 2-poisson model for probabilistic weighted retrieval", "journal": "", "year": "1994", "authors": "S Robertson; S Walker"}, {"ref_id": "b8", "title": "On relevance weights with little relevance information", "journal": "", "year": "1997", "authors": "S Robertson; S Walker"}, {"ref_id": "b9", "title": "Automatic Text Processing: The Transformation, Analysis and Retrieval of Information by Computer", "journal": "Addison-Wesley", "year": "1989", "authors": "G Salton"}, {"ref_id": "b10", "title": "Term-weighting approaches in automatic text retrieval", "journal": "Information Processing and Management", "year": "1988", "authors": "G Salton; C Buckley"}, {"ref_id": "b11", "title": "Introduction to Modern Information Retrieval", "journal": "McGraw-Hill", "year": "1983", "authors": "G Salton; M Mcgill"}, {"ref_id": "b12", "title": "A theory of term importance in automatic text analysis", "journal": "Journal of the American Society for Information Science", "year": "1975-02", "authors": "G Salton; C S Yang; C T Yu"}, {"ref_id": "b13", "title": "Modern information retrieval: A brief overview", "journal": "Bulletin of the IEEE Computer Society Technical Committee on Data Engineering", "year": "2001", "authors": "A Singhal"}, {"ref_id": "b14", "title": "Evaluation of an inference network-based retrieval model", "journal": "ACM Transactions on Information Systems", "year": "1991", "authors": "H Turtle; W B Croft"}, {"ref_id": "b15", "title": "A theoretical basis for theuse of co-occurrence data in information retrieval", "journal": "Journal of Documentation", "year": "1977", "authors": "C J Van Rijbergen"}, {"ref_id": "b16", "title": "A non-classical logic for information retrieval", "journal": "The Computer Journal", "year": "1986", "authors": "C J Van Rijsbergen"}, {"ref_id": "b17", "title": "Proceedings of Text REtrieval Conference", "journal": "NIST Special Publications", "year": "2001", "authors": "E Voorhees; D Harman"}, {"ref_id": "b18", "title": "On modeling information retrieval with probabilistic inference", "journal": "ACM Transactions on Information Systems", "year": "1995", "authors": "S K M Wong; Y Y Yao"}, {"ref_id": "b19", "title": "A study of smoothing methods for language models applied to ad hoc information retrieval", "journal": "", "year": "2001-09", "authors": "C Zhai; J Lafferty"}, {"ref_id": "b20", "title": "Exploring the similarity space", "journal": "SIGIR Forum", "year": "1998", "authors": "J Zobel; A Moffat"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Assume |d 1 |1= |d 2 |. If c(w, d 1 ) > c(w, d 2 ), then f (d 1 , q) > f (d 2 , q). TFC2: Let q = {w} be a query with only one term w. Assume |d 1 | = |d 2 | = |d 3 | and c(w, d 1 ) > 0. If c(w, d 2 ) \u2212 c(w, d 1 ) = 1 and c(w, d 3 ) \u2212 c(w, d 2", "figure_data": ""}, {"figure_label": "1", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "|d 1 |1= |d 2 | and idf (w 1 ) = idf (w 2 ). If c(w 1 , d 1 ) = c(w 1 , d 2 ) + c(w 2 , d 2 ) and c(w 2 , d 1 ) = 0, c(w 1 , d 2 ) = 0,c(w 2 , d 2 ) = 0, then f (d 1 , q) < f (d 2 , q).", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "LNC1:Let q be a query and d 1 , d 2 be two documents. If for some word w \u2032 / \u2208 q, c(w \u2032 , d 2 ) = c(w \u2032 , d 1 ) + 1 but for any query term w, c(w, d 2 ) = c(w, d 1 ), then f (d 1 , q) \u2265 f (d 2 , q). LNC2: Let q be a query. \u2200k > 1, if d 1 and d 2 are two documents such that |d 1 | = k \u2022 |d 2 | and for all terms w, c(w, d 1", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "If d 33is the document such that c(w, d 3 ) > c(w, d 2 ) and |d 3 | < |d 2 | + c(w, d 3 ) \u2212 c(w, d 2 ), then f (d 3 , q) > f (d 2 , q). The above constraint can be derived in the following way. Assume we have a document d 1 such that |d 1 | = |d 2 | + c(w, d 1 )\u2212c(w, d 2 ) and c(w, d 3 ) = c(w, d 1 ). It is obvious that the only difference between d 1 and d 3 is that d 1 has more occurrences of the non-query terms. According to LNC1, we know that", "figure_data": ""}, {"figure_label": "1", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "Figure 1 :1Figure 1: Upper bound of parameter s.", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_6", "figure_caption": "Figure 2 :2Figure 2: Performance Comparison between Okapi and Pivoted for AP-LK.", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_8", "figure_caption": "Figure 3 :3Figure 3: Performance of Dirichlet for AP-LK.", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_10", "figure_caption": "Figure 4 :4Figure 4: Performance Comparison between modified Okapi, Okapi and Pivoted for AP-SV.", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "Summary of intuitions for each formalized constraint Constraints Intuitions TFC1", "figure_data": ""}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "Constraint analysis results (Pivoted)", "figure_data": "TFCs TDC LNC1 LNC2 TF-LNCYesCond.YesCond.Cond."}, {"figure_label": "3", "figure_type": "table", "figure_id": "tab_2", "figure_caption": "Constraint analysis results (Okapi)", "figure_data": "Formula TFCs TDC LNC1 LNC2 TF-LNCOriginal Cond Cond Cond CondCondModifiedYesCondYesYesYes"}, {"figure_label": "4", "figure_type": "table", "figure_id": "tab_3", "figure_caption": "", "figure_data": "Constraint analysis results (Dirichlet)TFCs TDC LNC1 LNC2 TF-LNCYesCondYesCondYes"}, {"figure_label": "5", "figure_type": "table", "figure_id": "tab_4", "figure_caption": "Comparison between different retrieval formulas", "figure_data": "FormulaTFCsTDCLNC1 LNC2 TF-LNCPivoted Dirichlet OkapiYes Yes C 6C 1 C  *  4 C 1 \u2229 C 6Yes Yes C 6C  *  2 C 5 C 6C  *  3 Yes C 6(original)\u00acC 1 \u2229 \u00acC 6OkapiYesC 1YesYesYes(modified)"}, {"figure_label": "6", "figure_type": "table", "figure_id": "tab_5", "figure_caption": "Document set characteristic", "figure_data": "APDOEFRADFWebTrec7Trec8#qry1423542144505050#rel/q1035733126469395size491MB184MB469MB1GB2GB2GB2GB#doc(k)165K226K204K437K247K528K528K#voc(k)361K163K204K700K1968K908K908Kmean(dl)4541171338372975477477dev(dl)23958522617392536789789mean(rdl)546136124661515659611271325"}, {"figure_label": "7", "figure_type": "table", "figure_id": "tab_6", "figure_caption": "Optimal s (for average precision) in the pivoted normalization method", "figure_data": "APDOEFRADF Web Trec7 Trec8lk0.20.20.050.2---sk 0.010.20.010.050.010.050.05lv0.30.30.10.20.20.20.2sv0.20.30.10.20.10.10.2"}, {"figure_label": "8", "figure_type": "table", "figure_id": "tab_7", "figure_caption": "Optimal \u00b5 (for average precision) in the Dirichlet prior method", "figure_data": "APDOEFRADFWebTrec7 Trec8lk2000 2000 20000 1000---sk2000 20005000200040002000800lv3000 1000 15000 3000800030002000sv8000 4000 20000 3000 1000080005000avdl4541171338372975477477"}, {"figure_label": "9", "figure_type": "table", "figure_id": "tab_8", "figure_caption": "Comparison of optimal performance for four formulas.", "figure_data": "APDOEFRADF Web Trec7 Trec8lkPiv0.390.280.330.27---lkDir0.380.280.320.25---lk Okapi 0.380.270.280.33---lkMod-0.390.280.280.33---OkapiskPiv0.230.180.190.220.290.180.24skDir0.220.180.180.210.300.190.26sk Okapi 0.230.190.230.190.310.190.25sk Mod-0.230.190.230.190.310.190.25OkapilvPiv0.290.210.230.210.220.200.23lvDir0.290.230.240.240.280.220.26lv Okapi 0.030.070.090.060.230.080.11lvMod-0.300.240.250.230.280.260.25OkapisvPiv0.190.100.140.140.210.150.20svDir0.200.130.160.160.270.180.23sv Okapi 0.080.080.080.090.210.090.10sv Mod-0.190.120.160.140.250.160.22Okapi"}], "formulas": [{"formula_id": "formula_0", "formula_text": ") = 1, then f (d 2 , q) \u2212 f (d 1 , q) > f (d 3 , q) \u2212 f (d 2 , q).", "formula_coordinates": [2.0, 316.8, 194.27, 239.12, 19.74]}, {"formula_id": "formula_1", "formula_text": "1 | = |d 2 |, c(w 1 , d 1 )+c(w 2 , d 1 ) = c(w 1 , d 2 )+ c(w 2 , d 2 ). If idf (w 1 ) \u2265 idf (w 2 ) and c(w 1 , d 1 ) \u2265 c(w 1 , d 2 ), then f (d 1 , q) \u2265 f (d 2 , q).", "formula_coordinates": [2.0, 316.8, 489.65, 239.14, 30.12]}, {"formula_id": "formula_2", "formula_text": ") = k \u2022 c(w, d 2 ), then f (d 1 , q) \u2265 f (d 2 , q).", "formula_coordinates": [2.0, 344.28, 710.57, 160.24, 9.24]}, {"formula_id": "formula_3", "formula_text": "If c(w, d 1 ) > c(w, d 2 ) and |d 1 | = |d 2 | + c(w, d 1 ) \u2212 c(w, d 2 ), then f (d 1 , q) > f (d 2 , q).", "formula_coordinates": [3.0, 53.82, 334.01, 239.08, 19.68]}, {"formula_id": "formula_4", "formula_text": "f (d 3 , q) \u2265 f (d 1 , q). Since f (d 1 , q) > f (d 2 , q) follows from TF-LNC, it is clear that f (d 3 , q) > f (d 2 , q).", "formula_coordinates": [3.0, 53.82, 501.35, 239.08, 19.74]}, {"formula_id": "formula_5", "formula_text": "w\u2208q\u2229d 1 + ln(1 + ln(c(w, d))) (1 \u2212 s) + s |d| avdl \u2022 c(w, q) \u2022 ln N + 1 df (w)", "formula_coordinates": [3.0, 340.56, 593.57, 190.42, 24.68]}, {"formula_id": "formula_6", "formula_text": "s \u2264 h(c(w, d 1 )) \u2212 h(c(w, d 2 )) (c(w, d 1 ) \u2212 c(w, d 2 )) \u00d7 (1 + h(c(w, d 1 ))) \u00d7 avdl", "formula_coordinates": [4.0, 64.02, 125.75, 218.51, 21.12]}, {"formula_id": "formula_7", "formula_text": "1 + ln(1 + ln(k \u00d7 c(w, d 2 ))) 1 \u2212 s + s k\u00d7|d 2 | avdl \u2022 c(w, q) \u2022 ln N + 1 df (w) \u2265 1 + ln(1 + ln(c(w, d 2 ))) 1 \u2212 s + s |d 2 | avdl \u2022 c(w, q) \u2022 ln N + 1 df (w)", "formula_coordinates": [4.0, 71.76, 254.64, 185.26, 52.1]}, {"formula_id": "formula_8", "formula_text": "s \u2264 tf 1 \u2212 tf 2 (k |d 2 | avdl \u2212 1)tf 2 \u2212 ( |d 2 | avdl \u2212 1)tf 1 where tf 1 = 1 + ln(1 + ln(k \u00d7 c(w, d 2 ))), tf 2 = 1 + ln(1 + ln(c(w, d 2 ))).", "formula_coordinates": [4.0, 53.82, 518.94, 239.06, 51.12]}, {"formula_id": "formula_9", "formula_text": "s \u2264 1 k \u2212 1 \u00d7 ( tf 1 tf 2 \u2212 1).", "formula_coordinates": [4.0, 127.8, 587.64, 91.12, 21.18]}, {"formula_id": "formula_10", "formula_text": "\u00d7 (k 1 + 1) \u00d7 c(w, d) k 1 ((1 \u2212 b) + b |d| avdl ) + c(w, d) \u00d7 (k 3 + 1) \u00d7 c(w, q) k 3 + c(w, q)", "formula_coordinates": [4.0, 434.4, 94.2, 130.42, 50.88]}, {"formula_id": "formula_11", "formula_text": "w\u2208q\u2229d c(w, q) \u2022 ln(1 + c(w, d) \u00b5 \u2022 p(w|C) ) + |q| \u2022 ln \u00b5 |d| + \u00b5", "formula_coordinates": [5.0, 74.76, 157.97, 195.99, 24.32]}, {"formula_id": "formula_12", "formula_text": "ln(1 + c(w 1 , d 1 ) \u00b5p(w 1 |C) ) + ln(1 + c(w 2 , d 1 ) \u00b5p(w 2 |C) ) + 2ln \u00b5 \u00b5 + |d 1 | \u2265 ln(1 + c(w 1 , d 2 ) \u00b5p(w 1 |C) ) + ln(1 + c(w 2 , d 2 ) \u00b5p(w 2 |C) ) + 2ln \u00b5 \u00b5 + |d 2 |", "formula_coordinates": [5.0, 60.42, 467.66, 206.71, 43.53]}, {"formula_id": "formula_13", "formula_text": "\u00b5 \u2265 c(w 1 , d 1 ) \u2212 c(w 2 , d 2 ) p(w 2 |C) \u2212 p(w 1 |C)", "formula_coordinates": [5.0, 122.64, 545.7, 100.19, 21.12]}, {"formula_id": "formula_14", "formula_text": "\u00b5 > c(w 1 , d 1 ) \u2212 c(w 2 , d 2 ) p(w 2 |C) = avdl \u00d7 (c(w 1 , d 1 ) \u2212 c(w 2 , d 2 ))", "formula_coordinates": [5.0, 99.54, 607.2, 147.59, 34.08]}, {"formula_id": "formula_15", "formula_text": "C 1 \u21d4 c(w 1 , d 2 ) \u2264 c(w 2 , d 1 ) C * 2 \u21d4 s \u2264 tf 1 \u2212 tf 2 (k |d 2 | avdl \u2212 1)tf 2 \u2212 ( |d 2 | avdl \u2212 1)tf 1 C * 3 \u21d4 s \u2264 (h(c(w, d 1 )) \u2212 h(c(w, d 2 ))) \u00d7 avdl (c(w, d 1 ) \u2212 c(w, d 2 )) \u00d7 (1 + h(c(w, d 1 ))) C * 4 \u21d4 \u00b5 \u2265 c(w 1 , d 1 ) \u2212 c(w 2 , d 2 ) p(w 2 |C) \u2212 p(w 1 |C) > avdl \u00d7 (c(w 1 , d 1 ) \u2212 c(w 2 , d 2 )) C 5 \u21d4 c(w, d 2 ) \u2265 |d 2 | \u2022 p(w|C) C 6 \u21d4 idf (w) \u2265 0 \u21d4 df (w) \u2264 N/2", "formula_coordinates": [5.0, 328.38, 283.79, 214.79, 125.7]}], "doi": ""}