{"title": "Hierarchical Finite State Controllers for Generalized Planning (Corrected Version)", "authors": "Javier Segovia-Aguas; Sergio Jim\u00e9nez; Anders Jonsson", "pub_date": "2019-11-07", "abstract": "Finite State Controllers (FSCs) are an effective way to represent sequential plans compactly. By imposing appropriate conditions on transitions, FSCs can also represent generalized plans that solve a range of planning problems from a given domain. In this paper we introduce the concept of hierarchical FSCs for planning by allowing controllers to call other controllers. We show that hierarchical FSCs can represent generalized plans more compactly than individual FSCs. Moreover, our call mechanism makes it possible to generate hierarchical FSCs in a modular fashion, or even to apply recursion. We also introduce a compilation that enables a classical planner to generate hierarchical FSCs that solve challenging generalized planning problems. The compilation takes as input a set of planning problems from a given domain and outputs a single classical planning problem, whose solution corresponds to a hierarchical FSC.", "sections": [{"heading": "Introduction", "text": "Finite state controllers (FSCs) are a compact and effective representation commonly used in AI; prominent examples include robotics [Brooks, 1989] and video-games [Buckland, 2004]. In planning, FSCs offer two main benefits: 1) solution compactness [B\u00e4ckstr\u00f6m et al., 2014]; and 2) the ability to represent generalized plans that solve a range of similar planning problems. This generalization capacity allows FSCs to represent solutions to arbitrarily large problems, as well as problems with partial observability and non-deterministic actions [Bonet et al., 2010;Hu and Levesque, 2011;Srivastava et al., 2011;Hu and De Giacomo, 2013].\nEven FSCs have limitations, however. Consider the problem of traversing all nodes of a binary tree as in Figure 1. A classical plan for this task consists of an action sequence whose length is linear in the number of nodes, and hence exponential in the depth of the tree. In contrast, the recursive definition of Depth-First Search (DFS) only requires a few lines of code. However, a standard FSC cannot implement recursion, and the iterative definition of DFS is considerably more complicated, involving an external data structure. In this paper we introduce a novel formalism for representing and computing compact and generalized planning solutions that we call hierarchical FSCs. Our formalism extends standard FSCs for planning in three ways. First, a hierarchical FSC can involve multiple individual FSCs. Second, each FSC can call other FSCs. Third, each FSC has a parameter list, and when an FSC is called, it is necessary to specify the arguments assigned to the parameters. As a special case, our formalism makes it possible to implement recursion by allowing an FSC to call itself with different arguments.\nTo illustrate this idea, Figure 2 shows an example hierarchical FSC C[n] that implements DFS traversal of binary trees using recursion. Here, n is the lone parameter of the controller and represents the current node of the binary tree. Condition null(n) tests whether n is points to a null node, while a hyphen '-' indicates that the transition fires no matter what. Action visit(n) visits node n, while copyL(n, m) and copyR(n, m) assign the left and right child of node n to m, respectively. Action call(m) is a recursive call to the FSC itself, assigning argument m to the only parameter of the controller and restarting execution from its initial node Q 0 . Intuitively, by repeatedly assigning the right child of n to n itself (using the action copyR(n, n)) and following the cycle of controller states Q 0 , Q 1 , Q 2 , Q 3 , Q 0 , . . ., the FSC C[n] has the effect of visiting all nodes on the rightmost branch of the tree until a null node is reached. Moreover, by assigning the left child of n to child (using the action copyL(n, child))\nand making the recursive call call(child), the FSC C[n] is recursively executed on all left sub-trees. The controller state Q 4 is a terminal state, and the action visit(child) on the transition to Q 4 is in fact not needed and could be removed. However, the FSC is automatically generated by our approach, so we present conditions and actions exactly as they appear.\nCompared to previous work on the automatic generation of FSCs for planning the contributions of this paper are:\n1. A reformulation of the transition function of FSCs that allows binary branching only in order to reduce the space of possible controllers. 2. A formal definition of hierarchical FSCs for planning that allows controllers to call other controllers and that includes recursion as a special case. 3. A novel compilation that enables the automatic generation of hierarchical FSCs for challenging generalized planning tasks. The compilation takes as input a set of planning problems from a given domain and outputs a single classical planning problem whose solution corresponds to a hierarchical FSC. This output is expressed in PDDL, thus an off-the-shelf classical planner can be used to generate hierarchical FSCs. The compilation also makes it possible to incorporate prior knowledge in the form of existing FSCs to automatically complete the definition of the remaining FSCs.", "publication_ref": ["b2", "b2", "b0", "b3", "b5", "b3"], "figure_ref": ["fig_0", "fig_1"], "table_ref": []}, {"heading": "Background", "text": "This section defines our model for classical planning and presents the formalism we use to define FSCs for planning.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Classical Planning with Conditional Effects", "text": "We describe states and actions in terms of literals. Formally, given a set of fluents F , a literal l is a valuation of a fluent in F , i.e. l = f or l = \u00acf for some f \u2208 F . A set of literals L thus represents a partial assignment of values to fluents (WLOG we assume that L does not assign conflicting values to any fluent). Given L, let \u00acL = {\u00acl : l \u2208 L} be the complement of L. A state s is a set of literals such that |s| = |F |, i.e. a total assignment of values to fluents. A classical planning problem is a tuple P = F, A, I, G , where F is a set of fluents, A is a set of actions, I is an initial state and G is a goal condition, i.e. a set of literals. Each action a \u2208 A has a set of literals pre(a) called the precondition and a set of conditional effects cond(a). Each conditional effect C E \u2208 cond(a) is composed of sets of literals C (the condition) and E (the effect). We often describe the initial state I \u2286 F compactly as the subset of fluents that are true.\nAction a is applicable in state s if and only if pre(a) \u2286 s, and the resulting set of triggered effects is A plan for P is an action sequence \u03c0 = a 1 , . . . , a n that induces a state sequence s 0 , s 1 , . . . , s n such that s 0 = I and, for each i such that 1 \u2264 i \u2264 n, a i is applicable in s i\u22121 and generates the successor state s i = \u03b8(s i\u22121 , a i ). The plan \u03c0 solves P if and only if G \u2286 s n , i.e. if the goal condition is satisfied following the application of \u03c0 in I.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Finite State Controllers", "text": "Given a planning problem P = F, A, I, G , an FSC is defined as a tuple C = Q, T, q 0 , q \u22a5 , where Q is a set of controller states, T : Q \u00d7 2 F \u2192 Q \u00d7 A is a (partial) transition function that assumes full observability, and q 0 \u2208 Q and q \u22a5 \u2208 Q are the initial and terminal controller states, respectively. This definition relates to previous work on FSCs for generalized planning [Bonet et al., 2010;Hu and De Giacomo, 2013] as follows:\n\u2022 Just like in previous approaches (and unlike Mealy machines), transitions do not depend on explicit input sequences but on the current planning state. \u2022 Previous approaches assume partial observability of the current planning state, defining the transition function T on Q \u00d7 O, where O is the observation set. We instead define T on Q \u00d7 2 F , i.e. on the full set of fluents. \u2022 We define an explicit terminal state q \u22a5 , while previous approaches terminate upon reaching the goal condition G. The reason is that we will later extend our definition to hierarchies of FSCs where goals G are not necessarily satisfied when the execution of an FSC terminates.\nWe briefly describe the execution semantics of an FSC C on planning problem P . The current world state is a pair (q, s) \u2208 Q \u00d7 2 F of a controller state and a planning state. From a pair (q, s), the system transitions to (q , s ), where (q , a) = T (q, s) is the result of applying the transition function in (q, s) and s = \u03b8(s, a) is the result of applying action a in s. Execution starts at (q 0 , I) and repeatedly transitions until reaching a pair (q \u22a5 , s \u22a5 ) that contains the terminal controller state q \u22a5 . An FSC C solves P iff G \u2286 s \u22a5 upon termination, i.e. if the goal condition holds in s \u22a5 . The execution of C fails if it reaches a pair (q, s) that was already visited.\nA generalized planning problem P = {P 1 , . . . , P T } is a set of multiple individual planning problems that share fluents and actions. Each individual planning problem P t \u2208 P is thus defined as P t = F, A, I t , G t , where only the initial state I t and goal condition G t differ from other planning problems in P. An FSC C solves a generalized planning problem P if and only if it solves every problem P t \u2208 P.", "publication_ref": ["b3"], "figure_ref": [], "table_ref": []}, {"heading": "Generating Finite State Controllers", "text": "This section presents a compilation that takes as input a classical planning problem P = F, A, I, G and a bound n on the maximum number of controller states, and produces as output a classical planning problem P n . Actions in P n are defined such that any plan that solves P n has to both generate an FSC C and simulate the execution of C on P , thus verifying that C solves P . We later extend this compilation to generalized planning problems and hierarchies of FSCs.\nTo generate an FSC C = Q, T, q 0 , q \u22a5 using this compilation we first define Q = {q 0 , . . . , q n } and set q \u22a5 \u2261 q n . The only thing that remains is to construct the transition function T . Our approach is to reduce the space of possible controllers by compactly representing T : Q \u00d7 2 F \u2192 Q \u00d7 A using the following three functions \u0393, \u039b and \u03a6:\n\u2022 \u0393 : Q \u2192 F associates a fluent f = \u0393(q) to each q \u2208 Q.\n\u2022 \u039b : Q \u00d7 {0, 1} \u2192 Q returns a successor state in Q.\n\u2022 \u03a6 : Q \u00d7 {0, 1} \u2192 A returns an action in A. The transition from a world state (q, s) depends on the truth value of \u0393(q) in s, hence allowing binary branching only. Let \u0393(q) \u2208 s be a test whose outcome is interpreted as a Boolean value in {0, 1}. The transition function is then defined as T (q, s) = (\u039b(q, \u0393(q) \u2208 s), \u03a6(q, \u0393(q) \u2208 s)).\nWe proceed to define P n = {F n , A n , I n , G n }. The idea behind the compilation is to define two types of actions: program actions that program the three functions \u0393, \u039b and \u03a6 for each controller state of C, and execute actions that simulate the execution of C on P by evaluating the functions in the current planning state.\nThe set of fluents is F n = F \u222a F T \u222a F aux , where F T contains the fluents needed to encode the transition function:\n\u2022 For each q \u2208 Q and f \u2208 F , a fluent cond f q that holds iff f is the condition of q\n, i.e. if \u0393(q) = f . \u2022 For each q, q \u2208 Q and b \u2208 {0, 1}, a fluent succ b q,q that holds iff \u039b(q, b) = q . \u2022 For each q \u2208 Q, b \u2208 {0, 1} and a \u2208 A, a fluent act b q,a that holds iff \u03a6(q, b) = a. \u2022 For each q \u2208 Q and b \u2208 {0, 1}, fluents nocond q ,\nnosucc b q and noact b q that hold iff we have yet to program the functions \u0393, \u039b and \u03a6, respectively. Moreover, F aux contains the following fluents:\n\u2022 For each q \u2208 Q, a fluent cs q that holds iff q is the current controller state. \u2022 Fluents evl and app that hold iff we are done evaluating the condition or applying the action corresponding to the current controller state, and fluents o 0 and o 1 representing the outcome of the evaluation. The initial state and goal condition are defined as\nI n = I \u222a {cs q0 } \u222a {nocond q , noact b q , nosucc b q : q \u2208 Q, b \u2208 {0, 1}} and G n = G \u222a {cs qn }.\nFinally, the set of actions A n replaces the actions in A with the following actions:\n\u2022 For each q \u2208 Q and f \u2208 F , an action pcond f q for programming \u0393(q) = f :\npre(pcond f q ) = {cs q , nocond q }, eff(pcond f q ) = {\u2205 {\u00acnocond q , cond f q }}.\n\u2022 For each q \u2208 Q and f \u2208 F , an action econd f q that evaluates the condition of the current controller state: We extend the compilation to address generalized planning problems P = {P 1 , . . . , P T }. In this case a solution to P n builds an FSC C and simulates the execution of C on all the individual planning problems P t \u2208 P. The extension introduces actions end t , 1 \u2264 t < T , with precondition G t \u222a {cs qn } and conditional effects that reset the world state to (q 0 , I t+1 ) after solving P t . In addition, the initial state and goal condition are redefined as\npre(econd f q ) = {cs q , cond f q , \u00acevl}, eff(econd f q ) = {\u2205 {evl}, {\u00acf } {o 0 }, {f } {o 1 }}. \u2022 For each q \u2208 Q, b \u2208 {0,\nI n = I 1 \u222a {cs q0 } \u222a {nocond q , noact b q , nosucc b q : q \u2208 Q, b \u2208 {0, 1}} and G n = G T \u222a {cs qn }.\nThis section extends our formalism for FSCs to hierarchical FSCs. We do so by allowing FSCs to call other FSCs. An FSC C can now have parameters, and calls to C specify the arguments passed to the parameters of C. Again, we first describe hierarchical FSCs for solving a single planning problem P = F, A, I, G , and then extend the idea to generalized planning.\nAs in PDDL, we assume that fluents in F are instantiated from predicates. Moreover, we assume that there exist a set of variable objects \u2126 v and a set of value objects \u2126 x , and that for each v \u2208 \u2126 v and x \u2208 \u2126 x , F contains a fluent assign v,x that models an assignment of type v = x. Let F a \u2286 F be the set of such assignment fluents and let F r = F \\ F a be the remaining fluents.\nGiven a planning problem P with fluents F a \u2286 F induced from sets \u2126 v and \u2126 x , a hierarchical FSC is a tuple H = C, C 1 , where C = {C 1 , . . . , C m } is the set of FSCs in the hierarchy and C 1 \u2208 C is the root FSC. We assume that all FSCs in C share the same set of controller states Q and that each C i \u2208 C has an associated parameter list L i \u2208 \u2126 ki v consisting of k i variable objects in \u2126 v . The set of possible FSC calls is then given by\nZ = {C i [p] : C i \u2208 C, p \u2208 \u2126 ki v }, i\n.e. all ways to select an FSC C i from C and assign arguments to its parameters. The transition function T i of each FSC C i is redefined as T i : Q \u00d7 2 F \u2192 Q \u00d7 (A \u222a Z) to include possible calls to the FSCs in C. As before, we represent T i compactly using functions \u0393 i , \u039b i and \u03a6 i .\nTo define the execution semantics of a hierarchical FSC H we introduce a call stack. Execution starts in the root FSC, at state (q 0 , I) and on level 0 of the stack. In general, for an FSC C i and a world state (q, s) and given that T i (q, s) = (q , a) returns an action a \u2208 A, the execution semantics is as explained in Section 2 for single FSCs. However, when T i (q, s) = (q , C j [p]) returns a call to controller C j [p] \u2208 Z, we set the state on the next level of the stack to (q 0 , s[p]), where s[p] is obtained from s by copying the value of each variable object in p to the corresponding parameter of C j . Execution then proceeds on the next level of the stack following transition function T j , which can include other FSC calls that invoke higher stack levels. If T j reaches a terminal state (q \u22a5 , s \u22a5 ), control is returned to the parent controller C i . Specifically, the state of C i becomes (q , s ), where s is obtained from s \u22a5 by substituting the original assignments of values to variables on the previous stack level. The execution of a hierarchical FSC H terminates when it reaches a terminal state (q \u22a5 , s \u22a5 ) on stack level 0, and H solves P iff G \u2286 s \u22a5 .", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "An Extended Compilation for Hierarchical Finite State Controllers", "text": "We now describe a compilation from P to a classical planning problem P n,m = F n,m , A n,m , I n,m , G n,m , such that solving P n,m amounts to programming a hierarchical FSC H = C, C 1 and simulating its execution on P . As before, n bounds the number of controller states, while m is the maximum number of FSCs in C and bounds the size of the call stack. The set of fluents is F n,m = F r \u222aF a \u222aF m T \u222aF aux \u222aF H where \u2022 F a = {f l : f \u2208 F a , 0 \u2264 l \u2264 }, i.e. each fluent of type assign v,x has a copy for each stack level l.\n\u2022 F m T = {f i : f \u2208 F T , 1 \u2264 i \u2264 m}, i.e. each fluent in F T has a copy for each FSC C i \u2208 C defining its corresponding transition function T i .\n\u2022 F aux = {f l : f \u2208 F aux , 0 \u2264 l \u2264 }, i.e. each fluent in F aux has a copy for each stack level l.\nMoreover, F H contains the following additional fluents:\n\u2022 For each l, 0 \u2264 l \u2264 , a fluent lvl l that holds iff l is the current stack level.\n\u2022 For each C i \u2208 C and l, 0 \u2264 l \u2264 , a fluent fsc i,l that holds iff C i is the FSC being executed on stack level l.\n\u2022 For each q \u2208 Q, b \u2208 {0, 1}, C i , C j \u2208 C and p \u2208 \u2126 kj v , a fluent call b,i q,j (p) that holds iff \u03a6 i (q, b) = C j [p].\nThe initial state and goal condition are now defined as\nI n,m = (I \u2229 F r ) \u222a {f 0 : f \u2208 I \u2229 F a } \u222a {cs 0 q0 , lvl 0 , fsc 1,0 } \u222a {nocond i q , noact b,i q , nosucc b,i q : q \u2208 Q, b \u2208 {0, 1}, C i \u2208 C} and G n,m = G \u222a {cs 0 qn }.\nIn other words, fluents of type assign v,x \u2208 F a are initially marked with stack level 0, the controller state on level 0 is q 0 , the current stack level is 0, the FSC on level 0 is C 1 , and functions \u0393 i , \u039b i and \u03a6 i are yet to be programmed for any FSC C i \u2208 C. To satisfy the goal we have to reach the terminal state q n on level 0 of the stack.\nTo establish the actions in the set A n,m , we first adapt all actions in A n by parameterizing on the FSC C i \u2208 C and stack level l, 0 \u2264 l \u2264 , adding preconditions lvl l and fsc i,l , and modifying the remaining preconditions and effects accordingly. As an illustration we provide the definition of the resulting action pcond f,i,l q :\npre(pcond f,i,l q ) = {lvl l , fsc i,l , cs l q , nocond i q }, eff(pcond f,i,l q ) = {\u2205 {\u00acnocond i q , cond f,i q }}.\nCompared to the old version of pcond f q , the current controller state cs l q \u2208 F aux refers to the stack level l, and fluents nocond i q and cond f,i q in F m T refer to the FSC C i . The precondition models the fact that we can only program the function \u0393 i of C i in controller state q on stack level l when l is the current stack level, C i is being executed on level l, the current controller state on level l is q, and \u0393 i has not been previously programmed in q.\nIn addition to the actions adapted from A n , the set A n,m also contains the following new actions:\n\u2022 For each q \u2208 Q, b \u2208 {0, 1}, C i , C j \u2208 C, p \u2208 \u2126 kj v\nand l, 0 \u2264 l < , an action pcall b,i,l q,j (p) to program a call from the current FSC, C i , to FSC C j :\npre(pcall b,i,l q,j (p)) = {lvl l , fsc i,l , cs l q , evl l , o b,l , noact b,i q }, eff(pcall b,i,l q,j (p)) = {\u2205 {\u00acnoact b,i q , call b,i q,j (p)}}. \u2022 For each q \u2208 Q, b \u2208 {0, 1}, C i , C j \u2208 C, p \u2208 \u2126 kj v\nand l, 0 \u2264 l < , an action ecall b,i,l q,j (p) that executes a call:\npre(ecall b,i,l q,j (p)) = {lvl l , fsc i,l , cs l q , evl l , o b,l , call b,i q,j (p), \u00acapp l }, eff(ecall b,i,l q,j (p)) = {\u2205 {\u00aclvl l , lvl l+1 , cs l+1 q0 , app l }} \u222a {{assign l p k ,x } {assign l+1 L k j ,x } : 1 \u2264 k \u2264 k j , x \u2208 \u2126 x }. \u2022 For each C i \u2208 C and l, 0 < l \u2264 , an action term i,l : pre(term i,l ) = {lvl l , fsc i,l , cs l qn }, eff(term i,l ) = {\u2205 {\u00aclvl l , \u00acfsc i,l , \u00accs l qn , lvl l\u22121 }} \u222a {\u2205 {\u00acassign l v,x : v \u2208 \u2126 v , x \u2208 \u2126 x }}.\nAs an alternative to pact b,i,l q,a , the action pcall b,i,l q,j (p) programs an FSC call C j [p], i.e. defines the function as\n\u03a6 i (q, b) = C j [p]. Action ecall b,i,l q,j(\np) executes this FSC call by incrementing the current stack level to l + 1 and setting the controller state on level l + 1 to q 0 . The conditional effect {assign l p k ,x } {assign l+1 L k j ,x } effectively copies the value of the argument p k on level l to the corresponding parameter L k j of C j on level l + 1. When in the terminal state q n , the termination action term i,l decrements the stack level to l \u2212 1 and deletes all temporary information about stack level l. Theorem 2. Any plan \u03c0 that solves P n,m induces a hierarchical FSC H that solves P . Proof sketch. Similar to the argument in the proof of Theorem 1, the plan \u03c0 has to program the functions \u0393 i , \u039b i and \u03a6 i of each FSC C i \u2208 C. Because of the new actions pcall b,i,l q,j (p), this includes the possibility of making FSC calls. Hence \u03c0 implicitly defines a hierarchical FSC H.\nMoreover, \u03c0 simulates an execution of H on P starting from (q 0 , I) on stack level 0. In any world state (q, s) on stack level l while executing the FSC C i , whenever the plan contains a partial action sequence econd f,i,l q , ecall b,i,l q,j (p), esucc b,i,l q,q that involves an FSC call, the effect of ecall b,i,l q,j (p) is to increment the stack level, causing execution to proceed on stack level l + 1 for the FSC C j . The only action that decrements the stack level is term j,l+1 , which is only applicable once we reach the terminal state q n on stack level l + 1. Once term j,l+1 has been applied, we can now apply action esucc b,i,l q,q to transition to the new controller state q .\nIf \u03c0 solves P n,m , execution terminates in a state (q n , s n ) on level 0 and the goal condition holds in s n , satisfying the condition that H solves P .\nWe remark that the action pcall b,i,l q,j (p) can be used to implement recursion by setting i \u2261 j, making the FSC C i call itself. We can also partially specify the functions \u0393 i , \u039b i and \u03a6 i of an FSC C i by adding fluents of type cond f,i q , act b,i q,a , succ b,i q,q and call b,i q,j (p) to the initial state I n,m . This way we can incorporate prior knowledge regarding the configuration of some previously existing FSCs in C.\nThe compilation can be extended to a generalized planning problem P = {P 1 , . . . , P T } in a way analogous to P n . Specifically, each action end t , 1 \u2264 t < T , should have precondition G t \u222a {cs 0 qn } and reset the state to I t+1 \u222a {cs 0 q0 }, i.e. the system should reach the terminal state q n on stack level 0 and satisfy the goal condition G t of P t before execution proceeds on the next problem P t+1 \u2208 P. To solve P n,m , a plan hence has to simulate the execution of H on all planning problems in P.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Evaluation", "text": "We evaluate our approach in a set of generalized planning benchmarks and programming tasks taken from Bonet et al. [2010] and Segovia-Aguas et al. [2016]. In all experiments, we run the classical planner Fast Downward [Helmert, 2006] with the LAMA-2011 setting [Richter and Westphal, 2010] on a processor Intel Core i5 3.10GHz x 4 with a 4GB memory bound and time limit of 3600s.\nWe briefly describe each domain used in experiments. In Blocks, the goal is to unstack blocks from a single tower until a green block is found. In Gripper, the goal is to transport a set of balls from one room to another. In List, the goal is to visit all the nodes of a linked list. In Reverse, the goal is to reverse the elements of a list. In Summatory, the goal is to compute the sum n i i for a given input n. In Tree/DFS, the goal is to visit all nodes of a binary tree. Finally, in Visitall, the goal is to visit all the cells of a square grid.\nTable 1 summarizes the obtained experimental results. In all but two domains our compilation makes it possible to find a single FSC (OC=One Controller) that solves all planning instances in the input. Moreover, we manually verified that the resulting FSC solves all other instances from the same domain. These results reflect those of earlier approaches, but in the domains from Segovia-Aguas et al. [2016], the FSC is able to store generalized plans more compactly, and generation of the FSC is faster.\nIn Tree/DFS, as mentioned in the introduction, generating a single FSC that solves the problem iteratively without recursive calls is difficult. In contrast, since our compilation simulates a call stack, we are able to automatically generate the FSC in Figure 2. There are some discrepancies with respect to the compilation that we address below:\n\u2022 As described, a solution to the compiled planning problem P n,m has to program a condition for each controller state, while the FSC in Figure 2 includes deterministic transitions. However, since all fluents in f are potential conditions, programming a condition on a fluent that is static is effectively equivalent to programming a deterministic transition, since the outcome of the evaluation will always be the same for this fluent.\n\u2022 In the solution generated by the planner, the condition null(n) is actually emulated by a condition equals(n, n), where equals is a derived predicate that tests whether two variables have the same value. The reason this works is that when applied to a leaf node n, the action copyR(n, n) deletes the current value of n without adding another value, since n does not have a right child.  Hence evaluating equals(n, n) returns false, since there is no current value of n to unify over. \u2022 As previously mentioned, the transition to the terminal state Q 4 includes an action visit(child) which is not needed; the reason this action is generated by the planner is that there is no option for leaving the action \"blank\". Effectively, when executing the FSC the action in question has no effect. Finally, in Visitall, attempting to generate a single controller for solving all input instances fails. Moreover, even if we set m > 1 and attempt to generate a hierarchical controller from scratch, the planner does not find a solution within the given time bound. Instead, our approach is to generate a hierarchical FSC incrementally. We first generate two single FSCs, where the first solves the subproblem of iterating over a single row, visiting all cells along the way, and the second solves the subproblem of returning to the first column. We then use the compilation to generate a planning problem P n,m in which two of the FSCs are already programmed, so the classical plan only has to automatically generate the root controller.", "publication_ref": ["b5", "b4", "b5"], "figure_ref": ["fig_1", "fig_1"], "table_ref": ["tab_1"]}, {"heading": "Related Work", "text": "The main difference with previous work on the automatic generation of FSCs [Bonet et al., 2010;Hu and De Giacomo, 2013] is that they generate single FSCs relying on a partially observable planning model. In contrast, our compilation generate hierarchical FSCs that can branch on any fluent since we consider all fluents as observable. Our approach also makes it possible to generate recursive slutions and to incorporate prior knowledge as existing FSCs, and automatically complete the definition of the remaining hierarchical FSC.\nHierarchical FSCs are similar to planning programs [Jim\u00e9nez and Jonsson, 2015;Segovia-Aguas et al., 2016]. Programs are a special case of FSCs, and in general, FSCs can represent a plan more compactly. Another related formalism is automaton plans [B\u00e4ckstr\u00f6m et al., 2014], which also store sequential plans compactly using hierarchies of finite state automata. However, automaton plans are Mealy machines whose transitions depend on the symbols of an explicit input string. Hence automaton plans cannot store generalized plans, and their focus is instead on the compression of sequential plans.\nFSCs can also represent other objects in planning. Hickmott et al. [2007] and LaValle [2006] used FSCs to represent the entire planning instance. In contrast, Toropila and Bart\u00e1k [2010] used FSCs to represent the domains of individual variables of the instance. Baier and McIlraith [2006] showed how to convert an LTL representation of temporally extended goals, i.e. conditions that must hold over the intermediate states of a plan, into a non-deterministic FSC.", "publication_ref": ["b3", "b4", "b5", "b0", "b2", "b5", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "Conclusion", "text": "In this paper we have presented a novel formalism for hierarchical FSCs in planning in which controllers can recursively call themselves or other controllers to represent generalized plans more compactly. We have also introduced a compilation into classical planning which makes it possible to use an off-the-shelf planner to generate hierarchical FSCs. Finally we have showed that hierarchical FSCs can be generated in an incremental fashion to address more challenging generalized planning problems.\nJust as in previous work on the automatic generation of FSCs, our compilation takes as input a bound on the number of controller states. Furthermore, for hierarchical FSCs we specify bounds on the number of FSCs and stack levels. An iterative deepening approach could be implemented to automatically derive these bounds. Another issue is the specification of representative subproblems to generate hierarchical FSCs in an incremental fashion. Inspired by \"Test Driven Development\" [Beck et al., 2001], we believe that defining subproblems is a step towards automation.\nLast but not least, we follow an inductive approach to generalization, and hence we can only guarantee that the solution generalizes over the instances of the generalized planning problem, much as in previous work on computing FSCs. With this said, all the controllers we report in the paper generalize. In machine learning, the validation of a generalized solution is traditionally done by means of statistics and validation sets. In planning this is an open issue, as well as the generation of relevant examples that lead to solutions that generalize.", "publication_ref": ["b1"], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgment", "text": "This work is partially supported by grant TIN2015-67959 and the Maria de Maeztu Units of Excellence Programme MDM-2015-0502, MEC, Spain. Sergio Jim\u00e9nez is partially supported by the Juan de la Cierva program funded by the Spanish government.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Planning with Temporally Extended Goals Using Heuristic Search", "journal": "", "year": "2006", "authors": "[ References;  B\u00e4ckstr\u00f6m"}, {"ref_id": "b1", "title": "Automatic derivation of finite-state machines for behavior control", "journal": "", "year": "2001", "authors": ""}, {"ref_id": "b2", "title": "Malte Helmert. The Fast Downward Planning System", "journal": "Wordware Publishing, Inc", "year": "1989", "authors": "; R Brooks; ; M Brooks; ; S Buckland; J Hickmott; S Rintanen; L Thi\u00e9baux;  White"}, {"ref_id": "b3", "title": "A correctness result for reasoning about one-dimensional planning problems", "journal": "Hu and Levesque", "year": "2011", "authors": "De Giacomo ; Yuxiao Hu; Giuseppe De Giacomo; ; Hu; Hector J Levesque"}, {"ref_id": "b4", "title": "Computing Plans with Control Flow and Procedures Using a Classical Planner", "journal": "", "year": "2006", "authors": "Sergio Jim\u00e9nez; Anders Jonsson; ; S Lavalle; ; S Richter; M Westphal"}, {"ref_id": "b5", "title": "Using Finite-State Automata to Model and Solve Planning Problems", "journal": "", "year": "2010", "authors": " Segovia-Aguas"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 1 :1Figure 1: Example of a binary tree with seven nodes.", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 2 :2Figure 2: Hierarchical FSC C[n] that traverses a binary tree.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": ". effects whose conditions hold in s. The result of applying a in s is a new state \u03b8(s, a) = (s \\ \u00aceff(s, a)) \u222a eff(s, a).", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "1} and a \u2208 A, an action pact b q,a for programming \u03a6(q, b) = a: pre(pact b q,a ) = pre(a) \u222a {cs q , evl, o b , noact b q }, eff(pact b q,a ) = {\u2205 {\u00acnoact b q , act b q,a }}. \u2022 For each q \u2208 Q, b \u2208 {0, 1} and a \u2208 A, an action eact b q,a that applies the action of the current controller state: pre(eact b q,a ) = pre(a) \u222a {cs q , evl, o b , act b q,a , \u00acapp}, eff(eact b q,a ) = eff(a) \u222a {\u2205 {app}}. \u2022 For each q, q \u2208 Q and b \u2208 {0, 1}, an action psucc b q,q for programming \u039b(q, b) = q : pre(psucc b q,q ) = {cs q , evl, o b , app, nosucc b q }, eff(psucc b q,q ) = {\u2205 {\u00acnosucc b q , succ b q,q }}. \u2022 For each q, q \u2208 Q and b \u2208 {0, 1}, an action esucc b q,q that transitions to the next controller state: pre(esucc b q,q ) = {cs q , evl, o b , app, succ b q,q }, eff(esucc b q,q ) = {\u2205 {\u00accs q , \u00acevl, \u00aco b , \u00acapp, cs q }}. Actions pcond f q , pact b q,a and psucc b q,q program the three functions \u0393, \u03a6 and \u039b, respectively, while econd f q , eact b q,a and esucc b q,q execute the corresponding function. Fluents evl and app control the order of the execution such that \u0393 is always executed first, then \u03a6, and finally \u039b. Theorem 1. Any plan \u03c0 that solves P n induces an FSC C that solves P . Proof sketch. The only way to change the current controller state is to apply an action of type esucc b q,q , which first requires programming and executing the functions \u0393, \u03a6 and \u039b in that order. Once programmed, the plan \u03c0 can no longer change these functions since there are no actions that add fluents among nocond q , noact b q and nosucc b q . Once programmed for all states and Boolean values b \u2208 {0, 1}, the three functions \u0393, \u03a6 and \u039b together define an FSC C. We show that \u03c0 simulates an execution of C on P . The initial state I \u222a {cs qo } corresponds to the world state (q 0 , I). In any world state (q, s), the plan has to apply the partial action sequence econd f q , eact b q,a , esucc b q,q . Action econd f q adds o b where b \u2208 {0, 1} is the truth value of f in s. Action eact b q,a applies the action a in s to obtain a new state s = \u03b8(s, a). Finally, action esucc b q,q transitions to controller state q . This deterministic execution continues until we reach a terminal state (q n , s n ) or revisit a world state. If \u03c0 solves P n , execution finishes in (q n , s n ) and the goal condition G holds in s n , which is the definition of C solving P .", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "Number of controllers used, solution kind (OC=One Controller, HC=Hierarchical Controller, RP=Recursivity with Parameters) and, for each controller: number of states, number of instances in P, planning time and plan length.", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": ", i.e. if \u0393(q) = f . \u2022 For each q, q \u2208 Q and b \u2208 {0, 1}, a fluent succ b q,q that holds iff \u039b(q, b) = q . \u2022 For each q \u2208 Q, b \u2208 {0, 1} and a \u2208 A, a fluent act b q,a that holds iff \u03a6(q, b) = a. \u2022 For each q \u2208 Q and b \u2208 {0, 1}, fluents nocond q ,", "formula_coordinates": [3.0, 63.96, 281.83, 233.04, 77.55]}, {"formula_id": "formula_1", "formula_text": "I n = I \u222a {cs q0 } \u222a {nocond q , noact b q , nosucc b q : q \u2208 Q, b \u2208 {0, 1}} and G n = G \u222a {cs qn }.", "formula_coordinates": [3.0, 54.0, 472.41, 243.0, 32.9]}, {"formula_id": "formula_2", "formula_text": "pre(pcond f q ) = {cs q , nocond q }, eff(pcond f q ) = {\u2205 {\u00acnocond q , cond f q }}.", "formula_coordinates": [3.0, 98.3, 548.49, 174.33, 30.14]}, {"formula_id": "formula_3", "formula_text": "pre(econd f q ) = {cs q , cond f q , \u00acevl}, eff(econd f q ) = {\u2205 {evl}, {\u00acf } {o 0 }, {f } {o 1 }}. \u2022 For each q \u2208 Q, b \u2208 {0,", "formula_coordinates": [3.0, 63.96, 611.27, 234.22, 47.42]}, {"formula_id": "formula_4", "formula_text": "I n = I 1 \u222a {cs q0 } \u222a {nocond q , noact b q , nosucc b q : q \u2208 Q, b \u2208 {0, 1}} and G n = G T \u222a {cs qn }.", "formula_coordinates": [3.0, 315.0, 671.95, 243.0, 32.9]}, {"formula_id": "formula_5", "formula_text": "Z = {C i [p] : C i \u2208 C, p \u2208 \u2126 ki v }, i", "formula_coordinates": [4.0, 140.99, 302.23, 134.39, 12.19]}, {"formula_id": "formula_6", "formula_text": "\u2022 For each q \u2208 Q, b \u2208 {0, 1}, C i , C j \u2208 C and p \u2208 \u2126 kj v , a fluent call b,i q,j (p) that holds iff \u03a6 i (q, b) = C j [p].", "formula_coordinates": [4.0, 324.96, 221.16, 233.03, 27.77]}, {"formula_id": "formula_7", "formula_text": "I n,m = (I \u2229 F r ) \u222a {f 0 : f \u2208 I \u2229 F a } \u222a {cs 0 q0 , lvl 0 , fsc 1,0 } \u222a {nocond i q , noact b,i q , nosucc b,i q : q \u2208 Q, b \u2208 {0, 1}, C i \u2208 C} and G n,m = G \u222a {cs 0 qn }.", "formula_coordinates": [4.0, 315.0, 256.56, 243.0, 51.54]}, {"formula_id": "formula_8", "formula_text": "pre(pcond f,i,l q ) = {lvl l , fsc i,l , cs l q , nocond i q }, eff(pcond f,i,l q ) = {\u2205 {\u00acnocond i q , cond f,i q }}.", "formula_coordinates": [4.0, 342.12, 441.18, 188.76, 30.14]}, {"formula_id": "formula_9", "formula_text": "\u2022 For each q \u2208 Q, b \u2208 {0, 1}, C i , C j \u2208 C, p \u2208 \u2126 kj v", "formula_coordinates": [4.0, 324.96, 602.39, 206.41, 13.01]}, {"formula_id": "formula_10", "formula_text": "pre(pcall b,i,l q,j (p)) = {lvl l , fsc i,l , cs l q , evl l , o b,l , noact b,i q }, eff(pcall b,i,l q,j (p)) = {\u2205 {\u00acnoact b,i q , call b,i q,j (p)}}. \u2022 For each q \u2208 Q, b \u2208 {0, 1}, C i , C j \u2208 C, p \u2208 \u2126 kj v", "formula_coordinates": [4.0, 324.96, 648.88, 231.48, 55.97]}, {"formula_id": "formula_11", "formula_text": "pre(ecall b,i,l q,j (p)) = {lvl l , fsc i,l , cs l q , evl l , o b,l , call b,i q,j (p), \u00acapp l }, eff(ecall b,i,l q,j (p)) = {\u2205 {\u00aclvl l , lvl l+1 , cs l+1 q0 , app l }} \u222a {{assign l p k ,x } {assign l+1 L k j ,x } : 1 \u2264 k \u2264 k j , x \u2208 \u2126 x }. \u2022 For each C i \u2208 C and l, 0 < l \u2264 , an action term i,l : pre(term i,l ) = {lvl l , fsc i,l , cs l qn }, eff(term i,l ) = {\u2205 {\u00aclvl l , \u00acfsc i,l , \u00accs l qn , lvl l\u22121 }} \u222a {\u2205 {\u00acassign l v,x : v \u2208 \u2126 v , x \u2208 \u2126 x }}.", "formula_coordinates": [5.0, 63.96, 75.09, 239.66, 141.55]}, {"formula_id": "formula_12", "formula_text": "\u03a6 i (q, b) = C j [p]. Action ecall b,i,l q,j(", "formula_coordinates": [5.0, 54.0, 240.87, 243.0, 24.41]}], "doi": ""}