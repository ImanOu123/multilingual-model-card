{"title": "Surpassing Human-Level Face Verification Performance on LFW with GaussianFace", "authors": "Chaochao Lu; Xiaoou Tang", "pub_date": "2014-12-20", "abstract": "Face verification remains a challenging problem in very complex conditions with large variations such as pose, illumination, expression, and occlusions. This problem is exacerbated when we rely unrealistically on a single training data source, which is often insufficient to cover the intrinsically complex face variations. This paper proposes a principled multi-task learning approach based on Discriminative Gaussian Process Latent Variable Model, named GaussianFace, to enrich the diversity of training data. In comparison to existing methods, our model exploits additional data from multiple source-domains to improve the generalization performance of face verification in an unknown target-domain. Importantly, our model can adapt automatically to complex data distributions, and therefore can well capture complex face variations inherent in multiple sources. Extensive experiments demonstrate the effectiveness of the proposed model in learning from diverse data sources and generalize to unseen domain. Specifically, the accuracy of our algorithm achieves an impressive accuracy rate of 98.52% on the well-known and challenging Labeled Faces in the Wild (LFW) benchmark [23]. For the first time, the human-level performance in face verification (97.53%) [28] on LFW is surpassed. 1", "sections": [{"heading": "Introduction", "text": "Face verification, which is the task of determining whether a pair of face images are from the same person, has been an active research topic in computer vision for decades [28,22,46,5,47,31,14,9]. It has many important applications, including surveillance, access control, image retrieval, and automatic log-on for personal computer or mobile devices. However, various visual complications deteriorate the performance of face verification, as shown by numerous studies on real-world face images from the wild [23]. The Labeled Faces in the Wild (LFW) dataset 1 For project update, please refer to mmlab.ie.cuhk.edu.hk. is well known as a challenging benchmark for face verification. The dataset provides a large set of relatively unconstrained face images with complex variations in pose, lighting, expression, race, ethnicity, age, gender, clothing, hairstyles, and other parameters. Not surprisingly, LFW has proven difficult for automatic face verification methods [23,28]. Although there has been significant work [22,9,5,14,47,13,59,50,51,53] on LFW and the accuracy rate has been improved from 60.02% [56] to 97.35% [53] since LFW is established in 2007, these studies have not closed the gap to human-level performance [28] in face verification.\nWhy could not we surpass the human-level performance? Two possible reasons are found as follows:\n1) Most existing face verification methods assume that the training data and the test data are drawn from the same feature space and follow the same distribution. When the distribution changes, these methods may suffer a large performance drop [58]. However, many practical scenarios involve cross-domain data drawn from different facial appearance distributions. Learning a model solely on a single source data often leads to overfitting due to dataset bias [55]. Moreover, it is difficult to collect sufficient and necessary training data to rebuild the model in new scenarios, for highly accurate face verification specific to the target domain. In such cases, it becomes critical to exploit more data from multiple source-domains to improve the generalization of face verification methods in the targetdomain.\n2) Modern face verification methods are mainly divided into two categories: extracting low-level features [36,3,34,10,24], and building classification models [62,50,13,37,31,56,5,28,47,33]. Although these existing methods have made great progress in face verification, most of them are less flexible when dealing with complex data distributions. For the methods in the first category, for example, low-level features such as SIFT [36], LBP [3], and Gabor [34] are handcrafted. Even for features learned from data [10,24], the algorithm parameters (such as the depth of random projection tree, or the number of centers in k-means) also need to be specified by users. Similarly, for the methods in the second category, the architectures of deep networks in [62,50,63,51] (for example, the number of layers, the number of nodes in each layer, etc.), and the parameters of the models in [31,5,28,47] (for example, the number of Gaussians, the number of classifiers, etc.) must also be determined in advance. Since most existing methods require some assumptions to be made about the structures of the data, they cannot work well when the assumptions are not valid. Moreover, due to the existence of the assumptions, it is hard to capture the intrinsic structures of data using these methods.\nTo this end, we propose the Multi-Task Learning approach based on Discriminative Gaussian Process Latent Variable Model (DGPLVM) [57], named GaussianFace, for face verification. Unlike most existing studies [22,5,14,47,13] that rely on a single training data source, in order to take advantage of more data from multiple source-domains to improve the performance in the target-domain, we introduce the multi-task learning constraint to DGPLVM. Here, we investigate the asymmetric multi-task learning because we only focus on the performance improvement of the target task. From the perspective of information theory, this constraint aims to maximize the mutual information between the distributions of target-domain data and multiple source-domains data. Moreover, the GaussianFace model is a reformulation based on the Gaussian Processes (GPs) [42], which is a non-parametric Bayesian kernel method. Therefore, our model also can adapt its complexity flexibly to the complex data distributions in the real-world, without any heuristics or manual tuning of parameters.\nReformulating GPs for large-scale multi-task learning is non-trivial. To simplify calculations, we introduce a more efficient equivalent form of Kernel Fisher Discriminant Analysis (KFDA) to DGPLVM. Despite that the Gaussian-Face model can be optimized effectively using the Scaled Conjugate Gradient (SCG) technique, the inference is slow for large-scale data. We make use of GP approximations [42] and anchor graphs [35] to speed up the process of inference and prediction, so as to scale our model to largescale data. Our model can be applied to face verification in two different ways: as a binary classifier and as a feature extractor. In the former mode, given a pair of face images, we can directly compute the posterior likelihood for each class to make a prediction. In the latter mode, our model can automatically extract high-dimensional features for each pair of face images, and then feed them to a classifier to make the final decision.\nThe main contributions of this paper are as follows:\n\u2022 We propose a novel GaussianFace model for face verification by virtue of the multi-task learning constraint to DGPLVM. Our model can adapt to complex distributions, avoid over-fitting, exploit discriminative information, and take advantage of multiple sourcedomains data.\n\u2022 We introduce a computationally more efficient equivalent form of KFDA to DGPLVM. This equivalent form reformulates KFDA to the kernel version consistent with the covariance function in GPs, which greatly simplifies calculations.\n\u2022 We introduce approximation in GPs and anchor graphs to speed up the process of inference and prediction.\n\u2022 We achieve superior performance on the challenging LFW benchmark [23], with an accuracy rate of 98.52%, beyond human-level performance reported in [28].", "publication_ref": ["b27", "b21", "b45", "b4", "b46", "b30", "b13", "b8", "b22", "b0", "b22", "b27", "b21", "b8", "b4", "b13", "b46", "b12", "b58", "b49", "b50", "b52", "b55", "b52", "b27", "b57", "b54", "b35", "b2", "b33", "b9", "b23", "b61", "b49", "b12", "b36", "b30", "b55", "b4", "b27", "b46", "b32", "b35", "b2", "b33", "b9", "b23", "b61", "b49", "b62", "b50", "b30", "b4", "b27", "b46", "b56", "b21", "b4", "b13", "b46", "b12", "b41", "b41", "b34", "b22", "b27"], "figure_ref": [], "table_ref": []}, {"heading": "Related Work", "text": "Human and computer performance on face recognition has been compared extensively [40,38,2,54,41,8]. These studies have shown that computer-based algorithms were more accurate than humans in well-controlled environments (e.g., frontal view, natural expression, and controlled illumination), whilst still comparable to humans in the poor condition (e.g., frontal view, natural expression, and uncontrolled illumination). However, the above conclusion is only verified on face datasets with controlled variations, where only one factor changes at a time [40,38]. To date, there has been virtually no work showing that computerbased algorithms could surpass human performance on unconstrained face datasets, such as LFW, which exhibits natural (multifactor) variations in pose, lighting, expression, race, ethnicity, age, gender, clothing, hairstyles, and other parameters.\nThere has been much work dealing with multifactor variations in face verification. For example, Simonyan et al. applied the Fisher vector to face verification and achieved a good performance [47]. However, the Fisher vector is derived from the Gaussian mixture model (GMM), where the number of Gaussians need to be specified by users, which means it cannot cover complex data automatically. Li et al. proposed a non-parametric subspace analysis [33,32], but it is only a linear transformation and cannot cover the complex distributions. Besides, there also exist some approaches for utilizing plentiful sourcedomain data. Based on the Joint Bayesian algorithm [13], Cao et al. proposed a transfer learning approach [9] by merging source-domain data with limited target-domain data. Since this transfer learning approach is based on the joint Bayesian model of original visual features, it is not suitable for handling the complex nonlinear data and the data with complex manifold structures. Moreover, the transfer learning approach in [9] only considered two different domains, restricting its wider applications in largescale data from multiple domains. More recently, Zhu et al. [63] learned the transformation from face images under various poses and lighting conditions to a canonical view with a deep convolutional network. Sun et al. [51] learned face representation with a deep model through face identification, which is a challenging multi-class prediction task. Taigman et al. [52] first utilized explicit 3D face modeling to apply a piecewise affine transformation, and then derived a face representation from a nine-layer deep neural network. Although these methods have achieved high performances on LFW, many parameters of them must be determined in advance so that they are less flexible when dealing with complex data distributions.\nThe core of our algorithm is GPs. To the best of our knowledge, GPs methods and Multi-task learning with related GPs methods (MTGP) have not been applied for face verification. Actually, MTGP/GPs have been extensively studied in machine learning and computer vision in recent years [6,60,11,25,30,44,49,61,26]. However, most of them [60,11,6,44,25,49,61] have only considered the symmetric multi-task learning, which means that all tasks have been assumed to be of equal importance, whereas our purpose is to enhance performance on a target task given all other source tasks. Leen et al. proposed a MTGP model in the asymmetric setting [30] to focus on improving performance on the target task, and Kim et al. developed a GP model for clustering [26], but their methods do not take the discriminative information of the covariance function into special account like DGPLVM. Although the discriminative information is considered in [57], it does not apply multi-task learning to improve its performance. Salakhutdinov et al. used a deep belief net to learn a good covariance kernel for GPs [45]. The limitation of such deep methods is that it is hard to determine which architecture for this network is optimal. Also, multi-task learning constraint was not considered in [45].", "publication_ref": ["b39", "b37", "b1", "b53", "b40", "b7", "b39", "b37", "b46", "b32", "b31", "b12", "b8", "b8", "b62", "b50", "b51", "b5", "b59", "b10", "b24", "b29", "b43", "b48", "b60", "b25", "b59", "b10", "b5", "b43", "b24", "b48", "b60", "b29", "b25", "b56", "b44", "b44"], "figure_ref": [], "table_ref": []}, {"heading": "Preliminary", "text": "In this section, we briefly review Gaussian Processes (GPs) for classification and clustering [26], and Gaussian Process Latent Variable Model (GPLVM) [29]. We use GPs method mainly due to the following three notable advantages. Firstly, as mentioned previously, it is a nonparametric method, which means it adapts its complexity flexibly to the complex data distributions in the real-world, without any heuristics or manual tuning of parameters. Secondly, GPs method can be computed effectively because of its closed-form marginal probability computation. Furthermore, its hyper-parameters can be learned from data automatically without using model selection methods such as cross validation, thereby avoiding the high computational cost. Thirdly, the inference of GPs is based on Bayesian rules, resulting in robustness to overfitting. We recommend Rasmussen and Williams's excellent monograph for further reading [42].", "publication_ref": ["b25", "b28", "b41"], "figure_ref": [], "table_ref": []}, {"heading": "Gaussian Processes for Binary Classification", "text": "Formally, for two-class classification, suppose that we have a training set D of N observations, D = {(x i , y i )} N i=1 , where the i-th input point x i \u2208 R D and its corresponding output y i is binary, with y = 1 i for one class and y i = \u22121 for the other. Let X be the N \u00d7 D matrix, where the row vectors represent all n input points, and y be the column vector of all n outputs. We define a latent variable f i for each input point x i , and let\nf = [f 1 , . . . , f N ] . A sigmoid function \u03c0(\u2022) is imposed to squash the output of the latent function into [0, 1], \u03c0(f i ) = p(y i = 1|f i ).\nAssuming the data set is i.i.d, then the joint likelihood factorizes to\np(y|f ) = N i=1 p(y i |f i ) = N i=1 \u03c0(y i f i ).(1)\nMoreover, the posterior distribution over latent functions is\np(f |X, y, \u03b8) = p(y|f )p(f |X) p(y|X, \u03b8) .(2)\nSince neither p(f |X, y, \u03b8) nor p(y|f ) can be computed analytically, the Laplace method is utilized to approximate the posterior\np(f |X, y, \u03b8) = N (f , (K \u22121 + W) \u22121 ),(3)\nwheref = arg max f p(f |X, y, \u03b8) and W = \u2212 log p(f |X, y, \u03b8)| f =f . Then, we can obtain\nlog p(y|X, \u03b8) = \u2212 1 2f K \u22121f + log p(y|f ) \u2212 1 2 log |B|.(4)\nwhere\n|B| = |K| \u2022 |K \u22121 + W| = |I n + W 1 2 KW 1 2 |.\nThe optimal value of \u03b8 can be acquired by using the gradient method to maximize Equation (4). Given any unseen test point x * , the probability of its latent function f * is\nf * |X, y, x * \u223c N (K * K \u22121f , K * * \u2212 K * K \u22121 K * ), (5) whereK = K + W \u22121 .\nFinally, we squash f * to find the probability of class membership as follows\n\u03c0(f * ) = \u03c0(f * )p(f * |X, y, x * )df * .(6)", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Gaussian Processes for Clustering", "text": "The principle of GP clustering is based on the key observation that the variances of predictive values are smaller in dense areas and larger in sparse areas. The variances can be employed as a good estimate of the support of a probability density function, where each separate support domain can be considered as a cluster. This observation can be explained from the variance function of any predictive data point\nx * \u03c3 2 (x * ) = K * * \u2212 K * K \u22121 K * .(7)\nIf x * is in a sparse region, then K * K \u22121 K * becomes small, which leads to large variance \u03c3 2 (x * ), and vice versa. Another good property of Equation ( 7) is that it does not depend on the labels, which means it can be applied to the unlabeled data.\nTo perform clustering, the following dynamic system associated with Equation ( 7) can be written as\nF (x) = \u2212 \u03c3 2 (x).(8)\nThe theorem in [26] guarantees that almost all the trajectories approach one of the stable equilibrium points detected from Equation ( 8). After each data point finds its corresponding stable equilibrium point, we can employ a complete graph [4,26] to assign cluster labels to data points with the stable equilibrium points. Obviously, the variance function in Equation ( 7) completely determines the performance of clustering.", "publication_ref": ["b25", "b3", "b25"], "figure_ref": [], "table_ref": []}, {"heading": "Gaussian Process Latent Variable Model", "text": "Let Z = [z 1 , . . . , z N ] denote the matrix whose rows represent corresponding positions of X in latent space, where\nz i \u2208 R d (d D).\nThe Gaussian Process Latent Variable Model (GPLVM) can be interpreted as a Gaussian process mapping from a low dimensional latent space to a high dimensional data set, where the locale of the points in latent space is determined by maximizing the Gaussian process likelihood with respect to Z. Given a covariance function for the Gaussian process, denoted by k(\u2022, \u2022), the likelihood of the data given the latent positions is as follows,\np(X|Z, \u03b8) = 1 (2\u03c0) N D |K| D exp \u2212 1 2 tr(K \u22121 XX ) ,(9)\nwhere K i,j = k(z i , z j ). Therefore, the posterior can be written as\np(Z, \u03b8|X) = 1 Z a p(X|Z, \u03b8)p(Z)p(\u03b8),(10)\nwhere Z a is a normalization constant, the uninformative priors over \u03b8, and the simple spherical Gaussian priors over Z are introduced [57]. To obtain the optimal \u03b8 and Z, we need to optimize the above likelihood (10) with respect to \u03b8 and Z, respectively.", "publication_ref": ["b56"], "figure_ref": [], "table_ref": []}, {"heading": "GaussianFace", "text": "In order to automatically learn discriminative features or covariance function, and to take advantage of sourcedomain data to improve the performance in face verification, we develop a principled GaussianFace model by including the multi-task learning constraint into Discriminative Gaussian Process Latent Variable Model (DGPLVM) [57].", "publication_ref": ["b56"], "figure_ref": [], "table_ref": []}, {"heading": "DGPLVM Reformulation", "text": "The DGPLVM is an extension of GPLVM, where the discriminative prior is placed over the latent positions, rather than a simple spherical Gaussian prior. The DGPLVM uses the discriminative prior to encourage latent positions of the same class to be close and those of different classes to be far. Since face verification is a binary classification problem and the GPs mainly depend on the kernel function, it is natural to use Kernel Fisher Discriminant Analysis (KFDA) [27] to model class structures in kernel spaces. For simplicity of inference in the followings, we introduce another equivalent formulation of KFDA to replace the one in [57].\nKFDA is a kernelized version of linear discriminant analysis method. It finds the direction defined by a kernel in a feature space, onto which the projections of positive and negative classes are well separated by maximizing the ratio of the between-class variance to the within-class variance. Formally, let {z 1 , . . . , z N+ } denote the positive class and {z N++1 , . . . , z N } the negative class, where the numbers of positive and negative classes are N + and N \u2212 = N \u2212 N + , respectively. Let K be the kernel matrix. Therefore, in the feature space, the two sets {\u03c6 K (z 1 ), . . . , \u03c6 K (z N+ )} and {\u03c6 K (z N++1 ), . . . , \u03c6 K (z N )} represent the positive class and the negative class, respectively. The optimization criterion of KFDA is to maximize the ratio of the betweenclass variance to the within-class variance\nJ(\u03c9, K) = (w (\u00b5 + K \u2212 \u00b5 \u2212 K )) 2 w (\u03a3 + K + \u03a3 \u2212 K + \u03bbI N )w ,(11)\nwhere \u03bb is a positive regularization parameter,\n\u00b5 + K = 1 N+ N+ i=1 \u03c6 K (z i ), \u00b5 \u2212 K = 1 N\u2212 N i=N++1 \u03c6 K (z i ), \u03a3 + K = 1 N+ N+ i=1 (\u03c6 K (z i ) \u2212 \u00b5 + K )(\u03c6 K (z i ) \u2212 \u00b5 + K ) , and \u03a3 \u2212 K = 1 N\u2212 N i=N++1 (\u03c6 K (z i ) \u2212 \u00b5 \u2212 K )(\u03c6 K (z i ) \u2212 \u00b5 \u2212 K )\n. In this paper, however, we focus on the covariance function rather than the latent positions. To simplify calculations, we represent Equation (11) with the kernel function, and let the kernel function have the same form as the covariance function. Therefore, it is natural to introduce a more efficient equivalent form of KFDA with certain assumptions as Kim et al. points out [27], i.e., maximizing Equation ( 11) is equivalent to maximizing the following equation\nJ * = 1 \u03bb a Ka \u2212 a KA(\u03bbI n + AKA) \u22121 AKa , (12\n)\nwhere\na =[ 1 n + 1 N+ , \u2212 1 N \u2212 1 N\u2212 ] A =diag 1 N + I N+ \u2212 1 N + 1 N+ 1 N+ , 1 N \u2212 I N\u2212 \u2212 1 N \u2212 1 N\u2212 1 N\u2212 .\nHere, I N denotes the N \u00d7N identity matrix and 1 N denotes the length-N vector of all ones in R N . Therefore, the discriminative prior over the latent positions in DGPLVM can be written as\np(Z) = 1 Z b exp \u2212 1 \u03c3 2 J * ,(13)\nwhere Z b is a normalization constant, and \u03c3 2 represents a global scaling of the prior. The covariance matrix obtained by DGPLVM is discriminative and more flexible than the one used in conventional GPs for classification (GPC), since they are learned based on a discriminative criterion, and more degrees of freedom are estimated than conventional kernel hyper-parameters.", "publication_ref": ["b26", "b56", "b26"], "figure_ref": [], "table_ref": []}, {"heading": "Multi-task Learning Constraint", "text": "From an asymmetric multi-task learning perspective, the tasks should be allowed to share common hyper-parameters of the covariance function. Moreover, from an information theory perspective, the information cost between target task and multiple source tasks should be minimized. A natural way to quantify the information cost is to use the mutual entropy, because it is the measure of the mutual dependence of two distributions. For multi-task learning, we extend the mutual entropy to multiple distributions as follows\nM = H(p t ) \u2212 1 S S i=1 H(p t |p i ),(14)\nwhere H(\u2022) is the marginal entropy, H(\u2022|\u2022) is the conditional entropy, S is the number of source tasks, {p i } S i=1 , and p t are the probability distributions of source tasks and target task, respectively.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "GaussianFace Model", "text": "In this section, we describe our GaussianFace model in detail. Suppose we have S source-domain datasets {X 1 , . . . , X S } and a target-domain data X T . For each source-domain data or target-domain data X i , according to Equation ( 9), we write its marginal likelihood\np(X i |Z i , \u03b8) = 1 (2\u03c0) N D |K| D exp \u2212 1 2 tr(K \u22121 X i X i ) . (15\n)\nwhere Z i represents the domain-relevant latent space. For each source-domain data and target-domain data, their covariance functions K have the same form because they share the same hyper-parameters \u03b8. In this paper, we use a widely used kernel\nK i,j = k \u03b8 (z i , z j ) =\u03b8 0 exp \u2212 1 2 d m=1 \u03b8 m (z m i \u2212 z m j ) 2 + \u03b8 d+1 + \u03b4 zi,zj \u03b8 d+2 ,(16)\nwhere \u03b8 = {\u03b8 i } d+2 i=0 and d is the dimension of the data point. Then, from Equations (10), learning the DGPLVM is equivalent to optimizing\np(Z i , \u03b8|X i ) = 1 Z a p(X i |Z i , \u03b8)p(Z i )p(\u03b8),(17)\nwhere p(X i |Z i , \u03b8) and p(Z i ) are respectively represented in (15) and (13). According to the multi-task learning constraint in Equation ( 14), we can attain\nM =H(p(Z T , \u03b8|X T )) \u2212 1 S S i=1 H(p(Z T , \u03b8|X T )|p(Z i , \u03b8|X i )). (18\n)\nFrom Equations ( 15), (17), and (18), we know that learning the GaussianFace model amounts to minimizing the following marginal likelihood\nL M odel = \u2212 log p(Z T , \u03b8|X T ) \u2212 \u03b2M,(19)\nwhere the parameter \u03b2 balances the relative importance between the target-domain data and the multi-task learning constraint.", "publication_ref": ["b14", "b12", "b16"], "figure_ref": [], "table_ref": []}, {"heading": "Optimization", "text": "For the model optimization, we first expand Equation (19) to obtain the following equation (ignoring the constant items)\nL M odel = \u2212 log P T + \u03b2P T log P T + \u03b2 S S i=1 P T,i log P i \u2212 P T,i log P T,i , (20\n)\nwhere P i = p(Z i , \u03b8|X i ) and P i,j means that its corresponding covariance function is computed on both X i and X j .\nWe can now optimize Equation (20) with respect to the hyper-parameters \u03b8 and the latent positions Z i by the Scaled Conjugate Gradient (SCG) technique. Since we focus on the covariance matrix in this paper, here we only present the derivations of hyper-parameters. It is easy to get\n\u2202L M odel \u2202\u03b8 j = \u03b2(log P T + 1) \u2212 1 P T \u2202P T \u2202\u03b8 j + \u03b2 S S i=1 P T,i P i \u2022 \u2202P i \u2202\u03b8 j + \u03b2 S S i=1 (log P i \u2212 log P T,i \u2212 1) \u2202P T,i \u2202\u03b8 j .\nThe above equation depends on the form \u2202Pi \u2202\u03b8j as follows (ignoring the constant items)\n\u2202P i \u2202\u03b8 j =P i \u2202 log P i \u2202\u03b8 j \u2248P i \u2202 log p(X i |Z i , \u03b8) \u2202\u03b8 j + \u2202 log p(Z i ) \u2202\u03b8 j + \u2202 log p(\u03b8) \u2202\u03b8 j .\nThe above three terms can be easily obtained (ignoring the constant items) by\n\u2202 log p(X i |Z i , \u03b8) \u2202\u03b8 j \u2248 \u2212 D 2 Tr K \u22121 \u2202K \u2202\u03b8 j + 1 2 Tr K \u22121 X i X i K \u22121 \u2202K \u2202\u03b8 j , \u2202 log p(Z i ) \u2202\u03b8 j \u2248 \u2212 1 \u03c3 2 \u2202J * i \u2202\u03b8 j = \u2212 1 \u03bb\u03c3 2 a \u2202K \u2202\u03b8 j a \u2212 a \u2202K \u2202\u03b8 j\u00c3 a + a K\u00c3 \u2202K \u2202\u03b8 j\u00c3 Ka \u2212 a K\u00c3 \u2202K \u2202\u03b8 j a , \u2202 log p(\u03b8) \u2202\u03b8 j = 1 \u03b8 j , where\u00c3 = A(\u03bbI n + AKA) \u22121 A.\nThus, the desired derivatives have been obtained.", "publication_ref": ["b18", "b19"], "figure_ref": [], "table_ref": []}, {"heading": "Speedup", "text": "In the GaussianFace model, we need to invert the large matrix when doing inference and prediction. For large problems, both storing the matrix and solving the associated linear systems are computationally prohibitive. In this paper, we use the anchor graphs method [35] to speed up this process. To put it simply, we first select q (q n) anchors to cover a cloud of n data points, and form an n \u00d7 q matrix Q, where Q i,j = k \u03b8 (z i , z j ). z i and z j are from n latent data points and q anchors, respectively. Then the original kernel matrix K can be approximated as K \u2248 QQ . Using the Woodbury identity [21], computing the n \u00d7 n matrix QQ can be transformed into computing the q \u00d7 q matrix Q Q, which is more efficient. 19), we need to invert the matrix (\u03bbI n + AKA). During inference, we take q k-means clustering centers as anchors to form Q. Substituting K \u2248 QQ into (\u03bbI n + AKA), and then using the Woodbury identity, we get", "publication_ref": ["b34", "b20"], "figure_ref": [], "table_ref": []}, {"heading": "Speedup on Inference When optimizing Equation (", "text": "(\u03bbI n + AKA) \u22121 \u2248 (\u03bbI n + AQQ A) \u22121 = \u03bb \u22121 I n \u2212 \u03bb \u22121 AQ(\u03bbI q + Q AAQ) \u22121 Q A.\nSimilarly, let K \u22121 \u2248 (K + \u03c4 I) \u22121 where \u03c4 a constant term, then we can get\nK \u22121 \u2248 (K + \u03c4 I) \u22121 \u2248 \u03c4 \u22121 I n \u2212 \u03c4 \u22121 Q(\u03c4 I q + Q Q) \u22121 Q .", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Speedup on Prediction", "text": "When we compute the predictive variance \u03c3(z * ), we need to invert the matrix (K + W \u22121 ). At this time, we can use the method in Section 3.2 to calculate the accurate clustering centers that can be regarded as the anchors. Using the Woodbury identity again, we obtain\n(K + W \u22121 ) \u22121 \u2248 W \u2212 WQ(I q + Q WQ) \u22121 Q W,\nwhere (I q + Q WQ) is only a q \u00d7 q matrix, and its inverse matrix can be computed more efficiently.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "GaussianFace Model for Face Verification", "text": "In this section, we describe two applications of the GaussianFace model to face verification: as a binary classifier and as a feature extractor.\nEach face image is first normalized to 150 \u00d7 120 size by an affine transformation based on five landmarks (two eyes, nose, and two mouth corners). The image is then divided into overlapped patches of 25 \u00d7 25 pixels with a stride of 2 pixels. Each patch within the image is mapped to a vector by a certain descriptor, and the vector is regarded as the feature of the patch, denoted by {x A p } P p=1 where P is the number of patches within the face image A. In this paper, the multi-scale LBP feature of each patch is extracted [14]. The difference is that the multi-scale LBP descriptors are extracted at the center of each patch instead of accurate landmarks.", "publication_ref": ["b13"], "figure_ref": [], "table_ref": []}, {"heading": "GaussianFace Model as a Binary Classifier", "text": "For classification, our model can be regarded as an approach to learn a covariance function for GPC, as shown in Figure 1 (a). Here, for a pair of face images A and B from the same (or different) person, let the similarity vector x i = [s 1 , . . . , s p , . . . , s P ] be the input data point of the GaussianFace model, where s p is the similarity of x A p and\nx B p , and its corresponding output is y i = 1 (or \u22121). With the learned hyper-parameters of covariance function from the training data, given any un-seen pair of face images, we first compute its similarity vector x * using the above method, then estimate its latent representation z * using the same method in [57], and finally predict whether the pair is from the same person through Equation (6). In this paper, we prescribe the sigmoid function \u03c0(\u2022) to be the cumulative Gaussian distribution \u03a6(\u2022), which can be solved\nanalytically as\u03c0 * = \u03a6 f * (z * ) \u221a 1+\u03c3 2 (z * )\n, where \u03c3 2 (z * ) = K * * \u2212 K * K \u22121 K * andf * (z * ) = K * K \u22121f from Equation ( 5) [42]. We call the method GaussianFace-BC.", "publication_ref": ["b56", "b5", "b41"], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "GaussianFace Model as a Feature Extractor", "text": "As a feature extractor, our model can be regarded as an approach to automatically extract facial features, shown in Figure 1 (b). Here, for a pair of face images A and B from the same (or different) person, we regard the joint feature vector\nx i = [(x A i ) , (x B i ) ]\nas the input data point of the GaussianFace model, and its corresponding output is y i = 1 (or \u22121). To enhance the robustness of our approach, the flipped form of x i is also included; for example,\nx i = [(x B i ) , (x A i ) ]\n. After the hyper-parameters of covariance function are learnt from the training data, we first estimate the latent representations of the training data using the same method in [57], then can use the method in Section 3.2 to group the latent data points into different clusters automatically. Suppose that we finally obtain C clusters. The centers of these clusters are denoted by {c i } C i=1 , the variances of these clusters by {\u03a3 2 i } C i=1 , and their weights by {w i } C\ni=1 where w i is the ratio of the number of latent data points from the i-th cluster to the number of all latent data points. Then we refer to each c i as the input of Equation ( 5), and we can obtain its corresponding probability p i and variance \u03c3 2 i . In fact, {c i } C i=1 can be regarded as a codebook generated by our model.\nFor any un-seen pair of face images, we also first compute its joint feature vector x * for each pair of patches, and estimate its latent representation z * . Then we compute its first-order and second-order statistics to the centers. Similarly, we regard z * as the input of Equation ( 5), and can also obtain its corresponding probability p * and variance \u03c3 2 * . The statistics and variance of z * are represented as its high-dimensional facial features, denoted by\u1e91\n* = [\u2206 1 1 , \u2206 2 1 , \u2206 3 1 , \u2206 4 1 , . . . , \u2206 1 C , \u2206 2 C , \u2206 3 C , \u2206 4 C ] ,\nwhere\n\u2206 1 i = w i z * \u2212ci \u03a3i , \u2206 2 i = w i z * \u2212ci \u03a3i 2 , \u2206 3 i = log p * (1\u2212pi) pi(1\u2212p * ) ,and\n\u2206 4 i = \u03c3 2 * \u03c3 2 i .\nWe then concatenate all of the new high-dimensional features from each pair of patches to form the final new high-dimensional feature for the pair of face images. The new high-dimensional facial features not only describe how the distribution of features of an un-seen face image differs from the distribution fitted to the features of all training images, but also encode the predictive information including the probabilities of label and uncertainty. We call this approach GaussianFace-FE.", "publication_ref": ["b56"], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "Experimental Settings", "text": "In this section, we conduct experiments on face verification. We start by introducing the source-domain datasets and the target-domain dataset in all of our experiments (see Figure 2 for examples). The source-domain datasets include four different types of datasets as follows: Multi-PIE [19]. This dataset contains face images from 337 subjects under 15 view points and 19 illumination conditions in four recording sessions. These images are collected under controlled conditions. MORPH [43]. The MORPH database contains 55,000 images of more than 13,000 people within the age ranges of 16 to 77. There are an average of 4 images per individual. Web Images 2 . This dataset contains around 40,000 facial images from 3261 subjects; that is, approximately 10 images for each person. The images were collected from the Web with significant variations in pose, expression, and illumination conditions. Life Photos 2 . This dataset contains approximately 5000 images of 400 subjects collected online. Each subject has roughly 10 images. If not otherwise specified, the target-domain dataset is the benchmark of face verification as follows: LFW [23]. This dataset contains 13,233 uncontrolled face images of 5749 public figures with variety of pose, lighting, expression, race, ethnicity, age, gender, clothing, hairstyles, and other parameters. All of these images are collected from the Web.\nWe use the LFW dataset as the target-domain dataset because it is well known as a challenging benchmark. Using it also allows us to compare directly with other existing face verification methods [9,5,14,47,13,59,1,20,16]. Besides, this dataset provides a large set of relatively unconstrained face images with complex variations as described above, and has proven difficult for automatic face verification methods [23,28]. In all the experiments conducted on LFW, we strictly follow the standard unrestricted protocol of LFW [23]. More precisely, during the training procedure, the four source-domain datasets are: Web Images, Multi-PIE, MORPH, and Life Photos, the target-domain dataset is the training set in View 1 of LFW, and the validation set is the test set in View 1 of LFW. At the test time, we follow the standard 10-fold cross-validation protocol to test our model in View 2 of LFW.\nFor each one of the four source-domain datasets, we randomly sample 20,000 pairs of matched images and 20,000 pairs of mismatched images. The training partition and the testing partition in all of our experiments are mutually exclusive. In other words, there is no identity overlap among the two partitions.\nFor the experiments below, \"The Number of SD\" means \"the Number of Source-Domain datasets that are fed into the GaussianFace model for training\". By parity of reasoning, if \"The Number of SD\" is i, that means the first i source-domain datasets are used for model training. Therefore, if \"The Number of SD\" is 0, models are trained with the training data from target-domain data only.\nImplementation details. Our model involves four important parameters: \u03bb in (12), \u03c3 in (13), \u03b2 in (19), and the number of anchors q in Speedup on Inference 3 . Following the same setting in [27], the regularization parameter \u03bb in ( 12) is fixed to 10 \u22128 . \u03c3 reflects the tradeoff between our method's ability to discriminate (small \u03c3) and its ability to generalize (large \u03c3), and \u03b2 balances the relative importance between the target-domain data and the multi-task learning constraint. Therefore, the validation set (the test set in View 1 of LFW) is used for selecting \u03c3 and \u03b2. Each time we use different number of source-domain datasets for training, the corresponding optimal \u03c3 and \u03b2 should be selected on the validation set.\nSince we collected a large number of image pairs for training (20,000 matched pairs and 20,000 mismatched pairs from each source-domain dataset), and our model is based on the kernel method, thus an important consideration is how to efficiently approximate the kernel matrix using a low-rank method in the limited space and time. We adopt the anchor graphs method (see Section 4.5) for kernel approximation. In our experiments, we take two steps to determine the number of anchor points. In the first step, the optimal \u03c3 and \u03b2 are selected on the validation set in each experiment. In the second step, we fix \u03c3 and \u03b2, and then tune the number of anchor points. We vary the number of anchor points to train our model on the training set, and test it on the validation set. We report the average accuracy for our model over 10 trials. After we consider the trade-off between memory and running time in practice, the number of anchor points with the best average accuracy is determined in each experiments.", "publication_ref": ["b18", "b42", "b22", "b8", "b4", "b13", "b46", "b12", "b58", "b0", "b19", "b15", "b22", "b27", "b22", "b18", "b26"], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "Experimental Results", "text": "In this section, we conduct five experiments to demonstrate the validity of the GaussianFace model.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Comparisons with Other MTGP/GP Methods", "text": "Since our model is based on GPs, it is natural to compare our model with four popular GP models: GPC [42], MTGP prediction [6], GPLVM [29], and DGPLVM [57]. For fair comparisons, all these models are trained on multiple source-domain datasets using the same two methods as our GaussianFace model described in Section 5. After the hyper-parameters of covariance function are learnt for each model, we can regard each model as a binary classifier and a feature extractor like ours, respectively. Figure 3 shows that our model significantly outperforms the other four GPs models, and the superiority of our model becomes more obvious as the number of source-domain datasets increases.", "publication_ref": ["b41", "b5", "b28", "b56"], "figure_ref": ["fig_2"], "table_ref": []}, {"heading": "Comparisons with Other Binary Classifiers", "text": "Since our model can be regarded as a binary classifier, we have also compared our method with other classical function and the number of anchors in Speedup on Prediction, can be automatically learned from the data. binary classifiers. For this paper, we chose three popular representatives: SVM [12], logistic regression (LR) [17], and Adaboost [18]. Table 1 demonstrates that the performance of our method GaussianFace-BC is much better than those of the other classifiers. Furthermore, these experimental results demonstrates the effectiveness of the multi-task learning constraint. For example, our GaussianFace-BC has about 7.5% improvement when all four source-domain datasets are used for training, while the best one of the other three binary classifiers has only around 4% improvement.", "publication_ref": ["b11", "b16", "b17"], "figure_ref": [], "table_ref": ["tab_0"]}, {"heading": "Comparisons with Other Feature Extractors", "text": "Our model can also be regarded as a feature extractor, which is implemented by clustering to generate a codebook. Therefore, we evaluate our method by comparing it with three popular clustering methods: K-means [24], Random Projection (RP) tree [15], and Gaussian Mixture Model (GMM) [47]. Since our method can determine the number of clusters automatically, for fair comparison, all the other methods generate the same number of clusters as ours. As shown in  [5] High dimensional LBP (95.17%) [14] Fisher Vector Faces (93.03%) [47] combined Joint Bayesian (92.42%) [13] Associate-Predict (90.57%) [59] TL Joint Bayesian (96.33%) [9] VisionLabs (92.90%) [1] Aurora (93.24%) [20] Face++ (97.27%) [16] Human, cropped (97.53%) [28] DeepFace-ensemble (97.35%) [53] GaussianFace-FE + GaussianFace-BC (98.52%) false positive rate true positive rate significantly outperforms all of the compared approaches, which verifies the effectiveness of our method as a feature extractor. The results have also proved that the multi-task learning constraint is effective. Each time one different type of source-domain dataset is added for training, the performance can be improved significantly. Our GaussianFace-FE model achieves over 8% improvement when the number of SD varies from 0 to 4, which is much higher than the \u223c3% improvement of the other methods.", "publication_ref": ["b23", "b14", "b46", "b4", "b13", "b46", "b12", "b58", "b8", "b0", "b19", "b15", "b27", "b52"], "figure_ref": [], "table_ref": []}, {"heading": "Comparison with the state-of-art Methods", "text": "Motivated by the appealing performance of both GaussianFace-BC and GaussianFace-FE, we further combine them for face verification. Specifically, after facial features are extracted using GaussianFace-FE, GaussianFace-BC 4 is used to make the final decision. Figure 4 shows the results of this combination compared with state-of-theart methods [9,5,14,47,13,53,59,1,20,16]. The best published result on the LFW benchmark is 97.35%, which is achieved by [53]. Our GaussianFace model can improve the accuracy to 98.52%, which for the first time beats the human-level performance (97.53%, cropped) [28]. Figure 5 presents some example pairs that were always incorrectly classified by our model. Obviously, even for humans, it is also difficult to verify some of them. Here, we emphasize that the centers of patches, instead of the accurate and dense facial landmarks like [9], are utilized to extract multi-scale features in our method. This makes our method simpler and easier to use.", "publication_ref": ["b3", "b8", "b4", "b13", "b46", "b12", "b52", "b58", "b0", "b19", "b15", "b52", "b27", "b8"], "figure_ref": ["fig_3", "fig_4"], "table_ref": []}, {"heading": "Further Validations: Shuffling the Source-Target", "text": "To further prove the validity of our model, we also consider to treat Multi-PIE and MORPH respectively as the target-domain dataset and the others as the sourcedomain datasets. The target-domain dataset is split into two mutually exclusive parts: one consisting of 20,000 matched pairs and 20,000 mismatched pairs is used for training, the other is used for test. In the test set, similar to the protocol of LFW, we select 10 mutually exclusive subsets, where each subset consists of 300 matched pairs and 300 mismatched pairs. The experimental results are presented in Figure 6. Each time one dataset is added to the training set, the performance can be improved, even though the types of data are very different in the training set.", "publication_ref": [], "figure_ref": ["fig_5"], "table_ref": []}, {"heading": "General Discussion", "text": "There is an implicit belief among many psychologists and computer scientists that human face verification abilities are currently beyond existing computer-based face verification algorithms [39]. This belief, however, is supported more by anecdotal impression than by scientific evidence. By contrast, there have already been a number of papers comparing human and computer-based face verification performance [2,54,40,41,38,8]. It has been shown that the best current face verification algorithms perform better than humans in the good and moderate conditions. So, it is really not that difficult to beat human performance in some specific scenarios.\nAs pointed out by [38,48], humans and computer-based algorithms have different strategies in face verification. Indeed, by contrast to performance with unfamiliar faces, human face verification abilities for familiar faces are relatively robust to changes in viewing parameters such as illumination and pose. For example, Bruce [7] found human recognition memory for unfamiliar faces dropped substantially when there were changes in viewing parameters. Besides, humans can take advantages of non-face configurable information from the combination of the face and body (e.g., neck, shoulders). It has also been examined in [28], where the human performance drops from 99.20% (tested using the original LFW images) to 97.53% (tested using the cropped LFW images). Hence, the experiments comparing human and computer performance may not show human face verification skill at their best, because humans were asked to match the cropped faces of people previously unfamiliar to them. To the contrary, those experiments can fully show the performance of computer-based face verification algorithms. First, the algorithms can exploit information from enough training images with variations in all viewing parameters to improve face verification performance, which is similar to information humans acquire in developing face verification skills and in becoming familiar with individuals. Second, the algorithms might exploit useful, but subtle, image-based detailed information that give them a slight, but consistent, advantage over humans. Therefore, surpassing the human-level performance may only be symbolically significant. In reality, a lot of challenges still lay ahead. To compete successfully with humans, more factors such as the robustness to familiar faces and the usage of non-face information, need to be considered in developing future face verification algorithms.", "publication_ref": ["b38", "b1", "b53", "b39", "b40", "b37", "b7", "b37", "b47", "b6", "b27"], "figure_ref": [], "table_ref": []}, {"heading": "Conclusion and Future Work", "text": "This paper presents a principled Multi-Task Learning approach based on Discriminative Gaussian Process Latent Variable Model, named GaussianFace, for face verification by including a computationally more efficient equivalent form of KFDA and the multi-task learning constraint to the DGPLVM model. We use Gaussian Processes approximation and anchor graphs to speed up the inference and prediction of our model. Based on the GaussianFace model, we propose two different approaches for face verification. Extensive experiments on challenging datasets validate the efficacy of our model. The GaussianFace model finally surpassed human-level face verification accuracy, thanks to exploiting additional data from multiple source-domains to improve the generalization performance of face verification in the target-domain and adapting automatically to complex face variations.\nAlthough several techniques such as the Laplace approximation and anchor graph are introduced to speed up the process of inference and prediction in our GaussianFace model, it still takes a long time to train our model for the high performance. In addition, large memory is also necessary. Therefore, for specific application, one needs to balance the three dimensions: memory, running time, and performance. Generally speaking, higher performance requires more memory and more running time. In the future, the issue of running time can be further addressed by the distributed parallel algorithm or the GPU implementation of large matrix inversion. To address the issue of memory, some online algorithms for training need to be developed. Another more intuitive method is to seek a more efficient sparse representation for the large covariance matrix. ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgements", "text": "We would like to thank Deli Zhao and Chen Change Loy for their insightful discussions. This work is partially supported by \"CUHK Computer Vision Cooperation\" grant from Huawei, and by the General Research Fund sponsored", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Website", "journal": "", "year": "", "authors": " Visionlabs"}, {"ref_id": "b1", "title": "Comparing human and automatic face recognition performance", "journal": "IEEE Transactions on Systems, Man, and Cybernetics", "year": "2007", "authors": "A Adler; M E Schuckers"}, {"ref_id": "b2", "title": "Face description with local binary patterns: Application to face recognition", "journal": "TPAMI", "year": "2006", "authors": "T Ahonen; A Hadid; M Pietikainen"}, {"ref_id": "b3", "title": "", "journal": "", "year": "2002", "authors": "A Ben-Hur; D Horn; H T Siegelmann; V Vapnik"}, {"ref_id": "b4", "title": "Tom-vs-pete classifiers and identity-preserving alignment for face verification", "journal": "", "year": "2012", "authors": "T Berg; P N Belhumeur"}, {"ref_id": "b5", "title": "Multi-task gaussian process prediction", "journal": "", "year": "2008", "authors": "E Bonilla; K M Chai; C Williams"}, {"ref_id": "b6", "title": "Changing faces: Visual and non-visual coding processes in face recognition", "journal": "British Journal of Psychology", "year": "1982", "authors": "V Bruce"}, {"ref_id": "b7", "title": "Comparisons between human and computer recognition of faces", "journal": "", "year": "1998", "authors": "V Bruce; P J Hancock; A M Burton"}, {"ref_id": "b8", "title": "A practical transfer learning algorithm for face verification", "journal": "", "year": "", "authors": "X Cao; D Wipf; F Wen; G Duan"}, {"ref_id": "b9", "title": "Face recognition with learning-based descriptor", "journal": "", "year": "2010", "authors": "Z Cao; Q Yin; X Tang; J Sun"}, {"ref_id": "b10", "title": "Multi-task learning with gaussian processes", "journal": "", "year": "2010", "authors": "K M Chai"}, {"ref_id": "b11", "title": "Libsvm: a library for support vector machines", "journal": "ACM TIST", "year": "2011", "authors": "C.-C Chang; C.-J Lin"}, {"ref_id": "b12", "title": "Bayesian face revisited: A joint formulation", "journal": "", "year": "2012", "authors": "D Chen; X Cao; L Wang; F Wen; J Sun"}, {"ref_id": "b13", "title": "Blessing of dimensionality: High-dimensional feature and its efficient compression for face verification", "journal": "", "year": "2013", "authors": "D Chen; X Cao; F Wen; J Sun"}, {"ref_id": "b14", "title": "Random projection trees for vector quantization", "journal": "IEEE Transactions on Information Theory", "year": "2009", "authors": "S Dasgupta; Y Freund"}, {"ref_id": "b15", "title": "Learning deep face representation", "journal": "", "year": "2014", "authors": "H Fan; Z Cao; Y Jiang; Q Yin; C Doudou"}, {"ref_id": "b16", "title": "Liblinear: A library for large linear classification", "journal": "JMLR", "year": "2008", "authors": "R.-E Fan; K.-W Chang; C.-J Hsieh; X.-R Wang; C.-J Lin"}, {"ref_id": "b17", "title": "A short introduction to boosting", "journal": "Journal-Japanese Society For Artificial Intelligence", "year": "1999", "authors": "Y Freund; R Schapire; N Abe"}, {"ref_id": "b18", "title": "Multi-pie. Image and Vision Computing", "journal": "", "year": "2010", "authors": "R Gross; I Matthews; J Cohn; T Kanade; S Baker"}, {"ref_id": "b19", "title": "Aurora face recognition technical report: Evaluation of algorithm aurora-c-2014-1 on labeled faces in the wild", "journal": "", "year": "", "authors": "T Heseltine; P Szeptycki; J Gomes; M Ruiz; P Li"}, {"ref_id": "b20", "title": "Accuracy and Stability of Numberical Algorithms. Number 48", "journal": "", "year": "1996", "authors": "N J Higham"}, {"ref_id": "b21", "title": "Learning hierarchical representations for face verification with convolutional deep belief networks", "journal": "", "year": "2012", "authors": "G Huang; H Lee; E Learned-Miller"}, {"ref_id": "b22", "title": "Labeled faces in the wild: A database for studying face recognition in unconstrained environments", "journal": "", "year": "2007", "authors": "G B Huang; M Ramesh; T Berg; E Learned-Miller"}, {"ref_id": "b23", "title": "Face recognition using local quantized patterns", "journal": "", "year": "2012", "authors": "S U Hussain; T Napol\u00e9on; F Jurie"}, {"ref_id": "b24", "title": "Appearance-based gender classification with gaussian processes", "journal": "Pattern Recognition Letters", "year": "2006", "authors": "H.-C Kim; D Kim; Z Ghahramani; S Y Bang"}, {"ref_id": "b25", "title": "Clustering based on gaussian processes", "journal": "Neural computation", "year": "2007", "authors": "H.-C Kim; J Lee"}, {"ref_id": "b26", "title": "Optimal kernel selection in kernel fisher discriminant analysis", "journal": "", "year": "2006", "authors": "S.-J Kim; A Magnani; S Boyd"}, {"ref_id": "b27", "title": "Attribute and simile classifiers for face verification", "journal": "", "year": "2009", "authors": "N Kumar; A C Berg; P N Belhumeur; S K Nayar"}, {"ref_id": "b28", "title": "Gaussian process latent variable models for visualisation of high dimensional data", "journal": "", "year": "2003", "authors": "N D Lawrence"}, {"ref_id": "b29", "title": "Focused multitask learning using gaussian processes", "journal": "", "year": "2011", "authors": "G Leen; J Peltonen; S Kaski"}, {"ref_id": "b30", "title": "Probabilistic elastic matching for pose variant face verification", "journal": "", "year": "2013", "authors": "H Li; G Hua; Z Lin; J Brandt; J Yang"}, {"ref_id": "b31", "title": "Nonparametric discriminant analysis for face recognition", "journal": "TPAMI", "year": "2009", "authors": "Z Li; D Lin; X Tang"}, {"ref_id": "b32", "title": "Nonparametric subspace analysis for face recognition", "journal": "", "year": "2005", "authors": "Z Li; W Liu; D Lin; X Tang"}, {"ref_id": "b33", "title": "Gabor feature based classification using the enhanced fisher linear discriminant model for face recognition", "journal": "TIP", "year": "2002", "authors": "C Liu; H Wechsler"}, {"ref_id": "b34", "title": "Large graph construction for scalable semi-supervised learning", "journal": "", "year": "2010", "authors": "W Liu; J He; S.-F Chang"}, {"ref_id": "b35", "title": "Distinctive image features from scaleinvariant keypoints", "journal": "IJCV", "year": "2004", "authors": "D G Lowe"}, {"ref_id": "b36", "title": "Bayesian face recognition", "journal": "Pattern Recognition", "year": "2000", "authors": "B Moghaddam; T Jebara; A Pentland"}, {"ref_id": "b37", "title": "Comparing face recognition algorithms to humans on challenging tasks", "journal": "ACM Transactions on Applied Perception", "year": "2012", "authors": "A J O'toole; X An; J Dunlop; V Natu; P J Phillips"}, {"ref_id": "b38", "title": "Predicting human performance for face recognition", "journal": "Elsevier", "year": "2006", "authors": "A J Otoole; F Jiang; D Roark; H Abdi"}, {"ref_id": "b39", "title": "Face recognition algorithms surpass humans matching faces over changes in illumination", "journal": "TPAMI", "year": "2007", "authors": "A J O'toole; P J Phillips; F Jiang; J Ayyad; N P\u00e9nard; H Abdi"}, {"ref_id": "b40", "title": "Comparison of human and computer performance across face recognition experiments", "journal": "Image and Vision Computing", "year": "2014", "authors": "P J Phillips; A J O'toole"}, {"ref_id": "b41", "title": "Gaussian processes for machine learning", "journal": "", "year": "2006", "authors": "C E Rasmussen; C K I Williams"}, {"ref_id": "b42", "title": "Morph: A longitudinal image database of normal adult age-progression", "journal": "", "year": "2006", "authors": "K Ricanek; T Tesafaye"}, {"ref_id": "b43", "title": "Coupled gaussian process regression for pose-invariant facial expression recognition", "journal": "", "year": "2010", "authors": "O Rudovic; I Patras; M Pantic"}, {"ref_id": "b44", "title": "Using deep belief nets to learn covariance kernels for gaussian processes", "journal": "", "year": "2007", "authors": "R Salakhutdinov; G E Hinton"}, {"ref_id": "b45", "title": "Face verification using the lark representation", "journal": "TIFS", "year": "2011", "authors": "H J Seo; P Milanfar"}, {"ref_id": "b46", "title": "Zisserman. Fisher vector faces in the wild", "journal": "IJCV", "year": "2004", "authors": "K Simonyan; O M Parkhi; A Vedaldi; A "}, {"ref_id": "b47", "title": "Face recognition by humans: 20 results all computer vision researchers should know about. Department of Brain and Cognitive Sciences", "journal": "", "year": "2005", "authors": "P Sinha; B Balas; Y Ostrovsky; R Russell"}, {"ref_id": "b48", "title": "Bayesian multitask classification with gaussian process priors", "journal": "IEEE Transactions on Neural Networks", "year": "2011", "authors": "G Skolidis; G Sanguinetti"}, {"ref_id": "b49", "title": "Hybrid deep learning for face verification", "journal": "", "year": "2013", "authors": "Y Sun; X Wang; X Tang"}, {"ref_id": "b50", "title": "Deep learning face representation from predicting 10,000 classes", "journal": "", "year": "2014", "authors": "Y Sun; X Wang; X Tang"}, {"ref_id": "b51", "title": "Multiple oneshots for utilizing class label information", "journal": "", "year": "2009", "authors": "Y Taigman; L Wolf; T Hassner"}, {"ref_id": "b52", "title": "Deep-Face: Closing the Gap to Human-Level Performance in Face Verification", "journal": "CVPR", "year": "2014", "authors": "Y Taigman; M Yang; M Ranzato; L Wolf"}, {"ref_id": "b53", "title": "Face sketch recognition", "journal": "IEEE Transactions on Circuits and Systems for Video Technology", "year": "2004", "authors": "X Tang; X Wang"}, {"ref_id": "b54", "title": "Unbiased look at dataset bias", "journal": "", "year": "2011", "authors": "A Torralba; A A Efros"}, {"ref_id": "b55", "title": "Face recognition using eigenfaces", "journal": "", "year": "1991", "authors": "M A Turk; A P Pentland"}, {"ref_id": "b56", "title": "Discriminative gaussian process latent variable model for classification", "journal": "", "year": "2007", "authors": "R Urtasun; T Darrell"}, {"ref_id": "b57", "title": "Implicit elastic matching with random projections for pose-variant face recognition", "journal": "", "year": "2009", "authors": "J Wright; G Hua"}, {"ref_id": "b58", "title": "An associate-predict model for face recognition", "journal": "", "year": "2011", "authors": "Q Yin; X Tang; J Sun"}, {"ref_id": "b59", "title": "Learning gaussian processes from multiple tasks", "journal": "", "year": "2005", "authors": "K Yu; V Tresp; A Schwaighofer"}, {"ref_id": "b60", "title": "Multi-task warped gaussian process for personalized age estimation", "journal": "", "year": "2010", "authors": "Y Zhang; D.-Y Yeung"}, {"ref_id": "b61", "title": "Deep learning identity preserving face space", "journal": "", "year": "", "authors": "Z Zhu; P Luo; X Wang; X Tang"}, {"ref_id": "b62", "title": "Recover canonical-view faces in the wild with deep neural networks", "journal": "", "year": "2014", "authors": "Z Zhu; P Luo; X Wang; X Tang"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 1 .1Figure 1. Two approaches based on GaussianFace model for face verification. (a) GaussianFace model as a binary classifier. (b) GaussianFace model as a feature extractor.", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 2 .2Figure 2. Samples of the datasets in our experiments. From left to right: LFW, Multi-PIE, MORPH, Web Images, and Life Photos.", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Figure 3 .3Figure 3. (a) The accuracy rate (%) of the GaussianFace-BC model and other competing MTGP/GP methods as a binary classifier. (b)The accuracy rate (%) of the GaussianFace-FE model and other competing MTGP/GP methods as a feature extractor. (c) The relative improvement of each method as a binary classifier with the increasing number of SD, compared to their performance when the number of SD is 0. (d) The relative improvement of each method as a feature extractor with the increasing number of SD, compared to their performance when the number of SD is 0.", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Figure 4 .4Figure 4. The ROC curve on LFW. Our method achieves the best performance, beating human-level performance.", "figure_data": ""}, {"figure_label": "5", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "Figure 5 .5Figure 5. The two rows present examples of matched and mismatched pairs respectively from LFW that were incorrectly classified by the GaussianFace model.", "figure_data": ""}, {"figure_label": "6", "figure_type": "figure", "figure_id": "fig_5", "figure_caption": "Figure 6 .6Figure 6. (a) The accuracy rate (%) of the GaussianFace model on Multi-PIE. (b) The accuracy rate (%) of the GaussianFace model on MORPH.", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "GaussianFace-BC 86.25 88.24 90.01 92.22 93.73 The accuracy rate (%) of our methods as a binary classifier and other competing methods on LFW using the increasing number of source-domain datasets.", "figure_data": "The Number of SD01234SVM [12]83.21 84.32 85.06 86.43 87.31LR [17]81.14 81.92 82.65 83.84 84.75Adaboost [18]82.91 83.62 84.80 86.30 87.21"}, {"figure_label": "22", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "our method GaussianFace-FE 85.20 85.74 86.81 87.68 RP Tree [15] 85.11 85.70 86.45 87.52 88.34 GMM [47] 86.63 87.02 87.58 88.60 89.21 GaussianFace-FE 89.33 91.04 93.31 95.62 97.79 The accuracy rate (%) of our methods as a feature extractor and other competing methods on LFW using the increasing number of source-domain datasets.", "figure_data": "The Number of SD01234K-means [24]84.71"}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_2", "figure_caption": "by the Research Grants Council of Hong Kong (Project No.CUHK 416510 and 416312) and Guangdong Innovative Research Team Program (No.201001D0104648280).", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "f = [f 1 , . . . , f N ] . A sigmoid function \u03c0(\u2022) is imposed to squash the output of the latent function into [0, 1], \u03c0(f i ) = p(y i = 1|f i ).", "formula_coordinates": [3.0, 308.86, 220.61, 236.25, 33.59]}, {"formula_id": "formula_1", "formula_text": "p(y|f ) = N i=1 p(y i |f i ) = N i=1 \u03c0(y i f i ).(1)", "formula_coordinates": [3.0, 353.54, 271.77, 191.57, 30.32]}, {"formula_id": "formula_2", "formula_text": "p(f |X, y, \u03b8) = p(y|f )p(f |X) p(y|X, \u03b8) .(2)", "formula_coordinates": [3.0, 365.34, 327.63, 179.77, 22.31]}, {"formula_id": "formula_3", "formula_text": "p(f |X, y, \u03b8) = N (f , (K \u22121 + W) \u22121 ),(3)", "formula_coordinates": [3.0, 349.73, 403.08, 195.38, 11.03]}, {"formula_id": "formula_4", "formula_text": "log p(y|X, \u03b8) = \u2212 1 2f K \u22121f + log p(y|f ) \u2212 1 2 log |B|.(4)", "formula_coordinates": [3.0, 314.76, 456.19, 230.36, 31.89]}, {"formula_id": "formula_5", "formula_text": "|B| = |K| \u2022 |K \u22121 + W| = |I n + W 1 2 KW 1 2 |.", "formula_coordinates": [3.0, 335.94, 500.31, 189.84, 12.53]}, {"formula_id": "formula_6", "formula_text": "f * |X, y, x * \u223c N (K * K \u22121f , K * * \u2212 K * K \u22121 K * ), (5) whereK = K + W \u22121 .", "formula_coordinates": [3.0, 308.86, 558.91, 236.25, 34.79]}, {"formula_id": "formula_7", "formula_text": "\u03c0(f * ) = \u03c0(f * )p(f * |X, y, x * )df * .(6)", "formula_coordinates": [3.0, 353.2, 623.36, 191.92, 9.68]}, {"formula_id": "formula_8", "formula_text": "x * \u03c3 2 (x * ) = K * * \u2212 K * K \u22121 K * .(7)", "formula_coordinates": [4.0, 92.17, 111.02, 194.19, 34.8]}, {"formula_id": "formula_9", "formula_text": "F (x) = \u2212 \u03c3 2 (x).(8)", "formula_coordinates": [4.0, 130.14, 256.18, 156.22, 11.03]}, {"formula_id": "formula_10", "formula_text": "z i \u2208 R d (d D).", "formula_coordinates": [4.0, 78.13, 430.84, 82.61, 11.23]}, {"formula_id": "formula_11", "formula_text": "p(X|Z, \u03b8) = 1 (2\u03c0) N D |K| D exp \u2212 1 2 tr(K \u22121 XX ) ,(9)", "formula_coordinates": [4.0, 55.71, 537.9, 230.66, 36.32]}, {"formula_id": "formula_12", "formula_text": "p(Z, \u03b8|X) = 1 Z a p(X|Z, \u03b8)p(Z)p(\u03b8),(10)", "formula_coordinates": [4.0, 94.25, 621.28, 192.12, 23.22]}, {"formula_id": "formula_13", "formula_text": "J(\u03c9, K) = (w (\u00b5 + K \u2212 \u00b5 \u2212 K )) 2 w (\u03a3 + K + \u03a3 \u2212 K + \u03bbI N )w ,(11)", "formula_coordinates": [4.0, 348.19, 518.31, 196.92, 27.64]}, {"formula_id": "formula_14", "formula_text": "\u00b5 + K = 1 N+ N+ i=1 \u03c6 K (z i ), \u00b5 \u2212 K = 1 N\u2212 N i=N++1 \u03c6 K (z i ), \u03a3 + K = 1 N+ N+ i=1 (\u03c6 K (z i ) \u2212 \u00b5 + K )(\u03c6 K (z i ) \u2212 \u00b5 + K ) , and \u03a3 \u2212 K = 1 N\u2212 N i=N++1 (\u03c6 K (z i ) \u2212 \u00b5 \u2212 K )(\u03c6 K (z i ) \u2212 \u00b5 \u2212 K )", "formula_coordinates": [4.0, 310.06, 557.67, 235.05, 60.09]}, {"formula_id": "formula_15", "formula_text": "J * = 1 \u03bb a Ka \u2212 a KA(\u03bbI n + AKA) \u22121 AKa , (12", "formula_coordinates": [5.0, 55.38, 96.02, 226.83, 22.31]}, {"formula_id": "formula_16", "formula_text": ")", "formula_coordinates": [5.0, 282.21, 103.08, 4.15, 8.64]}, {"formula_id": "formula_17", "formula_text": "a =[ 1 n + 1 N+ , \u2212 1 N \u2212 1 N\u2212 ] A =diag 1 N + I N+ \u2212 1 N + 1 N+ 1 N+ , 1 N \u2212 I N\u2212 \u2212 1 N \u2212 1 N\u2212 1 N\u2212 .", "formula_coordinates": [5.0, 84.62, 147.52, 167.24, 79.07]}, {"formula_id": "formula_18", "formula_text": "p(Z) = 1 Z b exp \u2212 1 \u03c3 2 J * ,(13)", "formula_coordinates": [5.0, 110.41, 294.72, 175.96, 23.23]}, {"formula_id": "formula_19", "formula_text": "M = H(p t ) \u2212 1 S S i=1 H(p t |p i ),(14)", "formula_coordinates": [5.0, 103.84, 560.98, 182.52, 30.32]}, {"formula_id": "formula_20", "formula_text": "p(X i |Z i , \u03b8) = 1 (2\u03c0) N D |K| D exp \u2212 1 2 tr(K \u22121 X i X i ) . (15", "formula_coordinates": [5.0, 309.48, 105.54, 235.01, 36.32]}, {"formula_id": "formula_21", "formula_text": ")", "formula_coordinates": [5.0, 540.96, 133.22, 4.15, 8.64]}, {"formula_id": "formula_22", "formula_text": "K i,j = k \u03b8 (z i , z j ) =\u03b8 0 exp \u2212 1 2 d m=1 \u03b8 m (z m i \u2212 z m j ) 2 + \u03b8 d+1 + \u03b4 zi,zj \u03b8 d+2 ,(16)", "formula_coordinates": [5.0, 315.02, 220.83, 230.09, 57.78]}, {"formula_id": "formula_23", "formula_text": "p(Z i , \u03b8|X i ) = 1 Z a p(X i |Z i , \u03b8)p(Z i )p(\u03b8),(17)", "formula_coordinates": [5.0, 344.7, 332.56, 200.41, 23.23]}, {"formula_id": "formula_24", "formula_text": "M =H(p(Z T , \u03b8|X T )) \u2212 1 S S i=1 H(p(Z T , \u03b8|X T )|p(Z i , \u03b8|X i )). (18", "formula_coordinates": [5.0, 327.48, 409.63, 213.49, 45.73]}, {"formula_id": "formula_25", "formula_text": ")", "formula_coordinates": [5.0, 540.96, 435.76, 4.15, 8.64]}, {"formula_id": "formula_26", "formula_text": "L M odel = \u2212 log p(Z T , \u03b8|X T ) \u2212 \u03b2M,(19)", "formula_coordinates": [5.0, 350.64, 509.52, 194.47, 9.68]}, {"formula_id": "formula_27", "formula_text": "L M odel = \u2212 log P T + \u03b2P T log P T + \u03b2 S S i=1 P T,i log P i \u2212 P T,i log P T,i , (20", "formula_coordinates": [5.0, 319.66, 636.39, 221.31, 45.7]}, {"formula_id": "formula_28", "formula_text": ")", "formula_coordinates": [5.0, 540.96, 662.49, 4.15, 8.64]}, {"formula_id": "formula_29", "formula_text": "\u2202L M odel \u2202\u03b8 j = \u03b2(log P T + 1) \u2212 1 P T \u2202P T \u2202\u03b8 j + \u03b2 S S i=1 P T,i P i \u2022 \u2202P i \u2202\u03b8 j + \u03b2 S S i=1 (log P i \u2212 log P T,i \u2212 1) \u2202P T,i \u2202\u03b8 j .", "formula_coordinates": [6.0, 65.48, 142.3, 206.7, 93.49]}, {"formula_id": "formula_30", "formula_text": "\u2202P i \u2202\u03b8 j =P i \u2202 log P i \u2202\u03b8 j \u2248P i \u2202 log p(X i |Z i , \u03b8) \u2202\u03b8 j + \u2202 log p(Z i ) \u2202\u03b8 j + \u2202 log p(\u03b8) \u2202\u03b8 j .", "formula_coordinates": [6.0, 51.31, 280.3, 237.01, 51.11]}, {"formula_id": "formula_31", "formula_text": "\u2202 log p(X i |Z i , \u03b8) \u2202\u03b8 j \u2248 \u2212 D 2 Tr K \u22121 \u2202K \u2202\u03b8 j + 1 2 Tr K \u22121 X i X i K \u22121 \u2202K \u2202\u03b8 j , \u2202 log p(Z i ) \u2202\u03b8 j \u2248 \u2212 1 \u03c3 2 \u2202J * i \u2202\u03b8 j = \u2212 1 \u03bb\u03c3 2 a \u2202K \u2202\u03b8 j a \u2212 a \u2202K \u2202\u03b8 j\u00c3 a + a K\u00c3 \u2202K \u2202\u03b8 j\u00c3 Ka \u2212 a K\u00c3 \u2202K \u2202\u03b8 j a , \u2202 log p(\u03b8) \u2202\u03b8 j = 1 \u03b8 j , where\u00c3 = A(\u03bbI n + AKA) \u22121 A.", "formula_coordinates": [6.0, 50.11, 373.43, 237.43, 183.29]}, {"formula_id": "formula_32", "formula_text": "(\u03bbI n + AKA) \u22121 \u2248 (\u03bbI n + AQQ A) \u22121 = \u03bb \u22121 I n \u2212 \u03bb \u22121 AQ(\u03bbI q + Q AAQ) \u22121 Q A.", "formula_coordinates": [6.0, 309.39, 189.58, 235.2, 28.25]}, {"formula_id": "formula_33", "formula_text": "K \u22121 \u2248 (K + \u03c4 I) \u22121 \u2248 \u03c4 \u22121 I n \u2212 \u03c4 \u22121 Q(\u03c4 I q + Q Q) \u22121 Q .", "formula_coordinates": [6.0, 308.86, 259.76, 245.47, 11.72]}, {"formula_id": "formula_34", "formula_text": "(K + W \u22121 ) \u22121 \u2248 W \u2212 WQ(I q + Q WQ) \u22121 Q W,", "formula_coordinates": [6.0, 314.57, 361.24, 224.83, 11.72]}, {"formula_id": "formula_35", "formula_text": "analytically as\u03c0 * = \u03a6 f * (z * ) \u221a 1+\u03c3 2 (z * )", "formula_coordinates": [7.0, 50.11, 181.11, 150.62, 18.43]}, {"formula_id": "formula_36", "formula_text": "x i = [(x A i ) , (x B i ) ]", "formula_coordinates": [7.0, 78.66, 305.08, 91.84, 12.32]}, {"formula_id": "formula_37", "formula_text": "x i = [(x B i ) , (x A i ) ]", "formula_coordinates": [7.0, 50.11, 352.9, 94.07, 12.32]}, {"formula_id": "formula_38", "formula_text": "* = [\u2206 1 1 , \u2206 2 1 , \u2206 3 1 , \u2206 4 1 , . . . , \u2206 1 C , \u2206 2 C , \u2206 3 C , \u2206 4 C ] ,", "formula_coordinates": [7.0, 50.11, 618.55, 236.25, 22.86]}, {"formula_id": "formula_39", "formula_text": "\u2206 1 i = w i z * \u2212ci \u03a3i , \u2206 2 i = w i z * \u2212ci \u03a3i 2 , \u2206 3 i = log p * (1\u2212pi) pi(1\u2212p * ) ,and", "formula_coordinates": [7.0, 50.11, 628.93, 236.25, 46.53]}, {"formula_id": "formula_40", "formula_text": "\u2206 4 i = \u03c3 2 * \u03c3 2 i .", "formula_coordinates": [7.0, 69.73, 661.83, 49.89, 18.43]}], "doi": ""}