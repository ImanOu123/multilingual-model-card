{"title": "Modular Multitask Reinforcement Learning with Policy Sketches", "authors": "Jacob Andreas; Dan Klein; Sergey Levine", "pub_date": "", "abstract": "We describe a framework for multitask deep reinforcement learning guided by policy sketches. Sketches annotate tasks with sequences of named subtasks, providing information about high-level structural relationships among tasks but not how to implement them-specifically not providing the detailed guidance used by much previous work on learning policy abstractions for RL (e.g. intermediate rewards, subtask completion signals, or intrinsic motivations). To learn from sketches, we present a model that associates every subtask with a modular subpolicy, and jointly maximizes reward over full task-specific policies by tying parameters across shared subpolicies. Optimization is accomplished via a decoupled actor-critic training objective that facilitates learning common behaviors from multiple dissimilar reward functions. We evaluate the effectiveness of our approach in three environments featuring both discrete and continuous control, and with sparse rewards that can be obtained only after completing a number of high-level subgoals. Experiments show that using our approach to learn policies guided by sketches gives better performance than existing techniques for learning task-specific or shared policies, while naturally inducing a library of interpretable primitive behaviors that can be recombined to rapidly adapt to new tasks.", "sections": [{"heading": "Introduction", "text": "This paper describes a framework for learning composable deep subpolicies in a multitask setting, guided only by abstract sketches of high-level behavior. General reinforcement learning algorithms allow agents to solve tasks in complex environments. But tasks featuring extremely \u03c01 \u03c03 \u03a02 \u03c01 \u03c02", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "K1 K2", "text": "Figure 1: Learning from policy sketches. The figure shows simplified versions of two tasks (make planks and make sticks, each associated with its own policy (\u03a01 and \u03a02 respectively). These policies share an initial high-level action b1: both require the agent to get wood before taking it to an appropriate crafting station. Even without prior information about how the associated behavior \u03c01 should be implemented, knowing that the agent should initially follow the same subpolicy in both tasks is enough to learn a reusable representation of their shared structure.\ndelayed rewards or other long-term structure are often difficult to solve with flat, monolithic policies, and a long line of prior work has studied methods for learning hierarchical policy representations (Sutton et al., 1999;Dietterich, 2000;Konidaris & Barto, 2007;Hauser et al., 2008). While unsupervised discovery of these hierarchies is possible (Daniel et al., 2012;Bacon & Precup, 2015), practical approaches often require detailed supervision in the form of explicitly specified high-level actions, subgoals, or behavioral primitives (Precup, 2000). These depend on state representations simple or structured enough that suitable reward signals can be effectively engineered by hand.\nBut is such fine-grained supervision actually necessary to achieve the full benefits of hierarchy? Specifically, is it necessary to explicitly ground high-level actions into the representation of the environment? Or is it sufficient to simply inform the learner about the abstract structure of policies, without ever specifying how high-level behaviors should make use of primitive percepts or actions?\nTo answer these questions, we explore a multitask reinforcement learning setting where the learner is pre-arXiv:1611.01796v2 [cs.LG] 17 Jun 2017 sented with policy sketches. Policy sketches are short, ungrounded, symbolic representations of a task that describe its component parts, as illustrated in Figure 1. While symbols might be shared across tasks (get wood appears in sketches for both the make planks and make sticks tasks), the learner is told nothing about what these symbols mean, in terms of either observations or intermediate rewards.\nWe present an agent architecture that learns from policy sketches by associating each high-level action with a parameterization of a low-level subpolicy, and jointly optimizes over concatenated task-specific policies by tying parameters across shared subpolicies. We find that this architecture can use the high-level guidance provided by sketches, without any grounding or concrete definition, to dramatically accelerate learning of complex multi-stage behaviors. Our experiments indicate that many of the benefits to learning that come from highly detailed low-level supervision (e.g. from subgoal rewards) can also be obtained from fairly coarse high-level supervision (i.e. from policy sketches). Crucially, sketches are much easier to produce: they require no modifications to the environment dynamics or reward function, and can be easily provided by nonexperts. This makes it possible to extend the benefits of hierarchical RL to challenging environments where it may not be possible to specify by hand the details of relevant subtasks. We show that our approach substantially outperforms purely unsupervised methods that do not provide the learner with any task-specific guidance about how hierarchies should be deployed, and further that the specific use of sketches to parameterize modular subpolicies makes better use of sketches than conditioning on them directly.\nThe present work may be viewed as an extension of recent approaches for learning compositional deep architectures from structured program descriptors (Andreas et al., 2016;Reed & de Freitas, 2016). Here we focus on learning in interactive environments. This extension presents a variety of technical challenges, requiring analogues of these methods that can be trained from sparse, non-differentiable reward signals without demonstrations of desired system behavior.\nOur contributions are:\n\u2022 A general paradigm for multitask, hierarchical, deep reinforcement learning guided by abstract sketches of task-specific policies.\n\u2022 A concrete recipe for learning from these sketches, built on a general family of modular deep policy representations and a multitask actor-critic training objective.\nThe modular structure of our approach, which associates every high-level action symbol with a discrete subpolicy, naturally induces a library of interpretable policy fragments that are easily recombined. This makes it possible to evaluate our approach under a variety of different data conditions: (1) learning the full collection of tasks jointly via reinforcement, (2) in a zero-shot setting where a policy sketch is available for a held-out task, and (3) in a adaptation setting, where sketches are hidden and the agent must learn to adapt a pretrained policy to reuse high-level actions in a new task. In all cases, our approach substantially outperforms previous approaches based on explicit decomposition of the Q function along subtasks (Parr & Russell, 1998;Vogel & Jurafsky, 2010), unsupervised option discovery (Bacon & Precup, 2015), and several standard policy gradient baselines.\nWe consider three families of tasks: a 2-D Minecraftinspired crafting game (Figure 3a), in which the agent must acquire particular resources by finding raw ingredients, combining them together in the proper order, and in some cases building intermediate tools that enable the agent to alter the environment itself; a 2-D maze navigation task that requires the agent to collect keys and open doors, and a 3-D locomotion task (Figure 3b) in which a quadrupedal robot must actuate its joints to traverse a narrow winding cliff.\nIn all tasks, the agent receives a reward only after the final goal is accomplished. For the most challenging tasks, involving sequences of four or five high-level actions, a taskspecific agent initially following a random policy essentially never discovers the reward signal, so these tasks cannot be solved without considering their hierarchical structure. We have released code at http://github.com/ jacobandreas/psketch.", "publication_ref": ["b30", "b11", "b16", "b13", "b9", "b4", "b24", "b2", "b25", "b23", "b34", "b4"], "figure_ref": ["fig_1", "fig_1"], "table_ref": []}, {"heading": "Related Work", "text": "The agent representation we describe in this paper belongs to the broader family of hierarchical reinforcement learners. As detailed in Section 3, our approach may be viewed as an instantiation of the options framework first described by Sutton et al. (1999). A large body of work describes techniques for learning options and related abstract actions, in both single-and multitask settings. Most techniques for learning options rely on intermediate supervisory signals, e.g. to encourage exploration (Kearns & Singh, 2002) or completion of pre-defined subtasks (Kulkarni et al., 2016). An alternative family of approaches employs post-hoc analysis of demonstrations or pretrained policies to extract reusable sub-components (Stolle & Precup, 2002;Konidaris et al., 2011;Niekum et al., 2015). Techniques for learning options with less guidance than the present work include Bacon & Precup (2015) and Vezhnevets et al. (2016), and other general hierarchical policy learners include Daniel et al. (2012), Bakker & Schmidhuber (2004 and Menache et al. (2002). We will see that the minimal supervision provided by policy sketches re-sults in (sometimes dramatic) improvements over fully unsupervised approaches, while being substantially less onerous for humans to provide compared to the grounded supervision (such as explicit subgoals or feature abstraction hierarchies) used in previous work.\nOnce a collection of high-level actions exists, agents are faced with the problem of learning meta-level (typically semi-Markov) policies that invoke appropriate high-level actions in sequence (Precup, 2000). The learning problem we describe in this paper is in some sense the direct dual to the problem of learning these meta-level policies: there, the agent begins with an inventory of complex primitives and must learn to model their behavior and select among them; here we begin knowing the names of appropriate high-level actions but nothing about how they are implemented, and must infer implementations (but not, initially, abstract plans) from context. Our model can be combined with these approaches to support a \"mixed\" supervision condition where sketches are available for some tasks but not others (Section 4.5).\nAnother closely related line of work is the Hierarchical Abstract Machines (HAM) framework introduced by Parr & Russell (1998). Like our approach, HAMs begin with a representation of a high-level policy as an automaton (or a more general computer program; Andre & Russell, 2001;Marthi et al., 2004) and use reinforcement learning to fill in low-level details. Because these approaches attempt to learn a single representation of the Q function for all subtasks and contexts, they require extremely strong formal assumptions about the form of the reward function and state representation (Andre & Russell, 2002) that the present work avoids by decoupling the policy representation from the value function. They perform less effectively when applied to arbitrary state representations where these assumptions do not hold (Section 4.3). We are additionally unaware of past work showing that HAM automata can be automatically inferred for new tasks given a pre-trained model, while here we show that it is easy to solve the corresponding problem for sketch followers (Section 4.5).\nOur approach is also inspired by a number of recent efforts toward compositional reasoning and interaction with structured deep models. Such models have been previously used for tasks involving question answering (Iyyer et al., 2014;Andreas et al., 2016) and relational reasoning (Socher et al., 2012), and more recently for multi-task, multi-robot transfer problems (Devin et al., 2016). In the present work-as in existing approaches employing dynamically assembled modular networks-task-specific training signals are propagated through a collection of composed discrete structures with tied weights. Here the composed structures specify time-varying policies rather than feedforward computations, and their parameters must be learned via interaction rather than direct supervision. Another closely related family of models includes neural programmers (Neelakantan et al., 2015) and programmer-interpreters (Reed & de Freitas, 2016), which generate discrete computational structures but require supervision in the form of output actions or full execution traces.\nWe view the problem of learning from policy sketches as complementary to the instruction following problem studied in the natural language processing literature. Existing work on instruction following focuses on mapping from natural language strings to symbolic action sequences that are then executed by a hard-coded interpreter (Branavan et al., 2009;Chen & Mooney, 2011;Artzi & Zettlemoyer, 2013;Tellex et al., 2011). Here, by contrast, we focus on learning to execute complex actions given symbolic representations as a starting point. Instruction following models may be viewed as joint policies over instructions and environment observations (so their behavior is not defined in the absence of instructions), while the model described in this paper naturally supports adaptation to tasks where no sketches are available. We expect that future work might combine the two lines of research, bootstrapping policy learning directly from natural language hints rather than the semi-structured sketches used here.", "publication_ref": ["b30", "b15", "b18", "b29", "b17", "b22", "b4", "b33", "b9", "b5", "b20", "b24", "b0", "b19", "b1", "b14", "b2", "b28", "b10", "b21", "b25", "b7", "b8", "b3", "b31"], "figure_ref": [], "table_ref": []}, {"heading": "Learning Modular Policies from Sketches", "text": "We consider a multitask reinforcement learning problem arising from a family of infinite-horizon discounted Markov decision processes in a shared environment. This environment is specified by a tuple (S, A, P, \u03b3), with S a set of states, A a set of low-level actions, P : S \u00d7 A \u00d7 S \u2192 R a transition probability distribution, and \u03b3 a discount factor. Each task \u03c4 \u2208 T is then specified by a pair (R \u03c4 , \u03c1 \u03c4 ), with R \u03c4 : S \u2192 R a task-specific reward function and \u03c1 \u03c4 : S \u2192 R an initial distribution over states. For a fixed sequence {(s i , a i )} of states and actions obtained from a rollout of a given policy, we will denote the empirical return starting in state s i as\nq i := \u221e j=i+1 \u03b3 j\u2212i\u22121 R(s j ).\nIn addition to the components of a standard multitask RL problem, we assume that tasks are annotated with sketches K \u03c4 , each consisting of a sequence (b \u03c4 1 , b \u03c4 2 , . . .) of high-level symbolic labels drawn from a fixed vocabulary B.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Model", "text": "We exploit the structural information provided by sketches by constructing for each symbol b a corresponding subpolicy \u03c0 b . By sharing each subpolicy across all tasks annotated with the corresponding symbol, our approach naturally learns the shared abstraction for the corresponding subtask, without requiring any information about the grounding of that task to be explicitly specified by annotation. \nd = {(s i , a i , (b i = K \u03c4,i ), q i , \u03c4 ), . . .} \u223c \u03a0 \u03c4 7: D \u2190 D \u222a d 8: // update parameters 9: for b \u2208 B, \u03c4 \u2208 T do 10: d = {(s i , a i , b , q i , \u03c4 ) \u2208 D : b = b, \u03c4 = \u03c4 } 11: // update subpolicy 12: \u03b8 b \u2190 \u03b8 b + \u03b1 D d \u2207 log \u03c0 b (a i |s i ) q i \u2212 c \u03c4 (s i ) 13: // update critic 14: \u03b7 \u03c4 \u2190 \u03b7 \u03c4 + \u03b2 D d \u2207c \u03c4 (s i ) q i \u2212 c \u03c4 (s i )\nAt each timestep, a subpolicy may select either a low-level action a \u2208 A or a special STOP action. We denote the augmented state space A + := A \u222a {STOP}. At a high level, this framework is agnostic to the implementation of subpolicies: any function that takes a representation of the current state onto a distribution over A + will do.\nIn this paper, we focus on the case where each \u03c0 b is represented as a neural network. 1 These subpolicies may be viewed as options of the kind described by Sutton et al. (1999), with the key distinction that they have no initiation semantics, but are instead invokable everywhere, and have no explicit representation as a function from an initial state to a distribution over final states (instead implicitly using the STOP action to terminate).\nGiven a fixed sketch (b 1 , b 2 , . . . ), a task-specific policy \u03a0 \u03c4 is formed by concatenating its associated subpolicies in sequence. In particular, the high-level policy maintains a subpolicy index i (initially 0), and executes actions from \u03c0 bi until the STOP symbol is emitted, at which point control is passed to \u03c0 bi+1 . We may thus think of \u03a0 \u03c4 as inducing a Markov chain over the state space S \u00d7 B, with transitions:\n(s, b i ) \u2192 (s , b i ) with pr. a\u2208A \u03c0 bi (a|s) \u2022 P (s |s, a) \u2192 (s, b i+1 ) with pr. \u03c0 bi (STOP|s)\nNote that \u03a0 \u03c4 is semi-Markov with respect to projection of the augmented state space S \u00d7 B onto the underlying state space S. We denote the complete family of task-specific policies \u03a0 := \u03c4 {\u03a0 \u03c4 }, and let each \u03c0 b be an arbitrary function of the current environment state parameterized by some weight vector \u03b8 b . The learning problem is to optimize 1 For ease of presentation, this section assumes that these subpolicy networks are independently parameterized. As described in Section 4.2, it is also possible to share parameters between subpolicies, and introduce discrete subtask structure by way of an embedding of each symbol b. \ncurriculum(\u03c4 ) \u221d 1[\u03c4 \u2208 T ](1 \u2212\u00car \u03c4 ) \u2200\u03c4 \u2208 T 13: r min \u2190 min \u03c4 \u2208T \u00ca r \u03c4 14: max \u2190 max + 1 over all \u03b8 b to maximize expected discounted reward J(\u03a0) := \u03c4 J(\u03a0 \u03c4 ) := \u03c4 E si\u223c\u03a0\u03c4 i \u03b3 i R \u03c4 (s i )\nacross all tasks \u03c4 \u2208 T .", "publication_ref": ["b30"], "figure_ref": [], "table_ref": []}, {"heading": "Policy Optimization", "text": "Here that optimization is accomplished via a simple decoupled actor-critic method. In a standard policy gradient approach, with a single policy \u03c0 with parameters \u03b8, we compute gradient steps of the form (Williams, 1992):\n\u2207 \u03b8 J(\u03c0) = i \u2207 \u03b8 log \u03c0(a i |s i ) q i \u2212 c(s i ) , (1\n)\nwhere the baseline or \"critic\" c can be chosen independently of the future without introducing bias into the gradient. Recalling our previous definition of q i as the empirical return starting from s i , this form of the gradient corresponds to a generalized advantage estimator (Schulman et al., 2015a) with \u03bb = 1. Here c achieves close to the optimal variance (Greensmith et al., 2004) when it is set exactly equal to the state-value function V \u03c0 (s i ) = E \u03c0 q i for the target policy \u03c0 starting in state s i .\nThe situation becomes slightly more complicated when generalizing to modular policies built by sequencing subpolicies. In this case, we will have one subpolicy per symbol but one critic per task. This is because subpolicies \u03c0 b might participate in a number of composed policies \u03a0 \u03c4 , each associated with its own reward function R \u03c4 . Thus individual subpolicies are not uniquely identified with value functions, and the aforementioned subpolicy-specific statevalue estimator is no longer well-defined. We extend the actor-critic method to incorporate the decoupling of policies from value functions by allowing the critic to vary persample (that is, per-task-and-timestep) depending on the reward function with which the sample is associated. Noting that \u2207 \u03b8 b J(\u03a0) = t:b\u2208K\u03c4 \u2207 \u03b8 b J(\u03a0 \u03c4 ), i.e. the sum of gradients of expected rewards across all tasks in which \u03c0 b participates, we have:\n\u2207 \u03b8 J(\u03a0) = \u03c4 \u2207 \u03b8 J(\u03a0 \u03c4 ) = \u03c4 i \u2207 \u03b8 b log \u03c0 b (a \u03c4 i |s \u03c4 i ) q i \u2212 c \u03c4 (s \u03c4 i ) , (2\n)\nwhere each state-action pair (s \u03c4 i , a \u03c4 i ) was selected by the subpolicy \u03c0 b in the context of the task \u03c4 . Now minimization of the gradient variance requires that each c \u03c4 actually depend on the task identity. (This follows immediately by applying the corresponding argument in Greensmith et al. (2004) individually to each term in the sum over \u03c4 in Equation 2.) Because the value function is itself unknown, an approximation must be estimated from data. Here we allow these c \u03c4 to be implemented with an arbitrary function approximator with parameters \u03b7 \u03c4 . This is trained to minimize a squared error criterion, with gradients given by\n\u2207 \u03b7\u03c4 \u2212 1 2 i (q i \u2212 c \u03c4 (s i )) 2 = i \u2207 \u03b7\u03c4 c \u03c4 (s i ) q i \u2212 c \u03c4 (s i ) . (3\n)\nAlternative forms of the advantage estimator (e.g. the TD residual R \u03c4 (s i )+\u03b3V \u03c4 (s i+1 )\u2212V \u03c4 (s i ) or any other member of the generalized advantage estimator family) can be easily substituted by simply maintaining one such estimator per task. Experiments (Section 4.4) show that conditioning on both the state and the task identity results in noticeable performance improvements, suggesting that the variance reduction provided by this objective is important for efficient joint learning of modular policies.\nThe complete procedure for computing a single gradient step is given in Algorithm 1. (The outer training loop over these steps, which is driven by a curriculum learning procedure, is specified in Algorithm 2.) This is an on-policy algorithm. In each step, the agent samples tasks from a task distribution provided by a curriculum (described in the following subsection). The current family of policies \u03a0 is used to perform rollouts in each sampled task, accumulating the resulting tuples of (states, low-level actions, highlevel symbols, rewards, and task identities) into a dataset D.\nOnce D reaches a maximum size D, it is used to compute gradients w.r.t. both policy and critic parameters, and the parameter vectors are updated accordingly. The step sizes \u03b1 and \u03b2 in Algorithm 1 can be chosen adaptively using any first-order method.", "publication_ref": ["b35", "b26", "b12", "b12"], "figure_ref": [], "table_ref": []}, {"heading": "Curriculum Learning", "text": "For complex tasks, like the one depicted in Figure 3b, it is difficult for the agent to discover any states with positive reward until many subpolicy behaviors have already been learned. It is thus a better use of the learner's time to focus on \"easy\" tasks, where many rollouts will result in high reward from which appropriate subpolicy behavior can be inferred. But there is a fundamental tradeoff involved here: if the learner spends too much time on easy tasks before being made aware of the existence of harder ones, it may overfit and learn subpolicies that no longer generalize or exhibit the desired structural properties.\nTo avoid both of these problems, we use a curriculum learning scheme (Bengio et al., 2009) that allows the model to smoothly scale up from easy tasks to more difficult ones while avoiding overfitting. Initially the model is presented with tasks associated with short sketches. Once average reward on all these tasks reaches a certain threshold, the length limit is incremented. We assume that rewards across tasks are normalized with maximum achievable reward 0 < q i < 1. Let\u00car \u03c4 denote the empirical estimate of the expected reward for the current policy on task \u03c4 . Then at each timestep, tasks are sampled in proportion to 1\u2212\u00car \u03c4 , which by assumption must be positive.\nIntuitively, the tasks that provide the strongest learning signal are those in which (1) the agent does not on average achieve reward close to the upper bound, but (2) many episodes result in high reward. The expected reward component of the curriculum addresses condition (1) by ensuring that time is not spent on nearly solved tasks, while the length bound component of the curriculum addresses condition (2) by ensuring that tasks are not attempted until high-reward episodes are likely to be encountered. Experiments show that both components of this curriculum learning scheme improve the rate at which the model converges to a good policy (Section 4.4).\nThe complete curriculum-based training procedure is specified in Algorithm 2. Initially, the maximum sketch length max is set to 1, and the curriculum initialized to sample length-1 tasks uniformly. (Neither of the environments we consider in this paper feature any length-1 tasks; in this case, observe that Algorithm 2 will simply advance to length-2 tasks without any parameter updates.) For each setting of max , the algorithm uses the current collection of task policies \u03a0 to compute and apply the gradient step described in Algorithm 1. The rollouts obtained from the call to TRAIN-STEP can also be used to compute reward estimates\u00car \u03c4 ; these estimates determine a new task distribution for the curriculum. The inner loop is repeated until the reward threshold r good is exceeded, at which point max is incremented and the process repeated over a (nowexpanded) collection of tasks.", "publication_ref": ["b6"], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "Experiments", "text": "We evaluate the performance of our approach in three environments: a crafting environment, a maze navigation environment, and a cliff traversal environment. These environments involve various kinds of challenging low-level control: agents must learn to avoid obstacles, interact with various kinds of objects, and relate fine-grained joint activation to high-level locomotion goals. They also feature hierarchical structure: most rewards are provided only after the agent has completed two to five high-level actions in the appropriate sequence, without any intermediate goals to indicate progress towards completion.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Implementation", "text": "In all our experiments, we implement each subpolicy as a feedforward neural network with ReLU nonlinearities and a hidden layer with 128 hidden units, and each critic as a linear function of the current state. Each subpolicy network receives as input a set of features describing the current state of the environment, and outputs a distribution over actions. The agent acts at every timestep by sampling from this distribution. The gradient steps given in lines 8 and 9 of Algorithm 1 are implemented using RMSPROP (Tieleman, 2012) with a step size of 0.001 and gradient clipping to a unit norm. We take the batch size D in Algorithm 1 to be 2000, and set \u03b3 = 0.9 in both environments. For curriculum learning, the improvement threshold r good is 0.8.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Environments", "text": "The crafting environment (Figure 3a) is inspired by the popular game Minecraft, but is implemented in a discrete 2-D world. The agent may interact with objects in the world by facing them and executing a special USE action. Interacting with raw materials initially scattered around the environment causes them to be added to an inventory. Interacting with different crafting stations causes objects in the agent's inventory to be combined or transformed. Each task in this game corresponds to some crafted object the agent must produce; the most complicated goals require the agent to also craft intermediate ingredients, and in some cases build tools (like a pickaxe and a bridge) to reach ingredients located in initially inaccessible regions of the environment.\nThe maze environment (not pictured) corresponds closely to the the \"light world\" described by Konidaris & Barto (2007). The agent is placed in a discrete world consisting of a series of rooms, some of which are connected by doors. Some doors require that the agent first pick up a key to open them. For our experiments, each task corresponds to a goal room (always at the same position relative to the agent's starting position) that the agent must reach by navigating through a sequence of intermediate rooms.\nThe agent has one sensor on each side of its body, which reports the distance to keys, closed doors, and open doors in the corresponding direction. Sketches specify a particular sequence of directions for the agent to traverse between rooms to reach the goal. The sketch always corresponds to a viable traversal from the start to the goal position, but other (possibly shorter) traversals may also exist.\nThe cliff environment (Figure 3b) is intended to demonstrate the applicability of our approach to problems involving high-dimensional continuous control. In this environment, a quadrupedal robot (Schulman et al., 2015b) is placed on a variable-length winding path, and must navi- \nFigure 4: Comparing modular learning from sketches with standard RL baselines. Modular is the approach described in this paper, while Independent learns a separate policy for each task, Joint learns a shared policy that conditions on the task identity, Q automaton learns a single network to map from states and action symbols to Q values, and Opt-Crit is an unsupervised option learner. Performance for the best iteration of the (off-policy) Q automaton is plotted. Performance is shown in (a) the crafting environment, (b) the maze environment, and (c) the cliff environment. The modular approach is eventually able to achieve high reward on all tasks, while the baseline models perform considerably worse on average.\ngate to the end without falling off. This task is designed to provide a substantially more challenging RL problem, due to the fact that the walker must learn the low-level walking skill before it can make any progress, but has simpler hierarchical structure than the crafting environment. The agent receives a small reward for making progress toward the goal, and a large positive reward for reaching the goal square, with a negative reward for falling off the path.\nA listing of tasks and sketches is given in Appendix A.", "publication_ref": ["b16", "b27"], "figure_ref": ["fig_1", "fig_1"], "table_ref": []}, {"heading": "Multitask Learning", "text": "The primary experimental question in this paper is whether the extra structure provided by policy sketches alone is enough to enable fast learning of coupled policies across tasks. We aim to explore the differences between the approach described in Section 3 and relevant prior work that performs either unsupervised or weakly supervised multitask learning of hierarchical policy structure. Specifically, we compare our modular to approach to:\n1. Structured hierarchical reinforcement learners:\n(a) the fully unsupervised option-critic algorithm of Bacon & Precup (2015) (b) a Q automaton that attempts to explicitly represent the Q function for each task / subtask combination (essentially a HAM (Andre & Russell, 2002) with a deep state abstraction function)\n2. Alternative ways of incorporating sketch data into standard policy gradient methods:\n(c) learning an independent policy for each task (d) learning a joint policy across all tasks, conditioning directly on both environment features and a representation of the complete sketch\nThe joint and independent models performed best when trained with the same curriculum described in Section 3.3, while the option-critic model performed best with a length-weighted curriculum that has access to all tasks from the beginning of training.\nLearning curves for baselines and the modular model are shown in Figure 4. It can be seen that in all environments, our approach substantially outperforms the baselines: it induces policies with substantially higher average reward and converges more quickly than the policy gradient baselines. It can further be seen in Figure 4c that after policies have been learned on simple tasks, the model is able to rapidly adapt to more complex ones, even when the longer tasks involve high-level actions not required for any of the short tasks (Appendix A).\nHaving demonstrated the overall effectiveness of our approach, our remaining experiments explore (1) the importance of various components of the training procedure, and\n(2) the learned models' ability to generalize or adapt to held-out tasks. For compactness, we restrict our consideration on the crafting domain, which features a larger and more diverse range of tasks and high-level actions.", "publication_ref": ["b1"], "figure_ref": [], "table_ref": []}, {"heading": "Ablations", "text": "In addition to the overall modular parameter-tying structure induced by our sketches, the key components of our training procedure are the decoupled critic and the curriculum.\nOur next experiments investigate the extent to which these are necessary for good performance.\nTo evaluate the the critic, we consider three ablations: (1) removing the dependence of the model on the environment state, in which case the baseline is a single scalar per task;\n(2) removing the dependence of the model on the task, in which case the baseline is a conventional generalized advantage estimator; and (3) removing both, in which case the baseline is a single scalar, as in a vanilla policy gradient approach. Results are shown in Figure 5a. Introducing both state and task dependence into the baseline leads to faster convergence of the model: the approach with a constant baseline achieves less than half the overall performance of the full critic after 3 million episodes. Introducing task and state dependence independently improve this performance; combining them gives the best result.\nWe also investigate two aspects of our curriculum learning scheme: starting with short examples and moving to long ones, and sampling tasks in inverse proportion to their accumulated reward. Experiments are shown in Figure 5b. Both components help; prioritization by both length and weight gives the best results.", "publication_ref": [], "figure_ref": ["fig_3", "fig_3"], "table_ref": []}, {"heading": "Zero-shot and Adaptation Learning", "text": "In our final experiments, we consider the model's ability to generalize beyond the standard training condition. We first consider two tests of generalization: a zero-shot setting, in which the model is provided a sketch for the new task and must immediately achieve good performance, and a adaptation setting, in which no sketch is provided and the model must learn the form of a suitable sketch via interaction in the new task. We hold out two length-four tasks from the full inventory used in Section 4.3, and train on the remaining tasks. For zero-shot experiments, we simply form the concatenated policy described by the sketches of the held-out tasks, and repeatedly execute this policy (without learning) in order to obtain an estimate of its effectiveness. For adaptation experiments, we consider ordinary RL over high-level actions B rather than low-level actions A, implementing the highlevel learner with the same agent architecture as described in Section 3.1. Note that the Independent and Option-Critic models cannot be applied to the zero-shot evaluation, while the Joint model cannot be applied to the adaptation baseline (because it depends on pre-specified sketch features). Results are shown in Table 1. The held-out tasks are sufficiently challenging that the baselines are unable to obtain more than negligible reward: in particular, the joint model overfits to the training tasks and cannot generalize to new sketches, while the independent model cannot discover enough of a reward signal to learn in the adaptation setting.\nThe modular model does comparatively well: individual subpolicies succeed in novel zero-shot configurations (suggesting that they have in fact discovered the behavior suggested by the semantics of the sketch) and provide a suitable basis for adaptive discovery of new high-level policies.", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_2"]}, {"heading": "Conclusions", "text": "We have described an approach for multitask learning of deep multitask policies guided by symbolic policy sketches. By associating each symbol appearing in a sketch with a modular neural subpolicy, we have shown that it is possible to build agents that share behavior across tasks in order to achieve success in tasks with sparse and delayed rewards. This process induces an inventory of reusable and interpretable subpolicies which can be employed for zeroshot generalization when further sketches are available, and hierarchical reinforcement learning when they are not. Our work suggests that these sketches, which are easy to produce and require no grounding in the environment, provide an effective scaffold for learning hierarchical policies from minimal supervision.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "A. Tasks and Sketches", "text": "The complete list of tasks, sketches, and symbols is given below. Tasks marked with an asterisk * are held out for the generalization experiments described in Section 4. ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgments", "text": "JA is supported by a Facebook Graduate Fellowship and a Berkeley AI / Huawei Fellowship.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Programmable reinforcement learning agents", "journal": "", "year": "2001", "authors": "David Andre; Stuart Russell"}, {"ref_id": "b1", "title": "State abstraction for programmable reinforcement learning agents", "journal": "", "year": "2002", "authors": "David Andre; Stuart Russell"}, {"ref_id": "b2", "title": "Learning to compose neural networks for question answering", "journal": "Association for Computational Linguistics", "year": "2016", "authors": "Jacob Andreas;  Rohrbach;  Marcus; Trevor Darrell; Dan Klein"}, {"ref_id": "b3", "title": "Weakly supervised learning of semantic parsers for mapping instructions to actions", "journal": "Transactions of the Association for Computational Linguistics", "year": "2013", "authors": "Yoav Artzi; Luke Zettlemoyer"}, {"ref_id": "b4", "title": "The option-critic architecture", "journal": "", "year": "2015", "authors": "Pierre-Luc Bacon; Doina Precup"}, {"ref_id": "b5", "title": "Hierarchical reinforcement learning based on subgoal discovery and subpolicy specialization", "journal": "", "year": "2004", "authors": "Bram Bakker; J\u00fcrgen Schmidhuber"}, {"ref_id": "b6", "title": "Curriculum learning", "journal": "ACM", "year": "2009", "authors": "Yoshua Bengio;  Louradour;  J\u00e9r\u00f4me; Ronan Collobert; Jason Weston"}, {"ref_id": "b7", "title": "Reinforcement learning for mapping instructions to actions", "journal": "", "year": "2009", "authors": "S R K Branavan;  Chen;  Harr; Luke S Zettlemoyer; Regina Barzilay"}, {"ref_id": "b8", "title": "Learning to interpret natural language navigation instructions from observations", "journal": "", "year": "2011", "authors": "David L Chen; Raymond J Mooney"}, {"ref_id": "b9", "title": "Hierarchical relative entropy policy search", "journal": "", "year": "2012-01", "authors": "Christian Daniel; Gerhard Neumann; Peters "}, {"ref_id": "b10", "title": "Learning modular neural network policies for multi-task and multi-robot transfer", "journal": "", "year": "2016", "authors": "Coline Devin;  Gupta;  Abhishek;  Trevor; Pieter Abbeel; Sergey Levine"}, {"ref_id": "b11", "title": "Hierarchical reinforcement learning with the maxq value function decomposition", "journal": "J. Artif. Intell. Res. (JAIR)", "year": "2000", "authors": "Thomas G Dietterich"}, {"ref_id": "b12", "title": "Variance reduction techniques for gradient estimates in reinforcement learning", "journal": "Journal of Machine Learning Research", "year": "2004-11", "authors": "Evan Greensmith;  Bartlett; L Peter; Jonathan Baxter"}, {"ref_id": "b13", "title": "Using motion primitives in probabilistic sample-based planning for humanoid robots", "journal": "Springer", "year": "2008", "authors": "Kris Hauser;  Bretl;  Timothy; Kensuke Harada; Jean-Claude Latombe"}, {"ref_id": "b14", "title": "A neural network for factoid question answering over paragraphs", "journal": "", "year": "2014", "authors": "Mohit Iyyer;  Boyd-Graber;  Jordan;  Claudino;  Leonardo; Richard Socher; Daum\u00e9 Iii; Hal "}, {"ref_id": "b15", "title": "Near-optimal reinforcement learning in polynomial time", "journal": "Machine Learning", "year": "2002", "authors": "Michael Kearns; Satinder Singh"}, {"ref_id": "b16", "title": "Building portable options: Skill transfer in reinforcement learning", "journal": "", "year": "2007", "authors": "George Konidaris; Andrew G Barto"}, {"ref_id": "b17", "title": "Robot learning from demonstration by constructing skill trees", "journal": "The International Journal of Robotics Research", "year": "2011", "authors": "George Konidaris;  Kuindersma;  Scott; Roderic Grupen; Andrew Barto"}, {"ref_id": "b18", "title": "Hierarchical deep reinforcement learning: Integrating temporal abstraction and intrinsic motivation", "journal": "", "year": "2016", "authors": "Tejas D Kulkarni;  Narasimhan; R Karthik; Ardavan Saeedi; Joshua B Tenenbaum"}, {"ref_id": "b19", "title": "Concurrent hierarchical reinforcement learning", "journal": "", "year": "2004", "authors": " Marthi;  Bhaskara;  Lantham;  David; Carlos Guestrin; Stuart Russell"}, {"ref_id": "b20", "title": "Q-cutdynamic discovery of sub-goals in reinforcement learning", "journal": "Springer", "year": "2002", "authors": " Menache;  Ishai; Shie Mannor; Nahum Shimkin"}, {"ref_id": "b21", "title": "Neural programmer: Inducing latent programs with gradient descent", "journal": "", "year": "2015", "authors": "Arvind Neelakantan; Le Quoc; V Sutskever;  Ilya"}, {"ref_id": "b22", "title": "Learning grounded finite-state representations from unstructured demonstrations", "journal": "The International Journal of Robotics Research", "year": "2015", "authors": "Scott Niekum;  Osentoski;  Sarah;  Konidaris;  George;  Chitta;  Sachin; Bhaskara Marthi; Andrew G Barto"}, {"ref_id": "b23", "title": "Reinforcement learning with hierarchies of machines", "journal": "", "year": "1998", "authors": "Ron Parr; Stuart Russell"}, {"ref_id": "b24", "title": "Temporal abstraction in reinforcement learning", "journal": "", "year": "2000", "authors": "Doina Precup"}, {"ref_id": "b25", "title": "Neural programmerinterpreters", "journal": "", "year": "2016", "authors": "Scott Reed; De Freitas; Nando "}, {"ref_id": "b26", "title": "High-dimensional continuous control using generalized advantage estimation", "journal": "", "year": "2015", "authors": "John Schulman;  Moritz;  Philipp;  Levine;  Sergey; Michael Jordan; Pieter Abbeel"}, {"ref_id": "b27", "title": "Trust region policy optimization", "journal": "", "year": "2015", "authors": "John Schulman;  Moritz;  Philipp;  Levine;  Sergey; Michael Jordan; Pieter Abbeel"}, {"ref_id": "b28", "title": "Semantic compositionality through recursive matrix-vector spaces", "journal": "", "year": "2012", "authors": "Richard Socher;  Brody; Christopher Manning; Andrew Ng"}, {"ref_id": "b29", "title": "Learning options in reinforcement learning", "journal": "Springer", "year": "2002", "authors": "Martin Stolle; Doina Precup"}, {"ref_id": "b30", "title": "Between MDPs and semi-MDPs: A framework for temporal abstraction in reinforcement learning. Artificial intelligence", "journal": "", "year": "1999", "authors": "Richard S Sutton; Doina Precup;  Singh;  Satinder"}, {"ref_id": "b31", "title": "Understanding natural language commands for robotic navigation and mobile manipulation", "journal": "", "year": "2011", "authors": "Stefanie Tellex;  Kollar;  Thomas;  Dickerson;  Steven; Matthew R Walter; Ashis Banerjee;  Gopal; Seth Teller; Nicholas Roy"}, {"ref_id": "b32", "title": "RMSProp (unpublished)", "journal": "", "year": "2012", "authors": "Tijmen Tieleman"}, {"ref_id": "b33", "title": "Strategic attentive writer for learning macro-actions", "journal": "", "year": "2016", "authors": "Alexander Vezhnevets;  Mnih;  Volodymyr;  Agapiou;  John;  Osindero;  Simon; Alex Graves; Oriol Vinyals; Koray Kavukcuoglu"}, {"ref_id": "b34", "title": "Learning to follow navigational directions", "journal": "Association for Computational Linguistics", "year": "2010", "authors": "Adam Vogel; Dan Jurafsky"}, {"ref_id": "b35", "title": "Simple statistical gradient-following algorithms for connectionist reinforcement learning", "journal": "Machine learning", "year": "1992", "authors": "Ronald J Williams"}], "figures": [{"figure_label": "2", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 2 :2Figure2: Model overview. Each subpolicy \u03c0 is uniquely associated with a symbol b implemented as a neural network that maps from a state si to distributions over A + , and chooses an action ai by sampling from this distribution. Whenever the STOP action is sampled, control advances to the next subpolicy in the sketch.", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 3 :3Figure3: Examples from the crafting and cliff environments used in this paper. An additional maze environment is also investigated. (a) In the crafting environment, an agent seeking to pick up the gold nugget in the top corner must first collect wood (1) and iron (2), use a workbench to turn them into a bridge (3), and use the bridge to cross the water (4). (b) In the cliff environment, the agent must reach a goal position by traversing a winding sequence of tiles without falling off. Control takes place at the level of individual joint angles; high-level behaviors like \"move north\" must be learned.", "figure_data": ""}, {"figure_label": "5", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Figure 5 :5Figure5: Training details in the crafting domain. (a) Critics: lines labeled \"task\" include a baseline that varies with task identity, while lines labeled \"state\" include a baseline that varies with state identity. Estimating a baseline that depends on both the representation of the current state and the identity of the current task is better than either alone or a constant baseline. (b) Curricula: lines labeled \"len\" use a curriculum with iteratively increasing sketch lengths, while lines labeled \"wgt\" sample tasks in inverse proportion to their current reward. Adjusting the sampling distribution based on both task length and performance return improves convergence. (c) Individual task performance. Colors correspond to task length. Sharp steps in the learning curve correspond to increases of max in the curriculum.", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "Algorithm 1 TRAIN-STEP(\u03a0, curriculum) 1: D \u2190 \u2205 2: while |D| < D do", "figure_data": "3:// sample task \u03c4 from curriculum (Section 3.3)4: 5:\u03c4 \u223c curriculum(\u2022) // do rollout6:"}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_2", "figure_caption": "Accuracy and generalization of learned models in the crafting domain. The table shows the task completion rate for each approach after convergence under various training conditions. Multitask is the multitask training condition described in Section 4.3, while 0-Shot and Adaptation are the generalization experiments described in Section 4.5. Our modular approach consistently achieves the best performance.", "figure_data": "ModelMultitask 0-shot AdaptationJoint Independent Option-Critic Modular (ours).49 .44 .47 .89.01 --.77-.01 .42 .76"}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_3", "figure_caption": "5, but included in the multitask training experiments in Sections 4.3 and 4.4.", "figure_data": "GoalSketchCrafting environmentmake plankget wooduse toolshedmake stickget wooduse workbenchmake clothget grass use factorymake ropeget grass use toolshedmake bridge get ironget wooduse factorymake bed  *get wooduse toolshedget grassuse workbenchmake axe  *get wooduse workbench get ironuse toolshedmake shears get wooduse workbench get ironuse workbenchget goldget ironget wooduse factory use bridgeget gemget wooduse workbench get ironuse toolsheduse axeMaze environmentroom 1leftleftroom 2leftdownroom 3rightdownroom 4upleftroom 5uprightroom 6uprightuproom 7downrightuproom 8leftleftdownroom 9rightdowndownroom 10leftuprightCliff environmentpath 0northpath 1eastpath 2southpath 3westpath 4westsouthpath 5westnorthnorthpath 6northeastnorthpath 7westnorthpath 8eastsouthpath 9northwestwestpath 10eastnortheastpath 11southeastpath 12southwestpath 13southsouthpath 14southsouthwestpath 15eastsouthsouthpath 16easteastpath 17eastnorthpath 18northeastpath 19westwestpath 20northnorthpath 21northwestpath 22westwestsouthpath 23southeastsouth"}], "formulas": [{"formula_id": "formula_0", "formula_text": "q i := \u221e j=i+1 \u03b3 j\u2212i\u22121 R(s j ).", "formula_coordinates": [3.0, 392.0, 527.64, 115.11, 14.11]}, {"formula_id": "formula_1", "formula_text": "d = {(s i , a i , (b i = K \u03c4,i ), q i , \u03c4 ), . . .} \u223c \u03a0 \u03c4 7: D \u2190 D \u222a d 8: // update parameters 9: for b \u2208 B, \u03c4 \u2208 T do 10: d = {(s i , a i , b , q i , \u03c4 ) \u2208 D : b = b, \u03c4 = \u03c4 } 11: // update subpolicy 12: \u03b8 b \u2190 \u03b8 b + \u03b1 D d \u2207 log \u03c0 b (a i |s i ) q i \u2212 c \u03c4 (s i ) 13: // update critic 14: \u03b7 \u03c4 \u2190 \u03b7 \u03c4 + \u03b2 D d \u2207c \u03c4 (s i ) q i \u2212 c \u03c4 (s i )", "formula_coordinates": [4.0, 55.94, 143.72, 218.96, 112.93]}, {"formula_id": "formula_2", "formula_text": "(s, b i ) \u2192 (s , b i ) with pr. a\u2208A \u03c0 bi (a|s) \u2022 P (s |s, a) \u2192 (s, b i+1 ) with pr. \u03c0 bi (STOP|s)", "formula_coordinates": [4.0, 56.17, 549.78, 232.55, 33.71]}, {"formula_id": "formula_3", "formula_text": "curriculum(\u03c4 ) \u221d 1[\u03c4 \u2208 T ](1 \u2212\u00car \u03c4 ) \u2200\u03c4 \u2208 T 13: r min \u2190 min \u03c4 \u2208T \u00ca r \u03c4 14: max \u2190 max + 1 over all \u03b8 b to maximize expected discounted reward J(\u03a0) := \u03c4 J(\u03a0 \u03c4 ) := \u03c4 E si\u223c\u03a0\u03c4 i \u03b3 i R \u03c4 (s i )", "formula_coordinates": [4.0, 307.44, 214.24, 225.63, 104.2]}, {"formula_id": "formula_4", "formula_text": "\u2207 \u03b8 J(\u03c0) = i \u2207 \u03b8 log \u03c0(a i |s i ) q i \u2212 c(s i ) , (1", "formula_coordinates": [4.0, 331.66, 428.27, 205.9, 22.31]}, {"formula_id": "formula_5", "formula_text": ")", "formula_coordinates": [4.0, 537.57, 428.27, 3.87, 12.0]}, {"formula_id": "formula_6", "formula_text": "\u2207 \u03b8 J(\u03a0) = \u03c4 \u2207 \u03b8 J(\u03a0 \u03c4 ) = \u03c4 i \u2207 \u03b8 b log \u03c0 b (a \u03c4 i |s \u03c4 i ) q i \u2212 c \u03c4 (s \u03c4 i ) , (2", "formula_coordinates": [5.0, 63.21, 301.82, 222.36, 47.73]}, {"formula_id": "formula_7", "formula_text": ")", "formula_coordinates": [5.0, 285.57, 327.23, 3.87, 12.0]}, {"formula_id": "formula_8", "formula_text": "\u2207 \u03b7\u03c4 \u2212 1 2 i (q i \u2212 c \u03c4 (s i )) 2 = i \u2207 \u03b7\u03c4 c \u03c4 (s i ) q i \u2212 c \u03c4 (s i ) . (3", "formula_coordinates": [5.0, 66.71, 518.56, 218.86, 53.85]}, {"formula_id": "formula_9", "formula_text": ")", "formula_coordinates": [5.0, 285.57, 550.1, 3.87, 12.0]}], "doi": ""}