{"title": "Immediate-Head Parsing for Language Models \u00a3", "authors": "Eugene Charniak", "pub_date": "", "abstract": "We present two language models based upon an \"immediate-head\" parserour name for a parser that conditions all events below a constituent c upon the head of c. While all of the most accurate statistical parsers are of the immediate-head variety, no previous grammatical language model uses this technology. The perplexity for both of these models significantly improve upon the trigram model base-line as well as the best previous grammarbased language model. For the better of our two models these improvements are 24% and 14% respectively. We also suggest that improvement of the underlying parser should significantly improve the model's perplexity and that even in the near term there is a lot of potential for improvement in immediatehead language models.", "sections": [{"heading": "Introduction", "text": "All of the most accurate statistical parsers [1,3,6,7,12,14] are lexicalized in that they condition probabilities on the lexical content of the sentences being parsed. Furthermore, all of these parsers are what we will call immediate-head parsers in that all of the properties of the immediate descendants of a constituent c are assigned probabilities that are conditioned on the lexical head of c. For example, in Figure 1 the probability that the vp expands into v np pp is conditioned on the head of the vp, \"put\", as are the choices of the sub-heads under the vp, i.e., \"ball\" (the head of the np) and \"in\" (the head of the pp). It is the experience of the statistical parsing community that immediate-head parsers are the most accurate we can design.\nIt is also worthy of note that many of these parsers [1,3,6,7] are generative -that is, for a sentence s they try to find the parse defined by Equation 1: arg max p( s) = arg max p( , s)\n(1)\nThis is interesting because insofar as they compute p( , s) these parsers define a language-model in that they can (in principle) assign a probability to all possible sentences in the language by computing the sum in Equation 2:\np(s) = p( , s) ( 2 )\nwhere p( , s) is zero if the yield of = s. Language models, of course, are of interest because speech-recognition systems require them. These systems determine the words that were spoken by solving Equation 3: arg max s p(s A) = arg max s p(s)p(A s) (3) where A denotes the acoustic signal. The first term on the right, p(s), is the language model, and is what we compute via parsing in Equation 2. Virtually all current speech recognition systems use the so-called trigram language model in which the probability of a string is broken down into conditional probabilities on each word given the two previous words. E.g., p(w 0,n ) = i=0,n 1 p(w i w i 1 , w i 2 )\n(4)\nOn the other hand, in the last few years there has been interest in designing language models based upon parsing and Equation 2. We now turn to this previous research.", "publication_ref": ["b0", "b2", "b5", "b6", "b11", "b13", "b0", "b2", "b5", "b6", "b2"], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "Previous Work", "text": "There is, of course, a very large body of literature on language modeling (for an overview, see [10]) and even the literature on grammatical language models is becoming moderately large [4,9,15,16,17]. The research presented in this paper is most closely related to two previous efforts, that by Chelba and Jelinek [4] (C&J) and that by Roark [15], and this review concentrates on these two papers. While these two works differ in many particulars, we stress here the ways in which they are similar, and similar in ways that differ from the approach taken in this paper.\nIn both cases the grammar based language model computes the probability of the next word based upon the previous words of the sentence. More specifically, these grammar-based models compute a subset of all possible grammatical relations for the prior words, and then comput\u0113 the probability of the next grammatical situation, and the probability of seeing the next word given each of these grammatical situations. Also, when computing the probability of the next word, both models condition on the two prior heads of constituents. Thus, like a trigram model, they use information about triples of words.\nNeither of these models uses an immediatehead parser. Rather they are both what we will call strict left-to-right parsers. At each sentence position in strict left-to-right parsing one computes the probability of the next word given the previous words (and does not go back to modify such probabilities). This is not possible in immediate-head parsing. Sometimes the immediate head of a constituent occurs after it (e.g, in noun-phrases, where the head is typically the rightmost noun) and thus is not available for conditioning by a strict left-to-right parser.\nThere are two reasons why one might prefer strict left-to-right parsing for a language model (Roark [15] and Chelba, personal communication). First, the search procedures for guessing the words that correspond to the acoustic signal works left to right in the string. If the language model is to offer guidance to the search procedure it must do so as well.\nThe second benefit of strict left-to-right parsing is that it is easily combined with the standard trigram model. In both cases at every point in the sentence we compute the probability of the next word given the prior words. Thus one can interpolate the trigram and grammar probability estimates for each word to get a more robust estimate. It turns out that this is a good thing to do, as is clear from While both of these reasons for strict-left-toright parsing (search and trigram interpolation) are valid, they are not necessarily compelling. The ability to combine easily with trigram models is important only as long as trigram models can improve grammar models. A sufficiently good grammar model would obviate the need for trigrams. As for the search problem, we briefly return to this point at the end of the paper. Here we simply note that while search requires that a language model provide probabilities in a left to right fashion, one can easily imagine procedures where these probabilities are revised after new information is found (i.e., the head of the constituent). Note that already our search procedure needs to revise previous most-likely-word hypotheses when the original guess makes the subsequent words very unlikely. Revising the associated language-model probabilities complicates the search procedure, but not unimaginably so. Thus it seems to us that it is worth finding out whether the superior parsing performance of immediate-head parsers translates into improved language models.", "publication_ref": ["b9", "b3", "b8", "b14", "b15", "b16", "b3", "b14", "b14"], "figure_ref": [], "table_ref": []}, {"heading": "The Immediate-Head Parsing Model", "text": "We have taken the immediate-head parser described in [3] as our starting point. This parsing model assigns a probability to a parse by a topdown process of considering each constituent c in and, for each c, first guessing the pre-terminal of c, t(c) (t for \"tag\"), then the lexical head of c, h(c), and then the expansion of c into further constituents e(c). Thus the probability of a parse is given by the equation\np( ) = c\u00be p(t(c) l(c), H(c)) \u00a1p(h(c) t(c), l(c), H(c))", "publication_ref": ["b2"], "figure_ref": [], "table_ref": []}, {"heading": "\u00a1p(e(c) l(c), t(c), h(c), H(c))", "text": "where l(c) is the label of c (e.g., whether it is a noun phrase (np), verb phrase, etc.) and H(c) is the relevant history of c -information outside c that our probability model deems important in determining the probability in question. In [3] H(c) approximately consists of the label, head, and head-part-of-speech for the parent of c: m(c), i(c), and u(c) respectively. One exception is the distribution p(e(c) l(c), t(c), h(c), H(c)), where H only includes m and u. 1 Whenever it is clear to which constituent we are referring we omit the (c) in, e.g., h(c). In this notation the above equation takes the following form:\np( ) = c\u00be p(t l, m, u, i) \u00a1 p(h t, l, m, u, i) \u00a1p(e l, t, h, m, u). (5\n)\nBecause this is a point of contrast with the parsers described in the previous section, note that all of the conditional distributions are conditioned on one lexical item (either i or h). Thus only p(h t, l, m, u, i), the distribution for the head of c, looks at two lexical items (i and h itself), and none of the distributions look at three lexical items as do the trigram distribution of Equation 4 and the previously discussed parsing language models [4,15].\nNext we describe how we assign a probability to the expansion e of a constituent. We break up a traditional probabilistic context-free grammar (PCFG) rule into a left-hand side with a label l(c) drawn from the non-terminal symbols of our grammar, and a right-hand side that is a sequence of one or more such symbols. For each expansion we distinguish one of the right-hand side labels as the \"middle\" or \"head\" symbol M(c). M(c) is the constituent from which the head lexical item h is obtained according to deterministic rules that pick the head of a constituent from among the heads of its children. To the left of M is a sequence of one or more left labels L i (c) including the special termination symbol , which indicates that there are no more symbols to the left, and similarly for the labels to the right, R i (c). Thus an expansion e(c) looks like:\nl L m . . . L 1 MR 1 . . . R n . (6\n)\nThe expansion is generated by guessing first M, then in order L 1 through L m+1 (= ), and similarly for R 1 through R n+1 .\nIn anticipation of our discussion in Section 4.2, note that when we are expanding an L i we do not know the lexical items to its left, but if we properly dovetail our \"guesses\" we can be sure of what word, if any, appears to its right and before M, and similarly for the word to the left of R j . This makes such words available to be conditioned upon.\nFinally, the parser of [3] deviates in two places from the strict dictates of a language model. First, as explicitly noted in [3], the parser does not compute the partition function (normalization constant) for its distributions so the numbers it returns are not true probabilities. We noted there that if we replaced the \"max-ent inspired\" feature with standard deleted interpolation smoothing, we took a significant hit in performance. We have now found several ways to overcome this problem, including some very efficient ways to compute partition functions for this class of models. In the end, however, this was not necessary, as we found that we could obtain equally good performance by \"hand-crafting\" our interpolation smoothing rather than using the \"obvious\" method (which performs poorly).\nSecondly, as noted in [2], the parser encourages right branching with a \"bonus\" multiplicative factor of 1.2 for constituents that end at the right boundary of the sentence, and a penalty of 0.8 for those that do not. This is replaced by explicitly conditioning the events in the expansion of Equation 6 on whether or not the constituent is at the right boundary (barring sentence-final punctu-ation). Again, with proper attention to details, this can be known at the time the expansion is taking place. This modification is much more complex than the multiplicative \"hack,\" and it is not quite as good (we lose about 0.1% in precision/recall figures), but it does allow us to compute true probabilities.\nThe resulting parser strictly speaking defines a PCFG in that all of the extra conditioning information could be included in the non-terminalnode labels (as we did with the head information in Figure 1). When a PCFG probability distribution is estimated from training data (in our case the Penn tree-bank) PCFGs define a tight (summing to one) probability distribution over strings [5], thus making them appropriate for language models. We also empirically checked that our individual distributions (p(t l, m, u, i), and p(h t, l, m, u, i) from Equation 5and p(L l, t, h, m, u), p(M l, t, h, m, u), and p(R l, t, h, m, u) from Equation 5) sum to one for a large, random, selection of conditioning events 2 As with [3], a subset of parses is computed with a non-lexicalized PCFG, and the most probable edges (using an empirically established threshold) have their probabilities recomputed according to the complete probability model of Equation 5. Both searches are conducted using dynamic programming.", "publication_ref": ["b2", "b0", "b3", "b14", "b2", "b2", "b1", "b4", "b1", "b2"], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "Experiments", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "The Immediate-Bihead Language Model", "text": "The parser as described in the previous section was trained and tested on the data used in the previously described grammar-based language modeling research [4,15]. This data is from the Penn Wall Street Journal tree-bank [13], but modified to make the text more \"speech-like\". In particular:\n1. all punctuation is removed,  The results are given in Table 2. We refer to the current model as the bihead model. \"Bihead\" here emphasizes the already noted fact that in this model probabilities involve at most two lexical heads. As seen in Table 2, the immediate-bihead model with a perplexity of 144.98 outperforms both previous models, even though they use trigrams of words in their probability estimates.\nWe also interpolated our parsing model with the trigram model (interpolation constant .36, as with the other models) and this model outperforms the other interpolation models. Note, however, that because our parser does not define probabilities for each word based upon previous words (as with trigram) it is not possible to do the integration at the word level. Rather we interpolate the probabilities of the entire sentences. This is a much less powerful technique than the word-level interpolation used by both C&J and Roark, but we still observe a significant gain in performance.", "publication_ref": ["b3", "b14", "b12"], "figure_ref": [], "table_ref": ["tab_2", "tab_2"]}, {"heading": "The Immediate-Trihead Model", "text": "While the performance of the grammatical model is good, a look at sentences for which the trigram model outperforms it makes its limitations apparent. The sentences in question have noun phrases like \"monday night football\" that trigram models eats up but on which our bihead parsing model performs less well. For example, consider the sentence \"he watched monday night football\". The trigram model assigns this a probability of 1. 9 \u00a1 10 5 , while the grammar model gives it a probability of 2. 77 \u00a1 10 7 . To a first approximation, this is entirely due to the difference in prob-monday night football nbar np Figure 2: A noun-phrase with sub-structure ability of the noun-phrase. For example, the trigram probability p(football monday, night) = 0. 366, and would have been 1.0 except that smoothing saved some of the probability for other things it might have seen but did not. Because the grammar model conditions in a different order, the closest equivalent probability would be that for \"monday\", but in our model this is only conditioned on \"football\" so the probability is much less biased, only 0. 0306. (Penn tree-bank base noun-phrases are flat, thus the head above \"monday\" is \"football\".) This immediately suggests creating a second model that captures some of the trigram-like probabilities that the immediate-bihead model misses. The most obvious extension would be to condition upon not just one's parent's head, but one's grandparent's as well. This does capture some of the information we would like, particularly the case heads of noun-phrases inside of prepositional phrases. For example, in \"united states of america\", the probability of \"america\" is now conditioned not just on \"of\" (the head of its parent) but also on \"states\".\nUnfortunately, for most of the cases where trigram really cleans up this revision would do little. Thus, in \"he watched monday night football\" \"monday\" would now be conditioned upon \"football\" and \"watched.\" The addition of \"watched\" is unlikely to make much difference, certainly compared to the boost trigram models get by, in effect, recognizing the complete name.\nIt is interesting to note, however, that virtually all linguists believe that a noun-phrase like \"monday night football\" has significant substructure -e.g., it would look something like Figure 2. If we assume this tree-structure the two heads above \"monday\" are \"night\" and \"football\" respectively, thus giving our trihead model the same power as the trigram for this case. Ignoring some of the conditioning events, we now get a probability p(h = monday i = night, j = football), which is much higher than the corresponding bihead version p(h = monday i = football). The reader may remember that h is the head of the current constituent, while i is the head of its parent. We now define j to be the grandparent head.\nWe decided to adopt this structure, but to keep things simple we only changed the definition of \"head\" for the distribution p(h t, l, m, u, i, j). Thus we adopted the following revised definition of head for constituents of base noun-phrases:\nFor a pre-terminal (e.g., noun) constituent c of a base noun-phrase in which it is not the standard head (h) and which has as its right-sister another preterminal constituent d which is not itself h, the head of c is the head of d. The sole exceptions to this rule are phraseinitial determiners and numbers which retain h as their heads.\nIn effect this definition assumes that the substructure of all base noun-phrases is left branching, as in Figure 2. This is not true, but Lauer [11] shows that about two-thirds of all branching in base-noun-phrases is leftward. We believe we would get even better results if the parser could determine the true branching structure.\nWe then adopt the following definition of a grandparent-head feature j.\n1. if c is a noun phrase under a prepositional phrase, or is a pre-terminal which takes a revised head as defined above, then j is the grandparent head of c, else 2. if c is a pre-terminal and is not next (in the production generating c) to the head of its parent (i) then j(c) is the head of the constituent next to c in the production in the direction of the head of that production, else 3. j is a \"none-of-the-above\" symbol.  The results for this model, again trained on F0-F20 and tested on F23-24, are given in Figure 3 under the heading \"Immediate-trihead model\". We see that the grammar perplexity is reduced to 130.20, a reduction of 10% over our first model, 14% over the previous best grammar model (152.26%), and 22% over the best of the above trigram models for the task (167.02). When we run the trigram and new grammar model in tandem we get a perplexity of 126.07, a reduction of 8% over the best previous tandem model and 24% over the best trigram model.", "publication_ref": ["b10"], "figure_ref": [], "table_ref": []}, {"heading": "Discussion", "text": "One interesting fact about the immediate-trihead model is that of the 3761 sentences in the test corpus, on 2934, or about 75%, the grammar model assigns a higher probability to the sentence than does the trigram model. One might well ask what went \"wrong\" with the remaining 25%? Why should the grammar model ever get beaten? Three possible reasons come to mind:\n1. The grammar model is better but only by a small amount, and due to sparse data problems occasionally the worse model will luck out and beat the better one.\n2. The grammar model and the trigram model capture different facts about the distribution of words in the language, and for some set of sentences one distribution will perform better than the other.  Based upon a few observations on sentences from the development corpus for which the trigram model gave higher probabilities we hypothesized that reason (3), bungled parses, is primary. To test this we performed the following experiment. We divide the sentences from the test corpus into two groups, ones for which the trigram model performs better, and the ones for which the grammar model does better. We then collect labeled precision and recall statistics (the standard parsing performance measures) separately for each group. If our hypothesis is correct we expect the \"grammar higher\" group to have more accurate parses than the trigram-higher group as the poor parse would cause poor grammar perplexity for the sentence, which would then be worse than the trigram perplexity. If either of the other two explanations were correct one would not expect much difference between the two groups. The results are shown in Table 4. We see there that, for example, sentences for which the grammar model has the superior perplexity have average recall 5.9 (= 84. 9 79. 0) percentage points higher than the sentences for which the trigram model performed better. The gap for precision is 5.6. This seems to support our hypothesis.", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_6"]}, {"heading": "Conclusion and Future Work", "text": "We have presented two grammar-based language models, both of which significantly improve upon both the trigram model baseline for the task (by 24% for the better of the two) and the best previous grammar-based language model (by 14%).\nFurthermore we have suggested that improvement of the underlying parser should improve the model's perplexity still further.\nWe should note, however, that if we were dealing with standard Penn Tree-bank Wall-Street-Journal text, asking for better parsers would be easier said than done. While there is still some progress, it is our opinion that substantial improvement in the state-of-the-art precision/recall figures (around 90%) is unlikely in the near future. 3 However, we are not dealing with standard tree-bank text. As pointed out above, the text in question has been \"speechified\" by removing punctuation and capitalization, and \"simplified\" by allowing only a fixed vocabulary of 10,000 words (replacing all the rest by the symbol \"UNK\"), and replacing all digits and symbols by the symbol \"N\".\nWe believe that the resulting text grossly underrepresents the useful grammatical information available to speech-recognition systems. First, we believe that information about rare or even truly unknown words would be useful. For example, when run on standard text, the parser uses ending information to guess parts of speech [3]. Even if we had never encountered the word \"showboating\", the \"ing\" ending tells us that this is almost certainly a progressive verb. It is much harder to determine this about UNK. 4 Secondly, while punctuation is not to be found in speech, prosody should give us something like equivalent information, perhaps even better. Thus significantly better parser performance on speechderived data seems possible, suggesting that highperformance trigram-less language models may be within reach. We believe that the adaptation of prosodic information to parsing use is a worthy topic for future research.\nFinally, we have noted two objections to immediate-head language models: first, they complicate left-to-right search (since heads are often to the right of their children) and second, they cannot be tightly integrated with trigram models.\nThe possibility of trigram-less language models makes the second of these objections without force. Nor do we believe the first to be a permanent disability. If one is willing to provide sub-optimal probability estimates as one proceeds left-to-right and then amend them upon seeing the true head, left-to-right processing and immediatehead parsing might be joined. Note that one of the cases where this might be worrisome, early words in a base noun-phrase could be conditioned upon a head which comes several words later, has been made significantly less problematic by our revised definition of heads inside noun-phrases. We believe that other such situations can be brought into line as well, thus again taming the search problem. However, this too is a topic for future research.", "publication_ref": ["b2", "b2", "b3"], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "What is the minimal set of fragments that achieves maximal parse accuracy", "journal": "", "year": "2001", "authors": "R Bod"}, {"ref_id": "b1", "title": "Tree-bank grammars", "journal": "AAAI Press/MIT Press", "year": "1996", "authors": "E Charniak"}, {"ref_id": "b2", "title": "A maximum-entropyinspired parser", "journal": "", "year": "2000", "authors": "E Charniak"}, {"ref_id": "b3", "title": "Exploiting syntactic structure for language modeling", "journal": "", "year": "1998", "authors": "C Chelba; F Jelinek"}, {"ref_id": "b4", "title": "Estimation of probabilistic context-free grammars", "journal": "Computational Linguistics", "year": "1998", "authors": "Z Chi; S Geman"}, {"ref_id": "b5", "title": "Three generative lexicalized models for statistical parsing", "journal": "", "year": "1997", "authors": "M J Collins"}, {"ref_id": "b6", "title": "Head-Driven Statistical Models for Natural Language Parsing. University of Pennsylvania", "journal": "", "year": "1999", "authors": "M J Collins"}, {"ref_id": "b7", "title": "Discriminative reranking for natural language parsing", "journal": "", "year": "2000", "authors": "M J Collins"}, {"ref_id": "b8", "title": "Using probabilistic shiftreduce parsing in speech recognition systems", "journal": "", "year": "1992", "authors": "D Goddeau"}, {"ref_id": "b9", "title": "Putting it all together: language model combination", "journal": "", "year": "2000", "authors": "J Goodman"}, {"ref_id": "b10", "title": "Corpus statistics meet the noun compound: some empirical results", "journal": "", "year": "1995", "authors": "M Lauer"}, {"ref_id": "b11", "title": "Statistical decision-tree models for parsing", "journal": "", "year": "1995", "authors": "D M Magerman"}, {"ref_id": "b12", "title": "Building a large annotated corpus of English: the Penn treebank", "journal": "Computational Linguistics", "year": "1993", "authors": "M P Marcus; B Santorini; M A Marcinkiewicz"}, {"ref_id": "b13", "title": "Learning to parse natural language with maximum entropy models. Machine Learning", "journal": "", "year": "0341", "authors": "A Ratnaparkhi"}, {"ref_id": "b14", "title": "Probabilistic top-down parsing and language modeling. Computational Linguistics (forthcoming)", "journal": "", "year": "", "authors": "B Roark"}, {"ref_id": "b15", "title": "An efficient probabilistic context-free parsing algorithm that computes prefix probabilities", "journal": "Computational Linguistics", "year": "1995", "authors": "A Stolcke"}, {"ref_id": "b16", "title": "Precise ngram probabilities from stochastic context-free grammars", "journal": "", "year": "1994", "authors": "A Stolcke; J Segal"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 1 :1Figure 1: A tree showing head information", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "", "figure_data": ", which gives perplexity resultsfor a trigram model of the data in column one, re-sults for the grammar-model in column two, andresults for a model in which the two are interpo-"}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_2", "figure_caption": "", "figure_data": "Perplexity results for the immediate-bihead model4. all words except for the 10,000 most com-mon are replaced by the symbol UNK.As in previous work, files F0 to F20 are used fortraining, F21-F22 for development, and F23-F24for testing."}, {"figure_label": "3", "figure_type": "table", "figure_id": "tab_4", "figure_caption": "Perplexity results for the immediatetrihead model", "figure_data": ""}, {"figure_label": "4", "figure_type": "table", "figure_id": "tab_6", "figure_caption": "", "figure_data": ": Precision/recall for sentences in whichtrigram/grammar models performed bestWe ask this question because what we shoulddo to improve performance of our grammar-basedlanguage models depends critically on which ofthese explanations is correct: if (1) we should col-lect more data, if (2) we should just live with thetandem grammar-trigram models, and if (3) weshould create better parsers."}], "formulas": [{"formula_id": "formula_0", "formula_text": "p(s) = p( , s) ( 2 )", "formula_coordinates": [1.0, 377.64, 571.75, 144.39, 9.82]}, {"formula_id": "formula_1", "formula_text": "p( ) = c\u00be p(t(c) l(c), H(c)) \u00a1p(h(c) t(c), l(c), H(c))", "formula_coordinates": [3.0, 324.36, 174.07, 158.32, 36.91]}, {"formula_id": "formula_2", "formula_text": "p( ) = c\u00be p(t l, m, u, i) \u00a1 p(h t, l, m, u, i) \u00a1p(e l, t, h, m, u). (5", "formula_coordinates": [3.0, 315.84, 436.7, 201.97, 42.24]}, {"formula_id": "formula_3", "formula_text": ")", "formula_coordinates": [3.0, 517.81, 467.23, 4.21, 9.82]}, {"formula_id": "formula_4", "formula_text": "l L m . . . L 1 MR 1 . . . R n . (6", "formula_coordinates": [4.0, 120.12, 239.59, 165.26, 10.86]}, {"formula_id": "formula_5", "formula_text": ")", "formula_coordinates": [4.0, 285.38, 239.59, 4.21, 9.82]}], "doi": ""}