{"title": "Generalized Label Reduction for Merge-and-Shrink Heuristics", "authors": "Silvan Sievers; Martin Wehrle; Malte Helmert", "pub_date": "", "abstract": "Label reduction is a technique for simplifying families of labeled transition systems by dropping distinctions between certain transition labels. While label reduction is critical to the efficient computation of merge-and-shrink heuristics, current theory only permits reducing labels in a limited number of cases. We generalize this theory so that labels can be reduced in every intermediate abstraction of a merge-andshrink tree. This is particularly important for efficiently computing merge-and-shrink abstractions based on non-linear merge strategies. As a case study, we implement a nonlinear merge strategy based on the original work on mergeand-shrink heuristics in model checking by Dr\u00e4ger et al.", "sections": [{"heading": "Introduction", "text": "State-space search is a fundamental problem in artificial intelligence. Many state spaces of interest, including those that arise in classical planning and in the verification of safety properties in model checking, can be compactly specified as a family of labeled transition systems (e. g., Helmert, Haslum, and Hoffmann 2008;Dr\u00e4ger, Finkbeiner, and Podelski 2009). Label reduction identifies and eliminates semantically equivalent labels in such transition systems. It was originally introduced as an efficiency improvement for merge-andshrink abstractions (Helmert, Haslum, and Hoffmann 2007). Later, Nissim, Hoffmann, and Helmert (2011a) showed that label reduction can (in some cases) exponentially reduce the representation size of abstractions based on bisimulation.\nAll implementations of merge-and-shrink abstractions described in the planning literature apply label reduction whenever possible: it has no negative impact on abstraction quality, is very fast to compute, and significantly reduces time and memory required to compute an abstraction. However, the current theory of merge-and-shrink abstractions only allows reducing labels in limited cases.\nBroadly speaking, the merge-and-shrink approach consists in constructing a set of atomic transition systems, each corresponding to a single state variable of the problem, and then iteratively merging two transition systems into a larger one until only one transition system remains, which then induces a heuristic for an overall state-space search algorithm.\nCopyright c 2014, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.\nL L L L L L L v 8 v 7 v 6 v 5 v 4 v 3 v 2 v 1 L L L v 1 v 2 v 3 v 4 v 5 v 6 v 7 v 8\nFigure 1: Two merge trees for a problem with 8 state variables. Previous theory allows reducing labels in the intermediate abstractions marked with an \"L\" when v 1 is the pivot.\nIntermediate results can be shrunk to trade off computation effort against heuristic accuracy. A so-called merge strategy decides which transition systems to merge in each step of the algorithm. The merge strategy defines a binary tree over the atomic transition systems, the so-called merge tree.\nFigure 1 shows two possible merge trees for a state space with 8 atomic transition systems, defined by state variables v 1 , . . . , v 8 . The left part of the figure shows a merge tree which degenerates to a list; such merge trees correspond to so-called linear merge strategies (Helmert, Haslum, and Hoffmann 2007). The right part shows a complete merge tree, corresponding to a non-linear merge strategy. According to current theory (Nissim, Hoffmann, and Helmert 2011a), when defining a merge strategy, one must select a single leaf of the merge tree, called a pivot, and may only reduce labels after merge operations which correspond to ancestors of the pivot in the merge tree. In general, this means that with a complete tree over n atomic transition systems, only O(log n) of the merged transition systems can have their labels reduced.\nWe introduce a generalized concept of label reduction to overcome this limitation. The generalization is introduced in a declarative way, independently of the merge-and-shrink framework. It is conceptually much easier to understand than the previous theory, yet more powerful in the sense that it allows reducing to a smaller set of labels than previous techniques and in the sense that it can be applied safely to every intermediate abstraction of a merge tree.\nGeneralized label reduction is particularly beneficial for the efficient computation of merge-and-shrink abstractions with non-linear merge strategies. As a case study, we have implemented such a merge strategy, based on the original work on merge-and-shrink heuristics in model checking by Dr\u00e4ger, Finkbeiner, and Podelski (2006), which did not make use of label reduction. We show experimental results that highlight the usefulness of generalized label reduction in general and non-linear merge strategies in particular.", "publication_ref": ["b5", "b2", "b4", "b7", "b4", "b7", "b1"], "figure_ref": [], "table_ref": []}, {"heading": "Planning Tasks", "text": "We present our techniques with the terminology of automated planning, but note that they are applicable to factored transition systems in general. We consider planning tasks in the SAS + formalism (B\u00e4ckstr\u00f6m and Nebel 1995) augmented with action costs. A planning task is a 4-tuple \u03a0 = V, O, s 0 , s , where V is a finite set of state variables, O is a finite set of operators, s 0 is the initial state and s is the goal.\nEach variable v \u2208 V has a finite domain D(v). A partial state s is a variable assignment on a subset of V, denoted by vars(s). We write s [v] for the value assigned to v \u2208 vars(s), which must satisfy s[v] \u2208 D(v). We say that s complies with partial state s if s\n[v] = s [v] for all v \u2208 vars(s) \u2229 vars(s ). A partial state s is a state if vars(s) = V.\nEach operator o \u2208 O has a precondition pre(o) and effect eff (o), which are partial states, and a cost c(o) \u2208 R + 0 . An operator o is applicable in a state s if s complies with pre(o), in which case o can be applied, resulting in the successor state s that complies with eff (o) and satisfies s\n[v] = s[v] for all v / \u2208 vars(eff (o)\n). The initial state s 0 is a state; the goal s is a partial state. A plan is a sequence o 1 , . . . , o n \u2208 O of operators which are applicable, in order, to the initial state, resulting in a state that complies with the goal. Such a plan is optimal if n i=1 c(o i ) is minimal among all plans. The objective of optimal planning is to find an optimal plan for a planning task or to prove that no plan exists.", "publication_ref": ["b0"], "figure_ref": [], "table_ref": []}, {"heading": "Transition Systems and Merge-and-Shrink", "text": "We briefly recap the key ideas behind merge-and-shrink abstractions (e. g., Helmert, Haslum, and Hoffmann 2007). The central notion in this context is the explicit manipulation of transition systems. We define a transition system as a 4-tuple \u0398 = S, L, T, S where S is a finite set of states, L is a finite set of labels, T \u2286 S \u00d7 L \u00d7 S is a set of (labeled) transitions, and S \u2286 S is the set of goal states. Each label l \u2208 L has a cost c(l) \u2208 R + 0 . Where it simplifies notation, we write s l \u2212 \u2192 s to denote a transition s, l, s from s to s with label l, and we may write s l \u2212 \u2192 s \u2208 \u0398 for s l \u2212 \u2192 s \u2208 T . A planning task naturally induces a transition system, which is usually too large to be represented explicitly. Instead, the merge-and-shrink approach works with a set X of smaller transition systems, which it iteratively transforms until only one transition system remains. This final transition system is then used to define a heuristic for solving the planning task.\nThe process starts by setting X to the set of atomic transition systems, which capture the behaviour of a single state variable. Then X is transformed by repeatedly applying one of the following two operations: \u2022 Merge: Remove two transition systems \u0398 = S, L, T, S and \u0398 = S , L, T , S from X and replace them with their synchronized product \u0398\u2297\u0398 = S\u00d7S , L, T \u2297 , S \u00d7 S , where a synchronized transition s, s l \u2212 \u2192 t, t \u2208 T \u2297 exists iff s l \u2212 \u2192 t \u2208 T and s l \u2212 \u2192 t \u2208 T . \u2022 Shrink: Remove a transition system \u0398 = S, L, T, S from X and replace it with the abstract transition system \u03b1(\u0398) := \u03b1(S), L, { \u03b1(s), l, \u03b1(t) | s, l, t \u2208 T }, \u03b1(S ) , where \u03b1 is an arbitrary function on S.\nWe remark that it is critical for merge operations (and hence for the correctness of the overall approach) that all transition systems work on a common set of labels. In the \"basic\" merge-and-shrink approach described in the paper by Helmert et al. (2007), this is always the set of operators of the underlying planning task. This changes when we make use of label reduction, described in the following section.\nBefore we move to label reduction, it is useful to introduce one more concept: the global transition system represented by X is the synchronized product (merge) of all elements in X, which we denote by X. (The product operator is associative and commutative modulo names of states, which we do not care about, so this is well-defined without having to specify an order on the individual merges.) At every stage of the merge-and-shrink algorithm, the current set X can be seen as a compact representation of X. In planning, initially X equals the global transition system of the planning task (shown by Helmert et al., 2007). Merge steps do not change the represented global system, and shrink steps apply an abstraction to it.", "publication_ref": ["b4", "b4", "b4"], "figure_ref": [], "table_ref": []}, {"heading": "Label Reduction: State of the Art", "text": "Label reduction adds a third class of transformations to the merge-and-shrink approach. It was first implemented, but not described, in the original application of merge-andshrink abstractions to planning (Helmert, Haslum, and Hoffmann 2007). Nissim et al. (2011a) gave the first description; Helmert et al. (2014) discuss it more thoroughly. The key idea is to identify transition labels that can be combined into a single label without losing relevant information. Among other benefits, this can significantly reduce the representation size of the transition system because parallel transitions with different labels can collapse into a single transition.\nThe existing theory of label reduction is very complicated. We do not describe it in detail here: this would require much space, and a full description is not necessary for this paper. Details can be found in Section 5 of Nissim et al. (2011a) and Section 5 of Helmert et al. (2014). Here, it suffices to discuss three weaknesses of the current theory.\nFirstly, the current theory largely attempts to define label reduction as a local concept considering individual transition systems: the central notion is that of a label-reduced transition system. This is fundamentally at odds with the purpose of labels in the merge-and-shrink framework to coordinate the joint behaviour of all transition systems in the set X. If we change the labels in some, but not all transition systems in X, synchronization cannot work correctly.\nThe earlier papers address this difficulty by performing a kind of \"just-in-time label reduction\" that makes the labels of two transition systems correspond just before they are merged (which is the only point at which labels matter). This works, but the resulting theory is complex to understand and reason about, as different parts of the merge tree work with different labels. Consequently, current theory only permits reducing labels in certain cases, with other cases deemed to be unsafe and hence forbidden. Complications mainly arise in the case of non-linear merge strategies, and consequently, these were never correctly implemented.\nSecondly, the current theory of label reduction is in a certain sense syntax-based while the rest of the merge-andshrink framework is semantic. Merge operations and shrink operations are purely semantic: once a planning task (or other problem) is translated into atomic transition systems, the task description is not needed any more. Labels are opaque tokens that do not need to \"stand for\" anything. This greatly simplifies the theory of merge-and-shrink abstractions and makes them very flexible: they work for everything representable as transition systems.\nUnfortunately, the current theory of label reduction needs to \"look inside\" the labels in order to decide which labels can be combined into one. For planning tasks, label reduction must treat labels as structured pairs of preconditions and effects, reintroducing and critically depending on the syntactic descriptions we would prefer not to have to reason about.\nThirdly, current theory cannot exploit label reductions that are enabled by shrinking. The decision how to reduce labels is completely independent of the shrink steps of the algorithm and hence needs to be correct for all possible shrink strategies. This severely limits simplification possibilities.\nAll these issues are addressed in the new theory of label reduction developed in the following section.", "publication_ref": ["b4", "b7", "b3", "b7", "b3"], "figure_ref": [], "table_ref": []}, {"heading": "Label Reduction: New Theory", "text": "In this section, we introduce the new theory of label reduction and discuss its properties. Like the merge and shrink operations described earlier, we define label reduction as a transformation of the set X of transition systems:\n\u2022 Reduce labels: Let \u03c4 be a label mapping, i. e., a function defined on the labels L of X, which satisfies c(\u03c4 (l)) \u2264 c(l) for all l \u2208 L. Replace each transition system \u0398 = S, L, T, S \u2208 X with the label-reduced system\n\u03c4 (\u0398) := S, \u03c4 (L), { s, \u03c4 (l), t | s, l, t \u2208 T }, S .\nIn words, label reduction means replacing all occurrences of each label l in all transition systems by the new label \u03c4 (l). (Of course, \u03c4 (l) = l is permitted.) When we choose to introduce a new label (i. e., \u03c4 (l) / \u2208 L), its cost can be set arbitrarily as long as it does not exceed c(l). The operation is called label reduction because it is generally used to reduce the number of labels by choosing a non-injective function \u03c4 . (Using an injective function \u03c4 is possible, but pointless.)\nIt is worth emphasizing that, unlike previous definitions, label reduction always affects all transition systems simultaneously. As we will see in the following, this is sufficient to guarantee that label reduction is always \"safe\" to be applied. Unlike the previous theory, there is no need for pivot variables or to restrict label reduction to certain stages of the merge-and-shrink computation. Also, labels in the new theory always remain completely opaque objects (without associated \"preconditions\" and \"effects\").\nHowever, there is a complication: the previous theory of label reduction reasoned about preconditions and effects to decide which labels can be combined to obtain exact label reductions, i. e., ones that do not introduce spurious transitions in X. With opaque labels, the question of exact label reduction must be addressed on the semantic level. Fortunately, we will see later that this is quite easy to do and more powerful than the previous syntax-based methods.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Properties of Label Reduction", "text": "To be able to use merge-and-shrink abstractions for admissible heuristics, we must guarantee that whenever a path from a given state s to some goal state exists in the actual problem, a corresponding path of at most the same cost exists in the final transition system computed.\nConsider a transformation of a set of transition systems X with labels L into a new set X with labels L (e. g., merging, shrinking or reducing labels). We call such a transformation transition-safe if all transitions in X have a corresponding transition in X (possibly with a different label) and goal states are preserved. Formally, the transformation is transition-safe if there exist functions \u03b1 and \u03c4 mapping the states and labels of X to the states and labels of\nX such that \u03c4 (L) = L , s l \u2212 \u2192 t \u2208 X implies \u03b1(s) \u03c4 (l)\n\u2212\u2212\u2192 \u03b1(t) \u2208 X for all s, l, t, and \u03b1(s ) is a goal state of X for all goal states s of X. We call a transformation transition-exact if additionally it does not give rise to any \"new\" transitions or goal states. Formally, the transformation is transition-exact if it is transition-safe, s l \u2212 \u2192 t \u2208 X implies s l \u2212 \u2192 t \u2208 X for all s \u2208 \u03b1 \u22121 (s ) and t \u2208 \u03b1 \u22121 (t ) and some l \u2208 \u03c4 \u22121 (l ), and for all goal states s of X all states in the preimage \u03b1 \u22121 (s ) are goal states of X. We call a transformation cost-safe if it cannot increase label costs and cost-exact if additionally it cannot decrease label costs. Formally, a transition-safe transformation must satisfy c(\u03c4 (l)) \u2264 c(l) for all l \u2208 L, and a cost-exact one must satisfy c(\u03c4 (l)) = c(l) for all l \u2208 L.\nFinally, a transformation is safe if it is transition-safe and cost-safe and exact if it is transition-exact and cost-exact.\nIt is easy to verify that if each step in a sequence of transformations has one of these properties (e. g., is transitionsafe), then the overall transformation also has it. (To prove this, compose the \u03b1 and \u03c4 functions of each step.) Safe transformations give rise to admissible and consistent heuristics, and exact transformations give rise to perfect heuristics. Hence, it is important to verify that all transformations used in a merge-and-shrink heuristic computation are safe, and exact transformations are especially desirable.\nPrevious work on merge-and-shrink (e. g., Helmert et al. 2014) established that merging is always exact, shrinking is always safe, and shrinking based on perfect bisimulation is exact. We now establish that in the new theory, label reduction is always safe.\nConsider a label reduction with mapping \u03c4 that transforms X = {\u0398 1 , . . . , \u0398 n } into X = {\u03c4 (\u0398 1 ), . . . , \u03c4 (\u0398 n )}. We first show that this label reduction is transition-safe. Here and in the following, we write states of X and X as tuples s 1 , . . . , s n where each s i is a state of \u0398 i . Consider some transition s 1 , . . . , s n l \u2212 \u2192 t 1 , . . . , t n \u2208 X. By the definition of products, we have s i l \u2212 \u2192 t i \u2208 \u0398 i for all 1 \u2264 i \u2264 n; by the definition of label reduction, we have\ns i \u03c4 (l) \u2212\u2212\u2192 t i \u2208 \u03c4 (\u0398 i ) for all 1 \u2264 i \u2264 n;\nfinally, again by definition of products we have s 1 , . . . , s n \u03c4 (l) \u2212\u2212\u2192 t 1 , . . . , t n \u2208 X . With \u03b1 set to the identity function, this proves that label reduction is transition-safe. (Label reduction does not change the set of goal states.) Due to the condition on \u03c4 in the definition of label reduction, the transformation is also cost-safe. In summary, label reduction is safe.", "publication_ref": ["b3"], "figure_ref": [], "table_ref": []}, {"heading": "Exact Label Reduction", "text": "Previous papers that study label reduction in the merge-andshrink framework (Nissim, Hoffmann, and Helmert 2011a;Helmert et al. 2014) focus on the question which conditions are required to make label reduction exact. In particular, exact label reduction is a critical ingredient in the polynomialtime perfect heuristics obtained in some planning domains (Nissim, Hoffmann, and Helmert 2011a). Helmert et al. (2014) discuss conditions for exactness of label reduction that are sufficient and in a certain sense necessary, thus seemingly closing the topic of exact label reduction. However, these results do not directly apply to our theory, as they rely on the limitations of the previous theory. We revisit the topic here, proving a sufficient and necessary condition for exact label reduction that generalizes the previous result.\nIt is obvious that a label reduction is cost-exact iff it only combines labels of the same cost (i. e., \u03c4 (l) = \u03c4 (l ) implies c(l) = c(l )), and of course we must always set c(\u03c4 (l)) := c(l) to be cost-exact. It remains to discuss under which conditions label reduction is transition-exact. We start by introducing some additional terminology. Definition 1. Let X be a set of transition systems with labels L. Let l, l \u2208 L be labels, and let \u0398 \u2208 X.\nLabel l is alive in X if all transition systems \u0398 \u2208 X have some transition\ns l \u2212 \u2192 t \u2208 \u0398 . Otherwise, l is dead. Label l locally subsumes label l in \u0398 if for all s l \u2212 \u2192 t \u2208 \u0398 we also have s l \u2212 \u2192 t. Label l globally subsumes label l in X if l locally subsumes l in all \u0398 \u2208 X.\nLabels l and l are locally equivalent in \u0398 if they label the same transitions in \u0398, i. e., if l and l locally subsume each other in \u0398.\nLabels l and l are \u0398-combinable in X if they are locally equivalent in all transition systems \u0398 \u2208 X \\ {\u0398}. (It does not matter whether or not they are locally equivalent in \u0398.)\nIt is easy to see that dead labels induce no transitions in X. Consequently, it is an exact transformation to remove all dead labels (and their transitions) from X. Hence, it suffices to consider the case where X has no dead labels.\nMoreover, we can restrict attention to label reductions \u03c4 that combine two labels l 1 and l 2 into some new label l 12 (\u03c4 (l 1 ) = \u03c4 (l 2 ) = l 12 ) while leaving all other labels unchanged (\u03c4 (l ) = l for all l / \u2208 {l 1 , l 2 }). Other label reductions can be represented as chains of such \"minimal\" label reductions. We are now ready to state our major result. Theorem 1. Let X be a set of transition systems without dead labels. Consider a label reduction on X which combines labels l 1 and l 2 and leaves other labels unchanged.\nThis label reduction is exact iff c(l 1 ) = c(l 2 ) and 1. l 1 globally subsumes l 2 , or 2. l 2 globally subsumes l 1 , or 3. l 1 and l 2 are \u0398-combinable for some \u0398 \u2208 X.\nProof. Let \u03c4 be the described label mapping, let X = {\u0398 1 , . . . , \u0398 n } and let X = {\u03c4 (\u0398 1 ), . . . , \u03c4 (\u0398 n )} be the result of label reduction. Let l 12 := \u03c4 (l 1 ) = \u03c4 (l 2 ).\nClearly, the label reduction is cost-exact iff c(l 1 ) = c(l 2 ). We need to show that it is transition-exact iff 1., 2., or 3. holds. We prove this in three parts:\n(A) If neither 1. nor 2. nor 3. holds, then the label reduction is not exact. (B) If 1. or 2. holds, then the label reduction is exact. (C) If 3. holds, then the label reduction is exact.\nLabel reduction is always transition-safe and leaves the set of goal states unchanged, so we only need to consider the second condition in the definition of transition-exactness.\nOn (A): We must show that no function \u03b1 satisfies the criterion of transition-exactness. It is sufficient to consider the case where \u03b1 is a bijection because X and X have the same number of states, so non-bijective \u03b1 cannot possibly work. Renaming states does not affect the notion of exactness, so we can further limit attention to \u03b1 being the identity function without loss of generality.\nWe say that a transition system \u0398 \u2208 X has an l 1 -only transition if there exists a transition s l1 \u2212 \u2192 t \u2208 \u0398 with s l2 \u2212 \u2192 t / \u2208 \u0398. Symmetrically, it has an l 2 -only transition if there exists a transition s l2 \u2212 \u2192 t \u2208 \u0398 with s l1 \u2212 \u2192 t / \u2208 \u0398. We try to find two transition systems \u0398 i , \u0398 j \u2208 X with i = j such that there is an l 1 -only transition s i l1 \u2212 \u2192 t i \u2208 \u0398 i and an l 2 -only transition s j l2 \u2212 \u2192 t j \u2208 \u0398 j . Then \u0398 i \u2297\u0398 j does not contain a transition s i , s j\nl \u2212 \u2192 t i , t j for either l = l 1 or l = l 2 , but \u03c4 (\u0398 i ) \u2297 \u03c4 (\u0398 j ) does contain the transition s i , s j l12 \u2212 \u2212 \u2192 t i , t j .\nBy induction over the remaining transition systems, it is then easy to show that X contains a transition that does not correspond to a transition in X, proving inexactness. (Here, we use that there are no dead labels: the argument fails if l 1 and l 2 are dead.) It remains to show that l 1 -only and l 2 -only transitions in different transition systems of X exist.\nBecause 1. does not hold, there exists an l 2 -only transition in some transition system \u0398 \u2208 X. Because 2. does not hold, there exists an l 1 -only transition in some transition system \u0398 \u2208 X. If \u0398 and \u0398 are different transition systems, we have found the required transitions and are done.\nSo let us assume that \u0398 = \u0398 . Because 3. does not hold, there exist at least two transition systems where l 1 and l 2 are not locally equivalent, so there is at least one transition system \u0398 = \u0398 where they are not locally equivalent. This means that \u0398 must have an l 1 -only transition or an l 2 -only transition. In the former case, we select the l 1 -only transition in \u0398 and the l 2 -only transition in \u0398. Otherwise, we select the l 2 -only transition in \u0398 and the l 1 -only transition in \u0398 (= \u0398).\nOn (B): Consider Case 1., where l 1 globally subsumes l 2 . Case 2. is identical with l 1 and l 2 swapped. As the function \u03b1 in the definition of transition-exactness, we choose the identity mapping. Then the condition for transitionexactness we need to verify simplifies to: for all s l \u2212 \u2192 t \u2208 X , there exists a label l \u2208 \u03c4 \u22121 (l ) with s l \u2212 \u2192 t \u2208 X. For l = l 12 , this is trivial because X and X are exactly identical regarding labels other than l 1 , l 2 and l 12 . So consider the case l = l 12 . Let s = s 1 , . . . , s n and let\nt = t 1 , . . . , t n . From s l12 \u2212 \u2212 \u2192 t \u2208 X we get s i l12 \u2212 \u2212 \u2192 t i \u2208 \u03c4 (\u0398 i ) for all 1 \u2264 i \u2264 n, and hence s i l1 \u2212 \u2192 t i \u2208 \u0398 i or s i l2 \u2212 \u2192 t i \u2208 \u0398 i for all 1 \u2264 i \u2264 n. Because l 1 globally subsumes l 2 , this implies s i l1 \u2212 \u2192 t i \u2208 \u0398 i for all 1 \u2264 i \u2264 n,\nand hence s l1 \u2212 \u2192 t \u2208 X, concluding this part of the proof. On (C): As in (B), we set \u03b1 to the identity function and only need to consider transitions s l12 \u2212 \u2212 \u2192 t \u2208 X . Let s = s 1 , . . . , s n and let t = t 1 , . . . , t n . Again, we obtain that for all\n1 \u2264 i \u2264 n, s i l12 \u2212 \u2212 \u2192 t i and hence s i l1 \u2212 \u2192 t i or s i l2 \u2212 \u2192 t i . Choose l \u2208 {l 1 , l 2 } such that s j l \u2212 \u2192 t j ,\nwhere j \u2208 {1, . . . , n} is chosen in such a way that l 1 and l 2 are \u0398 j -combinable in X. (Such a transition system \u0398 j exists because we are in Case 3.) By the definition of \u0398-combinable, l 1 and l 2 are locally equivalent for all transition systems in X other than \u0398 j , and hence (s\ni l1 \u2212 \u2192 t i or s i l2 \u2212 \u2192 t i ) implies (s i l1 \u2212 \u2192 t i and s i l2 \u2212 \u2192 t i ) for all i = j. This shows that s i l \u2212 \u2192 t i \u2208 \u0398 i for all 1 \u2264 i \u2264 n,\nand hence s l \u2212 \u2192 t \u2208 X, concluding the final part of the proof.\nWe conclude the section with a brief discussion of the conditions in Theorem 1. Although all conditions can be checked in low-order polynomial time, there is a practical difference in complexity. Finding \u0398-combinable labels essentially consists in computing the local equivalence relations of all \u0398 \u2208 X, which is possible in linear time in the representation size of X. In contrast, finding globally subsumed labels involves finding subset relationships in a set family, for which to the best of our knowledge no lineartime algorithms are known.\nA comparison to the results of Helmert et al. (2014) shows that the \u0398-combinability condition strictly generalizes the previous conditions on exactness. Hence, the new theory permits a larger number of exact label reductions even if we only use \u0398-combinability and do not consider global subsumption of labels. For this reason, coupled with efficiency concerns, we only perform exact label reductions based on \u0398-combinability in our experiments, which we describe next.", "publication_ref": ["b7", "b3", "b7", "b3", "b3"], "figure_ref": [], "table_ref": []}, {"heading": "Experiments", "text": "As discussed in the preceding sections, the new theory of label reduction is significantly more general and at the same time much less complicated than previous work. However,\nwe have yet to establish that it is useful for practical implementations of merge-and-shrink heuristics.\nFirstly, we need to show that label reduction is actually a practically useful element of the merge-and-shrink toolbox. Although previous papers on merge-and-shrink heuristics already mentioned significant performance improvements due to label reduction, these are not a central focus of any previous experiment, and we think it is important to give solid quantitative evidence in favour of label reduction.\nSecondly, while the semantic (rather than syntax-based, as in previous work) basis for exact label reduction has the advantage of being much more flexible and easier to implement than previous label reduction theory, it does carry a nontrivial computational overhead. If this overhead were so large that implementations based on the new theory performed significantly worse than ones based on the older theory, the usefulness of the new theory would be diminished.\nThirdly, a major drawback of previous label-reduction approaches are the limitations and difficulties in using them for non-linear merge strategies. Consequently, we are not aware of any implementations of non-linear merge strategies in the planning literature. The new theory removes these weaknesses, so it is appropriate to test it with non-linear merging.\nIn this section, we report on experiments that address these three aspects.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Experiment Description", "text": "Our experiments were conducted with the Fast Downward planning system (Helmert 2006), which already features the merge-and-shrink framework including the previous label reduction approach. We evaluate on all benchmarks from the International Planning Competitions for optimal planning (up to 2011) that only use language features supported by the merge-and-shrink framework (44 domains and 1396 instances in total). The experiments were performed on Intel Xeon E5-2660 CPUs running at 2.2 GHz, using a time bound of 30 minutes and a memory bound of 2 GB per run.\nAll planning algorithms we evaluate employ an A * search with a merge-and-shrink heuristic, which we varied along three dimensions: label reduction method, merge strategy and shrink strategy.", "publication_ref": ["b6"], "figure_ref": [], "table_ref": []}, {"heading": "Label Reduction Methods", "text": "We consider the case without label reduction (none), the old label reduction method based on the syntactic descriptions of operators (Nissim, Hoffmann, and Helmert 2011a;Helmert et al. 2014) and the new concept of label reduction described in this paper.\nOur implementation of the new method only performs exact label reduction, combining labels whenever the \u0398combinability condition in Theorem 1 applies. Specifically, the computation proceeds as follows: whenever label reduction makes sense (after each merge or shrink step), we compute the local equivalence relations for labels in each transition system, then use these to test for \u0398-combinable labels in each transition system \u0398. If such labels exist, they are combined in all transition systems, and the local equivalence relations are recomputed. The process repeats until no further \u0398-combinable labels exist for any transition system \u0398. Local equivalence relations are cached so that they are only recomputed from scratch if the given transition system has changed since the last computation.\nMerge Strategies We consider two merge strategies. Firstly, in order to represent the state of the art, we report results for the (linear) reverse-level (RL) strategy used in previous work (Nissim, Hoffmann, and Helmert 2011a;2011b).\nHowever, to more fully utilize the potential of the new label reduction approach, we also evaluate it on a non-linear merge strategy, for which the previous label reduction approach is comparatively ill-suited and no implementations were previously available. Therefore, as a case study, we implemented the originally proposed non-linear strategy by Dr\u00e4ger, Finkbeiner, and Podelski (2006) from model checking, which we call the DFP merge strategy in the following.\nRoughly speaking, the DFP merge strategy is based on the idea of preferably merging transition systems which must synchronize on labels that occur close to a goal state. We refer to the original paper by Dr\u00e4ger et al. (2006) for details. We remind the reader that the work of Dr\u00e4ger et al. preceded the concept of label reduction, so the combination of nonlinear merge strategies with label reduction is novel.", "publication_ref": ["b7", "b3", "b7", "b8", "b1", "b1"], "figure_ref": [], "table_ref": []}, {"heading": "Shrink Strategies", "text": "We report results on shrink strategies based on bisimulation (Nissim, Hoffmann, and Helmert 2011a;Helmert et al. 2014), which set the current state of the art. Specifically, we consider a shrink strategy based on greedy bisimulation with no limit on transition system size (G-N\u221e) as well as shrink strategies based on (exact) bisimulation with different size limits N for the intermediate transition system size (B-N10k, B-N50k, B-N100k, B-N200k, B-N\u221e). For example, with N = 10000 (strategy B-N10k), shrinking is performed to guarantee that no intermediate transition system has more than 10,000 abstract states, while with N = \u221e (strategy B-N\u221e) there is no size bound, so that a perfect heuristic is constructed.\nThe threshold parameter (Helmert et al. 2014) was set to N for the strategies with bounded transition system size and to 1 for the unbounded ones (G-N\u221e and B-N\u221e), following Nissim, Hoffmann, and Helmert (2011a). This configuration space includes the shrink strategies used in the mergeand-shrink planner that participated in IPC 2011 (Nissim, Hoffmann, and Helmert 2011b).", "publication_ref": ["b7", "b3", "b3", "b7", "b8"], "figure_ref": [], "table_ref": []}, {"heading": "Experimental Results", "text": "Table 1 provides a result overview for coverage, i. e., the number of instances solved by each planner configuration within our resource bounds. The top half of the table presents results for the linear merge strategy (RL), the bottom half presents results for the non-linear DFP strategy. 1 shows that planner configurations with label reduction dramatically outperform the corresponding ones without. (For readers less familiar with optimal planning, we point out that these tasks tend to scale exponentially in difficulty, so that even small improvements in coverage tend to be very hard to obtain.)    performing shrink strategies for each merge strategy. The table shows that label reduction is very useful across the board, over a wide range of domains.", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_1", "tab_1"]}, {"heading": "Usefulness of Label Reduction Table", "text": "For the linear RL merge strategy, the new label reduction approach increases coverage in 19 domains compared to the baseline where no labels are reduced, while decreasing coverage in 2 domains. For the non-linear DFP merge strategy, label reduction increases coverage in 18 domains and decreases it in none.\nTo provide another detailed view, Figure 2 shows the number of expanded states with the strongest configuration, DFP-B-N50k, with and without label reduction. The figure plots the results without label reduction against the results with our new label reduction approach, over all instances in the benchmark suite. The figure clearly shows the significant impact that label reduction has on performance in many cases.\nOld vs. New Label Reduction Method Focusing on the comparison between the old and new label reduction method with a linear merge strategy (top half of Table 1), we see that despite the larger effort involved in determining reducible labels, the results are in fact quite a bit better with new label reduction compared to the old technique. In particular, the best overall result of 639 solved tasks (RL-B-100k) is considerably higher than the best result with the previous state of the art (624 solved tasks with RL-B-10K and the old label reduction method).\nThere are two shrink strategies that show the opposite trend, namely the ones that tend to compute the simplest abstractions among the six strategies we consider: greedy bisimulation (RL-G-N\u221e) and exact bisimulation with the smallest size bound (RL-B-N10k). One possible explanation for this behaviour is that for the shrink strategies that compute more complex abstractions, the additional label reductions afforded by the new method are critical for comput- ing the merge-and-shrink abstraction within the given limits for time and especially memory. With the shrink strategies that compute simpler abstractions, on the other hand, memory for computing the abstraction is less of a concern, and the new label reduction method suffers from the higher computational cost for determining combinable labels.\nThis interpretation is supported by Figure 3, which compares the time to construct the abstraction heuristic for the old and new label reduction method for the strategy RL-B-N100k. The new strategy tends to construct abstractions faster and runs out of memory far less frequently. Figure 4 compares state expansions for the same configurations, showing that the heuristics are similarly informative in both cases, and it is mainly the ability to complete the computation of the abstraction (see Figure 3) that makes the difference between the old and new label reduction here.\nIn the case of perfect bisimulations (RL-B-N\u221e), there is no difference in coverage between the two label reduction methods for a different reason: unless the given planning task exhibits significant amounts of symmetry, unrestricted bisimulation tends to exhaust the available memory very quickly, and hence the perfect abstraction heuristic is either computed quickly or not at all. In all cases not solved by the perfect bisimulation approaches, this is due to running out of memory while computing the abstraction.\nNon-Linear Merge Strategy Shifting attention to the results for the non-linear DFP merge strategy (bottom half of Table 1), we see that the results with the new label reduction method are excellent. In particular, the best configuration (DFP-B-N50k) solves 644 tasks, again setting a new best result (compared to 639 solved by RL-B-N100k, also with our new label reduction method).\nGenerally speaking, the non-linear merge strategy appears to benefit even more from label reduction than the linear one on average. One possible explanation for this observation is that non-linear merge strategies involve more complex products (merges) than linear ones, and hence benefit more from label reduction collapsing multiple parallel transitions into one. In linear merge strategies, at least one of the merged transition systems is always atomic, and atomic transition systems tend to have a comparatively low density of transitions. An alternative possibility is that label reduction interacts favourably with the DFP merge strategy, which -unlike merge strategies previously considered in planning -takes the labels into account directly in order to decide which transition systems to merge next.\nFigure 5 compares the number of state expansions for the linear and non-linear merge strategy on an otherwise identical configuration (shrink strategy B-N50k, new label reduction). The comparison shows that the two merge strategies are quite complementary, with both strategies greatly outperforming each other on a significant number of instances.", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_1", "tab_1"]}, {"heading": "Conclusions", "text": "We have introduced a general theory of label reduction that addresses several drawbacks in the previous development of this topic. Compared to the previous theory, the new theory of label reduction is easier to understand, easier to reason about, and more general.\nUnder the new theory, label reduction can always be safely applied. Moreover, we have provided efficiently checkable necessary and sufficient criteria for label reduction to be exact, i. e., preserve all relevant information. The new theory allows identifying more cases where exact label reduction is possible, leading to improved performance of merge-and-shrink heuristics based on label reduction.\nUnlike the previous theory of label reduction, the new theory allows for a straight-forward application of non-linear merge strategies. We conducted the first experiments of this kind by adapting the originally proposed non-linear merge strategy from model checking to planning. In the future, we hope that the development of strong non-linear merge strategies can further increase the scalability of merge-and-shrink heuristics.\nAnother possible direction for future work is the exploration of inexact label reduction. Inexact label reduction is a general abstraction method just like shrinking, and similar intuitions to those that have guided the development of stateof-the-art shrink strategies could be used to develop useful inexact label reduction methods. For example, one might try to abstract a factored transition system by combining labels that only occur far away from goal states, similarly to the way that current shrink strategies prefer to combine abstract states that are far away from the goal.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgments", "text": "We thank the anonymous reviewers for their comments, which helped improve the paper. This work was supported by the Swiss National Science Foundation (SNSF) as part of the project \"Abstraction Heuristics for Planning and Combinatorial Search\" (AHPACS).", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Complexity results for SAS + planning", "journal": "Computational Intelligence", "year": "1995", "authors": "C B\u00e4ckstr\u00f6m; B Nebel"}, {"ref_id": "b1", "title": "Directed model checking with distance-preserving abstractions", "journal": "Springer-Verlag", "year": "2006", "authors": "K Dr\u00e4ger; B Finkbeiner; A Podelski"}, {"ref_id": "b2", "title": "Directed model checking with distance-preserving abstractions", "journal": "International Journal on Software Tools for Technology Transfer", "year": "2009", "authors": "K Dr\u00e4ger; B Finkbeiner; A Podelski"}, {"ref_id": "b3", "title": "Merge-and-shrink abstraction: A method for generating lower bounds in factored state spaces", "journal": "Journal of the ACM", "year": "2014", "authors": "M Helmert; P Haslum; J Hoffmann; R Nissim"}, {"ref_id": "b4", "title": "Flexible abstraction heuristics for optimal sequential planning", "journal": "AAAI Press", "year": "2007", "authors": "M Helmert; P Haslum; J Hoffmann"}, {"ref_id": "b5", "title": "Explicitstate abstraction: A new method for generating heuristic functions", "journal": "AAAI Press", "year": "2008", "authors": "M Helmert; P Haslum; J Hoffmann"}, {"ref_id": "b6", "title": "The Fast Downward planning system", "journal": "Journal of Artificial Intelligence Research", "year": "2006", "authors": "M Helmert"}, {"ref_id": "b7", "title": "Computing perfect heuristics in polynomial time: On bisimulation and merge-and-shrink abstraction in optimal planning", "journal": "", "year": "2011", "authors": "R Nissim; J Hoffmann; M Helmert"}, {"ref_id": "b8", "title": "The Merge-and-Shrink planner: Bisimulation-based abstraction for optimal planning", "journal": "", "year": "2011", "authors": "R Nissim; J Hoffmann; M Helmert"}], "figures": [{"figure_label": "", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 2: Number of expanded states for DFP-B-N50k: no label reduction vs. new label reduction.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 3: Construction time (in seconds) for RL-B-N100k: old label reduction vs. new label reduction. Almost all failures are due to running out of memory.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Figure 4: Number of expanded states for RL-B-N100k: old label reduction vs. new label reduction.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Figure 5: Number of expanded states for RL-B-N50k vs. DFP-B-N50k, both using new label reduction.", "figure_data": ""}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "", "figure_data": "shows detailed coverage results for the individ-ual planning domains in the benchmark set for the best-"}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "", "figure_data": ": Total coverage for several merge-and-shrink config-urations, using no label reduction (none), the previous (old)or the new label reduction. See the text for descriptions ofthe merge and shrink strategies. Best results for each mergestrategy in bold.RL-B-100KDFP-B-50Knoneoldnewnonenewmprime (35)8+6 +156 +17miconic (150)60 +13 +1358 +14gripper (20)7 +13 +137 +11freecell (80)6\u22122 +139 +11mystery (30)8+1+88+8zenotravel (20)9+3+310+2pipesworld-tankage (50)8+2+312+2nomystery-opt11-strips (20)17+1+116+2woodworking-opt08-strips (30)11\u22121+111+2blocks (35)25\u22123\u2212325+2grid (5)1+2+21+1floortile-opt11-strips (20)5+1+14+1rovers (40)7+1+17+1satellite (36)5+1+15+1scanalyzer-08-strips (30)12+1+112+1scanalyzer-opt11-strips (20)9+1+19+1woodworking-opt11-strips (20)6\u22121+16+1pipesworld-notankage (50)14\u00b10\u00b1014+1sokoban-opt08-strips (30)24\u00b10+225\u00b10trucks-strips (30)6\u00b10+26\u00b10transport-opt11-strips (20)6+1+16\u00b10driverlog (20)13\u22121\u2212112\u00b10Sum (791)267 +39 +79269 +79Remaining domains (605)293\u00b10\u00b10296\u00b10Sum (1396)560599639565644"}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_2", "figure_caption": "", "figure_data": ": Per-domain coverage. Columns 2-4 compare no(none), old and new label reduction for the linear mergestrategy reverse level (RL) in its best configuration (RL-B-100K). Columns 5-6 compare no (none) and new labelreduction for the non-linear DFP merge strategy in its bestconfiguration (DFP-B-50K). For old and new, the columnsshow increase/decrease in coverage compared to none. Do-mains where label reduction showed no increase/decrease incoverage are omitted. The best results for the given mergestrategy are highlighted in bold."}], "formulas": [{"formula_id": "formula_0", "formula_text": "L L L L L L L v 8 v 7 v 6 v 5 v 4 v 3 v 2 v 1 L L L v 1 v 2 v 3 v 4 v 5 v 6 v 7 v 8", "formula_coordinates": [1.0, 331.47, 219.29, 214.06, 103.94]}, {"formula_id": "formula_1", "formula_text": "[v] = s [v] for all v \u2208 vars(s) \u2229 vars(s ). A partial state s is a state if vars(s) = V.", "formula_coordinates": [2.0, 54.0, 319.52, 238.5, 19.92]}, {"formula_id": "formula_2", "formula_text": "[v] = s[v] for all v / \u2208 vars(eff (o)", "formula_coordinates": [2.0, 54.0, 387.25, 238.5, 19.91]}, {"formula_id": "formula_3", "formula_text": "\u03c4 (\u0398) := S, \u03c4 (L), { s, \u03c4 (l), t | s, l, t \u2208 T }, S .", "formula_coordinates": [3.0, 63.96, 569.87, 204.34, 8.96]}, {"formula_id": "formula_4", "formula_text": "X such that \u03c4 (L) = L , s l \u2212 \u2192 t \u2208 X implies \u03b1(s) \u03c4 (l)", "formula_coordinates": [3.0, 319.5, 381.94, 238.5, 21.81]}, {"formula_id": "formula_5", "formula_text": "s i \u03c4 (l) \u2212\u2212\u2192 t i \u2208 \u03c4 (\u0398 i ) for all 1 \u2264 i \u2264 n;", "formula_coordinates": [4.0, 54.0, 165.47, 151.02, 11.76]}, {"formula_id": "formula_6", "formula_text": "s l \u2212 \u2192 t \u2208 \u0398 . Otherwise, l is dead. Label l locally subsumes label l in \u0398 if for all s l \u2212 \u2192 t \u2208 \u0398 we also have s l \u2212 \u2192 t. Label l globally subsumes label l in X if l locally subsumes l in all \u0398 \u2208 X.", "formula_coordinates": [4.0, 54.0, 542.47, 238.5, 44.56]}, {"formula_id": "formula_7", "formula_text": "l \u2212 \u2192 t i , t j for either l = l 1 or l = l 2 , but \u03c4 (\u0398 i ) \u2297 \u03c4 (\u0398 j ) does contain the transition s i , s j l12 \u2212 \u2212 \u2192 t i , t j .", "formula_coordinates": [4.0, 319.5, 528.68, 238.5, 33.68]}, {"formula_id": "formula_8", "formula_text": "t = t 1 , . . . , t n . From s l12 \u2212 \u2212 \u2192 t \u2208 X we get s i l12 \u2212 \u2212 \u2192 t i \u2208 \u03c4 (\u0398 i ) for all 1 \u2264 i \u2264 n, and hence s i l1 \u2212 \u2192 t i \u2208 \u0398 i or s i l2 \u2212 \u2192 t i \u2208 \u0398 i for all 1 \u2264 i \u2264 n. Because l 1 globally subsumes l 2 , this implies s i l1 \u2212 \u2192 t i \u2208 \u0398 i for all 1 \u2264 i \u2264 n,", "formula_coordinates": [5.0, 54.0, 230.53, 238.5, 44.64]}, {"formula_id": "formula_9", "formula_text": "1 \u2264 i \u2264 n, s i l12 \u2212 \u2212 \u2192 t i and hence s i l1 \u2212 \u2192 t i or s i l2 \u2212 \u2192 t i . Choose l \u2208 {l 1 , l 2 } such that s j l \u2212 \u2192 t j ,", "formula_coordinates": [5.0, 54.0, 318.35, 238.5, 22.72]}, {"formula_id": "formula_10", "formula_text": "i l1 \u2212 \u2192 t i or s i l2 \u2212 \u2192 t i ) implies (s i l1 \u2212 \u2192 t i and s i l2 \u2212 \u2192 t i ) for all i = j. This shows that s i l \u2212 \u2192 t i \u2208 \u0398 i for all 1 \u2264 i \u2264 n,", "formula_coordinates": [5.0, 54.0, 384.1, 238.5, 32.77]}], "doi": ""}