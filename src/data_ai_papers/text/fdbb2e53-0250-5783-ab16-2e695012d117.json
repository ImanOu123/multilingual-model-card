{"title": "Counterfactual Multi-Agent Policy Gradients", "authors": "Jakob N Foerster; Gregory Farquhar; Nantas Nardelli; Shimon Whiteson", "pub_date": "2017-12-14", "abstract": "Many real-world problems, such as network packet routing and the coordination of autonomous vehicles, are naturally modelled as cooperative multi-agent systems. There is a great need for new reinforcement learning methods that can efficiently learn decentralised policies for such systems. To this end, we propose a new multi-agent actor-critic method called counterfactual multi-agent (COMA) policy gradients. COMA uses a centralised critic to estimate the Q-function and decentralised actors to optimise the agents' policies. In addition, to address the challenges of multi-agent credit assignment, it uses a counterfactual baseline that marginalises out a single agent's action, while keeping the other agents' actions fixed. COMA also uses a critic representation that allows the counterfactual baseline to be computed efficiently in a single forward pass. We evaluate COMA in the testbed of StarCraft unit micromanagement, using a decentralised variant with significant partial observability. COMA significantly improves average performance over other multi-agent actorcritic methods in this setting, and the best performing agents are competitive with state-of-the-art centralised controllers that get access to the full state.", "sections": [{"heading": "Introduction", "text": "Many complex reinforcement learning (RL) problems such as the coordination of autonomous vehicles (Cao et al. 2013), network packet delivery (Ye, Zhang, and Yang 2015), and distributed logistics (Ying and Dayong 2005) are naturally modelled as cooperative multi-agent systems. However, RL methods designed for single agents typically fare poorly on such tasks, since the joint action space of the agents grows exponentially with the number of agents.\nTo cope with such complexity, it is often necessary to resort to decentralised policies, in which each agent selects its own action conditioned only on its local action-observation history. Furthermore, partial observability and communication constraints during execution may necessitate the use of decentralised policies even when the joint action space is not prohibitively large.\nHence, there is a great need for new RL methods that can efficiently learn decentralised policies. In some settings, the learning itself may also need to be decentralised. However, in many cases, learning can take place in a simulator or a laboratory in which extra state information is available and agents can communicate freely. This centralised training of decentralised policies is a standard paradigm for multi-agent planning (Oliehoek, Spaan, and Vlassis 2008;Kraemer and Banerjee 2016) and has recently been picked up by the deep RL community (Foerster et al. 2016;Jorge, K\u00e5geb\u00e4ck, and Gustavsson 2016). However, the question of how best to exploit the opportunity for centralised learning remains open.\nAnother crucial challenge is multi-agent credit assignment (Chang, Ho, and Kaelbling 2003): in cooperative settings, joint actions typically generate only global rewards, making it difficult for each agent to deduce its own contribution to the team's success. Sometimes it is possible to design individual reward functions for each agent. However, these rewards are not generally available in cooperative settings and often fail to encourage individual agents to sacrifice for the greater good. This often substantially impedes multi-agent learning in challenging tasks, even with relatively small numbers of agents.\nIn this paper, we propose a new multi-agent RL method called counterfactual multi-agent (COMA) policy gradients, in order to address these issues. COMA takes an actor-critic (Konda and Tsitsiklis 2000) approach, in which the actor, i.e., the policy, is trained by following a gradient estimated by a critic. COMA is based on three main ideas.\nFirst, COMA uses a centralised critic. The critic is only used during learning, while only the actor is needed during execution. Since learning is centralised, we can therefore use a centralised critic that conditions on the joint action and all available state information, while each agent's policy conditions only on its own action-observation history.\nSecond, COMA uses a counterfactual baseline. The idea is inspired by difference rewards (Wolpert and Tumer 2002;Tumer and Agogino 2007), in which each agent learns from a shaped reward that compares the global reward to the reward received when that agent's action is replaced with a default action. While difference rewards are a powerful way to perform multi-agent credit assignment, they require access to a simulator or estimated reward function, and in general it is unclear how to choose the default action. COMA addresses this by using the centralised critic to compute an agent-specific advantage function that compares the estimated return for the current joint action to a counterfactual baseline that marginalises out a single agent's action, while keeping the other agents' actions fixed. This is similar to cal-culating an aristocrat utility (Wolpert and Tumer 2002), but avoids the problem of a recursive interdependence between the policy and utility function because the expected contribution of the counterfactual baseline to the policy gradient is zero. Hence, instead of relying on extra simulations, approximations, or assumptions regarding appropriate default actions, COMA computes a separate baseline for each agent that relies on the centralised critic to reason about counterfactuals in which only that agent's action changes.\nThird, COMA uses a critic representation that allows the counterfactual baseline to be computed efficiently. In a single forward pass, it computes the Q-values for all the different actions of a given agent, conditioned on the actions of all the other agents. Because a single centralised critic is used for all agents, all Q-values for all agents can be computed in a single batched forward pass.\nWe evaluate COMA in the testbed of StarCraft unit micromanagement 1 , which has recently emerged as a challenging RL benchmark task with high stochasticity, a large stateaction space, and delayed rewards. Previous works (Usunier et al. 2016;Peng et al. 2017) have made use of a centralised control policy that conditions on the entire state and can use powerful macro-actions, using StarCraft's built-in planner, that combine movement and attack actions. To produce a meaningfully decentralised benchmark that proves challenging for scenarios with even relatively few agents, we propose a variant that massively reduces each agent's field-of-view and removes access to these macro-actions.\nOur empirical results on this new benchmark show that COMA can significantly improve performance over other multi-agent actor-critic methods, as well as ablated versions of COMA itself. In addition, COMA's best agents are competitive with state-of-the-art centralised controllers that are given access to full state information and macro-actions.", "publication_ref": ["b1", "b36", "b37", "b20", "b14", "b7", "b12", "b2", "b13", "b34", "b30", "b34", "b31", "b22"], "figure_ref": [], "table_ref": []}, {"heading": "Related Work", "text": "Although multi-agent RL has been applied in a variety of settings (Busoniu, Babuska, and De Schutter 2008;Yang and Gu 2004), it has often been restricted to tabular methods and simple environments. One exception is recent work in deep multi-agent RL, which can scale to high dimensional input and action spaces. Tampuu et al. (2015) use a combination of DQN with independent Q-learning (Tan 1993;Shoham and Leyton-Brown 2009) to learn how to play twoplayer pong. More recently the same method has been used by Leibo et al. (2017) to study the emergence of collaboration and defection in sequential social dilemmas.\nAlso related is work on the emergence of communication between agents, learned by gradient descent (Das et al. 2017;Mordatch and Abbeel 2017;Lazaridou, Peysakhovich, and Baroni 2016;Foerster et al. 2016;Sukhbaatar, Fergus, and others 2016). In this line of work, passing gradients between agents during training and sharing parameters are two common ways to take advantage of centralised training. However, these methods do not allow for extra state information to be used during learning and do not address the multi-agent credit assignment problem. Gupta, Egorov, and Kochenderfer (2017) investigate actor-critic methods for decentralised execution with centralised training. However, in their methods both the actors and the critic condition on local, per-agent, observations and actions, and multi-agent credit assignment is addressed only with hand-crafted local rewards.\nMost previous applications of RL to StarCraft micromanagement use a centralised controller, with access to the full state, and control of all units, although the architecture of the controllers exploits the multi-agent nature of the problem. Usunier et al. (2016) use a greedy MDP, which at each timestep sequentially chooses actions for agents given all previous actions, in combination with zero-order optimisation, while Peng et al. (2017) use an actor-critic method that relies on RNNs to exchange information between the agents.\nThe closest to our problem setting is that of Foerster et al. (2017), who also use a multi-agent representation and decentralised policies. However, they focus on stabilising experience replay while using DQN and do not make full use of the centralised training regime. As they do not report on absolute win-rates we do not compare performance directly. However, Usunier et al. (2016) address similar scenarios to our experiments and implement a DQN baseline in a fully observable setting. In Section 6 we therefore report our competitive performance against these state-of-the-art baselines, while maintaining decentralised control. Omidshafiei et al. (2017) also address the stability of experience replay in multi-agent settings, but assume a fully decentralised training regime. (Lowe et al. 2017) concurrently propose a multi-agent policy-gradient algorithm using centralised critics. Their approach does not address multi-agent credit assignment. Unlike our work, it learns a separate centralised critic for each agent and is applied to competitive environments with continuous action spaces.\nOur work builds directly off of the idea of difference rewards (Wolpert and Tumer 2002). The relationship of COMA to this line of work is discussed in Section 4.", "publication_ref": ["b0", "b35", "b28", "b29", "b16", "b6", "b19", "b15", "b7", "b9", "b31", "b22", "b8", "b31", "b21", "b17", "b34"], "figure_ref": [], "table_ref": []}, {"heading": "Background", "text": "We consider a fully cooperative multi-agent task that can be described as a stochastic game G, defined by a tuple G = S, U, P, r, Z, O, n, \u03b3 , in which n agents identified by a \u2208 A \u2261 {1, ..., n} choose sequential actions. The environment has a true state s \u2208 S. At each time step, each agent simultaneously chooses an action u a \u2208 U , forming a joint action u \u2208 U \u2261 U n which induces a transition in the environment according to the state transition function\nP (s |s, u) : S \u00d7 U \u00d7 S \u2192 [0, 1].\nThe agents all share the same reward function r(s, u) :\nS \u00d7 U \u2192 R and \u03b3 \u2208 [0, 1) is a discount factor.\nWe consider a partially observable setting, in which agents draw observations z \u2208 Z according to the observation function O(s, a) : S \u00d7 A \u2192 Z. Each agent has an action-observation history \u03c4 a \u2208 T \u2261 (Z \u00d7 U ) * , on which it conditions a stochastic policy \u03c0 a (u a |\u03c4 a ) :\nT \u00d7 U \u2192 [0, 1].\nWe denote joint quantities over agents in bold, and joint quantities over agents other than a given agent a with the superscript \u2212a.\nThe discounted return is R t = \u221e l=0 \u03b3 l r t+l . The agents' joint policy induces a value function, i.e., an expectation over R t , V \u03c0 (s t ) = E st+1:\u221e,ut:\u221e [R t |s t ], and an action-\nvalue function Q \u03c0 (s t , u t ) = E st+1:\u221e,ut+1:\u221e [R t |s t , u t ].", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "The advantage function is given by", "text": "A \u03c0 (s t , u t ) = Q \u03c0 (s t , u t ) \u2212 V \u03c0 (s t ).\nFollowing previous work (Oliehoek, Spaan, and Vlassis 2008;Kraemer and Banerjee 2016;Foerster et al. 2016;Jorge, K\u00e5geb\u00e4ck, and Gustavsson 2016), our problem setting allows centralised training but requires decentralised execution. This is a natural paradigm for a large set of multi-agent problems where training is carried out using a simulator with additional state information, but the agents must rely on local action-observation histories during execution. To condition on this full history, a deep RL agent may make use of a recurrent neural network (Hausknecht and Stone 2015), typically with a gated model such as LSTM (Hochreiter and Schmidhuber 1997) or GRU (Cho et al. 2014).\nIn Section 4, we develop a new multi-agent policy gradient method for tackling this setting. In the remainder of this section, we provide some background on single-agent policy gradient methods (Sutton et al. 1999). Such methods optimise a single agent's policy, parameterised by \u03b8 \u03c0 , by performing gradient ascent on an estimate of the expected discounted total reward J = E \u03c0 [R 0 ]. Perhaps the simplest form of policy gradient is REINFORCE (Williams 1992), in which the gradient is:\ng = E s0:\u221e,u0:\u221e T t=0 R t \u2207 \u03b8 \u03c0 log \u03c0(u t |s t ) .\n(1)\nIn actor-critic approaches (Sutton et al. 1999;Konda and Tsitsiklis 2000;Schulman et al. 2015), the actor, i.e., the policy, is trained by following a gradient that depends on a critic, which usually estimates a value function. In particular, R t is replaced by any expression equivalent to Q(s t , u t ) \u2212 b(s t ), where b(s t ) is a baseline designed to reduce variance (Weaver and Tao 2001). A common choice is b(s t ) = V (s t ), in which case R t is replaced by A(s t , u t ).\nAnother option is to replace R t with the temporal difference (TD) error r t + \u03b3V (s t+1 ) \u2212 V (s), which is an unbiased estimate of A(s t , u t ). In practice, the gradient must be estimated from trajectories sampled from the environment, and the (action-)value functions must be estimated with function approximators. Consequently, the bias and variance of the gradient estimate depends strongly on the exact choice of estimator (Konda and Tsitsiklis 2000).\nIn this paper, we train critics f c (\u2022, \u03b8 c ) on-policy to estimate either Q or V , using a variant of TD(\u03bb) (Sutton 1988) adapted for use with deep neural networks. TD(\u03bb) uses a mixture of n-step returns G\n(n) t = n l=1 \u03b3 l\u22121 r t+l + \u03b3 n f c (\u2022 t+n , \u03b8 c ).\nIn particular, the critic parameters \u03b8 c are updated by minibatch gradient descent to minimise the following loss:\nL t (\u03b8 c ) = (y (\u03bb) \u2212 f c (\u2022 t , \u03b8 c )) 2 ,(2)\nwhere\ny (\u03bb) = (1 \u2212 \u03bb) \u221e n=1 \u03bb n\u22121 G (n)\nt , and the n-step returns G (n) t are calculated with bootstrapped values estimated by a target network (Mnih et al. 2015) with parameters copied periodically from \u03b8 c .", "publication_ref": ["b20", "b14", "b7", "b12", "b10", "b11", "b3", "b26", "b33", "b26", "b13", "b24", "b32", "b13", "b27", "b18"], "figure_ref": [], "table_ref": []}, {"heading": "Methods", "text": "In this section, we describe approaches for extending policy gradients to our multi-agent setting.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Independent Actor-Critic", "text": "The simplest way to apply policy gradients to multiple agents is to have each agent learn independently, with its own actor and critic, from its own action-observation history. This is essentially the idea behind independent Qlearning (Tan 1993), which is perhaps the most popular multi-agent learning algorithm, but with actor-critic in place of Q-learning. Hence, we call this approach independent actor-critic (IAC).\nIn our implementation of IAC, we speed learning by sharing parameters among the agents, i.e., we learn only one actor and one critic, which are used by all agents. The agents can still behave differently because they receive different observations, including an agent-specific ID, and thus evolve different hidden states. Learning remains independent in the sense that each agent's critic estimates only a local value function, i.e., one that conditions on u a , not u. Though we are not aware of previous applications of this specific algorithm, we do not consider it a significant contribution but instead merely a baseline algorithm.\nWe consider two variants of IAC. In the first, each agent's critic estimates V (\u03c4 a ) and follows a gradient based on the TD error, as described in Section 3. In the second, each agent's critic estimates Q(\u03c4 a , u a ) and follows a gradient based on the advantage: A(\u03c4 a , u a ) = Q(\u03c4 a , u a ) \u2212 V (\u03c4 a ), where V (\u03c4 a ) = u a \u03c0(u a |\u03c4 a )Q(\u03c4 a , u a ). Independent learning is straightforward, but the lack of information sharing at training time makes it difficult to learn coordinated strategies that depend on interactions between multiple agents, or for an individual agent to estimate the contribution of its actions to the team's reward.", "publication_ref": ["b29"], "figure_ref": [], "table_ref": []}, {"heading": "Counterfactual Multi-Agent Policy Gradients", "text": "The difficulties discussed above arise because, beyond parameter sharing, IAC fails to exploit the fact that learning is centralised in our setting. In this section, we propose counterfactual multi-agent (COMA) policy gradients, which overcome this limitation. Three main ideas underly COMA: 1) centralisation of the critic, 2) use of a counterfactual baseline, and 3) use of a critic representation that allows efficient evaluation of the baseline. The remainder of this section describes these ideas.\nFirst, COMA uses a centralised critic. Note that in IAC, each actor \u03c0(u a |\u03c4 a ) and each critic Q(\u03c4 a , u a ) or V (\u03c4 a ) conditions only on the agent's own action-observation history \u03c4 a . However, the critic is used only during learning and only the actor is needed during execution. Since learning is centralised, we can therefore use a centralised critic that conditions on the true global state s, if it is available, or the joint action-observation histories \u03c4 otherwise. Each actor conditions on its own action-observation histories \u03c4 a , with parameter sharing, as in IAC. Figure 1a illustrates this setup.\nA naive way to use this centralised critic would be for each actor to follow a gradient based on the TD error estimated from this critic:\ng = \u2207 \u03b8 \u03c0 log \u03c0(u|\u03c4 a t ) (r + \u03b3V (s t+1 ) \u2212 V (s t )) .\n(3) However, such an approach fails to address a key credit assignment problem. Because the TD error considers only global rewards, the gradient computed for each actor does not explicitly reason about how that particular agent's actions contribute to that global reward. Since the other agents may be exploring, the gradient for that agent becomes very noisy, particularly when there are many agents.\nTherefore, COMA uses a counterfactual baseline. The idea is inspired by difference rewards (Wolpert and Tumer 2002), in which each agent learns from a shaped reward D a = r(s, u) \u2212 r(s, (u \u2212a , c a )) that compares the global reward to the reward received when the action of agent a is replaced with a default action c a . Any action by agent a that improves D a also improves the true global reward r(s, u), because r(s, (u \u2212a , c a )) does not depend on agent a's actions.\nDifference rewards are a powerful way to perform multiagent credit assignment. However, they typically require access to a simulator in order to estimate r(s, (u \u2212a , c a )). When a simulator is already being used for learning, difference rewards increase the number of simulations that must be conducted, since each agent's difference reward requires a separate counterfactual simulation. Proper and Tumer (2012) and Colby, Curran, and Tumer (2015) propose estimating difference rewards using function approximation rather than a simulator. However, this still requires a user-specified default action c a that can be difficult to choose in many applications. In an actor-critic architecture, this approach would also introduce an additional source of approximation error.\nA key insight underlying COMA is that a centralised critic can be used to implement difference rewards in a way that avoids these problems. COMA learns a centralised critic, Q(s, u) that estimates Q-values for the joint action u conditioned on the central state s. For each agent a we can then compute an advantage function that compares the Q-value for the current action u a to a counterfactual baseline that marginalises out u a , while keeping the other agents' actions u \u2212a fixed:\nA a (s, u) = Q(s, u) \u2212 u a \u03c0 a (u a |\u03c4 a )Q(s, (u \u2212a , u a )).\n(4) Hence, A a (s, u a ) computes a separate baseline for each agent that uses the centralised critic to reason about counterfactuals in which only a's action changes, learned directly from agents' experiences instead of relying on extra simulations, a reward model, or a user-designed default action.\nThis advantage has the same form as the aristocrat utility (Wolpert and Tumer 2002). However, optimising for an aristocrat utility using value-based methods creates a selfconsistency problem because the policy and utility function depend recursively on each other. As a result, prior work focused on difference evaluations using default states and actions. COMA is different because the counterfactual baseline's expected contribution to the gradient, as with other policy gradient baselines, is zero. Thus, while the baseline does depend on the policy, its expectation does not. Consequently, COMA can use this form of the advantage without creating a self-consistency problem.\nWhile COMA's advantage function replaces potential extra simulations with evaluations of the critic, those evaluations may themselves be expensive if the critic is a deep neural network. Furthermore, in a typical representation, the number of output nodes of such a network would equal |U | n , the size of the joint action space, making it impractical to train. To address both these issues, COMA uses a critic representation that allows for efficient evaluation of the baseline. In particular, the actions of the other agents, u \u2212a t , are part of the input to the network, which outputs a Q-value for each of agent a's actions, as shown in Figure 1c. Consequently, the counterfactual advantage can be calculated efficiently by a single forward pass of the actor and critic, for each agent. Furthermore, the number of outputs is only |U | instead of (|U | n ). While the network has a large input space that scales linearly in the number of agents and actions, deep neural networks can generalise well across such spaces.\nIn this paper, we focus on settings with discrete actions. However, COMA can be easily extended to continuous actions spaces by estimating the expectation in (4) with Monte Carlo samples or using functional forms that render it analytical, e.g., Gaussian policies and critic.\nThe following lemma establishes the convergence of COMA to a locally optimal policy. The proof follows directly from the convergence of single-agent actor-critic algorithms (Sutton et al. 1999;Konda and Tsitsiklis 2000), and is subject to the same assumptions. Lemma 1. For an actor-critic algorithm with a compatible TD(1) critic following a COMA policy gradient\ng k = E \u03c0 a \u2207 \u03b8 k log \u03c0 a (u a |\u03c4 a )A a (s, u)(5)\nat each iteration k, lim inf\nk ||\u2207J|| = 0 w.p. 1.(6)\nProof. The COMA gradient is given by (h 1 , )  where the expectation E \u03c0 is with respect to the state-action distribution induced by the joint policy \u03c0. Now let d \u03c0 (s) be the discounted ergodic state distribution as defined by Sutton et al. (1999):\ng = E \u03c0 a \u2207 \u03b8 log \u03c0 a (u a |\u03c4 a )A a (s, u) , (7) A a (s, u) = Q(s, u) \u2212 b(s, u \u2212a ),(8)\nA 1 t u 1 t u 1 t u 2 t u 2 t (h 2 , )\ng b = \u2212 s d \u03c0 (s) a u \u2212a \u03c0(u \u2212a |\u03c4 \u2212a) \u2022 u a \u03c0 a (u a |\u03c4 a )\u2207 \u03b8 log \u03c0 a (u a |\u03c4 a )b(s, u \u2212a ) (10) = \u2212 s d \u03c0 (s) a u \u2212a \u03c0(u \u2212a |\u03c4 \u2212a) \u2022 u a \u2207 \u03b8 \u03c0 a (u a |\u03c4 a )b(s, u \u2212a ) (11) = \u2212 s d \u03c0 (s) a u \u2212a \u03c0(u \u2212a |\u03c4 \u2212a)b(s, u \u2212a )\u2207 \u03b8 1 = 0. (12\n)\nClearly, the per-agent baseline, although it reduces variance, does not change the expected gradient, and therefore does not affect the convergence of COMA. The remainder of the expected policy gradient is given by:\ng = E \u03c0 a \u2207 \u03b8 log \u03c0 a (u a |\u03c4 a )Q(s, u) (13) = E \u03c0 \u2207 \u03b8 log a \u03c0 a (u a |\u03c4 a )Q(s, u) . (14\n)\nWriting the joint policy as a product of the independent actors:\n\u03c0(u|s) = a \u03c0 a (u a |\u03c4 a ),(15)\nyields the standard single-agent actor-critic policy gradient: Konda and Tsitsiklis (2000) prove that an actor-critic following this gradient converges to a local maximum of the expected return J \u03c0 , given that:\ng = E \u03c0 [\u2207 \u03b8 log \u03c0(u|s)Q(s, u)] . (16\n)\n1. the policy \u03c0 is differentiable, 2. the update timescales for Q and \u03c0 are sufficiently slow, and that \u03c0 is updated sufficiently slower than Q, and 3. Q uses a representation compatible with \u03c0, amongst several further assumptions. The parameterisation of the policy (i.e., the single-agent joint-action learner is decomposed into independent actors) is immaterial to convergence, as long as it remains differentiable. Note however that COMA's centralised critic is essential for this proof to hold.", "publication_ref": ["b34", "b23", "b4", "b34", "b26", "b13", "b26", "b13"], "figure_ref": ["fig_1", "fig_1"], "table_ref": []}, {"heading": "Experimental Setup", "text": "In this section, we describe the StarCraft problem to which we apply COMA, as well as details of the state features, network architectures, training regimes, and ablations.\nDecentralised StarCraft Micromanagement. StarCraft is a rich environment with stochastic dynamics that cannot be easily emulated. Many simpler multi-agent settings, such as Predator-Prey (Tan 1993) or Packet World (Weyns, Helleboogh, and Holvoet 2005), by contrast, have full simulators with controlled randomness that can be freely set to any state in order to perfectly replay experiences. This makes it possible, though computationally expensive, to compute difference rewards via extra simulations. In StarCraft, as in the real world, this is not possible.\nIn this paper, we focus on the problem of micromanagement in StarCraft, which refers to the low-level control of individual units' positioning and attack commands as they fight enemies. This task is naturally represented as a multi-agent system, where each StarCraft unit is replaced by a decentralised controller. We consider several scenarios with symmetric teams formed of: 3 marines (3m), 5 marines (5m), 5 wraiths (5w), or 2 dragoons with 3 zealots (2d 3z). The enemy team is controlled by the StarCraft AI, which uses reasonable but suboptimal hand-crafted heuristics.\nWe allow the agents to choose from a set of discrete actions: move[direction], attack[enemy id], stop, and noop. In the StarCraft game, when a unit selects an attack action, it first moves into attack range before firing, using the game's built-in pathfinding to choose a route. These powerful attack-move macro-actions make the control problem considerably easier.\nTo create a more challenging benchmark that is meaningfully decentralised, we impose a restricted field of view on the agents, equal to the firing range of ranged units' weapons, shown in Figure 2. This departure from the standard setup for centralised StarCraft control has three effects. First, it introduces significant partial observability. Second, it means units can only attack when they are in range of enemies, removing access to the StarCraft macro-actions. Third, agents cannot distinguish between enemies who are dead and those who are out of range and so can issue invalid attack commands at such enemies, which results in no action being taken. This substantially increases the average size of the action space, which in turn increases the difficulty of both exploration and control.\nUnder these difficult conditions, scenarios with even relatively small numbers of units become much harder to solve. As seen in Table 1, we compare against a simple hand-coded heuristic that instructs the agents to run forwards into range and then focus their fire, attacking each enemy in turn until it dies. This heuristic achieves a 98% win rate on 5m with a full field of view, but only 66% in our setting. To perform well in this task, the agents must learn to cooperate by positioning properly and focussing their fire, while remembering which enemy and ally units are alive or out of view.\nAll agents receive the same global reward at each time step, equal to the sum of damage inflicted on the opponent units minus half the damage taken. Killing an opponent generates a reward of 10 points, and winning the game generates a reward equal to the team's remaining total health plus 200. This damage-based reward signal is comparable to that used by Usunier et al. (2016). Unlike (Peng et al. 2017), our approach does not require estimating local rewards.\nState Features. The actor and critic receive different input features, corresponding to local observations and global state, respectively. Both include features for allies and enemies. Units can be either allies or enemies, while agents are the decentralised controllers that command ally units.\nThe local observations for every agent are drawn only from a circular subset of the map centred on the unit it controls and include for each unit within this field of view: distance, relative x, relative y, unit type and shield. 2 All features are normalised by their maximum values. We do not include any information about the units' current target.\nThe global state representation consists of similar features, but for all units on the map regardless of fields of view. Absolute distance is not included, and x-y locations are given relative to the centre of the map rather than to a particular agent. The global state also includes health points and cooldown for all agents. The representation fed to the centralised Q-function critic is the concatenation of the global state representation with the local observation of the agent whose actions are being evaluated. Our centralised critic that estimates V (s), and is therefore agent-agnostic, receives the global state concatenated with all agents' observations. The observations contain no new information but include the egocentric distances relative to that agent.\nArchitecture & Training. The actor consists of 128-bit gated recurrent units (GRUs) (Cho et al. 2014) that use fully connected layers both to process the input and to produce the output values from the hidden state, h a t . The IAC critics use extra output heads appended to the last layer of the actor network. Action probabilities are produced from the final layer, z, via a bounded softmax distribution that lower-bounds the probability of any given action by /|U |: P (u) = (1 \u2212 )softmax(z) u + /|U |). We anneal linearly from 0.5 to 0.02 across 750 training episodes. The centralised critic is a feedforward network with multiple ReLU layers combined with fully connected layers. Hyperparameters were coarsely tuned on the 5m scenario and then used for all other maps. We found that the most sensitive parameter was TD(\u03bb), but settled on \u03bb = 0.8, which worked best for both COMA and our baselines. Our implementation uses TorchCraft (Synnaeve et al. 2016) and Torch 7 (Collobert, Kavukcuoglu, and Farabet 2011). Pseudocode and further details on the training procedure are in the appendix.\nWe experimented with critic architectures that are factored at the agent level and further exploit internal parameter sharing. However, we found that the bottleneck for scalability was not the centralisation of the critic, but rather the difficulty of multi-agent exploration. Hence, we defer further investigation of factored COMA critics to future work.\nAblations. We perform ablation experiments to validate three key elements of COMA. First, we test the importance of centralising the critic by comparing against two IAC variants, IAC-Q and IAC-V . These critics take the same decentralised input as the actor, and share parameters with the actor network up to the final layer. IAC-Q then outputs |U | Q-values, one for each action, while IAC-V outputs a single state-value. Note that we still share parameters between agents, using the egocentric observations and ID's as part of the input to allow different behaviours to emerge. The cooperative reward function is still shared by all agents.\nSecond, we test the significance of learning Q instead of  Centralised critics also clearly outperform their decentralised counterparts. The legend at the top applies across all plots.\nV . The method central-V still uses a central state for the critic, but learns V (s), and uses the TD error to estimate the advantage for policy gradient updates. Third, we test the utility of our counterfactual baseline. The method central-QV learns both Q and V simultaneously and estimates the advantage as Q \u2212 V , replacing COMA's counterfactual baseline with V . All methods use the same architecture and training scheme for the actors, and all critics are trained with TD(\u03bb).", "publication_ref": ["b29", "b32", "b31", "b22", "b3", "b28", "b5"], "figure_ref": ["fig_2"], "table_ref": ["tab_1"]}, {"heading": "Results", "text": "Figure 3 shows average win rates as a function of episode for each method and each StarCraft scenario. For each method, we conducted 35 independent trials and froze learning every 100 training episodes to evaluate the learned policies across 200 episodes per method, plotting the average across episodes and trials. Also shown is one standard deviation in performance.\nThe results show that COMA is superior to the IAC baselines in all scenarios. Interestingly, the IAC methods also eventually learn reasonable policies in 5m, although they need substantially more episodes to do so. This may seem counterintuitive since in the IAC methods, the actor and critic networks share parameters in their early layers (see Section 5), which could be expected to speed learning. However, these results suggest that the improved accuracy of policy evaluation made possible by conditioning on the global state outweighs the overhead of training a separate network.\nFurthermore, COMA strictly dominates central-QV , both in training speed and in final performance across all settings. This is a strong indicator that our counterfactual baseline is crucial when using a central Q-critic to train decentralised policies.\nLearning a state-value function has the obvious advantage of not conditioning on the joint action. Still, we find that COMA outperforms the central-V baseline in final performance. Furthermore, COMA typically achieves good policies faster, which is expected as COMA provides a shaped training signal. Training is also more stable than central-V , which is a consequence of the COMA gradient tending to zero as the policy becomes greedy. Overall, COMA is the best performing and most consistent method. Usunier et al. (2016) report the performance of their best agents trained with their state-of-the-art centralised controller labelled GMEZO (greedy-MDP with episodic zeroorder optimisation), and for a centralised DQN controller, both given a full field of view and access to attack-move macro-actions. These results are compared in  9) 19 ( 21) 36 ( 6) 39 ( 5) 47 ( 5) 65 68 61 90\nTable 1: Mean win percentage averaged across final 1000 evaluation episodes for the different maps, for all methods and the hand-coded heuristic in the decentralised setting with a limited field of view. The highest mean performances are in bold, while the values in parentheses denote the 95% confidence interval, for example 87(3) = 87 \u00b1 3. Also shown, maximum win percentages for COMA (decentralised), in comparison to the heuristic and published results (evaluated in the centralised setting).\nin most settings these agents achieve performance comparable to the best published win rates despite being restricted to decentralised policies and local fields of view.", "publication_ref": ["b31"], "figure_ref": ["fig_4"], "table_ref": ["tab_1"]}, {"heading": "Conclusions & Future Work", "text": "This paper presented COMA policy gradients, a method that uses a centralised critic in order to estimate a counterfactual advantage for decentralised policies in mutliagent RL. COMA addresses the challenges of multi-agent credit assignment by using a counterfactual baseline that marginalises out a single agent's action, while keeping the other agents' actions fixed. Our results in a decentralised StarCraft unit micromanagement benchmark show that COMA significantly improves final performance and training speed over other multi-agent actor-critic methods and remains competitive with state-of-the-art centralised controllers under best-performance reporting. Future work will extend COMA to tackle scenarios with large numbers of agents, where centralised critics are more difficult to train and exploration is harder to coordinate. We also aim to develop more sample-efficient variants that are practical for real-world applications such as self-driving cars.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgements", "text": "This project has received funding from the European Research Council (ERC) under the European Union's Horizon 2020 research and innovation programme (grant agreement number 637713). It was also supported by the Oxford-Google DeepMind Graduate Scholarship, the UK EPSRC CDT in Autonomous Intelligent Machines and Systems, and a generous grant from Microsoft for their Azure cloud computing services. We would like to thank Nando de Freitas, Yannis Assael, and Brendan Shillingford for helpful comments and discussion. We also thank Gabriel Synnaeve, Zeming Lin, and the rest of the TorchCraft team at FAIR for their work on the interface.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Appendix Training Details and Hyperparameters", "text": "Training is performed in batch mode, with a batch size of 30. Due to parameter sharing, all agents can be processed in parallel, with each agent for each episode and time step occupying one batch entry. The training cycle progresses in three steps (completion of all three steps constitutes as one episode in our graphs): 1) collect data: collect 30 n episodes; 2) train critic: for each time step, apply a gradient step to the feed-forward critic, starting at the end of the episode; and 3) train actor: fully unroll the recurrent part of the actor, aggregate gradients in the backward pass across all time steps, and apply a gradient update.\nWe use a target network for the critic, which updates every 150 training steps for the feed-forward centralised critics and every 50 steps for the recurrent IAC critics. The feed-forward critic receives more learning steps, since it performs a parameter update for each timestep. Both the actor and the critic networks are trained using RMS-prop with learning rate 0.0005 and alpha 0.99, without weight decay. We set gamma to 0.99 for all maps.\nAlthough tuning the skip-frame in StarCraft can improve absolute performance (Peng et al. 2017), we use a default value of 7, since the main focus is a relative evaluation between COMA and the baselines.\nEmpty buffer for e c = 1 to BatchSize n do s 1 = initial state, t = 0, h a 0 = 0 for each agent a while s t = terminal and t < T do\n) Get reward r t and next state s t+1 Add episode to buffer Collate episodes in buffer into single batch for t = 1 to T do // from now processing all agents in parallel via single batch Batch unroll RNN using states, actions and rewards Calculate TD(\u03bb) targets y a t using\u03b8 c i for t = T down to 1 do \u2206Q a t = y a t \u2212 Q s a j , u \u2206\u03b8 c = \u2207 \u03b8 c (\u2206Q a t ) 2 // calculate critic gradient \u03b8 c i+1 = \u03b8 c i \u2212 \u03b1\u2206\u03b8 c // update critic weights Every C steps reset\u03b8 c i = \u03b8 c i for t = T down to 1 do A a (s a t , u) = Q(s a t , u) \u2212 u Q(s a t , u, u \u2212a )\u03c0(u|h a t ) // calculate COMA \u2206\u03b8 \u03c0 = \u2206\u03b8 \u03c0 + \u2207 \u03b8 \u03c0 log \u03c0(u|h a t )A a (s a t , u) // accumulate actor gradients \u03b8 \u03c0 i+1 = \u03b8 \u03c0 i + \u03b1\u2206\u03b8 \u03c0 // update actor weights", "publication_ref": ["b22"], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "A comprehensive survey of multiagent reinforcement learning", "journal": "IEEE Transactions on Systems Man and Cybernetics Part C Applications and Reviews", "year": "2008", "authors": "L Busoniu; R Babuska; De Schutter; B "}, {"ref_id": "b1", "title": "An overview of recent progress in the study of distributed multi-agent coordination", "journal": "IEEE Transactions on Industrial informatics", "year": "2013", "authors": "Y Cao; W Yu; W Ren; G Chen"}, {"ref_id": "b2", "title": "All learning is local: Multi-agent learning in global reward games", "journal": "", "year": "2003", "authors": "Y.-H Chang; T Ho; L P Kaelbling"}, {"ref_id": "b3", "title": "On the properties of neural machine translation", "journal": "", "year": "2014", "authors": "K Cho; B Van Merri\u00ebnboer; D Bahdanau; Y Bengio"}, {"ref_id": "b4", "title": "Approximating difference evaluations with local information", "journal": "", "year": "2015", "authors": "M K Colby; W Curran; K Tumer"}, {"ref_id": "b5", "title": "Torch7: A matlab-like environment for machine learning", "journal": "", "year": "2011", "authors": "R Collobert; K Kavukcuoglu; C Farabet"}, {"ref_id": "b6", "title": "Learning cooperative visual dialog agents with deep reinforcement learning", "journal": "", "year": "2017", "authors": "A Das; S Kottur; J M Moura; S Lee; D Batra"}, {"ref_id": "b7", "title": "Learning to communicate with deep multi-agent reinforcement learning", "journal": "", "year": "2016", "authors": "J Foerster; Y M Assael; N De Freitas; S Whiteson"}, {"ref_id": "b8", "title": "Stabilising experience replay for deep multi-agent reinforcement learning", "journal": "", "year": "2017", "authors": "J Foerster; N Nardelli; G Farquhar; P Torr; P Kohli; S Whiteson"}, {"ref_id": "b9", "title": "Cooperative multi-agent control using deep reinforcement learning", "journal": "", "year": "2017", "authors": "J K Gupta; M Egorov; M Kochenderfer"}, {"ref_id": "b10", "title": "Deep recurrent q-learning for partially observable mdps", "journal": "", "year": "2015", "authors": "M Hausknecht; P Stone"}, {"ref_id": "b11", "title": "Long short-term memory", "journal": "Neural computation", "year": "1997", "authors": "S Hochreiter; J Schmidhuber"}, {"ref_id": "b12", "title": "Learning to play guess who? and inventing a grounded language as a consequence", "journal": "", "year": "2016", "authors": "E Jorge; M K\u00e5geb\u00e4ck; E Gustavsson"}, {"ref_id": "b13", "title": "Actor-critic algorithms", "journal": "", "year": "2000", "authors": "V R Konda; J N Tsitsiklis"}, {"ref_id": "b14", "title": "Multi-agent reinforcement learning as a rehearsal for decentralized planning", "journal": "Neurocomputing", "year": "2016", "authors": "L Kraemer; B Banerjee"}, {"ref_id": "b15", "title": "Multi-agent cooperation and the emergence of (natural)", "journal": "", "year": "2016", "authors": "A Lazaridou; A Peysakhovich; M Baroni"}, {"ref_id": "b16", "title": "Multi-agent reinforcement learning in sequential social dilemmas", "journal": "", "year": "2017", "authors": "J Z Leibo; V Zambaldi; M Lanctot; J Marecki; T Graepel"}, {"ref_id": "b17", "title": "Multi-agent actor-critic for mixed cooperative-competitive environments", "journal": "", "year": "2017", "authors": "R Lowe; Y Wu; A Tamar; J Harb; P Abbeel; I Mordatch"}, {"ref_id": "b18", "title": "Humanlevel control through deep reinforcement learning", "journal": "Nature", "year": "2015", "authors": "V Mnih; K Kavukcuoglu; D Silver; A A Rusu; J Veness; M G Bellemare; A Graves; M Riedmiller; A K Fidjeland; G Ostrovski"}, {"ref_id": "b19", "title": "Emergence of grounded compositional language in multi-agent populations", "journal": "", "year": "2017", "authors": "I Mordatch; P Abbeel"}, {"ref_id": "b20", "title": "Optimal and approximate Q-value functions for decentralized POMDPs", "journal": "", "year": "2008", "authors": "F A Oliehoek; M T J Spaan; N Vlassis"}, {"ref_id": "b21", "title": "Deep decentralized multi-task multi-agent rl under partial observability", "journal": "", "year": "2017", "authors": "S Omidshafiei; J Pazis; C Amato; J P How; J Vian"}, {"ref_id": "b22", "title": "Multiagent bidirectionally-coordinated nets for learning to play starcraft combat games", "journal": "", "year": "2017", "authors": "P Peng; Q Yuan; Y Wen; Y Yang; Z Tang; H Long; J Wang"}, {"ref_id": "b23", "title": "Modeling difference rewards for multiagent learning", "journal": "", "year": "2012", "authors": "S Proper; K Tumer"}, {"ref_id": "b24", "title": "High-dimensional continuous control using generalized advantage estimation. CoRR abs/1506.02438", "journal": "Cambridge University Press", "year": "2009", "authors": "J Schulman; P Moritz; S Levine; M I Jordan; P Abbeel"}, {"ref_id": "b25", "title": "Learning multiagent communication with backpropagation", "journal": "", "year": "2016", "authors": "S Sukhbaatar; R Fergus"}, {"ref_id": "b26", "title": "Policy gradient methods for reinforcement learning with function approximation", "journal": "", "year": "1999", "authors": "R S Sutton; D A Mcallester; S P Singh; Y Mansour"}, {"ref_id": "b27", "title": "Learning to predict by the methods of temporal differences", "journal": "Machine learning", "year": "1988", "authors": "R S Sutton"}, {"ref_id": "b28", "title": "Torchcraft: a library for machine learning research on realtime strategy games", "journal": "", "year": "2015", "authors": "G Synnaeve; N Nardelli; A Auvolat; S Chintala; T Lacroix; Z Lin; F Richoux; N Usunier; A Tampuu; T Matiisen; D Kodelja; I Kuzovkin; K Korjus; J Aru; J Aru; R Vicente"}, {"ref_id": "b29", "title": "Multi-agent reinforcement learning: Independent vs. cooperative agents", "journal": "", "year": "1993", "authors": "M Tan"}, {"ref_id": "b30", "title": "Distributed agent-based air traffic flow management", "journal": "ACM", "year": "2007", "authors": "K Tumer; Agogino ; A "}, {"ref_id": "b31", "title": "Episodic exploration for deep deterministic policies: An application to starcraft micromanagement tasks", "journal": "", "year": "2016", "authors": "N Usunier; G Synnaeve; Z Lin; S Chintala"}, {"ref_id": "b32", "title": "The packet-world: A test bed for investigating situated multiagent systems", "journal": "Springer", "year": "2001", "authors": "L Weaver; N Tao; D Weyns; A Helleboogh; T Holvoet"}, {"ref_id": "b33", "title": "Simple statistical gradient-following algorithms for connectionist reinforcement learning", "journal": "Machine learning", "year": "1992", "authors": "R J Williams"}, {"ref_id": "b34", "title": "Optimal payoff functions for members of collectives. In Modeling complexity in economic and social systems", "journal": "World Scientific", "year": "2002", "authors": "D H Wolpert; K Tumer"}, {"ref_id": "b35", "title": "Multiagent reinforcement learning for multi-robot systems: A survey", "journal": "", "year": "2004", "authors": "E Yang; D Gu"}, {"ref_id": "b36", "title": "A multi-agent framework for packet routing in wireless sensor networks", "journal": "sensors", "year": "2015", "authors": "D Ye; M Zhang; Yang ; Y "}, {"ref_id": "b37", "title": "Multi-agent framework for third party logistics in e-commerce", "journal": "Expert Systems with Applications", "year": "2005", "authors": "W Ying; S Dayong"}], "figures": [{"figure_label": "", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "where \u03b8 are the parameters of all actor policies, e.g. \u03b8 = {\u03b8 1 , . . . , \u03b8 |A| }, and b(s, u \u2212a ) is the counterfactual baseline defined in equation 4. First consider the expected contribution of the this baseline b(s, u \u2212a ): g b = \u2212E \u03c0 a \u2207 \u03b8 log \u03c0 a (u a |\u03c4 a )b(s, u \u2212a ) , (9)", "figure_data": ""}, {"figure_label": "1", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 1 :1Figure 1: In (a), information flow between the decentralised actors, the environment and the centralised critic in COMA; red arrows and components are only required during centralised learning. In (b) and (c), architectures of the actor and critic.", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "xFigure 2 :2Figure 2: Starting position with example local field of view for the 2d 3z map.", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "Figure 3 :3Figure 3: Win rates for COMA and competing algorithms on four different scenarios. COMA outperforms all baseline methods.Centralised critics also clearly outperform their decentralised counterparts. The legend at the top applies across all plots.", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "against the best agents trained with COMA for each map. Clearly,", "figure_data": "Local Field of View (FoV)Full FoV, Central Controlmapheur. IAC-V IAC-Q cnt-V cnt-QVCOMA mean bestheur. DQN GMEZO3m3547 (3)56 (6) 83 (3)83 (5)87 (3)9874--5m6663 (2)58 (3) 67 (5)71 (9)81 (5)9598991005w7018 (5)57 (5) 65 (3)76 (1)82 (3)98827074 32d 3z6327 ("}], "formulas": [{"formula_id": "formula_0", "formula_text": "P (s |s, u) : S \u00d7 U \u00d7 S \u2192 [0, 1].", "formula_coordinates": [2.0, 319.5, 617.69, 139.35, 8.77]}, {"formula_id": "formula_1", "formula_text": "S \u00d7 U \u2192 R and \u03b3 \u2208 [0, 1) is a discount factor.", "formula_coordinates": [2.0, 319.5, 628.65, 238.5, 19.94]}, {"formula_id": "formula_2", "formula_text": "T \u00d7 U \u2192 [0, 1].", "formula_coordinates": [2.0, 491.66, 695.2, 66.34, 8.74]}, {"formula_id": "formula_3", "formula_text": "value function Q \u03c0 (s t , u t ) = E st+1:\u221e,ut+1:\u221e [R t |s t , u t ].", "formula_coordinates": [3.0, 54.0, 122.07, 238.5, 11.25]}, {"formula_id": "formula_4", "formula_text": "A \u03c0 (s t , u t ) = Q \u03c0 (s t , u t ) \u2212 V \u03c0 (s t ).", "formula_coordinates": [3.0, 54.0, 133.03, 238.5, 22.21]}, {"formula_id": "formula_5", "formula_text": "g = E s0:\u221e,u0:\u221e T t=0 R t \u2207 \u03b8 \u03c0 log \u03c0(u t |s t ) .", "formula_coordinates": [3.0, 86.1, 396.67, 174.31, 30.2]}, {"formula_id": "formula_6", "formula_text": "(n) t = n l=1 \u03b3 l\u22121 r t+l + \u03b3 n f c (\u2022 t+n , \u03b8 c ).", "formula_coordinates": [3.0, 54.0, 644.42, 238.5, 23.74]}, {"formula_id": "formula_7", "formula_text": "L t (\u03b8 c ) = (y (\u03bb) \u2212 f c (\u2022 t , \u03b8 c )) 2 ,(2)", "formula_coordinates": [3.0, 112.38, 693.12, 180.13, 11.72]}, {"formula_id": "formula_8", "formula_text": "y (\u03bb) = (1 \u2212 \u03bb) \u221e n=1 \u03bb n\u22121 G (n)", "formula_coordinates": [3.0, 348.38, 54.47, 141.1, 14.28]}, {"formula_id": "formula_9", "formula_text": "g = \u2207 \u03b8 \u03c0 log \u03c0(u|\u03c4 a t ) (r + \u03b3V (s t+1 ) \u2212 V (s t )) .", "formula_coordinates": [4.0, 77.54, 140.2, 191.43, 12.69]}, {"formula_id": "formula_10", "formula_text": "A a (s, u) = Q(s, u) \u2212 u a \u03c0 a (u a |\u03c4 a )Q(s, (u \u2212a , u a )).", "formula_coordinates": [4.0, 62.0, 595.37, 222.49, 22.13]}, {"formula_id": "formula_11", "formula_text": "g k = E \u03c0 a \u2207 \u03b8 k log \u03c0 a (u a |\u03c4 a )A a (s, u)(5)", "formula_coordinates": [4.0, 350.78, 496.73, 207.22, 21.69]}, {"formula_id": "formula_12", "formula_text": "k ||\u2207J|| = 0 w.p. 1.(6)", "formula_coordinates": [4.0, 403.02, 535.16, 154.98, 14.66]}, {"formula_id": "formula_13", "formula_text": "g = E \u03c0 a \u2207 \u03b8 log \u03c0 a (u a |\u03c4 a )A a (s, u) , (7) A a (s, u) = Q(s, u) \u2212 b(s, u \u2212a ),(8)", "formula_coordinates": [4.0, 331.9, 574.02, 226.1, 35.9]}, {"formula_id": "formula_14", "formula_text": "A 1 t u 1 t u 1 t u 2 t u 2 t (h 2 , )", "formula_coordinates": [5.0, 111.13, 58.18, 125.86, 95.04]}, {"formula_id": "formula_15", "formula_text": "g b = \u2212 s d \u03c0 (s) a u \u2212a \u03c0(u \u2212a |\u03c4 \u2212a) \u2022 u a \u03c0 a (u a |\u03c4 a )\u2207 \u03b8 log \u03c0 a (u a |\u03c4 a )b(s, u \u2212a ) (10) = \u2212 s d \u03c0 (s) a u \u2212a \u03c0(u \u2212a |\u03c4 \u2212a) \u2022 u a \u2207 \u03b8 \u03c0 a (u a |\u03c4 a )b(s, u \u2212a ) (11) = \u2212 s d \u03c0 (s) a u \u2212a \u03c0(u \u2212a |\u03c4 \u2212a)b(s, u \u2212a )\u2207 \u03b8 1 = 0. (12", "formula_coordinates": [5.0, 65.05, 306.83, 227.45, 145.74]}, {"formula_id": "formula_16", "formula_text": ")", "formula_coordinates": [5.0, 288.35, 443.94, 4.15, 8.64]}, {"formula_id": "formula_17", "formula_text": "g = E \u03c0 a \u2207 \u03b8 log \u03c0 a (u a |\u03c4 a )Q(s, u) (13) = E \u03c0 \u2207 \u03b8 log a \u03c0 a (u a |\u03c4 a )Q(s, u) . (14", "formula_coordinates": [5.0, 90.44, 516.79, 202.06, 55.56]}, {"formula_id": "formula_18", "formula_text": ")", "formula_coordinates": [5.0, 288.35, 553.06, 4.15, 8.64]}, {"formula_id": "formula_19", "formula_text": "\u03c0(u|s) = a \u03c0 a (u a |\u03c4 a ),(15)", "formula_coordinates": [5.0, 122.57, 598.24, 169.93, 21.69]}, {"formula_id": "formula_20", "formula_text": "g = E \u03c0 [\u2207 \u03b8 log \u03c0(u|s)Q(s, u)] . (16", "formula_coordinates": [5.0, 107.42, 639.94, 180.93, 9.68]}, {"formula_id": "formula_21", "formula_text": ")", "formula_coordinates": [5.0, 288.35, 640.29, 4.15, 8.64]}], "doi": ""}