{"title": "Deep Reinforcement Learning at the Edge of the Statistical Precipice", "authors": "Rishabh Agarwal; Pablo Samuel Castro; Aaron Courville; Marc G Bellemare", "pub_date": "2022-01-05", "abstract": "Deep reinforcement learning (RL) algorithms are predominantly evaluated by comparing their relative performance on a large suite of tasks. Most published results on deep RL benchmarks compare point estimates of aggregate performance such as mean and median scores across tasks, ignoring the statistical uncertainty implied by the use of a finite number of training runs. Beginning with the Arcade Learning Environment (ALE), the shift towards computationally-demanding benchmarks has led to the practice of evaluating only a small number of runs per task, exacerbating the statistical uncertainty in point estimates. In this paper, we argue that reliable evaluation in the few-run deep RL regime cannot ignore the uncertainty in results without running the risk of slowing down progress in the field. We illustrate this point using a case study on the Atari 100k benchmark, where we find substantial discrepancies between conclusions drawn from point estimates alone versus a more thorough statistical analysis. With the aim of increasing the field's confidence in reported results with a handful of runs, we advocate for reporting interval estimates of aggregate performance and propose performance profiles to account for the variability in results, as well as present more robust and efficient aggregate metrics, such as interquartile mean scores, to achieve small uncertainty in results. Using such statistical tools, we scrutinize performance evaluations of existing algorithms on other widely used RL benchmarks including the ALE, Procgen, and the DeepMind Control Suite, again revealing discrepancies in prior comparisons. Our findings call for a change in how we evaluate performance in deep RL, for which we present a more rigorous evaluation methodology, accompanied with an open-source library rliable 2 , to prevent unreliable results from stagnating the field.", "sections": [{"heading": "Introduction", "text": "Research in artificial intelligence, and particularly deep reinforcement learning (RL), relies on evaluating aggregate performance on a diverse suite of tasks to assess progress. Quantitative evaluation on a suite of tasks, such as Atari games [5], reveals strengths and limitations of methods while simultaneously guiding researchers towards methods with promising results. Performance of RL algorithms is usually summarized with a point estimate of task performance measure, such as mean and median performance across tasks, aggregated over independent training runs.\nA small number of training runs (Figure 1) coupled with high variability in performance of deep RL algorithms [16,17,41,68,70], often leads to substantial statistical uncertainty in reported point estimates. While evaluating more runs per task has been prescribed to reduce uncertainty and obtain reliable estimates [20,41,49], 3-10 runs are prevalent in deep RL as it is often computationally prohibitive to evaluate more runs. For example, 5 runs each on 50+ Atari 2600 games in ALE using standard protocol requires more than 1000 GPU training days [15]. As we move towards more challenging and complex RL benchmarks (e.g., StarCraft [110]), evaluating more than a handful of runs will become increasingly demanding due to increased amount of compute and data needed to tackle such tasks. Additional confounding factors, such as exploration in the low-data regime, exacerbates the performance variability in deep RL -as seen on the Atari 100k benchmark [50] often requiring many more runs to achieve negligible statistical uncertainty in reported estimates. Here, we show representative RL papers with empirical results, in the order of their publication year: TD-learning [99], Sparse coding [100], Options [102], Tetris (CEM) [103], Batch-Q [31], ALE [5], DQN [75], AlphaGo [96], A3C [76], DDPG [62], ES [88], PPO [92], SAC [36], Rainbow [42], AlphaStar [110], Go-Explore [28], OpenAI Five [8], Balloon navigation [7] and MuZero [91].\nIgnoring the statistical uncertainty in deep RL results gives a false impression of fast scientific progress in the field. It inevitably evades the question: \"Would similar findings be obtained with new independent runs under different random conditions?\" This could steer researchers towards superficially beneficial methods [11,12,25], often at the expense of better methods being neglected or even rejected early [67,74] as such methods fail to outperform inferior methods simply due to less favorable random conditions. Furthermore, only reporting point estimates obscures nuances in comparisons [85] and can erroneously lead the field to conclude which methods are state-ofthe-art [63,84], ensuing wasted effort when applied in practice [108]. Moreover, not reporting the uncertainty in deep RL results makes them difficult to reproduce except under the exact same random conditions, which could lead to a reproducibility crisis similar to the one that plagues other fields [4,44,78]. Finally, unreliable results could erode trust in deep RL research itself [45].\nIn this work, we show that recent deep RL papers compare unreliable point estimates, which are dominated by statistical uncertainty, as well as exploit non-standard evaluation protocols, using a case study on Atari 100k (Section 3). Then, we illustrate how to reliably evaluate performance with only a handful of runs using a more rigorous evaluation methodology that accounts for uncertainty in results (Section 4). To exemplify the necessity of such methodology, we scrutinize performance evaluations of existing algorithms on widely used benchmarks, including the ALE [5] (Atari 100k, Atari 200M), Procgen [18] and DeepMind Control Suite [104], again revealing discrepancies in prior comparisons (Section 5). Our findings call for a change in how we evaluate performance in deep RL, for which we present a better methodology to prevent unreliable results from stagnating the field.\nHow do we reliably evaluate performance on deep RL benchmarks with only a handful of runs? As a practical solution that is easily applicable with 3-10 runs per task, we identify three statistical tools (Table 1) for improving the quality of experimental reporting. Since any performance estimate based on a finite number of runs is a random variable, we argue that it should be treated as such. Specifically, we argue for reporting aggregate performance measures using interval estimates via stratified bootstrap confidence intervals, as opposed to point estimates. Among prevalent aggregate measures, mean can be easily dominated by performance on a few outlier tasks, while median has high variability and zero performance on nearly half of the tasks does not change it. To address these deficiencies, we present more efficient and robust alternatives, such as interquartile mean, which are not unduly affected by outliers and have small uncertainty even with a handful of runs. Furthermore, to reveal the variability in performance across tasks, we propose reporting performance distributions across all runs. Compared to prior work [5,83], these distributions result in performance profiles [26] that are statistically unbiased, more robust to outliers, and require fewer runs for smaller uncertainty.", "publication_ref": ["b4", "b15", "b16", "b40", "b67", "b69", "b19", "b40", "b48", "b14", "b109", "b49", "b98", "b99", "b101", "b102", "b30", "b4", "b74", "b95", "b75", "b61", "b87", "b91", "b35", "b41", "b109", "b27", "b7", "b6", "b90", "b10", "b11", "b24", "b66", "b73", "b84", "b62", "b83", "b107", "b3", "b43", "b77", "b44", "b4", "b17", "b103", "b4", "b82", "b25"], "figure_ref": ["fig_0"], "table_ref": ["tab_0"]}, {"heading": "Formalism", "text": "We consider the setting in which a reinforcement learning algorithm is evaluated on M tasks. For each of these tasks, we perform N independent runs 3 which each provide a scalar, normalized score x m,n , m = 1, . . . , M and n = 1, . . . , N . These normalized scores are obtained by linearly rescaling per-task scores 4 based on two reference points; for example, performance on the Atari games is typically normalized with respect to a random agent and an average human, who are assigned a normalized score of 0 and 1 respectively [75]. We denote the set of normalized scores by x 1:M ,1:N .\nIn most experiments, there is inherent randomness in the scores obtained from different runs. This randomness can arise from stochasticity in the task, exploratory choices made during learning, randomized initial parameters, but also software and hardware considerations such as non-determinism in GPUs and in machine learning frameworks [116]. Thus, we model the algorithm's normalized score on the m th task as a real-valued random variable X m . Then, the score x m,n is a realization of the random variable X m,n , which is identically distributed as X m . For \u03c4 \u2208 R, we define the tail distribution function of X m as F m (\u03c4 ) = P(X m > \u03c4 ). For any collection of scores y 1:K , the empirical tail distribution function is given byF (\u03c4 ; y 1:\nK ) = 1 K K k=1 1[y k > \u03c4 ].\nIn particular, we writeF m (\u03c4 ) =F (\u03c4 ; x m,1:N ).\nThe aggregate performance of an algorithm maps the set of normalized scores x 1:M ,1:N to a scalar value. Two prevalent aggregate performance metrics are the mean and median normalized scores. If we denote byx m = 1 N N n=1 x m,n the average score on task m across N runs, then these aggregate metrics are Mean(x 1:M ) and Median(x 1:M ). More precisely, we call these sample mean and sample median over the task means since they are computed from a finite set of N runs. Sincex m is a realization of the random variableX m = 1 N N n=1 X m,n , the sample mean and median scores are point estimates of the random variables Mean(X 1:M ) and Median(X 1:M ) respectively. We call true mean and true median the metrics that would be obtained if we had unlimited experimental capacity (N \u2192 \u221e), given by Mean(E[X 1:M ]) and Median(E[X 1:M ]) respectively.\nConfidence intervals (CIs) for a finite-sample score can be interpreted as an estimate of plausible values for the true score. A \u03b1 \u00d7 100% CI computes an interval such that if we rerun the experiment and construct the CI using a different set of runs, the fraction of calculated CIs (which would differ for each set of runs) that contain the true score would tend towards \u03b1 \u00d7 100%, where \u03b1 \u2208 [0, 1] is the nominal coverage rate. 95% CIs are typically used in practice. If the true score lies outside the 95% CI, then a sampling event has occurred which had a probability of 5% of happening by chance. Remark. Following Amrhein et al. [2], Romer [87], Wasserstein et al. [112], we recommend using confidence intervals for measuring the uncertainty in results and showing effect sizes (e.g., performance improvements over baseline) that are compatible with the given data. Furthermore, we emphasize using statistical thinking but avoid statistical significance tests (e.g., p-value < 0.05) because of their dichotomous nature (significant vs. not significant) and common misinterpretations [33,35,73] such as 1) lack of statistically significant results does not demonstrate the absence of effect (Figure 2, right), and 2) given enough data, any trivial effect can be statistically significant but may not be practically significant.", "publication_ref": ["b2", "b3", "b74", "b115", "b1", "b86", "b111", "b32", "b34", "b72"], "figure_ref": [], "table_ref": []}, {"heading": "Case Study: The Atari 100k benchmark", "text": "We begin with a case study to illustrate the pitfalls arising from the na\u00efve use of point estimates in the few-run regime. Our case study concerns the Atari 100k benchmark [50], an offshoot of the ALE for evaluating data-efficiency in deep RL. In this benchmark, algorithms are evaluated on only 100k steps (2-3 hours of game-play) for each of its 26 games, versus 200M frames in the ALE benchmark.\nPrior reported results on this benchmark have been computed mostly from 3 [39,55,59,72,89,95] or 5 runs [50,51,53,54,64,66,86,107,115], and more rarely, 10 [65,93] or 20 runs [56].\nOur case study compares the performance of five recent deep RL algorithms, namely: (1) DER [107] and (2) OTR [51], (3) DrQ 5 [53], (4) CURL [56], and (5) SPR [93]. We chose these methods as representative of influential algorithms within this benchmark. Since good performance on one game can result in unduly high sample means without providing much information about performance on other games, it is common to measure performance on Atari 100k using sample medians. Refer to Appendix A. 2 for more details about the experimental setup.\nWe investigate statistical variations in the few-run regime by evaluating 100 independent runs for each algorithm, where the score for a run is the average returns obtained in 100 evaluation episodes taking place after training. Each run corresponds to training one algorithm on each of the 26 games in Atari 100k. This provides us with 26 \u00d7 100 scores per algorithm, which we then subsample with replacement to 3-100 runs. The subsampled scores are then used to produce a collection of point estimates whose statistical variability can be measured. We begin by using this experimental protocol to highlight statistical concerns regarding median normalized scores.\nHigh variability in reported results. Our first observation is that the sample medians reported in the literature exhibit substantial variability when viewed as random quantities that depend on a small number of sample runs (Figure 2, left). This shows that there is a fairly large potential for drawing erroneous conclusions based on point estimates alone. As a concrete example, our analysis suggests that DER may in fact be better than OTR, unlike what the reported point estimates suggest. We conclude that in the few-run regime, point estimates are unlikely to provide definitive answers to the question: \"Would we draw the same conclusions were we to re-evaluate our algorithm with a different set of runs?\"  In the few-run regime, we find that this bias can dominate the comparison between algorithms, as evidenced in Figure 3. For example, the score difference between sample medians with 5 and 100 runs for SPR (+0.03 points) is about 36% of its mean improvement over DrQ(\u03b5) (+0.08 points). Adding to the issue, the magnitude and sign of this bias strongly depends on the algorithm being evaluated.\nStatistical concerns cannot be satisfactorily addressed with few runs. While claiming improvements with 3 or fewer runs may naturally raise eyebrows, folk wisdom in experimental RL suggests that 20 or 30 runs are enough. By calculating 95% confidence interval 6 on sample medians for a varying number of runs (Figure 2, right), we find that this number is closer to 50-100 runs in Atari 100k -far too many to be computationally feasible for most research projects.\nConsider a setting in which an algorithm is known to be better -what is the reliability of median and IQM (Section 4.3) for accurately assessing performance differences as the number of runs varies? Specifically, we consider two identical N -run experiments involving SPR, except that we artificially inflate one of the experiments' scores by a fixed fraction or lift of + % (Figure 4). In particular, = 0 corresponds to running the same experiment twice but with different runs. We find that statistically defensible improvements with median scores is only achieved for 25 runs ( = 25) and 100 runs ( = 10). With = 0, even 100 runs are insufficient, with deviations of 20% possible.\nChanges in evaluation protocols invalidates comparisons to prior work. A typical and relatively safe approach for measuring the performance of an RL algorithm is to average the scores received in their final training episodes [69]. However, the field has seen a number of alternative protocols used, including reporting the maximum evaluation score achieved during training [1,3,75] or across multiple runs [32,47,82]. A similar protocol is also used by CURL and SUNRISE [59] (Appendix A.4).\nResults produced under alternative protocols involving maximum are generally incomparable with end-performance reported results. On Atari 100k, we find that the two protocols produce substantially different results (Figure 5), of a magnitude greater than the actual difference in score. In particular, evaluating DER with CURL's protocol results in scores far above those reported for CURL. In other words, this gap in evaluation procedures resulted in CURL being assessed as achieving a greater true median than DER, where our experiment gives strong support to DER being superior. Similarly, we find that a lot of SUNRISE's improvement over DER can be explained by the change in evaluation protocol (Figure 5). Refer to Appendix A.4 for discussion on pitfalls of such alternative protocols.", "publication_ref": ["b49", "b38", "b54", "b58", "b71", "b88", "b94", "b49", "b50", "b52", "b53", "b63", "b65", "b85", "b106", "b114", "b64", "b92", "b55", "b106", "b50", "b52", "b55", "b92", "b1", "b5", "b68", "b0", "b2", "b74", "b31", "b46", "b81", "b58"], "figure_ref": ["fig_2"], "table_ref": []}, {"heading": "Recommendations and Tools for Reliable Evaluation", "text": "Our case study shows that the increase in the number of runs required to address the statistical uncertainty issues is typically infeasible for computationally demanding deep RL benchmarks. In this section, we identify three tools for improving the quality of experimental reporting in the few-run regime, all aligned with the principle of accounting for statistical uncertainty in results.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Stratified Bootstrap Confidence Intervals", "text": "We first reaffirm the importance of reporting interval estimates to indicate the range within which an algorithm's aggregate performance is believed to lie. Concretely, we propose using bootstrap CIs [29]  with stratified sampling for aggregate performance, a method that can be applied to small sample sizes and is better justified than reporting sample standard deviations in this context. While prior work has recommended using bootstrap CIs for reporting uncertainty in single task mean scores with N runs [16,20,41], this is less useful when N is small (Figure A.18), as bootstrapping assumes that re-sampling from the data approximates sampling from the true distribution. We can do better by aggregating samples across tasks, for a total of M N random samples.\nTo compute the stratified bootstrap CIs, we re-sample runs with replacement independently for each task to construct an empirical bootstrap sample with N runs each for M tasks from which we calculate a statistic and repeat this process many times to approximate the sampling distribution of the statistic. We measure the reliability of this technique in Atari 100k for variable N , by comparing the nominal coverage of 95% to the \"true\" coverage from the estimated CIs (Figure 6) for different bootstrap methods (see [30] and Appendix A.5). We find that percentile CIs provide good interval estimates for as few as N = 10 runs for both median and IQM scores (Section 4.3).", "publication_ref": ["b28", "b15", "b19", "b40", "b29"], "figure_ref": [], "table_ref": []}, {"heading": "Performance Profiles", "text": "Most deep RL benchmarks yield scores that vary widely between tasks and may be heavy-tailed, multimodal, or possess outliers (e.g., Figure A.14). In this regime, both point estimates, such as mean and median scores, and interval estimates of these quantities paint an incomplete picture of an algorithm's performance [24,Section 3]. Instead, we recommend the use of performance profiles [26], commonly used in benchmarking optimization software. While performance profiles from Dolan and Mor\u00e9 [26] correspond to empirical cumulative distribution functions without any uncertainty estimates, profiles proposed herein visualize the empirical tail distribution function (Section 2) of a random score (higher curve is better), with pointwise confidence bands based on stratified bootstrap.\nBy representing the entire set of normalized scores x 1:M,1:N visually, performance profiles reveal performance variability across tasks much better than interval estimates of aggregate metrics. Although tables containing per-task mean scores and standard deviations can reveal this variability, such tables tend to be overwhelming for more than a few tasks. 7 In addition, performance profiles are robust to outlier runs and insensitive to small changes in performance across all tasks [26].\nIn this paper, we propose the use of a performance profile we call run-score distributions or simply score distributions (Figure 7, right), particularly well-suited to the few-run regime. A score distribution shows the fraction of runs above a certain normalized score and is given by We use 10 runs to show the robustness of profiles with a few runs. For SimPLe [50], we use the 5 runs from their reported results. The \u03c4 value where the profiles intersect y = 0.5 shows the median while for a non-negative random variable, area under the performance profile corresponds to the mean.\nF X (\u03c4 ) =F (\u03c4 ; x 1:M,1:N ) = 1 M M m=1F m (\u03c4 ) = 1 M M m=1 1 N N n=1 1[x m,n > \u03c4 ].(1)\nOne advantage of the score distribution is that it is an unbiased estimator of the underlying distribution\nF (\u03c4 ) = 1 N M m=1 F m (\u03c4 ).\nAnother advantage is that an outlier run with extremely high score can change the output of score distribution for any \u03c4 by at most a value of 1 M N . It is useful to contrast score distributions to average-score distributions, originally proposed in the context of the ALE [5] as a generalization of the median score. Average-score distributions correspond to the performance profile of a random variableX,FX (\u03c4 ) =F (\u03c4 ;x 1:M ), which shows the fraction of tasks on which an algorithm performs better than a certain score. However, such distributions are a biased estimate of the thing they seek to represent. Run-score distributions are more robust than average-score distributions, as they are a step function in 1/M N versus 1/M intervals, and typically has less variance:  Performance profiles allow us to compare different methods at a glance. If one curve is strictly above another, the better method is said to stochastically dominate 8 the other [27,61]. In RL benchmarks with a large number of tasks, however, stochastic dominance is rarely observed: performance profiles often intersect at multiple points. Finer quantitative comparisons must therefore entail aggregate metrics.\n\u03c3 2 X = 1 M 2 N M m=1 F m (\u03c4 )(1 \u2212 F m (\u03c4 )) versus \u03c3 2 X = 1 M 2 M m=1 FX m (\u03c4 )(1 \u2212 FX m (\u03c4 )).\nWe can extract a number of aggregate metrics from score distributions, including median (mixing runs and tasks) and mean normalized scores (matching our usual definition). As we already argued that these metrics are deficient, we now consider interesting alternatives also derived from score distributions.\nAs an alternative to median, we recommend using the interquartile mean (IQM). Also called 25% trimmed mean, IQM discards the bottom and top 25% of the runs and calculates the mean score of the remaining 50% runs (= N M/2 for N runs each on M tasks). IQM interpolates between mean and median across runs, which are 0% and almost 50% trimmed means  respectively. Compared to sample median, IQM is a better indicator of overall performance as it is calculated using 50% of the combined runs while median only depends on the performance ordering across tasks and not on the magnitude except at most 2 tasks. For example, zero scores on nearly half of the tasks does not affect the median while IQM exhibits a severe degradation. Compared to mean, IQM is robust to outliers, yet has considerably less bias than median (Figure A.17). While median is more robust to outliers than IQM, this robustness comes at the expense of statistical efficiency, which is crucial in the few-run regime: IQM results in much smaller CIs (Figure 2 (right) and 6) and is able to detect a given improvement with far fewer runs (Figures 4 and A .15).\nAs a robust alternative to mean, we recommend using the optimality gap: the amount by which the algorithm fails to meet a minimum score of \u03b3 = 1.0 (orange region in Figure 8). This assumes that a score of 1.0 is a desirable target beyond which improvements are not very important, for example when the aim is to obtain human-level performance [e.g., 3,23]. Naturally, the threshold \u03b3 may be chosen differently, which we discuss further in Appendix A.7.\nIf one is interested in knowing how robust an improvement from an algorithm X over an algorithm Y is, another possible metric to consider is the average probability of improvement -this metric shows how likely it is for X to outperform Y on a randomly selected task. Specifically, P (X\n> Y ) = 1 M M m=1 P (X m > Y m ), where P (X m > Y m ) (Equation A.\n2) is the probability that X is better than Y on task m. Note that, unlike IQM and optimality gap, this metric does not account for the size of improvement. While finding the best aggregate metric is still an open question and is often dependent on underlying normalized score distribution, our proposed alternatives avoid the failure modes of prevalent metrics while being robust and requiring fewer runs to reduce uncertainty.", "publication_ref": ["b23", "b25", "b25", "b6", "b25", "b49", "b4", "b26", "b60", "b2", "b22"], "figure_ref": ["fig_3", "fig_5"], "table_ref": []}, {"heading": "Re-evaluating Evaluation on Deep RL Benchmarks", "text": "Arcade Learning Environment. Training RL agents for 200M frames on the ALE [5,69] is the most widely recognized benchmark in deep RL. We revisit some popular methods which demonstrated progress on this benchmark and reveal discrepancies in their findings as a consequence of ignoring the uncertainty in their results (Figure 9). For example, DreamerV2 [38] exhibits a large amount of uncertainty in aggregate scores. While M-IQN [109] claimed better performance than Dopamine Rainbow 9 [42] in terms of median normalized scores, their interval estimates strikingly overlap. Similarly, while C51 [5] is considered substantially better than DQN [75], the interval estimates as well as performance profiles for DQN (Adam) and C51 overlap significantly. Figure 9 reveals an interesting limitation of aggregate metrics: depending on the choice of metric, the ordering between algorithms changes (e.g., Median vs. IQM). The inconsistency in ranking across aggregate metrics arises from the fact that such metrics only capture a specific aspect of overall performance across tasks and runs. Additionally, the change of algorithm ranking between optimality gap and IQM/median scores reveal that while recent algorithms typically show performance gains relative to humans on average, their performance seems to be worse on games below human Figure 11: DeepMind Control Suite evaluation results, averaged across 6 tasks, on the 100k and 500k benchmark. We compare SAC+AE [114], SLAC [58], Dreamer [37], CURL [98], RAD [57], DrQ [53], PISAC [60], SUNRISE [59], and CURL-D2RL [97]. The ordering of the algorithms in the left figure is based on their claimed relative performance -all algorithms except Dreamer claimed improvement over at least one algorithm placed below them. (a) Interval estimates show 95% stratified bootstrap CIs for methods with individual runs provided by their respective authors and 95% studentized CIs for CURL, CURL-D2RL, and SUNRISE. Normalized scores are computed by dividing by the maximum score (=1000). (b) Score distributions. (c) The i th column in the rank distribution plots show the probability that a given method is assigned rank i, averaged across all tasks. The ranks are estimated using 200,000 stratified bootstrap re-samples.\nperformance. Since performance profiles capture the full picture, they would often illustrate why such inconsistencies exist. For example, optimality gap and IQM can be both read as areas in the profile (Figure 8). The performance profile in Figure 10 (left) illustrates the nuances present when comparing different algorithms. For example, IQN seems to be better than Rainbow for \u03c4 \u2265 2, but worse for \u03c4 < 2. Similarly, the profiles of DreamerV2 and M-IQN for \u03c4 < 8 intersect at multiple points. To compare sample efficiency of the agents, we also present their IQM scores as a function of number of frames in Figure 10 (right).\nDeepMind Control Suite. Recent continuous control papers benchmark performance on 6 tasks in DM Control [104] at 100k and 500k steps. Typically, such papers claim improvement based on higher mean scores per task regardless of the variability in those scores. However, we find that when accounting for uncertainty in results, most algorithms do not consistently rank above algorithms they claimed to improve upon (Figure 11c and 11b). Furthermore, there are huge overlaps in 95% CIs of mean normalized scores for most algorithms (Figure 11a). These findings suggest that a lot of the reported improvements are spurious, resulting from randomness in the experimental protocol.\nProcgen benchmark. Procgen [18] is a popular benchmark, consisting of 16 diverse tasks, for evaluating generalization in RL. Recent papers report mean PPO-normalized scores on this benchmark to emphasize the gains relative to PPO [92] as most methods are built on top of it. However, Figure 12 (left) shows that PPO-normalized scores typically have a heavy-tailed distribution making the mean scores highly dependent on performance on a small fraction of tasks. Instead, we recommend using normalization based on the estimated minimum and maximum scores on ProcGen [18] and reporting aggregate metrics based on such scores (Figure A.32). While publications sometimes make binary claims about whether they improve over prior methods, such improvements are inherently probabilistic. To reveal this discrepancy, we investigate the following question: \"What is the  [92], MixReg [111], UCB-DrAC [81], PLR [48], PPG [19] and IDAAC [80]. Shaded regions indicate 95% percentile stratified bootstrap CIs. Right. Each row shows the probability of improvement, with 95% bootstrap CIs, that the algorithm X on the left outperforms algorithm Y on the right, given that X was claimed to be better than Y . For all algorithms, results are based on 10 runs per task.\nprobability that an algorithm which claimed improvement over a prior algorithm performs better than it?\" (Figure 12, right). While this probability does not distinguish between two algorithms which uniformly improve on all tasks by 1% and 100%, it does highlight how likely an improvement is. For example, there is only a 40 \u2212 50% chance that UCB-DrAC [81] improves upon PLR [48]. We note that a number of improvements reported in the existing literature are only 50 \u2212 70% likely.", "publication_ref": ["b4", "b68", "b37", "b108", "b41", "b4", "b74", "b113", "b57", "b36", "b97", "b56", "b52", "b59", "b58", "b96", "b103", "b17", "b91", "b17", "b91", "b110", "b80", "b47", "b18", "b79", "b80", "b47"], "figure_ref": ["fig_7", "fig_7", "fig_0", "fig_5", "fig_0", "fig_0", "fig_0", "fig_0", "fig_0", "fig_0"], "table_ref": []}, {"heading": "Discussion", "text": "We saw, both in our case study on the Atari 100k benchmark and with our analysis of other widely-used RL benchmarks, that statistical issues can have a sizeable influence on reported results, in particular when point estimates are used or evaluation protocols are not kept constant within comparisons. Despite earlier calls for more experimental rigor in deep RL [16,20,21,41,49,83] (discussed in Appendix A.3), our analysis shows that the field has not yet found sure footing in this regards.\nIn part, this is because the issue of reproducibility is a complex one; where our work is concerned with our confidence about and interpretation of reported results (what Goodman et al. [34] calls results reproducibility), others [79] have highlighted that there might be missing information about the experiments themselves (methods reproducibility). We remark that the problem is not solved by fixing random seeds, as has sometimes been proposed [52,77], since it does not really address the question of whether an algorithm would perform well under similar conditions but with different seeds. Furthermore, fixed seeds might benefit certain algorithms more than others. Nor can the problem be solved by the use of dichotomous statistical significance tests, as discussed in Section 2.\nOne way to minimize the risks associated with statistical effects is to report results in a more complete fashion, paying close attention to bias and uncertainty within these estimates. To this end, our recommendations are summarized in Table 1. To further support RL researchers in this endeavour, we released an easy-to-use Python library, rliable along with a Colab notebook for implementing our recommendations, as well as all the individual runs used in our experiments 10 . Again, we emphasize the importance of published papers providing results for all runs to allow for future statistical analyses.\nA barrier to adoption of evaluation protocols proposed in this work, and more generally, rigorous evaluation, is whether there are clear incentives for researchers to do so, as more rigor generally entails more nuanced and tempered claims. Arguably, doing good and reproducible science is one such incentive. We hope that our findings about erroneous conclusions in published papers would encourage researchers to avoid fooling themselves, even if that requires tempered claims. That said, a more pragmatic incentive would be if conferences and reviewers required more rigorous evaluation for publication, e.g., NeurIPS 2021 checklist asks whether error bars are reported. Moving towards reliable evaluation is an ongoing process and we believe that this paper would greatly benefit it.\nGiven the substantial influence of statistical considerations in experiments involving 40-year old Atari 2600 video games and low-DOF robotic simulations, we argue that it is unlikely that an increase in available computation will resolve the problem for the future generation of RL benchmarks. Instead, just as a well-prepared rock-climber can skirt the edge of the steepest precipices, it seems likely that ongoing progress in reinforcement learning will require greater experimental discipline.", "publication_ref": ["b15", "b19", "b20", "b40", "b48", "b82", "b33", "b78", "b51", "b76", "b9"], "figure_ref": [], "table_ref": ["tab_0"]}, {"heading": "Societal Impacts", "text": "This paper calls for statistical sophistication in deep RL research by accounting for statistical uncertainty in reported results. However, statistical sophistication can introduce new forms of statistical abuses and monitoring the literature for such abuses should be an ongoing priority for the research community. Moving towards reliable evaluation and reproducible research is an ongoing process and this paper only partly addresses it by providing tools for more reliable evaluation. That said, while accounting for uncertainty in results is not a panacea, it provides a strong foundation for trustworthy results on which the community can build upon, with increased confidence. In terms of broader societal impact of this work, we do not see any foreseeable strongly negative impacts. However, this paper could positively impact society by constituting a step forwards in rigorous few-run evaluation regime, which reduces computational burden on researchers and is \"greener\" than evaluating a large number of runs.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "A Appendix", "text": "A.1 Open-source notebook and data Colab notebook for producing and analyzing performance profiles, robust aggregate metrics, and interval estimates based on stratified bootstrap CIs, as well as replicating the results in the paper can be found at bit.ly/statistical_precipice_colab.\nIndividual runs for Atari 100k. We released the 100 runs per game for each of the 6 algorithms in the case study in a public cloud bucket at gs://rl-benchmark-data/atari_100k.\nIndividual runs for ALE, Procgen and DM Control. For ALE, we used the individual runs from Dopamine [14] baselines except for DreamerV2 [38], REM [1] and M-IQN [109], for which the individual run scores were obtained from the corresponding authors. We release all the individual run scores as well as final scores for ALE at gs://rl-benchmark-data/ALE. The Procgen results were obtained from the authors of IDAAC [80] and MixReg [48] and are released at gs://rl-benchmark-data/procgen. For DM Control 11 , all the runs were obtained from the corresponding authors and are released at gs://rl-benchmark-data/dm_control. See agarwl.github.io/rliable for a website for the paper. Runs can be different from using fixed random seeds. We find that correlation between two sets of 100 runs of DER on Atari 100k using the same set of random seeds, that is, using a fixed random seed per run for Python, NumPy and JAX, is quite small. Small values of correlation coefficient highlight that fixing seeds does not ensure deterministic results due to non-determinism in GPUs. Similarly, setting random seed in PyTorch ensures reproducibility only on the same hardware.", "publication_ref": ["b13", "b37", "b0", "b108", "b79", "b47"], "figure_ref": [], "table_ref": []}, {"heading": "A.2 Atari 100k: Additional Details and Results", "text": "Code. Due to unavailability of open-source code for DER, and OTR for Atari 100k, we re-implemented these algorithms using Dopamine [14], a reproducible deep RL framework. For CURL and SPR, we used the open-source code released by the authors while for DrQ, we used the source-code obtained from the authors. Our code for Atari 100k experiments is open-sourced as part of the Dopamine library under the labs/atari_100k folder. We also released a JAX [13] implementation of the full Rainbow [42] in Dopamine.\nHyperparameters. All algorithms build upon the Rainbow [42] architecture and we use the exact same hyperparameters specified in the corresponding publication unless specified otherwise. Akin to DrQ and SPR, we used n-step returns with n = 10 instead of n = 20 for DER. DrQ codebase uses non-standard evaluation hyperparameters, such as a 5% probability of selecting random actions during evaluation (\u03b5-eval= 0.05). DrQ(\u03b5) differs DrQ in terms of using standard \u03b5-greedy parameters [14, Table 1] including training \u03b5 decayed to 0.01 rather than 0.1 and evaluation \u03b5 set to 0.001 instead of 0.05. Refer to the gin configurations in labs/atari_100k/configs for more details. Efficiency of an estimator is typically measured in terms of its mean squared error (MSE). We estimate MSE for trimmed estimators with 10 runs by subsampling 20,000 sets of 10 runs with replacement from 100 runs.\nCompute. For the case study on Atari 100k, we used Tesla P100 GPUs for all the runs. Each run spanned about 3-5 hours depending on the algorithm, and we ran a total of 100 runs / game \u00d7 26 games/algorithm \u00d7 6 algorithms = 15,600 runs. Additionally, we ran an additional 100 runs per game for DER to compute a good approximation of point estimates for aggregate scores, which increases the total number of runs by 2600. Overall, we trained and evaluated 18,200 runs, which roughly amounts to 2400 days -3600 days of GPU training.\nComparing performance of two algorithms. When confidence intervals (CIs) overlap for two random variables X and Y overlap, we estimate the 95% CIs for X \u2212 Y to account for uncertainty in their difference (Figure A.15). For example, when using 5 runs, the median score improvement from DrQ(\u03b5) over DER is estimated to lie within (0.01, 0.21) while that of SPR over DrQ lies within (\u22120.09, 0.18). Furthermore, while improvement from SPR over DER with 5 to 15 runs is not statistically significant, claiming \"no improvement\" would be misleading as evaluating more runs indeed shows that the improvement is significant.\nAnalyzing efficiency and bias of IQM. Theoretically, trimmed means, are known to have higher statistical efficiency for mixed distributions and heavy-tailed distributions (Cauchy distribution), at the cost of lower efficiency for some other less heavily-tailed distributions (normal distribution) than mean, as shown by the seminal work of Tukey [106]. Empirically, on Atari 100k, IQM provides good statistically efficiency among trimmed estimators across different algorithms (Figure A.16) as well as has considerably small bias than median (c.f. Figure A.17 vs. Figure 3). Expected IQM scores with varying number of runs. The expected score for N runs is computed by repeatedly subsampling N runs with replacement out of 100 runs for 100,000 times. Compared to expected median score differences (Figure 3), the difference in expected IQM scores with 3 runs and 100 runs is typically an order of magnitude smaller. For example, the expected median differences for SPR is 0.05 points while expected IQM differences are only 0.006 points.", "publication_ref": ["b13", "b12", "b41", "b41", "b105"], "figure_ref": ["fig_2", "fig_2"], "table_ref": ["tab_0"]}, {"heading": "A.3 Related work on rigorous evaluation in deep RL", "text": "While prior work [41,46,68] highlights various reproducibility issues in policy-gradient methods, this paper focuses specifically on the reliability of evaluation procedures on RL benchmarks and provides an extensive analysis on common deep RL algorithms on widely-used benchmarks.\nFor more rigorous performance comparisons on a single RL task, Colas et al. [21], Henderson et al. [41] provide guidelines for statistical significance testing while Colas et al. [20] focuses on determining the minimum number of runs needed for such comparisons to be statistically significant.\nInstead, this paper focuses on reliable comparisons on a suite of tasks and mainly recommends reporting stratified bootstrap CIs due to the dichotomous nature and wide misinterpretation of statistical significance tests (see Remark in Section 2). Colas et al. [20,21], Henderson et al. [41] also discuss bootstrap CIs but for reporting single task mean scores -however, 3-5 runs is a small sample size for bootstrapping: on Atari 100k, for achieving true coverage close to 95%, such CIs require at least 20-30 runs per task ( Chan et al. [16] propose metrics to measure the reliability of RL algorithms in terms of their stability during training and their variability and risk in returns across multiple episodes. While this paper focuses on reliability of evaluation itself, performance profiles showing the tail distribution of episodic returns, applicable for even a single task with multiple runs, can be useful for measuring reliability of an algorithm's performance.\nJordan et al. [49] propose a game-theoretic evaluation procedure for \"complete\" algorithms that do not require any hyperparameter tuning and recommend evaluating between 1,000 to 10,000 runs per task to detect statistically significant results. Instead, this work focuses on reliably evaluating performance obtained after the hyperparameter tuning phase, even with just a handful of runs. That said, run-score distributions based on runs with different hyperparameter configurations might reveal sensitivity to hyperparameter tuning.\nAn alternative to score distributions, proposed by Recht [83], is to replace scores in a performance profile [26] by the probability that average task scores of a given method outperforms the best method (among a given set of methods), computed using the Welsh's t-test [113]. However, this profile is (1) also a biased estimate, (2) less robust to outlier runs, ( 3) is insensitive to the size of performance differences, i.e., two methods that are uniformly 1% and 100% worse than the best method are assigned the same probability, ( 4) is only sensible when task score distributions are Gaussian, as required by Welsh's t-test, and finally, (5) the ranking of methods depends on the specific set of methods being compared in such profiles.", "publication_ref": ["b40", "b45", "b67", "b20", "b40", "b19", "b19", "b20", "b40", "b15", "b48", "b82", "b25", "b112"], "figure_ref": [], "table_ref": []}, {"heading": "A.4 Non-standard Evaluation Protocols Involving Maximum", "text": "Even when adequate number of runs are used, the use of non-standard evaluation protocols can result in misleading comparisons. Such protocols commonly involve the insertion of a maximum operation inside evaluation, across or within runs, leading to a positive bias in reported scores compared to the standard approach without the maximum.\nOne seemingly reasonable but faulty argument [10] for maximum across runs is that in a real-world application, one might wish to run an stochastic algorithm A for N runs and then select the best result. However, in this case, we are not discussing A but another algorithm A N , which evaluates N We show CIs for median, mean and IQM scores, aggregated using scores across 26 games, for DER. The true coverage % is computed by sampling 10,000 sets of K runs without replacement from 200 runs and checking the fraction of 95% CIs that contains the true estimate approximation based on 200 runs. Please note that coverage above 95%, even with 50+ runs, is likely due to approximation error in the true estimate using finite runs. random runs of A. If we are interested in A N , taking maximum over N runs only considers a single run of A N . Since A N is itself stochastic, proper experimental methodology requires multiple runs of A N . Furthermore, because learning curves are not in general monotonic, results produced under the maximum-during-training protocol are in general incomparable with end-performance reported results. In addition, such protocols introduces an additional source of positive statistical bias, since the maximum of a set of random variables is a biased estimate of their true maximum.\nOn Atari 100k, CURL [56] and SUNRISE [59] used non-standard evaluation protocols. CURL reported the maximum performance over 10 different evaluations during training. As a result, natural variability in both evaluation itself and in the agent's performance during training contribute to overestimation. Applying the same procedure to CURL's baseline DER leads to scores far above those reported for CURL (Figure 5, \"DER (CURL's protocol)\"). In the case of SUNRISE, the maximum was taken over eight hyperparameter configurations separately for each game, with three runs each. We simulate this procedure for DER (also SUNRISE's baseline), using a dummy hyperparameter. We find that a lot of SUNRISE's improvement over DER can be explained by this evaluation scheme (Figure 5, \"DER (SUNRISE's protocol)\").", "publication_ref": ["b9", "b55", "b58"], "figure_ref": [], "table_ref": []}, {"heading": "A.5 Bootstrap Confidence Intervals", "text": "Bootstrap CIs for a real parameter \u03b8 are based on re-sampling with replacement from a fixed set of K samples to create a bootstrap sample of size K and compute the bootstrap parameter \u03b8 * and repeating this process a numerous to create the bootstrap distribution over \u03b8 * . In this paper, we evaluate the following non-parametric methods for constructing CIs for \u03b8 using this bootstrap distribution:\n1. Basic bootstrap, also known as the reverse percentile interval, uses the empirical quantiles from the bootstrap distribution of the parameter \u03b4 =\u03b8 \u2212 \u03b8 for defining the \u03b1 \u00d7 100% CI:\n(2 \u03b8 \u2212 \u03b8 * (\u03b1/2) , 2 \u03b8 \u2212 \u03b8 * (1\u2212\u03b1/2) )\n, where \u03b8 * (1\u2212\u03b1/2) denotes the 1 \u2212 \u03b1/2 percentile of the bootstrapped parameters \u03b8 * and \u03b8 is the empirical estimate of the parameter based on finite samples. 2. Percentile bootstrap. The percentile bootstrap proceeds in a similar way to the basic bootstrap, using percentiles of the bootstrap distribution, but with a different formula: (\u03b8 * (1\u2212\u03b1/2) , \u03b8 * (\u03b1/2) ) for defining the \u03b1 \u00d7 100% CI. 3. Bias-corrected (bc) bootstrap -adjusts for bias in the bootstrap distribution. 4. Bias-corrected and accelerated (bca) bootstrap, by Efron [29], adjusts for both bias and skewness in the bootstrap distribution. This approach is typically considered to be more accurate and has better asymptotic properties. However, we find that it is not as effective as percentile methods in the few-run deep RL regime.\nMore technical details about bootstrap CIs can be found in [40]. We find that bootstrap CIs for mean scores per game (computed using N random samples) require many more runs than aggregate scores (computed using M N random samples) for achieving true coverage close to the nominal coverage of 95% (c.f. Number of bootstrap re-samples. Unless specified otherwise, for computing uncertainty estimates using stratified bootstrap, we use 50,000 samples for aggregate metrics and 2000 samples for pointwise confidence bands and average probability of improvement. Using larger number of samples then the above specified values might result in more accurate uncertainty estimates but would be slower to compute.  [18] based on results in the easy mode setting [80]. Shaded regions indicate 95% CIs estimated using the percentile bootstrap with stratified sampling. We compare PPO [92], MixReg [111], UCB-DrAC [81], PLR [48], PPG [19] and IDAAC [80]. We recommend using min-max normalized scores as opposed to PPO normalized scores.   In the plots above, the x-axis is scaled such that spacing between any two \u03c4 values, \u03c41 and \u03c42, is proportional to the fraction of runs averaged across algorithms between those two \u03c4 values. This scaling shows the regions of the score distribution where most of the runs lie as opposed to comparing tail ends of the distribution. However, this scaling implies sub-linear utility of achieving higher scores, which may not be accurate as the utility depends on the difficulty of obtaining higher scores -it is much higher to obtain higher scores on hard exploration games. Furthermore, we cannot visually inspect mean/IQM scores based on the area under the curve due to the non-linear scaling.\nto zero) scores for DM Control. We do not use record normalized scores for ALE (Figure A.27) in the main text as ALE results are reported by evaluating agents for 30 minutes of game-play as opposed to record scores which were obtained using game play spanning numerous hours (e.g., Toromanoff et al. [105] recommend evaluating agents for 100 hours). Furthermore, we recommend   shows an alternative for visualizing score distributions where we simply scale the x-axis depending on the fraction of runs in a given region. This scaling more clearly shows the differences in algorithms by focusing on the regions where most of the runs lie 13 .", "publication_ref": ["b28", "b39", "b17", "b79", "b91", "b110", "b80", "b47", "b18", "b79", "b104", "b12"], "figure_ref": [], "table_ref": []}, {"heading": "A.7 Aggregate metrics: Additional visualizations and details", "text": "Alternative aggregate metrics. Different aggregate metrics emphasize different characteristics and no single metric would be sufficient for evaluating progress. While score distributions provide a full picture of evaluation results, we provide suggestions for alternative aggregate metrics to highlight other important aspects of performance across different tasks and runs.\n\u2022 Difficulty Progress: One might be more interested in evaluating progress on the hardest tasks on a benchmark [3]. In addition to optimality gap which emphasizes all tasks below a certain performance level, a possible aggregate measure to consider is the mean scores of the bottom 25% of the runs (Figure A.25, left), which we call Difficulty Progress (DP-25).\n\u2022 Superhuman Probability: We also recommend reporting probability of being superhuman, P (X > 1), given by the number of runs above average human performance (Figure A.25, right) instead of number of games above average human performance [42,93], a commonly used metric on ALE. Choice of \u03b3 for optimality gap. When using min-max normalized scores or human-normalized scores, setting a score threshold of \u03b3 = 1 is sensible as it considers performance on games below maximum performance or human performance respectively. If there is no preference for a specific threshold, an alternative is to consider a curve of optimality gap as the threshold is varied, as shown in Figure A.26, which shows how far from optimality an algorithm is given any threshold -a small value of optimality gaps for all achievable score thresholds is desirable.\nProbability of improvement. To compute the probability of improvement for a task m for algorithms X and Y with N and K runs respectively, we use the Mann-Whitney U-statistic [71], that is, Please note that if the probability of improvement is higher than 0.5 and the CIs do not contain 0.5, then the results are statistically significant. Furthermore, if the upper CI is higher than a threshold of 0.75, then the results are said to be statistically meaningful as per the Neyman-Pearson statistical testing criterion by Bouthillier et al. [12]. We show the average probability of improvement metrics  The i th column in the rank distribution plots show the probability that a given method is assigned rank i, when compared to other methods. These distributions are estimated using stratified bootstrap with 200,000 repetitions. We observe that no single algorithm consistently ranks above other algorithms on all tasks, making comparisons difficult without aggregating results across tasks.\nP (X m > Y m ) = 1 N K N i=1", "publication_ref": ["b2", "b41", "b92", "b70", "b11"], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgments", "text": "We thank Xavier Bouthillier, Dumitru Erhan, Marlos C. Machado, David Ha, Fabio Viola, Fernando Diaz, Stephanie Chan, Jacob Buckman, Danijar Hafner and anonymous NeurIPS' reviewers for providing valuable feedback for an earlier draft of this work. We also acknowledge Matteo Hessel, David Silver, Tom Schaul, Csaba Szepesv\u00e1ri, Hado van Hasselt, Rosanne Liu, Simon Kornblith, Aviral Kumar, George Tucker, Kevin Murphy, Ankit Anand, Aravind Srinivas, Matthew Botvinick, Clare Lyle, Kimin Lee, Misha Laskin, Ankesh Anand, Joelle Pineau and Braham Synder for helpful discussions. We also thank all the authors who provided individual runs for their corresponding publications. We are also grateful for general support from Google Research teams in Montr\u00e9al and elsewhere.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": " ", "text": "[92]\n, MixReg [111], UCB-DrAC [81], PLR [48], PPG [19] and IDAAC [80]. All results are based on 10 runs per game.", "publication_ref": ["b91", "b110", "b80", "b47", "b18", "b79"], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "An optimistic perspective on offline reinforcement learning", "journal": "", "year": "2020", "authors": "Rishabh Agarwal; Dale Schuurmans; Mohammad Norouzi"}, {"ref_id": "b1", "title": "Scientists rise up against statistical significance", "journal": "Nature", "year": "2019", "authors": "Valentin Amrhein; Sander Greenland; Blake Mcshane"}, {"ref_id": "b2", "title": "Agent57: Outperforming the atari human benchmark", "journal": "PMLR", "year": "2020", "authors": "Bilal Adri\u00e0 Puigdom\u00e8nech Badia; Steven Piot; Pablo Kapturowski; Alex Sprechmann; Zhaohan Vitvitskyi; Charles Daniel Guo;  Blundell"}, {"ref_id": "b3", "title": "Monya Baker. 1,500 scientists lift the lid on reproducibility", "journal": "Nature News", "year": "2016", "authors": ""}, {"ref_id": "b4", "title": "The arcade learning environment: An evaluation platform for general agents", "journal": "Journal of Artificial Intelligence Research", "year": "2013", "authors": "Yavar Marc G Bellemare; Joel Naddaf; Michael Veness;  Bowling"}, {"ref_id": "b5", "title": "A distributional perspective on reinforcement learning", "journal": "PMLR", "year": "2017", "authors": "Will Marc G Bellemare; R\u00e9mi Dabney;  Munos"}, {"ref_id": "b6", "title": "Autonomous navigation of stratospheric balloons using reinforcement learning", "journal": "Nature", "year": "2020", "authors": "Salvatore Marc G Bellemare; Pablo Samuel Candido; Jun Castro;  Gong; C Marlos; Subhodeep Machado;  Moitra; S Sameera; Ziyu Ponda;  Wang"}, {"ref_id": "b7", "title": "Dota 2 with large scale deep reinforcement learning", "journal": "", "year": "2019", "authors": "Christopher Berner; Greg Brockman; Brooke Chan; Vicki Cheung; Przemys\u0142aw D\u0119biak; Christy Dennison; David Farhi; Quirin Fischer; Shariq Hashme; Chris Hesse"}, {"ref_id": "b8", "title": "Resampling fewer than n observations: gains, losses, and remedies for losses", "journal": "Springer", "year": "2012", "authors": "J Peter; Friedrich Bickel; Willem R G\u00f6tze;  Van Zwet"}, {"ref_id": "b9", "title": "How to assess and report the performance of a stochastic algorithm on a benchmark problem: mean or best result on a number of runs? Optimization letters", "journal": "", "year": "2007", "authors": "Mauro Birattari; Marco Dorigo"}, {"ref_id": "b10", "title": "Unreproducible research is reproducible", "journal": "", "year": "2019", "authors": "Xavier Bouthillier; C\u00e9sar Laurent; Pascal Vincent"}, {"ref_id": "b11", "title": "Accounting for variance in machine learning benchmarks", "journal": "", "year": "", "authors": "Xavier Bouthillier; Pierre Delaunay; Mirko Bronzi; Assya Trofimov; Brennan Nichyporuk; Justin Szeto; Nazanin Mohammadi Sepahvand; Edward Raff; Kanika Madan; Vikram Voleti"}, {"ref_id": "b12", "title": "JAX: composable transformations of Python+NumPy programs", "journal": "", "year": "2018", "authors": "James Bradbury; Roy Frostig; Peter Hawkins; Matthew James Johnson; Chris Leary; Dougal Maclaurin; George Necula; Adam Paszke; Jake Vanderplas; Skye Wanderman-Milne; Qiao Zhang"}, {"ref_id": "b13", "title": "Dopamine: A research framework for deep reinforcement learning", "journal": "", "year": "2018", "authors": "Pablo Samuel Castro; Subhodeep Moitra; Carles Gelada; Saurabh Kumar; Marc G Bellemare"}, {"ref_id": "b14", "title": "Revisiting rainbow: Promoting more insightful and inclusive deep reinforcement learning research", "journal": "", "year": "2021", "authors": "Johan Samir; Obando Ceron; Pablo Samuel Castro"}, {"ref_id": "b15", "title": "Measuring the reliability of reinforcement learning algorithms", "journal": "", "year": "2020", "authors": "C Y Stephanie; Samuel Chan; Anoop Fishman; John Korattikara; Sergio Canny;  Guadarrama"}, {"ref_id": "b16", "title": "Let's play again: Variability of deep reinforcement learning agents in atari environments", "journal": "", "year": "2019", "authors": "Kaleigh Clary; Emma Tosch; John Foley; David Jensen"}, {"ref_id": "b17", "title": "Leveraging procedural generation to benchmark reinforcement learning", "journal": "PMLR", "year": "2020", "authors": "Karl Cobbe; Chris Hesse; Jacob Hilton; John Schulman"}, {"ref_id": "b18", "title": "", "journal": "", "year": "2020", "authors": "Karl Cobbe; Jacob Hilton; Oleg Klimov; John Schulman"}, {"ref_id": "b19", "title": "How many random seeds? statistical power analysis in deep reinforcement learning experiments", "journal": "", "year": "2018", "authors": "C\u00e9dric Colas; Olivier Sigaud; Pierre-Yves Oudeyer"}, {"ref_id": "b20", "title": "A hitchhiker's guide to statistical comparisons of reinforcement learning algorithms", "journal": "", "year": "2019", "authors": "C\u00e9dric Colas; Olivier Sigaud; Pierre-Yves Oudeyer"}, {"ref_id": "b21", "title": "Implicit quantile networks for distributional reinforcement learning", "journal": "PMLR", "year": "2018", "authors": "Will Dabney; Georg Ostrovski; David Silver; R\u00e9mi Munos"}, {"ref_id": "b22", "title": "Distributional reinforcement learning with quantile regression", "journal": "", "year": "2018", "authors": "Will Dabney; Mark Rowland; G Marc; R\u00e9mi Bellemare;  Munos"}, {"ref_id": "b23", "title": "The benchmark lottery", "journal": "", "year": "2021", "authors": "Mostafa Dehghani; Yi Tay; A Alexey; Zhe Gritsenko; Neil Zhao; Fernando Houlsby; Donald Diaz; Oriol Metzler;  Vinyals"}, {"ref_id": "b24", "title": "Finetuning pretrained language models: Weight initializations, data orders, and early stopping", "journal": "", "year": "2020", "authors": "Jesse Dodge; Gabriel Ilharco; Roy Schwartz; Ali Farhadi; Hannaneh Hajishirzi; Noah Smith"}, {"ref_id": "b25", "title": "Benchmarking optimization software with performance profiles", "journal": "", "year": "2002", "authors": "D Elizabeth; Jorge J Dolan;  Mor\u00e9"}, {"ref_id": "b26", "title": "Deep dominance-how to properly compare deep neural models", "journal": "", "year": "2019", "authors": "Rotem Dror; Segev Shlomov; Roi Reichart"}, {"ref_id": "b27", "title": "Go-explore: a new approach for hard-exploration problems", "journal": "", "year": "2019", "authors": "Adrien Ecoffet; Joost Huizinga; Joel Lehman; O Kenneth; Jeff Stanley;  Clune"}, {"ref_id": "b28", "title": "Bootstrap methods: another look at the jackknife", "journal": "The Annals of Statistics", "year": "1979", "authors": "Bradley Efron"}, {"ref_id": "b29", "title": "Better bootstrap confidence intervals", "journal": "Journal of the American statistical Association", "year": "1987", "authors": "Bradley Efron"}, {"ref_id": "b30", "title": "Tree-based batch mode reinforcement learning", "journal": "Journal of Machine Learning Research", "year": "2005", "authors": "Damien Ernst; Pierre Geurts; Louis Wehenkel"}, {"ref_id": "b31", "title": "Impala: Scalable distributed deep-rl with importance weighted actor-learner architectures", "journal": "PMLR", "year": "2018", "authors": "Lasse Espeholt; Hubert Soyer; Remi Munos; Karen Simonyan; Vlad Mnih; Tom Ward; Yotam Doron; Vlad Firoiu; Tim Harley; Iain Dunning"}, {"ref_id": "b32", "title": "Statistical rituals: The replication delusion and how we got there", "journal": "Advances in Methods and Practices in Psychological Science", "year": "2018", "authors": "Gerd Gigerenzer"}, {"ref_id": "b33", "title": "What does research reproducibility mean?", "journal": "Science translational medicine", "year": "2016", "authors": "Daniele Steven N Goodman; John Pa Fanelli;  Ioannidis"}, {"ref_id": "b34", "title": "Statistical tests, p values, confidence intervals, and power: a guide to misinterpretations", "journal": "European journal of epidemiology", "year": "2016", "authors": "Sander Greenland; J Stephen;  Senn; J Kenneth; John B Rothman; Charles Carlin;  Poole; N Steven; Douglas G Goodman;  Altman"}, {"ref_id": "b35", "title": "Soft actor-critic: Off-policy maximum entropy deep reinforcement learning with a stochastic actor", "journal": "PMLR", "year": "2018", "authors": "Tuomas Haarnoja; Aurick Zhou; Pieter Abbeel; Sergey Levine"}, {"ref_id": "b36", "title": "Dream to control: Learning behaviors by latent imagination", "journal": "", "year": "2019", "authors": "Danijar Hafner; Timothy Lillicrap; Jimmy Ba; Mohammad Norouzi"}, {"ref_id": "b37", "title": "Mastering atari with discrete world models", "journal": "", "year": "2020", "authors": "Danijar Hafner; Timothy Lillicrap; Mohammad Norouzi; Jimmy Ba"}, {"ref_id": "b38", "title": "Fast task inference with variational intrinsic successor features", "journal": "", "year": "2020", "authors": "Steven Hansen; Will Dabney; Andre Barreto; David Warde-Farley; Tom Van De Wiele; Volodymyr Mnih"}, {"ref_id": "b39", "title": "Bootstrap Confidence Intervals", "journal": "", "year": "2021-01", "authors": "E Nathaniel;  Helwig"}, {"ref_id": "b40", "title": "Deep reinforcement learning that matters", "journal": "", "year": "2018", "authors": "Peter Henderson; Riashat Islam; Philip Bachman; Joelle Pineau; Doina Precup; David Meger"}, {"ref_id": "b41", "title": "Rainbow: Combining improvements in deep reinforcement learning", "journal": "", "year": "2018", "authors": "Matteo Hessel; Joseph Modayil; Hado Van Hasselt; Tom Schaul; Georg Ostrovski; Will Dabney; Dan Horgan; Bilal Piot; Mohammad Azar; David Silver"}, {"ref_id": "b42", "title": "Muesli: Combining improvements in policy optimization", "journal": "", "year": "2021", "authors": "Matteo Hessel; Ivo Danihelka; Fabio Viola; Arthur Guez; Simon Schmitt; Laurent Sifre; Theophane Weber; David Silver; Hado Van Hasselt"}, {"ref_id": "b43", "title": "Why most published research findings are false", "journal": "PLoS medicine", "year": "2005", "authors": "P A John;  Ioannidis"}, {"ref_id": "b44", "title": "Deep reinforcement learning doesn't work yet", "journal": "", "year": "2018", "authors": "Alex Irpan"}, {"ref_id": "b45", "title": "Reproducibility of benchmarked deep reinforcement learning tasks for continuous control", "journal": "", "year": "2017", "authors": "Riashat Islam; Peter Henderson; Maziar Gomrokchi; Doina Precup"}, {"ref_id": "b46", "title": "Reinforcement learning with unsupervised auxiliary tasks", "journal": "", "year": "2016", "authors": "Max Jaderberg; Volodymyr Mnih; Wojciech Marian Czarnecki; Tom Schaul; Joel Z Leibo; David Silver; Koray Kavukcuoglu"}, {"ref_id": "b47", "title": "Prioritized level replay. International Conference on Machine Learning", "journal": "", "year": "2021", "authors": "Minqi Jiang; Ed Grefenstette; Tim Rockt\u00e4schel"}, {"ref_id": "b48", "title": "Evaluating the performance of reinforcement learning algorithms", "journal": "PMLR", "year": "2020", "authors": "Scott Jordan; Yash Chandak; Daniel Cohen; Mengxue Zhang; Philip Thomas"}, {"ref_id": "b49", "title": "Model-based reinforcement learning for atari", "journal": "", "year": "2019", "authors": "Lukasz Kaiser; Mohammad Babaeizadeh; Piotr Milos; Blazej Osinski; H Roy; Konrad Campbell; Dumitru Czechowski; Chelsea Erhan; Piotr Finn; Sergey Kozakowski;  Levine"}, {"ref_id": "b50", "title": "Do recent advancements in model-based deep reinforcement learning really improve data efficiency?", "journal": "", "year": "2020", "authors": "Kacper Kielak"}, {"ref_id": "b51", "title": "Catalyst. rl: a distributed framework for reproducible rl research", "journal": "", "year": "2019", "authors": "Sergey Kolesnikov; Oleksii Hrinchuk"}, {"ref_id": "b52", "title": "Image augmentation is all you need: Regularizing deep reinforcement learning from pixels", "journal": "", "year": "2021", "authors": "* Ilya Kostrikov; Denis Yarats; * ; Rob Fergus"}, {"ref_id": "b53", "title": "Afroz Mohiuddin, and Katarzyna Ka\u0144ska. Qvalue weighted regression: Reinforcement learning with limited data", "journal": "", "year": "2021", "authors": "Piotr Kozakowski; Lukasz Kaiser; Henryk Michalewski"}, {"ref_id": "b54", "title": "Unsupervised learning of object keypoints for perception and control", "journal": "NeurIPS", "year": "2019", "authors": "D Tejas; Ankush Kulkarni; Catalin Gupta; Sebastian Ionescu; Malcolm Borgeaud; Andrew Reynolds; Volodymyr Zisserman;  Mnih"}, {"ref_id": "b55", "title": "Curl: Contrastive unsupervised representations for reinforcement learning", "journal": "", "year": "2020", "authors": "Michael Laskin; Aravind Srinivas; Pieter Abbeel"}, {"ref_id": "b56", "title": "Reinforcement learning with augmented data", "journal": "", "year": "2020", "authors": "Misha Laskin; Kimin Lee; Adam Stooke; Lerrel Pinto; Pieter Abbeel; Aravind Srinivas"}, {"ref_id": "b57", "title": "Stochastic latent actor-critic: Deep reinforcement learning with a latent variable model", "journal": "Advances in Neural Information Processing Systems", "year": "2020", "authors": "Alex Lee; Anusha Nagabandi; Pieter Abbeel; Sergey Levine"}, {"ref_id": "b58", "title": "Sunrise: A simple unified framework for ensemble learning in deep reinforcement learning", "journal": "", "year": "2021", "authors": "Kimin Lee; Michael Laskin; Aravind Srinivas; Pieter Abbeel"}, {"ref_id": "b59", "title": "Predictive information accelerates learning in rl", "journal": "", "year": "2020", "authors": "Kuang-Huei Lee; Ian Fischer; Anthony Liu; Yijie Guo; Honglak Lee; John Canny; Sergio Guadarrama"}, {"ref_id": "b60", "title": "Stochastic dominance and expected utility: Survey and analysis", "journal": "Management science", "year": "1992", "authors": "Haim Levy"}, {"ref_id": "b61", "title": "Continuous control with deep reinforcement learning", "journal": "", "year": "2015", "authors": "P Timothy; Jonathan J Lillicrap; Alexander Hunt; Nicolas Pritzel; Tom Heess; Yuval Erez; David Tassa; Daan Silver;  Wierstra"}, {"ref_id": "b62", "title": "Significant improvements over the state of the art? a case study of the ms marco document ranking leaderboard", "journal": "", "year": "2021", "authors": "Jimmy Lin; Daniel Campos; Nick Craswell; Mitra Bhaskar; Emine Yilmaz"}, {"ref_id": "b63", "title": "Return-based contrastive representation learning for reinforcement learning", "journal": "", "year": "2021", "authors": "Guoqing Liu; Chuheng Zhang; Li Zhao; Tao Qin; Jinhua Zhu; Li Jian; Nenghai Yu; Tie-Yan Liu"}, {"ref_id": "b64", "title": "Behavior from the void: Unsupervised active pre-training", "journal": "", "year": "2021", "authors": "Hao Liu; Pieter Abbeel"}, {"ref_id": "b65", "title": "Aps: Active pretraining with successor features", "journal": "", "year": "2021", "authors": "Hao Liu; Pieter Abbeel"}, {"ref_id": "b66", "title": "Are gans created equal? a large-scale study", "journal": "", "year": "2017", "authors": "Mario Lucic; Karol Kurach; Marcin Michalski; Sylvain Gelly; Olivier Bousquet"}, {"ref_id": "b67", "title": "A survey on reproducibility by evaluating deep reinforcement learning algorithms on real-world robots", "journal": "", "year": "2020", "authors": "A Nicolai; Laura Lynnerup; Rasmus Nolling; John Hasle;  Hallam"}, {"ref_id": "b68", "title": "Revisiting the arcade learning environment: Evaluation protocols and open problems for general agents", "journal": "Journal of Artificial Intelligence Research", "year": "2018", "authors": "C Marlos;  Machado; G Marc; Erik Bellemare; Joel Talvitie; Matthew Veness; Michael Hausknecht;  Bowling"}, {"ref_id": "b69", "title": "Simple random search provides a competitive approach to reinforcement learning", "journal": "", "year": "2018", "authors": "Horia Mania; Aurelia Guy; Benjamin Recht"}, {"ref_id": "b70", "title": "On a test of whether one of two random variables is stochastically larger than the other. The annals of mathematical statistics", "journal": "", "year": "1947", "authors": "B Henry; Donald R Mann;  Whitney"}, {"ref_id": "b71", "title": "Ensemble and auxiliary tasks for data-efficient deep reinforcement learning", "journal": "", "year": "2021", "authors": "Wee Muhammad Rizki Maulana;  Sun Lee"}, {"ref_id": "b72", "title": "Abandon statistical significance", "journal": "The American Statistician", "year": "2019", "authors": "B Blakeley; David Mcshane; Andrew Gal; Christian Gelman; Jennifer L Robert;  Tackett"}, {"ref_id": "b73", "title": "On the state of the art of evaluation in neural language models", "journal": "", "year": "2018", "authors": "G\u00e1bor Melis; Chris Dyer; Phil Blunsom"}, {"ref_id": "b74", "title": "Human-level control through deep reinforcement learning", "journal": "Nature", "year": "2015", "authors": "Volodymyr Mnih; Koray Kavukcuoglu; David Silver; Andrei A Rusu; Joel Veness; G Marc; Alex Bellemare; Martin Graves; Andreas K Riedmiller; Georg Fidjeland;  Ostrovski"}, {"ref_id": "b75", "title": "Asynchronous methods for deep reinforcement learning", "journal": "PMLR", "year": "2016", "authors": "Volodymyr Mnih; Adria Puigdomenech Badia; Mehdi Mirza; Alex Graves; Timothy Lillicrap; Tim Harley; David Silver; Koray Kavukcuoglu"}, {"ref_id": "b76", "title": "Deterministic implementations for reproducibility in deep reinforcement learning", "journal": "", "year": "2018", "authors": "Prabhat Nagarajan; Garrett Warnell; Peter Stone"}, {"ref_id": "b77", "title": "Editors' introduction to the special section on replicability in psychological science: A crisis of confidence?", "journal": "Perspectives on psychological science", "year": "2012", "authors": "Harold Pashler; Eric-Jan Wagenmakers"}, {"ref_id": "b78", "title": "Improving reproducibility in machine learning research (a report from the neurips 2019 reproducibility program)", "journal": "", "year": "2020", "authors": "Joelle Pineau; Philippe Vincent-Lamarre; Koustuv Sinha; Vincent Larivi\u00e8re; Alina Beygelzimer;  Florence D'alch\u00e9; Emily Buc; Hugo Fox;  Larochelle"}, {"ref_id": "b79", "title": "Decoupling value and policy for generalization in reinforcement learning", "journal": "", "year": "2021", "authors": "Roberta Raileanu; Rob Fergus"}, {"ref_id": "b80", "title": "Automatic data augmentation for generalization in deep reinforcement learning", "journal": "", "year": "2020", "authors": "Roberta Raileanu; Max Goldstein; Denis Yarats; Ilya Kostrikov; Rob Fergus"}, {"ref_id": "b81", "title": "Synthetic returns for long-term credit assignment", "journal": "", "year": "2021", "authors": "David Raposo; Sam Ritter; Adam Santoro; Greg Wayne; Theophane Weber; Matt Botvinick; Francis Hado Van Hasselt;  Song"}, {"ref_id": "b82", "title": "Benchmarking Machine Learning with Performance Profiles", "journal": "", "year": "2018", "authors": "Ben Recht"}, {"ref_id": "b83", "title": "Reporting score distributions makes a difference: Performance study of lstm-networks for sequence tagging", "journal": "", "year": "2017", "authors": "Nils Reimers; Iryna Gurevych"}, {"ref_id": "b84", "title": "Cognitive psychology for deep neural networks: A shape bias case study", "journal": "", "year": "2017", "authors": "Samuel Ritter; G T David; Adam Barrett; Matt M Santoro;  Botvinick"}, {"ref_id": "b85", "title": "Smaller world models for reinforcement learning", "journal": "", "year": "2020", "authors": "Jan Robine; Tobias Uelwer; Stefan Harmeling"}, {"ref_id": "b86", "title": "In praise of confidence intervals", "journal": "", "year": "2020", "authors": "David Romer"}, {"ref_id": "b87", "title": "Evolution strategies as a scalable alternative to reinforcement learning", "journal": "", "year": "2017", "authors": "Tim Salimans; Jonathan Ho; Xi Chen; Szymon Sidor; Ilya Sutskever"}, {"ref_id": "b88", "title": "Seerl: Sample efficient ensemble reinforcement learning", "journal": "", "year": "2021", "authors": "Rohan Saphal; Dheevatsa Balaraman Ravindran; Sasikant Mudigere; Bharat Avancha;  Kaul"}, {"ref_id": "b89", "title": "Return-based scaling: Yet another normalisation trick for deep rl", "journal": "", "year": "2021", "authors": "Tom Schaul; Georg Ostrovski; Iurii Kemaev; Diana Borsa"}, {"ref_id": "b90", "title": "Mastering atari, go, chess and shogi by planning with a learned model", "journal": "Nature", "year": "2020", "authors": "Julian Schrittwieser; Ioannis Antonoglou; Thomas Hubert; Karen Simonyan; Laurent Sifre; Simon Schmitt; Arthur Guez; Edward Lockhart; Demis Hassabis; Thore Graepel"}, {"ref_id": "b91", "title": "Proximal policy optimization algorithms", "journal": "", "year": "2017", "authors": "John Schulman; Filip Wolski; Prafulla Dhariwal; Alec Radford; Oleg Klimov"}, {"ref_id": "b92", "title": "Data-efficient reinforcement learning with self-predictive representations", "journal": "", "year": "2021", "authors": "Max Schwarzer; Ankesh Anand; Rishab Goel; Devon Hjelm; Aaron Courville; Philip Bachman"}, {"ref_id": "b93", "title": "The multiberts: Bert reproductions for robustness analysis", "journal": "", "year": "2021", "authors": "Thibault Sellam; Steve Yadlowsky; Jason Wei; Naomi Saphra; Alexander D' Amour; Tal Linzen; Jasmijn Bastings; Iulia Turc; Jacob Eisenstein; Dipanjan Das"}, {"ref_id": "b94", "title": "State entropy maximization with random encoders for efficient exploration", "journal": "", "year": "2021", "authors": "Younggyo Seo; Lili Chen; Jinwoo Shin; Honglak Lee; Pieter Abbeel; Kimin Lee"}, {"ref_id": "b95", "title": "Mastering the game of go with deep neural networks and tree search", "journal": "nature", "year": "2016", "authors": "David Silver; Aja Huang; Chris J Maddison; Arthur Guez; Laurent Sifre; George Van Den; Julian Driessche; Ioannis Schrittwieser; Veda Antonoglou; Marc Panneershelvam;  Lanctot"}, {"ref_id": "b96", "title": "D2rl: Deep dense architectures in reinforcement learning", "journal": "", "year": "2020", "authors": "Samarth Sinha; Homanga Bharadhwaj; Aravind Srinivas; Animesh Garg"}, {"ref_id": "b97", "title": "Contrastive unsupervised representations for reinforcement learning", "journal": "", "year": "2020", "authors": "Aravind Srinivas; Michael Laskin; Pieter Abbeel"}, {"ref_id": "b98", "title": "Learning to predict by the methods of temporal differences", "journal": "Machine learning", "year": "1988", "authors": "S Richard;  Sutton"}, {"ref_id": "b99", "title": "Generalization in reinforcement learning: Successful examples using sparse coarse coding", "journal": "", "year": "1996", "authors": "S Richard;  Sutton"}, {"ref_id": "b100", "title": "Reinforcement learning: An introduction", "journal": "MIT Press", "year": "2018", "authors": "Richard S Sutton; Andrew G Barto"}, {"ref_id": "b101", "title": "Between mdps and semi-mdps: A framework for temporal abstraction in reinforcement learning", "journal": "Artificial intelligence", "year": "1999", "authors": "Doina Richard S Sutton; Satinder Precup;  Singh"}, {"ref_id": "b102", "title": "Learning tetris using the noisy cross-entropy method. Neural computation", "journal": "", "year": "2006", "authors": "Istv\u00e1n Szita; Andr\u00e1s L\u00f6rincz"}, {"ref_id": "b103", "title": "", "journal": "", "year": "2018", "authors": "Yuval Tassa; Yotam Doron; Alistair Muldal; Tom Erez; Yazhe Li; Diego De Las; David Casas; Abbas Budden; Josh Abdolmaleki; Andrew Merel;  Lefrancq"}, {"ref_id": "b104", "title": "Is deep reinforcement learning really superhuman on atari? leveling the playing field", "journal": "", "year": "2019", "authors": "Marin Toromanoff; Emilie Wirbel; Fabien Moutarde"}, {"ref_id": "b105", "title": "A survey of sampling from contaminated distributions. Contributions to probability and statistics", "journal": "", "year": "1960", "authors": "W John;  Tukey"}, {"ref_id": "b106", "title": "When to use parametric models in reinforcement learning?", "journal": "NeurIPS", "year": "2019", "authors": "Matteo Hado Van Hasselt; John Hessel;  Aslanides"}, {"ref_id": "b107", "title": "How i failed machine learning in medical imagingshortcomings and recommendations", "journal": "", "year": "2021", "authors": "Ga\u00ebl Varoquaux; Veronika Cheplygina"}, {"ref_id": "b108", "title": "Munchausen reinforcement learning", "journal": "", "year": "2020", "authors": "Nino Vieillard; Olivier Pietquin; Matthieu Geist"}, {"ref_id": "b109", "title": "Grandmaster level in starcraft ii using multi-agent reinforcement learning", "journal": "Nature", "year": "2019", "authors": "Oriol Vinyals; Igor Babuschkin; Wojciech M Czarnecki; Micha\u00ebl Mathieu; Andrew Dudzik; Junyoung Chung; H David; Richard Choi; Timo Powell; Petko Ewalds;  Georgiev"}, {"ref_id": "b110", "title": "Improving generalization in reinforcement learning with mixture regularization", "journal": "", "year": "2020", "authors": "Kaixin Wang; Bingyi Kang; Jie Shao; Jiashi Feng"}, {"ref_id": "b111", "title": "Moving to a world beyond", "journal": "", "year": "2019", "authors": "Ronald L Wasserstein; Allen L Schirm; Nicole A Lazar"}, {"ref_id": "b112", "title": "The generalization ofstudent's' problem when several different population variances are involved", "journal": "Biometrika", "year": "1947", "authors": "L Bernard;  Welch"}, {"ref_id": "b113", "title": "Improving sample efficiency in model-free reinforcement learning from images", "journal": "", "year": "2019", "authors": "Denis Yarats; Amy Zhang; Ilya Kostrikov; Brandon Amos; Joelle Pineau; Rob Fergus"}, {"ref_id": "b114", "title": "Masked contrastive representation learning for reinforcement learning", "journal": "", "year": "2020", "authors": "Jinhua Zhu; Yingce Xia; Lijun Wu; Jiajun Deng; Wengang Zhou; Tao Qin; Houqiang Li"}, {"ref_id": "b115", "title": "Randomness in neural network training: Characterizing the impact of tooling", "journal": "", "year": "2021", "authors": "Donglin Zhuang; Xingyao Zhang; Leon Shuaiwen; Sara Song;  Hooker"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 1 :1Figure 1: Number of runs in RL over the years. Beginning with DQN[75] on the ALE, 5 or less runs are common in the field. Here, we show representative RL papers with empirical results, in the order of their publication year: TD-learning[99], Sparse coding[100], Options[102], Tetris (CEM)[103], Batch-Q[31], ALE[5], DQN[75], AlphaGo[96], A3C[76], DDPG[62], ES[88], PPO[92], SAC[36], Rainbow[42], AlphaStar[110], Go-Explore[28], OpenAI Five[8], Balloon navigation[7] and MuZero[91].", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Figure 3 :3Figure 3: Expected sample median of task means. The expected score for N runs is computed by repeatedly subsampling N runs with replacement out of 100 runs for 100,000 times. Substantial bias in sample medians. The sample median is a biased estimator of the true median: E[Median(X 1:M )] = Median(E[X 1:M ]) in general.In the few-run regime, we find that this bias can dominate the comparison between algorithms, as evidenced in Figure3. For example, the score difference between sample medians with 5 and 100 runs for SPR (+0.03 points) is about 36% of its mean improvement over DrQ(\u03b5) (+0.08 points). Adding to the issue, the magnitude and sign of this bias strongly depends on the algorithm being evaluated.", "figure_data": ""}, {"figure_label": "7", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Figure 7 :7Figure7: Performance profiles on Atari 100k based on score distributions (left), which we recommend, and average score distributions (right). Shaded regions show pointwise 95% confidence bands based on percentile bootstrap with stratified sampling. The profiles on the left are more robust to outliers and have smaller confidence bands. We use 10 runs to show the robustness of profiles with a few runs. For SimPLe[50], we use the 5 runs from their reported results. The \u03c4 value where the profiles intersect y = 0.5 shows the median while for a non-negative random variable, area under the performance profile corresponds to the mean.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "Figure  7illustrates these differences.4.3 Robust and Efficient Aggregate Metrics", "figure_data": ""}, {"figure_label": "8", "figure_type": "figure", "figure_id": "fig_5", "figure_caption": "Figure 8 :8Figure 8: Aggregate metrics. For a non-negative random variable X, IQM corresponds to the red shaded region while optimality gap corresponds to the orange shaded region in the performance profile of X.", "figure_data": ""}, {"figure_label": "9", "figure_type": "figure", "figure_id": "fig_7", "figure_caption": "Figure 9 :9Figure 9: Aggregate metrics on Atari 200M with 95% CIs based on 55 games with sticky actions[69]. Higher mean, median and IQM scores and lower optimality gap are better. The CIs are estimated using the percentile bootstrap with stratified sampling. IQM typically results in smaller CIs than median scores. Large values of mean scores relative to median and IQM indicate being dominated by a few high performing tasks, for example, DreamerV2 and M-IQN obtain normalized scores above 50 on the game JAMESBOND. Optimality gap is less susceptible to outliers compared to mean scores. We compare DQN (Nature)[75], DQN with Adam optimizer, C51[6], REM[1], Rainbow[42], IQN[22], Munchausen-IQN (M-IQN)[109], and DreamerV2[38]. All results are based on 5 runs per game except for M-IQN and DreamerV2 which report results with 3 and 11 runs.", "figure_data": ""}, {"figure_label": "10", "figure_type": "figure", "figure_id": "fig_8", "figure_caption": "Figure 10 :10Figure 10: Atari 200M evaluation. Left. Score distributions using human-normalized scores obtained after training for 200M frames. Right. Sample-efficiency of agents as a function of number of frames measured via IQM human-normalized scores. Shaded regions show pointwise 95% percentile stratified bootstrap CIs.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_9", "figure_caption": "Figure A.13: Runs can be different from using fixed random seeds. We find that correlation between two sets of 100 runs of DER on Atari 100k using the same set of random seeds, that is, using a fixed random seed per run for Python, NumPy and JAX, is quite small. Small values of correlation coefficient highlight that fixing seeds does not ensure deterministic results due to non-determinism in GPUs. Similarly, setting random seed in PyTorch ensures reproducibility only on the same hardware.", "figure_data": ""}, {"figure_label": "141516", "figure_type": "figure", "figure_id": "fig_10", "figure_caption": "Figure A. 14 :Figure A. 15 :Figure A. 16 :141516Figure A.14: Per-game score distributions. Histogram plot with kernel density estimate of human-normalized scores of DER on 26 games in the Atari 100k benchmark. Each histogram plot is based on 100 runs per game. For most games, the distributions are either skewed (e.g., KUNGFUMASTER), heavy-tailed (e.g., BANKHEIST, FROSTBITE) or multimodal (e.g., HERO).", "figure_data": ""}, {"figure_label": "17", "figure_type": "figure", "figure_id": "fig_11", "figure_caption": "Figure A. 17 :17Figure A.17: Negligible bias in IQM scores.Expected IQM scores with varying number of runs. The expected score for N runs is computed by repeatedly subsampling N runs with replacement out of 100 runs for 100,000 times. Compared to expected median score differences (Figure3), the difference in expected IQM scores with 3 runs and 100 runs is typically an order of magnitude smaller. For example, the expected median differences for SPR is 0.05 points while expected IQM differences are only 0.006 points.", "figure_data": ""}, {"figure_label": "18", "figure_type": "figure", "figure_id": "fig_12", "figure_caption": "Figure A. 18 )18as opposed to 5-10 runs for stratified bootstrap CIs for aggregate metrics like median, mean and IQM (Figure A.19).", "figure_data": ""}, {"figure_label": "1819", "figure_type": "figure", "figure_id": "fig_13", "figure_caption": "Figure A. 18 :Figure A. 19 :1819Figure A.18: Validating 95% bootstrap CIs for per-game mean scores for a varying number of runs for DER, shown as a scatter plot where each point corresponds to one of the 26 games in Atari 100k. For a given game, the true coverage % is computed by sampling 10,000 sets of K runs without replacement from 200 runs and checking the fraction of 95% CIs that contains the true mean score for that game based on 200 runs. For many games, the true coverage for per-game CIs is below the nominal coverage of 95% even with 30 runs per game.", "figure_data": ""}, {"figure_label": "20", "figure_type": "figure", "figure_id": "fig_14", "figure_caption": "Figure A. 20 :20Figure A.20: Comparing Median vs IQM on Atari 200M. Sample-efficiency of agents as a function of number of frames measured via median (left) and IQM (right) human-normalized scores. Shaded regions show pointwise 95% percentile stratified bootstrap CIs. IQM results in significantly smaller CIs than median scores.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_15", "figure_caption": "Figure A.18 vs. Figure A.19).", "figure_data": ""}, {"figure_label": "22", "figure_type": "figure", "figure_id": "fig_16", "figure_caption": "Figure A. 22 :22Figure A.22: Stratified Bootstrap across tasks and runs. Aggregate metrics on Atari 200M with 95% CIs based on 55 games with sticky actions[69]. Higher mean, median and IQM scores and lower optimality gap are better. The CIs are estimated using the percentile bootstrap with stratified sampling across tasks and runs. MuZero[91] results use 1 run/game while Muesli[43] uses 2 runs/game, as provided by the corresponding authors. All other results are based on 5 runs per game except for M-IQN and DreamerV2 which report results with 3 and 11 runs. These estimates are much wider than that obtained via bootstrap over runs (Figure9).", "figure_data": ""}, {"figure_label": "23", "figure_type": "figure", "figure_id": "fig_17", "figure_caption": "Figure A. 23 :23Figure A.23: Score distributions with linear and with non-linear scaling on Atari 200M.In the plots above, the x-axis is scaled such that spacing between any two \u03c4 values, \u03c41 and \u03c42, is proportional to the fraction of runs averaged across algorithms between those two \u03c4 values. This scaling shows the regions of the score distribution where most of the runs lie as opposed to comparing tail ends of the distribution. However, this scaling implies sub-linear utility of achieving higher scores, which may not be accurate as the utility depends on the difficulty of obtaining higher scores -it is much higher to obtain higher scores on hard exploration games. Furthermore, we cannot visually inspect mean/IQM scores based on the area under the curve due to the non-linear scaling.", "figure_data": ""}, {"figure_label": "24", "figure_type": "figure", "figure_id": "fig_18", "figure_caption": "Figure A. 24 :24Figure A.24: Score distributions with linear and with non-linear scaling on Atari 100k. In the plots above, the x-axis is scaled such that spacing between any two \u03c4 values, \u03c41 and \u03c42, is proportional to the fraction of runs averaged across algorithms between those two \u03c4 values.", "figure_data": ""}, {"figure_label": "25", "figure_type": "figure", "figure_id": "fig_19", "figure_caption": "Figure A. 25 :25Figure A.25: Alternative aggregate metrics on ALE based on 55 games with 95% CIs. Higher metrics are better. The CIs are estimated using the percentile bootstrap with stratified sampling.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_20", "figure_caption": "Figure A.23 (right) and Figure A.24 (right)", "figure_data": ""}, {"figure_label": "262728", "figure_type": "figure", "figure_id": "fig_21", "figure_caption": "Figure A. 26 :Figure A. 27 :Figure A. 28 :262728Figure A.26: Optimality gap (\u03b3) divided by \u03b3 as a function of \u03b3. Lower curves are better.", "figure_data": ""}, {"figure_label": "11", "figure_type": "figure", "figure_id": "fig_22", "figure_caption": "\uf8f3 1 , 1 2,11m,i , y m,j ) where S(x, y) = \uf8f1 \uf8f2 if y < x, if y = x, 0, if y > x. (A.2)", "figure_data": ""}, {"figure_label": "2930", "figure_type": "figure", "figure_id": "fig_23", "figure_caption": "Figure A. 29 :Figure A. 30 :2930Figure A.29: Average Probability of Improvement on Atari 100k. Each subplot shows the probability of improvement of a given algorithm compared to all other algorithms. The interval estimates are based on stratified bootstrap with independent sampling with 2000 bootstrap re-samples.", "figure_data": ""}, {"figure_label": "33", "figure_type": "figure", "figure_id": "fig_24", "figure_caption": "Figure A. 33 :33Figure A.33: Ranking on individual tasks on DM Control 100k and 500k step benchmark.The i th column in the rank distribution plots show the probability that a given method is assigned rank i, when compared to other methods. These distributions are estimated using stratified bootstrap with 200,000 repetitions. We observe that no single algorithm consistently ranks above other algorithms on all tasks, making comparisons difficult without aggregating results across tasks.", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "Our recommendations for reliable evaluation, easily applicable with a handful of runs. Refer to Section 4 for details about recommendations and Section 5 for their application to widely-used RL benchmarks.", "figure_data": "Desideratum Current Evaluation ProtocolOur RecommendationUncertainty in aggregate performancePoint estimates \u2022 Ignore statistical uncertainty \u2022 Hinder results reproducibilityInterval estimates via stratified bootstrap confidence intervalsTables with mean scores per taskPerformance profiles (score distributions)Variability in\u2022 Overwhelming beyond a few tasks\u2022 Show tail distribution of scores on com-performance\u2022 Standard deviations often omittedbined runs across tasksacross tasks and runs\u2022 Incomplete picture for multimodal and heavy-tailed distributions\u2022 Allow qualitative comparisons \u2022 Easily read any score percentileMean\u2022 Often dominated by performance onInterquartile Mean (IQM) across all runsAggregateoutlier tasks\u2022 Performance on middle 50% of com-metricsMedianbined runsfor marizing sum-performance across tasks\u2022 Requires large number of runs to claim improvements \u2022 Poor indicator of overall perfor-mance: zero scores on nearly half\u2022 Robust to outlier scores but more statisti-cally efficient than median To show other aspects of performance gains, report average probability of improvementthe tasks do not affect itand optimality gap."}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_2", "figure_caption": "Detecting score lifts. Left. 95% CIs for observed lift with median scores, and Right. 95% CIs for observed lift with IQM (Section 4.3) when comparing SPR with an algorithm that performs % better. IQM requires fewer runs than median for small uncertainty.", "figure_data": "0% Lift (Upper CI)10% Lift (Upper CI)25% Lift (Upper CI)95% Median CIs95% IQM CIs3 10 Number of Runs (N) 25 50 100 Median Lift 100% 40% 60% 80% 120% 0% Lift (Lower CI) -40% -20% 0% 20% 40% 60% 80% 100% 120% 10% Lift (Lower CI) 3 5 10 Number of Runs (N) 25 50 100 IQM Lift 25% Lift (Lower CI) (Lift = ScoreX/ScoreY \u2212 1) 95% CIs for % Observed Lift -40% -20% 0% 20%0.00 75 85 95 Coverage % 0.10 0.05 CI Width True Average3 5 10 20 50100 0.00 95 75 85 0.10 0.053 5 10 20 50100 basic bc bca percentileDER (Final) DER Reported Figure 4: 0.2 Median0.3 DER (CURL's protocol) 0.3 CURL Reported Mean0.4 DER (SUNRISE's protocol) 0.5 SUNRISE ReportedNumber of Runs Figure 6: Validating 95% Stratified Bootstrap Number of Runs CIs for a varying number of runs for median and IQM scores for DER. The true coverage % is com-puted by sampling 10,000 sets of K runs without replacement from 200 runs and checking the frac-tion of 95% CIs that contains the true estimate approximation based on 200 runs. Note that we evaluate additional 100 runs for95% Confidence Interval"}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_3", "figure_caption": "Procgen evaluation results based on easy mode comparisons [80] with 16 tasks. Left. Score distributions which compare PPO", "figure_data": "Fraction of runs with score > \u03c40.00 0.25 0.50 0.75 1.000.51.0 Min-Max Normalized Score (\u03c4) 1.5 2.0 2.5 3.0 PPO MixReg 3.5 PLR PPG IDAAC UCB-DrACP(X > Y) 0.4 0.5 0.6 0.7 0.8 0.9 1.0 PPO MixReg MixReg PLR PPO PPO UCB-DrAC PPG Algorithm X MixReg UCB-DrAC PLR UCB-DrAC PPG IDAAC IDAAC IDAAC Algorithm YFigure 12:"}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_4", "figure_caption": "Stratified bootstrap over tasks and runs12 . With access to only 1-2 runs per task, stratified bootstrapping can be done over tasks(Figure A.22), to answer the question: \"If I repeat the experiment with a different set of tasks, what performance an algorithm is I expected to get?\" It shows the sensitivity of the aggregate score to a given task and can also be viewed as an estimate of performance if we had used a larger unknown population of tasks [e.g.,90,94]. Compared to the interval estimates in Figure9, bootstraping over tasks results in much larger uncertainty due to high variations in performance across different tasks (e.g., easy vs hard exploration tasks).", "figure_data": "PPOMixRegUCB-DrACPLRPPGIDAACFraction of Runs with Score > \u03c40.00 0.25 0.50 0.75 1.000.51.01.52.02.53.03.5Fraction of Runs with Score > \u03c40.00 0.25 0.50 0.75 1.000.00.20.40.60.81.0PPO Normalized Score (\u03c4)Min-Max Normalized Score (\u03c4)Figure A.21: Score Distributions on the Procgen benchmarkA.6 Visualizing score distributions"}], "formulas": [{"formula_id": "formula_0", "formula_text": "K ) = 1 K K k=1 1[y k > \u03c4 ].", "formula_coordinates": [3.0, 331.49, 486.28, 103.47, 14.56]}, {"formula_id": "formula_1", "formula_text": "F X (\u03c4 ) =F (\u03c4 ; x 1:M,1:N ) = 1 M M m=1F m (\u03c4 ) = 1 M M m=1 1 N N n=1 1[x m,n > \u03c4 ].(1)", "formula_coordinates": [7.0, 152.81, 300.43, 351.19, 30.2]}, {"formula_id": "formula_2", "formula_text": "F (\u03c4 ) = 1 N M m=1 F m (\u03c4 ).", "formula_coordinates": [7.0, 108.0, 344.54, 105.5, 14.56]}, {"formula_id": "formula_3", "formula_text": "\u03c3 2 X = 1 M 2 N M m=1 F m (\u03c4 )(1 \u2212 F m (\u03c4 )) versus \u03c3 2 X = 1 M 2 M m=1 FX m (\u03c4 )(1 \u2212 FX m (\u03c4 )).", "formula_coordinates": [7.0, 108.0, 443.26, 396.0, 29.08]}, {"formula_id": "formula_4", "formula_text": "> Y ) = 1 M M m=1 P (X m > Y m ), where P (X m > Y m ) (Equation A.", "formula_coordinates": [8.0, 108.0, 437.28, 396.0, 24.85]}, {"formula_id": "formula_5", "formula_text": "(2 \u03b8 \u2212 \u03b8 * (\u03b1/2) , 2 \u03b8 \u2212 \u03b8 * (1\u2212\u03b1/2) )", "formula_coordinates": [22.0, 124.77, 319.22, 114.75, 12.94]}, {"formula_id": "formula_6", "formula_text": "P (X m > Y m ) = 1 N K N i=1", "formula_coordinates": [25.0, 128.57, 636.94, 107.23, 30.32]}], "doi": ""}