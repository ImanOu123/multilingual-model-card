{"title": "QCDCL with Cube Learning or Pure Literal Elimination -What is Best?", "authors": "Benjamin B\u00f6hm; Tom\u00e1\u0161 Peitl; Olaf Beyersdorff", "pub_date": "", "abstract": "conflict-driven clause learning (QCDCL) is one of the main approaches for solving quantified Boolean formulas (QBF). We formalise and investigate several versions of QCDCL that include cube learning and/or pure-literal elimination, and formally compare the resulting solving models via proof complexity techniques. Our results show that almost all of the QCDCL models are exponentially incomparable with respect to proof size (and hence solver running time), pointing towards different orthogonal ways how to practically implement QCDCL.", "sections": [{"heading": "Introduction", "text": "SAT solving has revolutionised the way we perceive computationally hard problems. Determining the satisfiability of propositional formulas (SAT) has traditionally been viewed as intractable due to its NP completeness. In contrast, modern SAT solvers today routinely solve huge industrial instances of SAT from a wide variety of application domains [Biere et al., 2021a]. This success of solving has not stopped at SAT, but in the last two decades was lifted to increasingly more challenging computational settings, with solving quantified Boolean formulas (QBF)-a PSPACE-complete problem-receiving key attention .\nConflict driven clause learning (CDCL) is the main paradigm of modern SAT solving [Marques Silva et al., 2021]. Based on the classic DPLL algorithm from the 1960s, it combines a number of advanced features, including clause learning, efficient Boolean constraint propagation, decision heuristics, restart strategies, and many more. In QBF there exist several competing approaches to solving, with lifting CDCL to the quantified level in the form of QCDCL as one of the main paradigms [Zhang and Malik, 2002], implemented e.g. in the state-of-the-art solvers DepQBF [Lonsing and Egly, 2017] and Qute [Peitl et al., 2019].\nFor SAT/QBF solving, two questions of prime theoretical and practical importance are: (1) why are SAT/QBF solvers so effective and on which formulas do they fail? (2) Which solving ingredients are most important for their performance?\nFor (1), proof complexity offers the main theoretical approach to analyse the strength of solving [Buss and Nord-str\u00f6m, 2021]. In a breakthrough result, Pipatsrisawat and Darwiche [2011] and Atserias et al. [2011] established that CDCL on unsatisfiable formulas is equivalent to the resolution proof system, in the sense that from a CDCL run a resolution proof can be efficiently extracted [Beame et al., 2004], and conversely, each resolution proof can be efficiently simulated by CDCL [Pipatsrisawat and Darwiche, 2011]. Hence the well-developed proof-complexity machinery for proof size lower bounds in resolution [Kraj\u00ed\u010dek, 2019] is directly applicable to show lower bounds for running time in CDCL.\nThe latter simulation of resolution by CDCL assumes a strong 'non-deterministic' version of CDCL, whereas practical CDCL (using decision heuristics such as VSIDS) has been recently proved to be exponentially weaker than resolution [Vinyals, 2020]. In contrast, an analogous proof-theoretic characterisation is not known for QCDCL, and in particular QCDCL has recently been shown to be incomparable to Q-Resolution [Beyersdorff and B\u00f6hm, 2021], the QBF analogue of propositional resolution [Kleine B\u00fcning et al., 1995].\nRegarding question (2) above, there are some experimental studies [Sakallah and Marques-Silva, 2011;Elffers et al., 2018;Kokkala and Nordstr\u00f6m, 2020], but no rigorous theoretical results are known on which (Q)CDCL ingredients are most crucial for performance. Of course, gaining such a theoretical understanding would also be very valuable in guiding future solving developments.\nIn this paper, we contribute towards question (2) in QBF.", "publication_ref": ["b3", "b3", "b0", "b0", "b2", "b1", "b2", "b3", "b1", "b2"], "figure_ref": [], "table_ref": []}, {"heading": "Contributions", "text": "Following the approach of Beyersdorff and B\u00f6hm [2021], we model QCDCL as rigorously defined proof systems that are amenable to a proof-complexity analysis. This involves formalising individual QCDCL ingredients, such as clause and cube learning and different variants of Boolean constraint propagation. These can then be 'switched' on or off, resulting in a number of different QCDCL solving models that we can formally investigate. Our results can be summarised as follows.\n(a) QCDCL with or without cube learning. In contrast to SAT solving, where there is somewhat of an asymmetry between satisfiable and unsatisfiable formulas, QCDCL implements a dual approach for false and true QBFs. In addition to learning clauses (as in CDCL) when running into a conflict under the current assignment, QCDCL also learns terms (or cubes) in the case a satisfying assignment is found (or a previously learned cube is satisfied). While cube learning is necessary to make QCDCL solving complete on true QBFs, it is less clear what the effect of cube learning is on false QBFs (and we only consider those throughout the paper as we cast all our models in terms of refutational proof systems, in accordance with the proof complexity analysis of SAT [Buss and Nordstr\u00f6m, 2021]). Here we establish the perhaps surprising result that even for false QBFs, cube learning can be advantageous, in the sense that QCDCL without cube learning (as a proof system for false QBFs) is exponentially weaker than QCDCL with cube learning.\n(b) QCDCL with or without pure-literal elimination. In its simplest form, Boolean constraint propagation, used to construct trails in (Q)CDCL, implements unit propagation. However, further methods can be additionally employed (and are considered in pre-and in-processing [Biere et al., 2021b]). One of the classic mechanisms is pure-literal elimination, setting a pure literal (which occurs in only one polarity) to the obvious value. This is e.g. implemented in De-pQBF and an efficient implementation is described by Lonsing [2012].\nWe show that QCDCL with or without pure-literal elimination results in incomparable proof systems, i.e., there are QBFs that are easy in QCDCL with pure literal elimination, but hard in plain QCDCL, and vice versa (the latter is perhaps more surprising).\n(c) Comparing QCDCL extensions. Given the preceding results, it is natural (and possibly most interesting for practice) to ask how the different QCDCL extensions compare with each other. We consider QCDCL with cube learning, QCDCL with pure-literal elimination but without cube learning, and QCDCL with both cube learning and pureliteral elimination. Except for the simulation of the second by the third system, we again obtain incomparability results between the systems with exponential separations. We further show that all these systems are incomparable to Q-Resolution, again via exponential separations. An overview of the systems and their relations is given in Figure 1.\nTechnically, our results rest on formalising QCDCL systems as proof calculi and exhibiting specific QBFs for their separations. The latter includes both the explicit construction of short QCDCL runs and proving exponential proof size lower bounds for the relevant calculi. For the lower bounds, we identify a property of proofs (called primitivity here) that allows to use proof-theoretic machinery of B\u00f6hm and Beyersdorff [2021] in the context of our QCDCL systems.\nOur theoretical results on the strength of different QCDCL models are empirically confirmed by experiments with stateof-the-art QCDCL solvers (cf. Section 8).\nOrganisation. We start in Section 2 by reviewing QBFs and Q-Resolution. In Section 3 we model variants of QCDCL as formal proof systems and develop a lower technique for such systems in Section 4. Sections 5 to 8 then contain our results on the relative strength of QCDCL variants. We conclude in Section 9 with an outlook on future research.\nDue to space constraints, some details are omitted. ", "publication_ref": ["b1"], "figure_ref": [], "table_ref": []}, {"heading": "Preliminaries", "text": "We will use standard notions from propositional logic, such as variables, literals, (propositional) formulas, clauses, conjunctive normal form (CNF), disjunctive normal form (DNF), assignments, satisfiability or restrictions. A cube (or term) is a conjunction of literals. A literal in a formula \u03a6 is pure, if it only appears in one polarity (i.e., if is contained in \u03a6, but is not). We define two \"empty\" literals K and J.\nA QBF (quantified Boolean formula) \u03a6 \" Q\u00a8\u03c6 consists of a propositional formula \u03c6, called the matrix (denoted by Cp\u03a6q), and a prefix Q. A prefix Q \" Q 1 1 V 1 . . . Q 1 s V s consists of non-empty and pairwise disjoint sets of variables V 1 , . . . , V s and quantifiers Q 1 1 , . . . , Q 1 s P tD, @u with Q 1 i \u2030 Q 1 i`1 for i P rs\u00b41s. For a variable x in Q, the quantifier level is lvpxq :\" lv \u03a6 pxq :\" i, if x P V i . For lv \u03a6 p 1 q \u0103 lv \u03a6 p 2 q we write 1 \u0103 \u03a6 2 .\nWe use the proof systems Q-resolution [Kleine B\u00fcning et al., 1995] and long-distance Q-resolution [Balabanov and Jiang, 2012], containing resolution and reduction rules. In general, a clause C can be reduced universally, while a cube D can be reduced existentially. We denote the maximally universally (resp. existentially) reduced clause (resp. cube) by red @ \u03a6 pCq (resp. red D \u03a6 pDq).", "publication_ref": ["b2", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "Formal Calculi for QCDCL Versions", "text": "In this section we model different versions of QCDCL as formal proof systems (we sketch this only here; for background on QCDCL cf. ). For this we need to formalise QCDCL ingredients. We start with trails. A trail T for a QCNF \u03a6 is a finite sequence of literals from \u03a6, including the empty literals K and J. In general, a trail has the form T \" pp p0,1q , . . . , p p0,g0q ; d 1 , p p1,1q , . . . , p p1,g1q ; . . . ; d r , p pr,1q , . . . , p pr,grq q, (3.1)\nwhere the d i are decision literals and p pi,jq are propagated literals. Decision literals are written in boldface. We use a semicolon before each decision to mark the end of a decision level. We write x \u0103 T y if x, y P T and x is left of y in T . Trails can be interpreted as non-tautological sets of literals, and therefore as (partial) assignments. If T is a trail, then T ri, js, for i P t0, . . . , ru and j P t0, . . . , g i u, is defined as the subtrail that contains all literals from T left of (and excluding) p pi,jq (resp. d i , if j \" 0). A trail T has run into conflict if K P T or J P T .\nSimply put, our QCDCL proof systems can be interpreted as sequences of trails. These trails cannot be created arbitrary, but have to follow special rules, depending on the model. We consider the following four QCDCL variants:\n\u2022 QCDCL, which can be seen as the plain model where we can only make decisions following the level order of the quantifier prefix, make propagations using clauses and use classic clause learning. We will never learn or use cubes and pure-literal elimination is turned off.\n\u2022 QCDCL CUBE is an extension of QCDCL in which we can learn cubes and use them for propagations. Decisions are still level-ordered and pure-literal elimination is turned off.\n\u2022 QCDCL PL is an extension of QCDCL, where we decide literals out of order if they are pure in the current configuration (pure-literal elimination). All other decisions (which we call regular decisions) are still level ordered. Cube learning is turned off.\n\u2022 QCDCL CUBE+PL is an extension of QCDCL PL , in which cube learning is now allowed (as in QCDCL CUBE ).\nNote that decisions can only be made if there are no more propagations possible and pure literal decisions always have a higher priority than regular decisions. Also, conflicts have a higher priority than propagations of proper (existential or universal) literals. Hence, we will never skip conflicts, propagations or pure literal decisions. For each propagated literal p pi,jq in a trail T the formula must contain a clause or a cube that caused this propagation by becoming a unit clause/cube. We denote such a clause/cube by ante T pp pi,jq q.\nAfter a trail has run into a conflict, or if all variables were assigned, we can start the learning process. Definition 1 (learnable constraints). Let T be a trail for \u03a6 of the form (3.1) with p pr,grq P tK, Ju. Starting with ante T pKq (resp. ante T pJq) we reversely resolve over the antecedent clauses (cubes) that propagated the existential (universal) variables, until we stop at some arbitrarily chosen point. The clause (cube) we so derive is a learnable constraint. We denote the set of learnable constraints by LpT q.\nWe can also learn cubes from trails that did not run into conflict. If T is a total assignment of the variables from \u03a6, then we define the set of learnable constraints as the set of cubes LpT q :\" tred D \u03a6 pDq| D \u010e T and D satisfies Cp\u03a6qu. Definition 2 (QCDCL proof systems). Let S be one of QCDCL, QCDCL CUBE , QCDCL PL , QCDCL CUBE+PL . An S proof \u03b9 from a QCNF \u03a6 \" Q\u00a8\u03c6 of a clause or cube C is a sequence of triples\n\u03b9 :\" rpT i , C i , \u03c0 i qs m i\"1 ,\nwhere C m \" C, each T i is a trail, each C i P LpT i q is one of the constraints we can learn from the trail, and \u03c0 i is the longdistance Q-resolution or long-distance Q-consensus proof of C i we get by performing the steps in Definition 1. We define Rp\u03b9q as the proof of C we get by sticking together suitable \u03c0 i . We denote the set of trails in \u03b9 as Tp\u03b9q.\nIf C \" pKq, then \u03b9 is called an S refutation of \u03a6. If C \" rJs, then \u03b9 is an S verification of \u03a6. The proof ends once we have learned pKq or rJs. The size of \u03b9 is |\u03b9| :\" \u0159 m i\"1 |T i |. Theorem 1. QCDCL, QCDCL CUBE , QCDCL PL , and QCDCL CUBE+PL are sound and complete proof systems.\nWe highlight that these systems formally model QCDCL solving as used in practice (cf. ).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Proving Lower Bounds for QCDCL Systems", "text": "Throughout the paper we will concentrate on \u03a3 b\n3 QCNFs which we alway assume to have the form \u03a6 \" DX@U DT\u00a8\u03c6 for non-empty blocks of variables X, U , and T .\nA literal is an X-literal, if varp q P X. Analogously, we get U -and T -literals and variables. A clause C P Cp\u03a6q is an X-clause, if all its literals are X-literals. The empty clause pKq is also an X-clause. Analogously, we define T-clauses. A clause C P Cp\u03a6q is an XT-clause, if it contains at least one X-literal, at least one T -literal, but no U -literals; analogously we define UT-clauses. A clause C P Cp\u03a6q is an XUT-clause if it contains at least one X-, U -and T -literal.\nDefinition 3. We say that \u03a6 fulfils the XT-property, if Cp\u03a6q contains no XT-clauses, no T-clauses that are unit (or empty) and no two T-clauses from Cp\u03a6q are resolvable.\nAs shown by B\u00f6hm and Beyersdorff [2021], clause learning does not affect the XT-property, i.e., a formula \u03a6 with the XT-property will still fulfil it during the whole QCDCL run even after having added new clauses to Cp\u03a6q.\nNext we recall the definition of formula gauge from [B\u00f6hm and Beyersdorff, 2021], which represents a measure that can be used for lower bounds.\nDefinition 4 ([B\u00f6hm and Beyersdorff, 2021]). For a QCNF \u03a6 as above let W \u03a6 be the set of all Q-resolution derivations \u03c0 from \u03a6 of some X-clause such that \u03c0 only contains resolutions over T -variables and reduction steps. We set gaugep\u03a6q :\" mint|C| : C is the root of some \u03c0 P W \u03a6 u.\nWe now define fully reduced and primitive proofs. Our lower bound technique will then work for fully reduced primitive refutations of formulas that fulfil the XT-property. Definition 5. A long-distance Q-resolution refutation \u03c0 of a QCNF \u03a6 is called fully reduced, if the following holds: For each clause C P \u03c0 that contains universal literals that are reducible, the reduction step has to be performed immediately and C cannot be used otherwise in the proof.\nEach proof Rp\u03b9q that was extracted from a QCDCL proof \u03b9 is automatically fully reduced, as we perform reduction steps as soon as possible during clause learning. On the other hand, primitivity does not hold for proofs Rp\u03b9q in general. In fact, the main work in proving our hardness results will be to show that specific extracted proofs are primitive. Definition 6. A long-distance Q-resolution proof \u03c0 from a \u03a3 b 3 formula with the XT-property is primitive, if there are no two XUT-clauses in \u03c0 that are resolved over an X-variable.\nSince it is not possible to derive tautological clauses in fully reduced primitive proofs, we may also refer to them as (fully reduced) primitive Q-resolution proofs.\nIt follows from [B\u00f6hm and Beyersdorff, 2021], that these two conditions suffice to show lower bounds via gauge. Theorem 2 ([B\u00f6hm and Beyersdorff, 2021]). Each fully reduced primitive Q-resolution refutation of a \u03a3 b 3 QCNF \u03a6 that fulfils the XT-property has size 2 \u2126pgaugep\u03a6qq .\nThe next two results represent the main methodology for most of our hardness results throughout the paper. Lemma 1. Let T be a trail in a QCDCL, QCDCL CUBE , QCDCL PL or QCDCL CUBE+PL proof from a QCNF \u03a6 with the XT-property. Then for each T -literal t 1 P T , which was not decided by pure literal elimination, there is a U -literal u P T with u \u0103 T t 1 . Proposition 1. Let \u03b9 be a QCDCL, QCDCL CUBE , QCDCL PL or QCDCL CUBE+PL refutation of a QCNF \u03a6 that fulfils the XTproperty. If Rp\u03b9q is not primitive, then there exists a trail T P Tp\u03b9q such that there is a U -literal u P T and an Xliteral x P T with u \u0103 T x. Additionally, u cannot be a regular decision literal.\nBasically, this result tells us that for a non-primitive proof Rp\u03b9q of some S proof \u03b9, where S is one of our four QCDCL variants, \u03b9 needs to consist of a trail that assigns a U -literal out-of-order (i.e., before we have assigned all X-literals).\nSince neither cube learning nor pure literal elimination is allowed in QCDCL, we can immediately conclude: Corollary 1. Let \u03b9 be a QCDCL refutation of a QCNF \u03a6 that fulfils the XT-property. Then Rp\u03b9q is primitive.\nWe remark that some of the QBFs we introduce in the paper are not minimally false, i.e., we have added extra clauses to formulas that were false already. Although this is unusual in proof complexity, practical (false) instances are not guaranteed to be minimally false. Therefore it is natural to also consider these QBFs when investigating QCDCL systems. These algorithmic proof systems have to utilize all clauses, even if they are redundant for Q-resolution refutations.", "publication_ref": ["b1", "b1", "b1", "b1", "b1"], "figure_ref": [], "table_ref": []}, {"heading": "Plain QCDCL vs. QCDCL with Cubes/PL", "text": "We start by examining the influence of cube learning on our QCDCL model. For false formulas we can always prevent learning cubes by just deciding the universal variables according to a winning strategy for the universal player, which will cause a conflict on the current trail. Thus cube learning will never be disadvantageous in principle. Proposition 2. QCDCL CUBE p-simulates QCDCL and QCDCL CUBE+PL p-simulates QCDCL PL .\nWe recall the equality formulas Eq n of Beyersdorff et al.\n[2019a]. These are QCNFs with prefix Dx 1 . . . x n @u 1 . . . u n Dt 1 . . . t n and matrix\npt 1 _ . . . _t n q^n \u013e i\"1 ppx i _\u016b i _ t i q^px i _ u i _ t i qq.\nThe formulas are known to be hard for Q-resolution [Beyersdorff et al., 2019a] and also for QCDCL [Beyersdorff and B\u00f6hm, 2021]. In contrast, we show that they are easy in QCDCL with cube learning. Proposition 3. There exist polynomial-size QCDCL CUBE refutations of Eq n .\nProof Sketch. First we learn the cubes x i^\u016bi andx i^ui for i P rn\u00b41s. E.g., to learn x 1^\u016b1 , we use the trail T 1 :\" px 1 ; . . . ; x n ;\u016b 1 ; . . . ;\u016b n ;t 1 ; t 2 ; . . . ; t n q.\nThen the partial assignment x 1^\u016b1^t1^t2^. . .^t n satisfies the matrix of Eq n . Reducing this cube existentially results in x 1^\u016b1 , hence x 1^\u016b1 P LpT 1 q.\nHaving learnt all these 2n\u00b42 cubes, we learn the clauses\nL i :\"x i _\u016b i _ \u017d n j\"i`1 pu j _\u016b j q _ \u017d i\u00b41 k\"1t k and R i :\" x i _u i _ \u017d n j\"i`1 pu j _\u016b j q_ \u017d i\u00b41\nk\"1t k , starting with i \" n\u00b41 and down to i \" 2. E.g., to learn L n\u00b41 we use the trail\nU n\u00b41 :\" px 1 , u 1 , t 1 ; . . . ; x n\u00b41 , u n\u00b41 , t n\u00b41 ,t n , x n , Kq,\nwhere u i are propagated directly after x i by the learnt cubes. We resolve over x n ,t n , and t n\u00b41 to get L n\u00b41 .\nHaving finally learnt L 2 and R 2 , we form the trail U 1 :\" px 1 , u 1 , t 1 , x 2 , Kq with ante U1 px 2 q \" R 2 and ante U1 pKq \" L 2 and learn px 1 q. Then the last trail px 1 ,\u016b 1 , t 1 , x 2 , Kq yields the empty clause.\nAs the formulas Eq n require exponential-sized QCDCL refutations [Beyersdorff and B\u00f6hm, 2021] we obtain: Theorem 3. QCDCL CUBE is exponentially stronger than QCDCL.\nNext we will look at the influence of pure literal elimination. Now, the effect of pure literal elimination is similar to cube learning: they enable out-of-order decisions that can shorten the refutations. This again manifests in Eq n .\nProposition 4. Eq n has poly-size QCDCL PL (and QCDCL CUBE+PL ) refutations.\nAlthough pure literal elimination helps to refute Eq n , it turns out that pure literal elimination can also be disadvantageous. It might be a fallacy to think that pure existential literals should be satisfied in the same way as unit clauses in unit propagation. We will construct formulas in which pure literal elimination thwarts finding a convenient conflict and therefore short refutations.\nWe construct these formulas in stages, starting with MirrorCR n . In turn, these QBFs are based on the Completion Principle CR n of Janota [2016], known to be hard for QCDCL [Janota, 2016;B\u00f6hm and Beyersdorff, 2021]. The \"Mirror\"-modification adds new symmetries to the formula, causing pure literals to appear too late to make a difference. Definition 7. The QCNF MirrorCR n consists of the prefix Dx p1,1q , . . . , x pn,nq @uDa 1 , . . . , a n , b 1 , . . . , b n and the matrix\nx pi,jq _ u _ a i ,\u0101 1 _ . . . _\u0101 n ,x pi,jq _\u016b _ b j ,b 1 _ . . . _b n x pi,jq _\u016b _\u0101 i , a 1 _ . . . _ a n ,x pi,jq _ u _b j , b 1 _ . . . _ b n for i, j P rns.\nIt is easy to see that MirrorCR n fulfil the XT-property. Additionally, we can show: Proposition 5. The CNF CpMirrorCR n q is unsatisfiable and gaugepMirrorCR n q \u011b n\u00b41.\nApplying Theorem 2 we infer: Corollary 2. MirrorCR n needs exponential-size fully reduced primitive Q-resolution refutations.\nAll we have to do now is to show that all QCDCL PL refutations of MirrorCR n are primitive. Then the gauge lower bound applies. We will show that for a non-primitive refutation of MirrorCR n we would need to decide literals by pure literal elimination, and before each pure literal elimination we have to perform another one, which is a contradiction. Proposition 6. From each QCDCL PL refutation of MirrorCR n we can extract a fully reduced primitive Q-resolution refutation of the same size.\nProof Sketch. We show that Rp\u03b9q is primitive if \u03b9 is a QCDCL PL refutation of MirrorCR n . Assume that some Rp\u03b9q is not primitive. Therefore, by Proposition 1, a U -literal was decided as a pure literal before all X-variables were assigned. However, such a situation is impossible due to the formula structure, resulting in a contradiction. Its matrix contains all clauses from MirrorCR n and additionally py _ aq, p\u0101 _ bq, p\u0101 _bq, pa _ bq, and pa _bq.\nProposition 7. PLTrap n needs exponential-size QCDCL PL and QCDCL CUBE+PL refutations.\nNot having to follow the PLD rule, we can construct short proofs of PLTrap n by focusing on the new clauses over a, b. Proposition 8. PLTrap n has polynomial-size QCDCL refutations.\nWe conclude that pure literal elimination is advantageous for Eq n , but not for PLTrap n . Therefore we obtain: Theorem 4. QCDCL PL and QCDCL are incomparable as well as QCDCL CUBE+PL and QCDCL.", "publication_ref": ["b0", "b1", "b1", "b1"], "figure_ref": [], "table_ref": []}, {"heading": "Cube Learning vs. Pure Literal Elimination", "text": "As shown in Section 5, cube learning improves QCDCL, while adding pure literal elimination leads to incomparable systems. Thus it is natural to directly compare cube learning and pure literal elimination. Because of the results above, we cannot use Eq n for a potential separation. However, we can modify the QBFs such that they remain easy for QCDCL PL , while eliminating the benefits from cube learning. Definition 9. The QCNF TwinEq n has the prefix Dx 1 , . . . , x n @u 1 , . . . , u n , w 1 , . . . , w n Dt 1 , . . . , t n . Its matrix contains the clauses from Eq n together with x i _ w i _ t i and x i _w i _ t i for i P rns.\nThe main idea of this twin construction is to ensure that all potential cubes consist of at least two universal variables. We can do the same construction for other QCNFs.\nObviously, TwinEq n fulfils the XT-property. We compute gaugepTwinEq n q \" n and hence infer by Theorem 2: Proposition 9. Fully reduced primitive Q-resolution refutations of TwinEq n have exponential size.\nWe show that QCDCL CUBE refutations of TwinEq n are primitive by proving that it is impossible to propagate Uliterals before having assigned all X-literals.\nProposition 10. Each QCDCL CUBE refutation of TwinEq n has at least exponential size.\nHaving shown that TwinEq n is hard for QCDCL CUBE , it remains to prove that it is easy for QCDCL PL .\nProposition 11. TwinEq n has polynomial-size QCDCL PL refutations.\nFor the other separation we use PLTrap n , which is hard for QCDCL PL , but still easy for QCDCL CUBE by Proposition 2. Therefore we conclude: Theorem 5. QCDCL CUBE is incomparable to QCDCL PL .\nWe have seen earlier that the QCDCL system including pure literal elimination is incomparable to the system without. Now we will prove that this incomparability still holds with cube learning turned on. By Proposition 2, we obtain that QCDCL CUBE+PL p-simulates QCDCL PL . Therefore we get from Proposition 11: We now consider the relation between QCDCL CUBE+PL and QCDCL PL . We introduce another modification of Eq n , which we call BulkyEq n , where we add two clauses. Definition 10. The QCNF BulkyEq n is obtained from Eq n by adding the clauses u 1 _ . . . _ u n _ t 1 _ . . . _ t n and u 1 _ . . . _\u016b n _ t 1 _ . . . _ t n to the matrix.\nAs Eq n , this formula fulfils the XT-property and has a high gauge value (\u011b n\u00b41). By Theorem 2 we infer that BulkyEq n needs exponential-size fully reduced primitive Q-resolution refutations. Similarly to MirrorCR n , we can then show that pure literal elimination does not shorten proofs because of the two additional 'bulky' clauses that prevent pure literals to occur early in trails. Therefore BulkyEq n is hard for QCDCL PL . On the other hand, we can explicitly construct short proofs in QCDCL CUBE+PL . Therefore we get: Proposition 13. BulkyEq n has poly-size QCDCL CUBE+PL refutations, but needs exponential-size QCDCL PL refutations.\nAs for the systems without pure literal elimination, we get:  \nx 1 _t 1 ,x 1 _ t 1 , u _ t n ,\u016b _t n , x i _ t i\u00b41 _t i , x i _t i\u00b41 _ t i , x i _ t i\u00b41 _ t i ,x i _t i\u00b41 _t i for i P t2, . . . ,", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Experiments", "text": "We study proof systems in the hope that proof-complexity results will translate to running-time complexity for solvers. In this section we do our reality check to see whether this hypothesis holds up experimentally.\nWe picked the solver DepQBF [Lonsing and Egly, 2017], as it is the only one that supports pure-literal elimination (PLE) and also has the ability to turn cube learning (SDCL) off. 1 We additionally ran Qute [Peitl et al., 2019] when we wanted to confirm DepQBF's surprising behaviour. Though, Qute only supports QCDCL CUBE of the systems discussed above, and so is poorly suited for most of our experiments.\nWe ran DepQBF on each of the formulas used for separations in this paper, as well as on the PCNF track of the QBF Evaluation 2020. 2 We set the time limit on each formula to 10 minutes (no memory limit). The computation was performed on a machine with two 16-core Intel\u00ae Xeon\u00ae E5-2683 v4@2.10GHz CPUs and 512GB RAM running Ubuntu 20.04.3 LTS on Linux 5.4.0-48, and organized with the help of GNU Parallel [Tange, 2011].\nWe discovered that heuristics have a significant impact on performance on theoretically easy formulas (theoretically hard formulas must be hard for solvers as well, and we confirm this in every case). We thus decided to run DepQBF 1 In order to obtain vanilla QCDCL in DepQBF, we set --traditional-qcdcl --long-dist-res --dep-man=simple --no-dynamic-nenofex --no-trivial-truth --no-trivial-falsity. with each available heuristic, in order to paint a full picture.\nIn total, we evaluated 24 configurations of DepQBF-with and without PLE and with and without SDCL, and for each of these four, with each of the 6 possible heuristics. 3 Figure 2 shows the results on Equality. While the formulas are easy using PLE regardless of the heuristic, without PLE DepQBF's performance fluctuates depending on the heuristic, even though the formulas are 'easy' as long as SDCL is on. Qute's performance is stabler, but still much worse than DepQBF with PLE. The formulas get hard without both PLE and SDCL, in line with [Beyersdorff and B\u00f6hm, 2021].\nWhile both PLE and SDCL make Eq easy, PLE seems easier to exploit. Perhaps there is simply less room for error in applying PLE than in learning the right cubes. A mild advantage from PLE is also confirmed by DepQBF's results on QBF Eval formulas. This suggests that in spite of conceptual simplicity PLE can be quite useful, and perhaps should appear on Qute's feature roadmap.", "publication_ref": ["b3", "b1"], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "Conclusion", "text": "While this paper only studies false formulas (in accordance with proof complexity conventions), we expect similar phenomena of incomparability on true formulas, which we leave for future work to explore. Interestingly, while cube learning is primarily needed for true QBFs, we have shown that it can also improve the running time on false instances.\nTechnically, we believe that our new notion of primitive proofs has further potential for showing QCDCL lower bounds, also for QBFs of higher quantifier complexity. While previous results tried to lift lower bounds from Q-Resolution [Beyersdorff and B\u00f6hm, 2021], primitivity also applies to QBFs easy for Q-Resolution, thus supplying new reasons for QCDCL hardness.", "publication_ref": ["b1"], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgements", "text": "Research was supported by grants from the Carl-Zeiss Foundation, Austrian Science Fund FWF grant no. J4361-N, and DFG grant BE 4209/3-1.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Clause-learning algorithms with many restarts and bounded-width resolution", "journal": "IOS Press", "year": "2004", "authors": " Atserias"}, {"ref_id": "b1", "title": "Seeking practical CDCL insights from theoretical SAT benchmarks", "journal": "IOS Press", "year": "2016", "authors": ""}, {"ref_id": "b2", "title": "Florian Lonsing and Uwe Egly. DepQBF 6.0: A search-based QBF solver beyond traditional QCDCL", "journal": "IOS Press", "year": "1995", "authors": "Kleine B\u00fcning"}, {"ref_id": "b3", "title": "Conflict driven learning in a quantified Boolean satisfiability solver", "journal": "", "year": "2002", "authors": ""}], "figures": [{"figure_label": "3", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Corollary 3 .3The QBFs MirrorCR n require exponential-size QCDCL PL refutations.Next we embed this formula into a new QCNF PLTrap n . Definition 8. The QCNF PLTrap n has the prefix Dy, x p1,1q , . . . , x pn,nq @uDa 1 , . . . , a n , b 1 , . . . , b n , a, b.", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 2 :2Figure 2: Labels indicate whether PLE (P*-) and SDCL (*C-) are on, configurations of one kind have the same line style. Lines for Qute start with Q-, the remaining lines are for DepQBF. The rest of the label is the heuristic; configurations with the same heuristic share colour. Gaps in lines indicate time-outs at 10 minutes. The legend is sorted in descending order of performance; some labels are omitted to save space (at least one of each colour and line style is shown).", "figure_data": ""}, {"figure_label": "4", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "TwinEq n has poly-size QCDCL CUBE+PL refutations. TwinEq n is hard for QCDCL CUBE , this gives us the first separation between QCDCL CUBE+PL and QCDCL CUBE . The other direction can be shown with PLTrap n . Proposition 12. PLTrap n has poly-size QCDCL CUBE refutations. QCDCL CUBE+PL and QCDCL CUBE are incomparable.", "figure_data": "Since Hence we get:Theorem 6."}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_2", "figure_caption": "Theorem 7. QCDCL CUBE+PL is exponentially stronger than QCDCL PL . 7 The QCDCL Systems vs. Q-resolution Beyersdorff and B\u00f6hm [2021] showed incomparability of Qresolution and QCDCL. We now lift this to the other QCDCL variants introduced here. For one separation, we can use the QCNF QParity n from [Beyersdorff et al., 2019b], which have short QCDCL refutations. These formulas have prefix Dx 1 . . . x n @uDt 1 . . . t n and clauses", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_3", "figure_caption": "nu. Theorem 8. QCDCL, QCDCL CUBE , QCDCL PL and QCDCL CUBE+PL are all incomparable to Q-resolution. In detail, the QBFs QParity n have polynomial-size QCDCL, QCDCL CUBE , QCDCL PL , and QCDCL CUBE+PL refutations, but need exponential-size Q-resolution refutations. On the other hand, MirrorCR n have polynomial-size Qresolution refutations, but need exponential-size QCDCL, QCDCL CUBE , QCDCL PL , and QCDCL CUBE+PL refutations.", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "\u03b9 :\" rpT i , C i , \u03c0 i qs m i\"1 ,", "formula_coordinates": [3.0, 131.81, 693.12, 87.38, 12.69]}, {"formula_id": "formula_1", "formula_text": "pt 1 _ . . . _t n q^n \u013e i\"1 ppx i _\u016b i _ t i q^px i _ u i _ t i qq.", "formula_coordinates": [4.0, 63.87, 684.97, 223.25, 22.37]}, {"formula_id": "formula_2", "formula_text": "L i :\"x i _\u016b i _ \u017d n j\"i`1 pu j _\u016b j q _ \u017d i\u00b41 k\"1t k and R i :\" x i _u i _ \u017d n j\"i`1 pu j _\u016b j q_ \u017d i\u00b41", "formula_coordinates": [4.0, 315.0, 226.84, 242.99, 29.08]}, {"formula_id": "formula_3", "formula_text": "U n\u00b41 :\" px 1 , u 1 , t 1 ; . . . ; x n\u00b41 , u n\u00b41 , t n\u00b41 ,t n , x n , Kq,", "formula_coordinates": [4.0, 326.16, 275.04, 220.67, 9.68]}, {"formula_id": "formula_4", "formula_text": "x pi,jq _ u _ a i ,\u0101 1 _ . . . _\u0101 n ,x pi,jq _\u016b _ b j ,b 1 _ . . . _b n x pi,jq _\u016b _\u0101 i , a 1 _ . . . _ a n ,x pi,jq _ u _b j , b 1 _ . . . _ b n for i, j P rns.", "formula_coordinates": [4.0, 315.0, 670.24, 242.5, 34.25]}, {"formula_id": "formula_5", "formula_text": "x 1 _t 1 ,x 1 _ t 1 , u _ t n ,\u016b _t n , x i _ t i\u00b41 _t i , x i _t i\u00b41 _ t i , x i _ t i\u00b41 _ t i ,x i _t i\u00b41 _t i for i P t2, . . . ,", "formula_coordinates": [6.0, 71.18, 225.09, 319.22, 37.55]}], "doi": ""}