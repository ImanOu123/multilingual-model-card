{"title": "Conditional Random Fields for Multi-agent Reinforcement Learning", "authors": "Xinhua Zhang; Douglas Aberdeen; S V N Vishwanathan", "pub_date": "", "abstract": "Conditional random fields (CRFs) are graphical models for modeling the probability of labels given the observations. They have traditionally been trained with using a set of observation and label pairs. Underlying all CRFs is the assumption that, conditioned on the training data, the labels are independent and identically distributed (iid). In this paper we explore the use of CRFs in a class of temporal learning algorithms, namely policygradient reinforcement learning (RL). Now the labels are no longer iid. They are actions that update the environment and affect the next observation. From an RL point of view, CRFs provide a natural way to model joint actions in a decentralized Markov decision process. They define how agents can communicate with each other to choose the optimal joint action. Our experiments include a synthetic network alignment problem, a distributed sensor network, and road traffic control; clearly outperforming RL methods which do not model the proper joint policy.", "sections": [{"heading": "Introduction", "text": "Conditional random fields (CRFs) have been studied in batch settings, where parameters are optimized over a training set; and online settings, where parameters are updated after each iid sample is observed. However, there is little work on CRFs for modelling temporal problems such as control or time-series prediction. The reinforcement learning (RL) community, on the other hand, has done work on decentralized (multiagent) control. RL algorithms optimize a long-term measure of temporally delayed rewards in controlled systems. This paper seeks to improve decentralized RL methods by using CRF models to exploit the structure between agents exhibited in many decentralized RL domains. Examples include sensor networks, traffic routing for roads or networks, pursuer-evader problems, and job-shop scheduling. Bernstein et al. (2000) proved that the complexity of learning optimal coordination in decentralized RL is generally NEXP-hard in the number of agents. The simplest algorithms assume all agents are independent, learning to cooperate implicitly via an appropriate reward function (Bagnell & Ng, 2006). More advanced algorithms explicitly share information about states, values, or proposed actions (Boutilier, 1999), but still avoid modeling the optimal joint policy. Our work is similar to Guestrin et al. (2002), which does model the optimal joint policy, using the underlying structure to factorise Q-values and choose joint actions. In contrast, our approach focuses on directly optimizing a joint probability distribution over preferred actions. Furthermore, we draw on the wealth of approximate inference methods for graphical models, and CRFs in particular, to evaluate and optimize policies that would otherwise be intractable despite the structured representation.\nTraditionally, CRFs use batch training algorithms to learn model p(y|x; \u03b8), the probability of a label y, conditioned on observable variables x with the CRF parameters \u03b8 (Lafferty et al., 2001). During training we iterate through a set of training instances (X, Y ) := ({x i } n i=1 , {y i } n i=1 ), finding \u03b8 * := arg max \u03b8 p(\u03b8|X, Y ). To predict the label for a novel observation x we select y := arg max y p(y|x ; \u03b8 * ). In this paper, we show that the same inference methods used for CRFs can be used to sample node actions from a joint stochastic RL policy. We also show how to optimize this joint policy by estimating the gradients of the long-term reward with respect to the policy parameters. Similar methods could be used for RL policies based on arbitrary graphical models. From the CRF point of view, we propose a method of using CRFs for modeling temporal processes. Section 2 and Section 3 are devoted to describing graphical models and reinforcement learning respectively, with particular emphasis on CRFs and policygradient methods for RL. We then elaborate on the combination of CRF and RL in Section 4. Section 5 describes our experiments before concluding.", "publication_ref": ["b4", "b2", "b5", "b8", "b10"], "figure_ref": [], "table_ref": []}, {"heading": "Conditional Random Fields", "text": "CRFs are a probabilistic framework for labeling and segmenting data.\nUnlike hidden Markov models (HMMs) and Markov random fields (MRFs), which model the joint density p(x, y) over inputs x and labels y, CRFs directly model p(y|x) for a given input observation x. Furthermore, instead of maintaining a per-state normalisation, which leads to the so-called label bias problem, CRFs use a global normalisation that allows them to take global interactions into account (Lafferty et al., 2001). We now introduce conditional exponential families, and describe CRFs as a special instance of conditional exponential family.", "publication_ref": ["b10"], "figure_ref": [], "table_ref": []}, {"heading": "Conditional Exponential Families", "text": "Given observation x \u2208 X , a conditional exponential family (CEF) distribution over labels y \u2208 Y (we assume all spaces are finite), parameterized by the natural parameter \u03b8 \u2208 R d , can be written in its canonical form as p(y|x; \u03b8) = exp( \u03c6(x, y), \u03b8 \u2212 g(\u03b8|x)).\n(1)\nHere, vector \u03c6(x, y) is the sufficient statistics of the distribution p(y|x; \u03b8), \u2022, \u2022 denotes the inner product, and g(\u2022) is the log-partition function for normalization:\ng (\u03b8|x) := ln y\u2208Y exp( \u03c6(x, y), \u03b8 ) (2)\nIt is known that the log-partition function is also the cumulant generating function of the CEF\n\u2202g(\u03b8|x)/\u2202\u03b8 = E p(y|x;\u03b8) [\u03c6(x, y)].(3)\nThe sufficient statistics \u03c6(x, y) (also called potentials) represent salient features of the input observations, and typically depend on the applications and CRF design.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Clique Decomposition Theorem", "text": "More generally, we consider the structured output case where y \u2208 Y m (m nodes). The clique decom-position theorem essentially states that if the conditional density p(y|x; \u03b8) factorizes according to a graph G = (V, E) on y, then the sufficient statistics \u03c6(x, y) decompose into terms over the maximal cliques Altun et al., 2004):\nC = {c 1 , . . . , c n } of G (\n\u03c6(x, y) = vec{\u03c6 c (x, y c )|c \u2208 C} (4) p(y|x; \u03b8) = exp c\u2208C \u03c6 c (x, y c ), \u03b8 c \u2212 g(\u03b8|x) , (5\n)\nwhere the vec operator concatenates vectors, c indexes the set of maximal cliques C, and y c is the label configuration for nodes in clique c. For convenience, we will assume that all maximal cliques have size two, i.e., an edge between nodes i and j has a feature \u03c6 ij associated with it. We will also associate potentials \u03c6 i to single nodes i. Node features represent the observation of state available at each node. The edge features encode the communication between nodes about their features and potential actions.\nCRFs are examples of conditional exponential families with special graphs. For 1-D CRFs, the graph is a chain, so the edge features are \u03c6 i,i+1 (x, y i , y i+1 ). For 2-D grid CRFs, the edge features are \u03c6 iji j (x, y ij , y i j ) where nodes are indexed by double coordinates and |i \u2212 i | + |j \u2212 j | = 1.", "publication_ref": ["b0"], "figure_ref": [], "table_ref": []}, {"heading": "Inference and Gradient Computations", "text": "CRF training procedures usually minimize the negative log-posterior of the parameters given the observation/label training set. As we will see in Section 3.1, policy-gradient algorithms instead draw samples from (5) given the parameters \u03b8 and most recent observation x. This involves computing the logpartition function, which can be done efficiently by exploiting the clique structure\nexp(g(\u03b8|x)) = y\u2208Y m c\u2208C exp( \u03c6 c (x, y c ), \u03b8 c ). (6\n)\nPolicy-gradient algorithms also require the gradient of the log probability of sampled labels/actions\u1ef9\n\u2202 \u2202\u03b8 ln p(\u1ef9|x; \u03b8) = \u2202 \u2202\u03b8 c\u2208C \u03c6 c (x,\u1ef9 c ), \u03b8 c \u2212 g(\u03b8|x) = vec{\u03c6 c (x,\u1ef9 c ) \u2212 E p(y|x;\u03b8) [\u03c6 c (x, y c )] |c \u2208 C}, (7\n)\nwhere the last step exploits (4) and (3). Let z be the constant normalisation term exp(g(\u03b8|x)), then the expected sufficient statistics for a fixed clique c is 1\nE p(y|x;\u03b8) [\u03c6 c (x, y c )] = y\u2208Y m \u03c6 c (x, y c )p(y|x; \u03b8) = z \u22121 y\u2208Y m \u03c6 c (x, y c ) exp c\u2208C \u03c6 c (x, y c ), \u03b8 c = z \u22121 y\u2208Y m c\u2208C\u03c6 c c (x, y c ) exp \u03c6 c (x, y c ), \u03b8 c , (8\n)\nwhere\u03c6 c c (x, y c ) := \u03c6 c (x, y c ) if c = c\n, and a vector of ones otherwise. Note that both (6) and ( 8) are in the familiar sum-product form, which can be computed exactly by belief propagation (BP) (e.g., Chapter 26 of MacKay, 2003). This has time complexity O(N |Y| w+1 ), where N is the number of nodes and w is the tree width of the graph, i.e., the size of its largest clique minus 1 after the graph is optimally triangulated. For trees and 1-D CRFs (chains), w = 1, so that calculating (8) directly is feasible. However, for more general cases like 2-D CRFs (grids), the tree width w is prohibitively high, and one has to resort to approximate approaches, e.g., sampling and variational methods. We now briefly describe one such method used in our experiments.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Tree MCMC Sampler for CRFs", "text": "The tree Markov chain Monte Carlo (MCMC) sampler of Hamze & de Freitas (2004) is a state-of-the-art algorithm for sampling from posterior distributions and computing expectations of sufficient statistics in undirected graphical models with regular structure and high tree width. Its basic form works on pairwise MRFs or CRFs whose cliques are either nodes or edges.\nThe algorithm exploits the property that MRFs can be split into several disjoint trees (see Figure 1 for four different choices of partitions). Although BP on the whole MRF is prohibitively expensive, it is cheap to run BP on each of the two trees (their tree width w = 1). So a natural idea is to combine analytical and sampling steps: conditioned on a sample of one of the trees, use BP to compute the exact joint conditional distribution of the other tree and draw a sample from it; then alternate between the two trees. Moreover, knowing the exact conditional distribution over the trees makes it possible to Rao-Blackwellise the sampler to reduce the variance (Casella & Robert, 1996). Each partition of the tree has to exclude some edges. In order to reduce the variance in the expectation es-timates of these edges, and to cover all edges in the graph, we need to partition the graph in several different ways. This leads to the four partitions in Figure 1.  Empirically tree sampling is considerably more efficient than other partition based sampling schemes and the na\u00efve Gibbs sampler, and with provable faster geometric convergence rate and lower variance (Hamze & de Freitas, 2004). ", "publication_ref": ["b9", "b6", "b9"], "figure_ref": ["fig_2", "fig_2"], "table_ref": []}, {"heading": "Reinforcement Learning", "text": "We assume an average reward setting where the task is to find a policy, or equivalently the parameter \u03b8, which maximizes R(\u03b8) := lim\nT \u2192\u221e 1 T E \u03b8 T \u22121 t=0 r(s t ) ,(10)\nThe expectation E \u03b8 is over the distribution of state trajectories {s 0 , s 1 , . . . } induced by P (\u03b8).\nThe core idea of this paper is to treat CRF distributions over labels, p(y|x; \u03b8), exactly as joint distributions over multi-agent RL actions, i.e., a stochastic policy. Each node in the CRF will represent a single RL agent. The joint stochastic policy will give the probability of a vector of actions p(y|x; \u03b8). The observations available to agent/node i are represented by the sufficient statistics \u03c6 i (x, y i ). However, we also need the edge \"observations\" \u03c6 ij (x, y i , y j ) to represent the information that can be communicated between neighboring agents i and j. Thus all we need for a CRF-RL model is a family of RL algorithms that directly optimizes stochastic policies.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Policy-Gradient Algorithms", "text": "Policy-gradient (PG) algorithms optimize polices by performing gradient ascent on a parameterized policy (Williams, 1992;Sutton et al., 2000;Baxter & Bartlett, 2001). These algorithms require only a parameterized and differentiable policy model p(y|x; \u03b8), and a way to compute the gradient of the long-term reward R(\u03b8).\nA number of algorithms (Williams, 1992;Baxter & Bartlett, 2001;Peters et al., 2005) compute a Monte Carlo approximation of the reward gradient: the agent interacts with the environment, producing an observation, action, reward sequence {x 1 , y 1 , r 1 , x 2 , . . . , x T , y T , r T }. 2 For example, under mild technical assumptions, including ergodicity and bounding all the terms involved, Baxter & Bartlett (2001) obtain\n\u2202R \u2202\u03b8 = 1 T T \u22121 t=0 \u2202 \u2202\u03b8 ln p(y t |x t ; \u03b8) T \u03c4 =t+1 \u03b2 \u03c4 \u2212t\u22121 r \u03c4 , (11\n)\nwhere an eligibility discount \u03b2 \u2208 [0, 1) implicitly assumes that rewards are exponentially more likely to be due to recent actions. Without it, rewards would be assigned over a potentially infinite horizon, resulting in gradient estimates with infinite variance. As \u03b2 decreases, so does the variance, but the bias of the gradient estimate increases (Baxter & Bartlett, 2001). In practice, (11) and all other policy-gradient algorithms share the same core estimator that make use of an eligibility trace\ne t = \u03b2e t\u22121 + \u2202 \u2202\u03b8 \u03b8=\u03b8t ln p (y t |x t ; \u03b8)(12)\nNow \u03b4 t = r t e t is the gradient of R(\u03b8) arising from assigning the instantaneous reward to all log proba-bility gradients, where \u03b2 \u2208 [0, 1) gives exponentially more credit to recent actions. Additionally, \u03b2 may be 1.0 for finite-horizon problems (Williams, 1992). The different policy-gradient algorithms vary in how they use instant gradient estimates \u03b4 t .\nFor the experiments in this paper we adopt an online variation of the natural actor-critic (NAC) algorithm (Peters et al., 2005;Richter et al., 2007). While the NAC algorithm uses the estimator (12), it improves performance over (11) by: 1) using a critic that approximates a projection of value function, with discount factor \u03b3 \u2208 [0, 1), to reduce variance of the gradient estimates; 2) using a clever choice of critic parametrization to naturalize gradients (Amari, 1998); and 3) using a least squares approach to solve for the naturalized gradients, making full use of simulated trajectories. Algorithm 1 is used in our experiments (Richter et al., 2007).\nAlgorithm 1 Online Natural Actor-Critic.\n1: t = 1, A \u22121 1 = I, \u03b8 1 = [0], e 1 = [0] 2: \u03b1=step size, \u03b3=critic discount, \u03b2=actor discount 3: Get observation x 1 4: while not converged do 5: Sample action\u1ef9 t \u223c p(\u2022|x t , \u03b8 t ) 6: e t = \u03b2e t\u22121 + [ \u2202 \u2202\u03b8 \u03b8=\u03b8t ln p (\u1ef9 t |x t ; \u03b8) , x t ] 7:\nDo actions\u1ef9 t 8:\nGet reward r t 9:\n\u03b4 t = r t e t 10:\nGet observation x t+1 11:\nw t = [ \u2202 \u2202\u03b8 \u03b8=\u03b8t ln p(\u1ef9 t |x t , \u03b8) , x t ] \u2212\u03b3[0 , x t+1 ] 12: t = 1 \u2212 t \u22121 13: u t = ( \u22121 t \u2212 1)A \u22121 t\u22121 e t 14: q t = \u22121 t w t A \u22121 t\u22121 15: A \u22121 t = \u22121 t A \u22121 t\u22121 \u2212 utq t 1+q t et 16: [d t , v t ] = A \u22121 t \u03b4 t 17: \u03b8 t+1 = \u03b8 t + \u03b1d t 18: t \u2190 t + 1 19: end while 3.2. Decentralized Multi-Agent RL Decentralized (PO)\nMDPs assume a number of agents, each with a local observation of the state space. Here the action y becomes a vector giving the action for each agent. In the general case, optimal decision making in Decentralized MDPs is NEXP-hard in the number of agents (Bernstein et al., 2000), due to the combinatorial degree of communication required between the agents to coordinate actions. Many approximate approaches exist including no communication (Peshkin et al., 2000); explicit actions to communicate state in-formation (Boutilier, 1999); local sharing of value functions (Schneider et al., 1999); and others with varying degrees of formalism. Under a common global reward, and some forms of local reward (Bagnell & Ng, 2006), agents that do not communicate can learn to cooperate implicitly to maximize the global reward (Boutilier, 1999). However, unless each agent has access to the full state description, they will generally not be able to act optimally. Our contribution is to introduce a mechanism for agents to efficiently -due to the graph structure of the CRF -communicate in order to converge to a joint policy. Our choice of policy-gradient algorithms is motivated by their ease of integration with CRFs, but they have the additional benefit of being guaranteed to converge (possibly to a poor local maximum) despite the use of function approximation and partial observability. Our model of multi-agent learning is similar to Guestrin et al. (2002), which uses an exact form of BP for factorising Q-values and choosing jointly optimal actions, and hence may still be intractable for high tree width graphs.", "publication_ref": ["b18", "b16", "b3", "b18", "b3", "b13", "b3", "b3", "b18", "b13", "b14", "b1", "b14", "b4", "b12", "b5", "b15", "b2", "b5", "b8"], "figure_ref": [], "table_ref": []}, {"heading": "Conditional Random Fields for RL", "text": "Applying CRFs for distributed RL is relatively straightforward: simply assume that the policy, P (y|x; \u03b8), of the POMDP factorizes according to a CRF. The agents correspond to the label nodes, and the edges encode the spatial or temporal collaboration between agents. In order to apply PG methods one needs: a) the ability to draw an action from the policy model (step 5 of Algorithm 1, and Eqns. (5),( 6)); and b) computation of the gradient of the log-probability of the sampled action (step 6,11 and Eqns. ( 7),( 8)). Efficient implementations rely on approximate sampling algorithms like the tree MCMC sampler described in Section 2.4. One can also easily verify that exponential families in general, and CRFs in particular, satisfy the mild technical conditions required for PG methods to converge, as long as all features are bounded. Interestingly, the CEF policy representation (1) implements exactly the soft-max stochastic policy with linear feature combinations commonly encountered in RL applications, e.g., Richter et al. (2007). Only the edge features prevent the trivial factorization of the distribution into independent agents that was demonstrated by Peshkin et al. (2000).\nFrom the perspective of multi-agent RL, CRFs make efficient decentralized RL possible. By using conditional independence assumptions, the search space of the policy-gradient methods factorizes, leading to faster learning. Also, even though a CRF requires only local connections between agents, global interactions are still incorporated by belief propagation.\nFrom a graphical models point of view, our technique is different from the usual online or offline training methods in two important ways. The training data is no longer iid. The action at time-step t stochastically determines the input at time-step t + 1. Furthermore, the evaluation metric is no longer a loss function but a reward function that depends on both the current state.\nSuperficially, our setup looks similar to dynamic Bayesian networks (DBNs). DBNs are directed graphical models (in contrast to CRFs which are undirected graphical models) used to represent models that evolve with time. Typically DBNs are used for a) filtering: monitor the hidden system state s over time by computing p(s t |x 1 . . . x t ); b) prediction: computing p(s t+1 |x 1 . . . x t ); or c) smoothing: computing p(s t\u22121 |x 1 . . . x t ). In an RL context DBNs have been used to estimate the state transition matrix P (y), as well as the distribution p(x|s), in order to resolve partial observability in a POMDP (Theocharous et al., 2004). In contrast, we use CRFs as a policy, rather than as a state transition model.\nWe have shown how to learn reactive policies that ignore the fact that the true MDP state is unknown. Fortunately, PG methods still converge in this case. To take partial observability into account we could encode observation history, or a belief state (if P (y) and p(x|s) are known), into the sufficient statistics.", "publication_ref": ["b14", "b12", "b17"], "figure_ref": [], "table_ref": []}, {"heading": "Experimental Results", "text": "We performed experiments on one toy domain to demonstrate why a joint policy is important, and two benchmark decentralized RL domains.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Grid Alignment", "text": "We constructed an abstract traffic domain, where it was known that agents would have to coordinate their actions in order to perform well, even in the case of a common global reward. Traffic flows along the edges of an n\u00d7n grid, always traversing to the opposite edge of the grid without turning (see Figure 2). Each intersection grid lines is an agent that controls a gate. The actions of a gate allow traffic to flow vertically or horizontally at each time step. Traffic units arrive with Pr=0.5 per time step per boundary node (but only the top and left boundaries). Importantly, traffic cannot flow until all the gates on the traffic's path line up. When this happens, all waiting traffic for that line propagates through instantly and each unit of traffic contributes +1 to a global reward. One or more  if the two nodes agree on an alignment, 0 otherwise. The optimal policy is for the all the n 2 gates to align in the orientation of the most waiting traffic, but since each node only knows how many traffic units are waiting for it, it must \"negotiate\" with neighbors on which way to align.\nLearning Parameters: The CRF model is a 2-D grid, with nodes for each agent, and edges for all nodes connected by a grid line. Due to the 2-D nature of the CRF, MCMC estimation of the log partition function, and its gradient were required. MCMC estimation needed 10 tree samples. To initialize the tree sampler, we randomly picked a spanning tree of the whole graph and sampled from the tree. Empirically, this allows us to obtain a good estimation of the distributions much faster than starting with independent node randomization. Other parameters, including the number of independent learning runs, are summarized in Table 1. To prevent poor local maxima when n > 5 we needed step sizes for edge feature parameters \u03b1 edge to be larger than for node feature parameters \u03b1 node , boosting the effect of edge features on the policy.", "publication_ref": [], "figure_ref": ["fig_4"], "table_ref": ["tab_0"]}, {"heading": "Results:", "text": "The optimal reward is the grid size n. Figure 3 shows the CRF RL approach compared to a na\u00efve implementation with independent agents. The CRF approach obtains the optimal reward all the way to grid size 10 (100 nodes), at which point some runs fail to reach the optimal policy. The number of iterations required to reach the optimal reward for the first time is shown on the right panel.", "publication_ref": [], "figure_ref": ["fig_5"], "table_ref": []}, {"heading": "Sensor Networks", "text": "The distributed sensor network (DSN) problem is a sequential decision making variant of the distributed constraint optimization problem described in Dutech et al. (2005). The network consists of two parallel chains of an arbitrary, but equal, number of sensors. The area between the sensors is divided into cells. Each cell is surrounded by four sensors and can be occupied by a target. With equal probability targets can (from left to right) jump to the cell to its left, to its right, or remain where it is. Jumps that would cause a collision are not executed. The goal of the sensors to capture all targets. With initial configuration as in Figure 4, there are 37 distinct states. Each sensor can perform three actions resulting in a joint action space of 3 8 = 6561 actions. The actions are: track a target in the cell to the left, cell to the right, or none. Every track action has a reward of -1. When in one time step at least three of the four surrounding sensors track a target, it is hit and its energy level is decreased by 1. Each target starts with an energy level of 3. When it reaches 0 the target is captured and removed. The three sensors involved in the capture are each provided with a reward of +10, and the goal is to maximize the total reward of all sensors. An epoch finishes when all targets are captured. If the DSN cannot capture all targets within 300 steps, the epoch is terminated, and a new epoch is started. A set of 50 randomly chosen initial states (with replacement) is cycled through for one episode. We run for 200 episodes and study the average reward of each episode. Finally, the whole process is independently repeated for 100 runs, and we report the average optimal reward and number of episodes.\nLearning Parameters: We experimented with two alternative CRF models, a cycle in which neighboring sensors along the top and bottom are connected as chains, and the cycle is completed with an edge between top and bottom sensors on the left and right ends. The chain is a more complex arrangement. Local sensors are bunched into groups of three (one top sensor, two bottom sensors and vice/versa). These meta-sensors form one CRF node. All the metasensors are connected in a 1-D chain, so ( 6) and ( 8) can efficiently estimate the log-partition function and its gradient.\nEach node (or meta-node) has access to whether there is a target in its left and right cells (two binary values with two dummy cells at the two ends always observing no target). For the chain topology, the single edge feature is whether there are at least three out of four sensors focusing on their common cell. For the cycle topology, a single edge feature encodes whether connected sensors are focused on the same cell.\nResults: The problem in Figure 4 has an optimal long-term average reward of 42. The best results from Dutech et al. (2005) use a distributed Q-learning approach where neighbors' Q-values are averaged (which implicitly assumes communication), achieving an average reward of less than 30. Figure 5 shows that CRF modeling with NAC achieves the optimal reward for this problem, and problems where the number of targets is increased up to 10. The ease with which we outperform the distributed Q-learning approach is not surprising, since the CRF allows sensors to agree on which target to focus on. We obtain similarly good results when the number of targets is fixed and more cells are added (Figure 6). The curious peak in the required iterations for 5 cells corresponds to the difficult situation where there are not enough sensors, and targets are able to jump around with few collisions. Adding more cells also adds more sensors, so that an individual sensor is rarely required to focus left and right at the same time. In both experiments the chain CRF does marginally better, probably due to the tighter coupling of the sensors and exact evaluation of the log-partition function.", "publication_ref": ["b7", "b7"], "figure_ref": ["fig_6", "fig_6", "fig_8", "fig_10"], "table_ref": []}, {"heading": "Traffic Light Control", "text": "Many drivers have been frustrated by driving along a main street, to be constantly interrupted by red lights. This domain demonstrates learning an offset between neighboring intersections. The domain and simulator    code are from Richter et al. (2007), which contains the full implementation details. We model one main road with n controlled intersections and n + 1 road links to traverse. It takes cars 2 time units to travel down a road to the next intersection. There are 4 actions, corresponding to the 4 traffic signal patterns that allow traffic to move through the intersection safely in any direction. For this experiment only the action that lets traffic drive straight ahead along the main road is useful. At each time step (about 5 seconds of real-time) the controller decides on the action for the next step. We do not restrict the order of actions, but importantly, we enforce the constraint that all actions must be activated at least once within 8 time steps so that vehicles on side streets would not wait forever. One car enters the leftmost end of the road every 4 time steps. We use realistic local rewards for each intersection: each intersection has an inductive loop sensor that can sense a car waiting, producing a -1 reward.\nLearning Parameters: Each intersection is a CRF node that chooses from one of the four actions. For independent learners the only feature is a constant bias bit that allows learning of which phase is the most commonly used. No node features were given to the CRF. The edge features for the CRF version are an a \u00d7 a binary matrix, where a is the number of actions. Bit i, j is on if the action of the left neighbor i from 2 time steps ago (the time required to drive down the road edge) matches the chosen action of the current intersection j. Edge parameters receive j's reward.  3 4 5 6 7 8 9 10 11 12 13 14  0   0 The edge feature matrix has exactly 1 bit set to true in the matrix in any step. Typically a road traffic network would be represented as an undirected graph. But this simple scenario is one long road, thus can be represented as a chain CRF.\nResults: Figure 7 shows the results on the road traffic domain in the same style as previous results. Again, the CRF model clearly outperforms the independent agents approach. We observed, however, that early in learning both the independent agents and CRF learn that all traffic moves left to right. Giving the maximum possible time to this direction is a strong local minimum. After that, the independent agents fail to improve but the CRF model asymptotically approaches the optimal 0 waiting time.\nFigure 8 shows convergence plots for the CRF approach versus the independent agents.", "publication_ref": ["b14"], "figure_ref": [], "table_ref": ["tab_0"]}, {"heading": "Conclusions", "text": "We have shown how to use CRFs to model control processes, or equivalently, how decentralized RL can be performed with CRF optimisation methods. Although all our examples have been related to controlling a process, a special case is where rewards are given simply for predicting the next input, i.e., time series prediction. From a reinforcement learning point of view we have presented an efficient policy-gradient solution to the difficult problem of optimizing joint actions in a decentralised (PO)MDP. Future work could explore RL in general graphical models, and how local rewards may be propagated through a graphical model.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgements", "text": "NICTA is funded by the Australian Government's Backing Australia's Ability program and the Centre of Excellence program.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Exponential families for conditional random fields", "journal": "AUAI Press", "year": "2004", "authors": "Y Altun; A Smola; T Hofmann"}, {"ref_id": "b1", "title": "Natural gradient works efficiently in learning", "journal": "Neural Computation", "year": "1998", "authors": "S.-I Amari"}, {"ref_id": "b2", "title": "On local rewards and scaling distributed reinforcement learning", "journal": "", "year": "2006", "authors": "J Bagnell; A Ng"}, {"ref_id": "b3", "title": "Infinite-horizon policygradient estimation", "journal": "JAIR", "year": "2001", "authors": "J Baxter; P Bartlett"}, {"ref_id": "b4", "title": "The complexity of decentralized control of Markov decision processes", "journal": "", "year": "2000", "authors": "D Bernstein; R Givan; N Immerman; S Zilberstein"}, {"ref_id": "b5", "title": "Sequential optimality and coordination in multiagent systems", "journal": "", "year": "1999", "authors": "C Boutilier"}, {"ref_id": "b6", "title": "Rao-Blackwellisation of sampling schemes", "journal": "Biometrika", "year": "1996", "authors": "G Casella; C Robert"}, {"ref_id": "b7", "title": "Proc of reinforcement learning benchmarks and bake-offs II", "journal": "", "year": "2005", "authors": "A Dutech"}, {"ref_id": "b8", "title": "Coordinated reinforcement learning", "journal": "", "year": "2002", "authors": "C Guestrin; M Lagoudakis; R Parr"}, {"ref_id": "b9", "title": "From fields to trees", "journal": "", "year": "2004", "authors": "F Hamze; N De Freitas"}, {"ref_id": "b10", "title": "Conditional random fields: Probabilistic modeling for segmenting and labeling sequence data", "journal": "", "year": "2001", "authors": "J Lafferty; A Mccallum; F Pereira"}, {"ref_id": "b11", "title": "Information Theory, Inference, and Learning Algorithms", "journal": "Cambridge Univ. Press", "year": "2003", "authors": "D Mackay"}, {"ref_id": "b12", "title": "Learning to cooperate via policy search", "journal": "", "year": "2000", "authors": "L Peshkin; K.-E Kim; N Meuleau; L Kaelbling"}, {"ref_id": "b13", "title": "Natural actor-critic", "journal": "", "year": "2005", "authors": "J Peters; S Vijayakumar; S Schaal"}, {"ref_id": "b14", "title": "Natural actorcritic for road traffic optimization", "journal": "", "year": "2007", "authors": "S Richter; D Aberdeen; J Yu"}, {"ref_id": "b15", "title": "Distributed value functions", "journal": "", "year": "1999", "authors": "J Schneider; W.-K Wong; A Moore; M Riedmiller"}, {"ref_id": "b16", "title": "Policy gradient methods for reinforcement learning with function approximation", "journal": "", "year": "2000", "authors": "R Sutton; D Mcallester; S Singh; Y Mansour"}, {"ref_id": "b17", "title": "Representing hierarchical POMDPs as DBNs for multi-scale robot localization", "journal": "", "year": "2004", "authors": "G Theocharous; K Murphy; L Kaelbling"}, {"ref_id": "b18", "title": "Simple statistical gradient-following algorithms for connectionist reinforcement learning. Machine Learning", "journal": "", "year": "1992", "authors": "R Williams"}], "figures": [{"figure_label": "", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Appearing in Proceedings of the 24 th International Conference on Machine Learning, Corvallis, OR, 2007. Copyright 2007 by the author(s)/owner(s).", "figure_data": ""}, {"figure_label": "1", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Figure 1 :1Figure 1: Four different partitions of a 5-by-6 CRF. Nodes in shaded and white regions are the two trees and the small black circles represent observations.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "AMarkov decision process (MDP) consists of a finite set of states s \u2208 S of the world, actions y \u2208 Y available to the agent in each state, and a reward function r(s) for each state s. In a partially observable MDP (POMDP), the controller sees only an observation x \u2208 X of the current state, sampled stochastically from an unknown distribution p(x|s). Each action y determines a stochastic matrix P (y) = [p(s |s, y)] of transition probabilities from state s to state s given action y. The methods discussed in this paper do not assume explicit knowledge of P (y) or of the observation process. All policies are stochastic, with a probability of choosing action y given state s, and parameters \u03b8 \u2208 R n of p(y|x; \u03b8). The evolution of the state s is Markovian, governed by an |S| \u00d7 |S| transition probability matrix P (\u03b8) = [p(s |s; \u03b8)] with entries p (s |s; \u03b8) = y\u2208Y p (y|s; \u03b8) p (s |s, y).", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "Figure 2 :2Figure 2: Abstract grid alignment domain.", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_5", "figure_caption": "Figure 3 :3Figure 3: Average reward over the last 1000 steps, and iterations to optimality.", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_6", "figure_caption": "Figure 4 :4Figure 4: Sensor network domain with 8 sensors, 2 targets, and 3 cells.", "figure_data": ""}, {"figure_label": "5", "figure_type": "figure", "figure_id": "fig_8", "figure_caption": "Figure 5 :5Figure 5: Results over 100 runs of the Sensor Network scenario, varying the number of targets.", "figure_data": ""}, {"figure_label": "6", "figure_type": "figure", "figure_id": "fig_10", "figure_caption": "Figure 6 :6Figure 6: Results over 100 runs of the Sensor Network scenario, varying the number of cells.", "figure_data": ""}, {"figure_label": "78", "figure_type": "figure", "figure_id": "fig_12", "figure_caption": "Figure 7 :Figure 8 :78Figure7: Results over 50 runs of the road traffic offset scenario. The X-axis is intersections. The left Y-axis is the travel time.", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "Learning algorithm parameters.", "figure_data": "Domain \u03b1 ind\u03b1 node \u03b1 edge\u03b2\u03b3 runsGrid.002 .00001.002 0.60.5100DSN.0005 .00025 .0005 0.60.5100Traffic.001N/A.01 0.9 0.9550misaligned gates blocks traffic, causing the length 10buffer to fill up as traffic arrives. Full buffers droptraffic. Two observations per node indicate the nor-malised number of traffic units waiting for the node toalign vertically, and horizontally. Edge features are 1"}], "formulas": [{"formula_id": "formula_0", "formula_text": "g (\u03b8|x) := ln y\u2208Y exp( \u03c6(x, y), \u03b8 ) (2)", "formula_coordinates": [2.0, 93.0, 541.04, 196.45, 14.17]}, {"formula_id": "formula_1", "formula_text": "\u2202g(\u03b8|x)/\u2202\u03b8 = E p(y|x;\u03b8) [\u03c6(x, y)].(3)", "formula_coordinates": [2.0, 101.6, 596.54, 187.84, 9.96]}, {"formula_id": "formula_2", "formula_text": "C = {c 1 , . . . , c n } of G (", "formula_coordinates": [2.0, 307.44, 118.04, 99.08, 9.65]}, {"formula_id": "formula_3", "formula_text": "\u03c6(x, y) = vec{\u03c6 c (x, y c )|c \u2208 C} (4) p(y|x; \u03b8) = exp c\u2208C \u03c6 c (x, y c ), \u03b8 c \u2212 g(\u03b8|x) , (5", "formula_coordinates": [2.0, 315.13, 139.23, 226.32, 45.1]}, {"formula_id": "formula_4", "formula_text": ")", "formula_coordinates": [2.0, 537.2, 164.27, 4.24, 8.74]}, {"formula_id": "formula_5", "formula_text": "exp(g(\u03b8|x)) = y\u2208Y m c\u2208C exp( \u03c6 c (x, y c ), \u03b8 c ). (6", "formula_coordinates": [2.0, 322.87, 542.8, 214.33, 20.09]}, {"formula_id": "formula_6", "formula_text": ")", "formula_coordinates": [2.0, 537.2, 542.83, 4.24, 8.74]}, {"formula_id": "formula_7", "formula_text": "\u2202 \u2202\u03b8 ln p(\u1ef9|x; \u03b8) = \u2202 \u2202\u03b8 c\u2208C \u03c6 c (x,\u1ef9 c ), \u03b8 c \u2212 g(\u03b8|x) = vec{\u03c6 c (x,\u1ef9 c ) \u2212 E p(y|x;\u03b8) [\u03c6 c (x, y c )] |c \u2208 C}, (7", "formula_coordinates": [2.0, 320.61, 618.05, 216.59, 72.96]}, {"formula_id": "formula_8", "formula_text": ")", "formula_coordinates": [2.0, 537.2, 681.05, 4.24, 8.74]}, {"formula_id": "formula_9", "formula_text": "E p(y|x;\u03b8) [\u03c6 c (x, y c )] = y\u2208Y m \u03c6 c (x, y c )p(y|x; \u03b8) = z \u22121 y\u2208Y m \u03c6 c (x, y c ) exp c\u2208C \u03c6 c (x, y c ), \u03b8 c = z \u22121 y\u2208Y m c\u2208C\u03c6 c c (x, y c ) exp \u03c6 c (x, y c ), \u03b8 c , (8", "formula_coordinates": [3.0, 68.67, 113.43, 216.53, 77.5]}, {"formula_id": "formula_10", "formula_text": ")", "formula_coordinates": [3.0, 285.2, 170.86, 4.24, 8.74]}, {"formula_id": "formula_11", "formula_text": "where\u03c6 c c (x, y c ) := \u03c6 c (x, y c ) if c = c", "formula_coordinates": [3.0, 55.44, 210.27, 176.36, 12.19]}, {"formula_id": "formula_13", "formula_text": "T \u2192\u221e 1 T E \u03b8 T \u22121 t=0 r(s t ) ,(10)", "formula_coordinates": [3.0, 391.92, 685.21, 149.52, 30.2]}, {"formula_id": "formula_14", "formula_text": "\u2202R \u2202\u03b8 = 1 T T \u22121 t=0 \u2202 \u2202\u03b8 ln p(y t |x t ; \u03b8) T \u03c4 =t+1 \u03b2 \u03c4 \u2212t\u22121 r \u03c4 , (11", "formula_coordinates": [4.0, 64.96, 477.86, 220.06, 30.2]}, {"formula_id": "formula_15", "formula_text": ")", "formula_coordinates": [4.0, 285.01, 488.27, 4.43, 8.74]}, {"formula_id": "formula_16", "formula_text": "e t = \u03b2e t\u22121 + \u2202 \u2202\u03b8 \u03b8=\u03b8t ln p (y t |x t ; \u03b8)(12)", "formula_coordinates": [4.0, 94.9, 636.74, 194.54, 24.86]}, {"formula_id": "formula_17", "formula_text": "1: t = 1, A \u22121 1 = I, \u03b8 1 = [0], e 1 = [0] 2: \u03b1=step size, \u03b3=critic discount, \u03b2=actor discount 3: Get observation x 1 4: while not converged do 5: Sample action\u1ef9 t \u223c p(\u2022|x t , \u03b8 t ) 6: e t = \u03b2e t\u22121 + [ \u2202 \u2202\u03b8 \u03b8=\u03b8t ln p (\u1ef9 t |x t ; \u03b8) , x t ] 7:", "formula_coordinates": [4.0, 312.23, 316.52, 226.08, 82.5]}, {"formula_id": "formula_18", "formula_text": "w t = [ \u2202 \u2202\u03b8 \u03b8=\u03b8t ln p(\u1ef9 t |x t , \u03b8) , x t ] \u2212\u03b3[0 , x t+1 ] 12: t = 1 \u2212 t \u22121 13: u t = ( \u22121 t \u2212 1)A \u22121 t\u22121 e t 14: q t = \u22121 t w t A \u22121 t\u22121 15: A \u22121 t = \u22121 t A \u22121 t\u22121 \u2212 utq t 1+q t et 16: [d t , v t ] = A \u22121 t \u03b4 t 17: \u03b8 t+1 = \u03b8 t + \u03b1d t 18: t \u2190 t + 1 19: end while 3.2. Decentralized Multi-Agent RL Decentralized (PO)", "formula_coordinates": [4.0, 307.44, 436.41, 227.01, 172.98]}], "doi": ""}