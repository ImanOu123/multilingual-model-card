{"title": "A Simple Prior-free Method for Non-Rigid Structure-from-Motion Factorization", "authors": "Yuchao Dai; Hongdong Li; Mingyi He", "pub_date": "", "abstract": "This paper proposes a simple \"prior-free\" method for solving non-rigid structure-from-motion factorization problems. Other than using the basic low-rank condition, our method does not assume any extra prior knowledge about the nonrigid scene or about the camera motions. Yet, it runs reliably, produces optimal result, and does not suffer from the inherent basis-ambiguity issue which plagued many conventional nonrigid factorization techniques. Our method is easy to implement, which involves solving no more than an SDP (semi-definite programming) of small and fixed size, a linear Least-Squares or trace-norm minimization. Extensive experiments have demonstrated that it outperforms most of the existing linear methods of nonrigid factorization. This paper offers not only new theoretical insight, but also a practical, everyday solution, to non-rigid structure-from-motion. 1", "sections": [{"heading": "Introduction", "text": "This paper revisits the classical geometric computer vision problem of non-rigid structure-from-motion (NRSFM). We focus on the factorization framework for NRSFM, originally proposed by Bregler et al. in [7], as an important extension to the well-known Tomasi-Kanade factorization from rigid scene to nonrigid scene, assuming that the nonrigid shape deformation follows a low-order linear combination model. To date, a large body of researches has been devoted to this topic, and numerous different methods/algorithms have been proposed. However, despite all the efforts, this problem remains a difficult and still active research topic (see e.g., [5,11,25,21,3,14]).\nOne of the primary causes to such difficulty is due to the inherent basis ambiguity of the nonrigid problem ( [26]). To overcome this, most existing work rely on introducing various prior knowledge to the problem at hand. They do so by assuming various constraints about the nonrigid scene, about the nonrigid shape bases, about the coefficients, about the deformation, about the shape itself, or about the camera motion etc. For instance, many methods require that the camera moves smoothly, or the deformation trajectory is slow and smooth. However, these additional constraints not only limit the practical applicability of the methods, but also obscure a clear theoretical understanding to the problem. We would like to answer: in order to solve the nonrigid factorization effectively, are these additional priors essential ?\nIn this paper, we propose a novel and simple solution to non-rigid factorization. Our method does not assume any extra prior knowledge about the problem other than the low-rank constraint, hence it is \"prior-free\". Nevertheless, it does not suffer from the basis ambiguity difficulty, but is able to recover both camera motion and non-rigid shape accurately and reliably. Experiments on both synthetic and real benchmark datasets show that: the proposed method, being prior-free, outperforms most other (often prior-based) linear factorization methods.\nTo better present this paper, and also to put our contributions in context, we briefly review some recent progress in non-rigid factorization.", "publication_ref": ["b6", "b4", "b10", "b24", "b20", "b2", "b13", "b25"], "figure_ref": [], "table_ref": []}, {"heading": "Related work", "text": "Ever since Bregler's seminal work [7] in 2000, researchers have been actively applying the factorization framework to various nonrigid problems. However, they soon noticed that, different from its rigid counterpart, the non-rigid factorization appeared to be much more difficult. In a 2004 paper, Xiao et al. proved that the problem itself is indeed ill-posed or under-constrained, in the sense that, based on the orthonormality constraint alone, one cannot recover the non-rigid shape bases and the corresponding shape coefficients uniquely [26]. There is always a fundamental ambiguity between the shape bases and the shape coefficients.\nTo resolve this ambiguity, Xiao et al. suggested to add extraneous \"basis constraints\" so as to make the system well-constrained. In the same spirit of adding extra priors to regularize an otherwise under-constrained problem, Torresani et al. [25] introduced Gaussian prior on the shape coefficients. Del Bue introduced special shape priors [11]. Akhter et al. proposed to use a fixed set of DCT bases in the trajectory dual space [3]. Temporally smooth deformation prior has also been used such as in [5] [1]. Gatardo et al. assumed the time-trajectory of a single point is smooth [14]. Other priors imposed speciality on the model such as assuming a quadratic model [13], local-rigidity [24], or extend to non-linear models [22].\nAkhter et al. made an important theoretical progress in [2] which reveals that: although the ambiguity in shape basis is inherent, the 3D shape itself can be recovered uniquely without ambiguity. In a slightly earlier paper, Hartley and Vidal proved a similar result but under perspective camera model [16]. Despite the significance of these theoretical results, neither paper has provided a practical algorithm to the problem, and our work aims to fill this gap.", "publication_ref": ["b6", "b25", "b24", "b10", "b2", "b4", "b0", "b13", "b12", "b23", "b21", "b1", "b15"], "figure_ref": [], "table_ref": []}, {"heading": "Problem Statement", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Formulation", "text": "The task of nonrigid factorization is to factorize an image measurement matrix W as the product of camera motion (projection) matrix M and a nonrigid shape matrix S, such that W = MS. We assume the measurement matrix is already centralized, therefore the camera matrix reduces to pure rotation [7].\nBased on the linear combination model, the non-rigid shape S i \u2208 R 3\u00d7P can be represented as a linear combination of K shape bases B k \u2208 R 3\u00d7P with shape coefficients c ik as: S i = K k=1 c ik B k . Under orthographic camera model, the coordinates of the 2D image points observed at frame i are given by: W i = R i S i , where R i \u2208 R 2\u00d73 is the first two rows of the i-th camera rotation, hence R i R T i = I 2 . Use this representation, and stack all the F frames of measurements and all the P points in a matrix form, we obtain:\nW = \uf8ee \uf8ef \uf8f0 x 11 \u2022 \u2022 \u2022 x 1F . . . . . . x F 1 \u2022 \u2022 \u2022 x F P \uf8f9 \uf8fa \uf8fb = \uf8ee \uf8ef \uf8f0 R 1 S 1 . . . R F S F \uf8f9 \uf8fa \uf8fb = \uf8ee \uf8ef \uf8f0 c 11 R 1 \u2022 \u2022 \u2022 c 1K R 1 . . . . . . . . . c F 1 R F \u2022 \u2022 \u2022 c F K R F \uf8f9 \uf8fa \uf8fb \uf8ee \uf8ef \uf8f0 B 1 . . . B K \uf8f9 \uf8fa \uf8fb (1) = R(C \u2297 I 3 )B . = \u03a0B.\nIn this formula, we call R = blkdiag(R 1 , \u2022 \u2022 \u2022 , R F ) \u2208 R 2F \u00d73F the camera motion (rotation) matrix. Since \u03a0 \u2208 R 2F \u00d73K and B \u2208 R 3K\u00d7P , it is easy to see: rank(W) \u2264 min(rank(\u03a0), rank(B))\u22643K. Additionally, the shape matrix S = (C \u2297 I 3 )B is low rank too, as rank(S) \u2264 min(rank(C \u2297 I 3 ), rank(B)) \u2264 3K.", "publication_ref": ["b6"], "figure_ref": [], "table_ref": []}, {"heading": "Orthonormality Constraint", "text": "From a measurement matrix W one can compute its rank-3K decomposition W =\u03a0B via SVD. However, this decomposition is not unique as any nonsingular matrix G \u2208 R 3K\u00d73K can be inserted between\u03a0 andB to obtain a new valid factorization as W =\u03a0B =\u03a0GG \u22121B = \u03a0B.\nA particular matrix G that rectifies\u03a0 to be a canonical Euclidean form is called the Euclidean corrective matrix, because once such a G is determined, one obtains R(C \u2297 I 3 ) =\u03a0G and the true shape bases B = G \u22121B .\nDenote the i-th double rows of\u03a0 as\u03a0 2i\u22121:2i \u2208 R 2\u00d73K , and the k-th column-triplet of G as G k \u2208 R 3K\u00d73 , we have:\n\u03a0 2i\u22121:2i G k = c ik R i , i = 1, \u2022 \u2022 \u2022 , F, k = 1, \u2022 \u2022 \u2022 , K. (2)\nOrthonormality constraints (i.e. rotation constraints) in the \u03a0 matrix can be imposed to recover a Gram matrix\nQ k \u2208 R 3K\u00d73K formed by Q k = G k G T k as\u03a0 2i\u22121:2i Q k\u03a0 T 2i\u22121:2i = c 2 ik I 2 .\nSince c ik is not known, one can only establish two linear equations over Q k as:\n\u03a0 2i\u22121 Q k\u03a0 T 2i\u22121 =\u03a0 2i Q k\u03a0 T 2i ,\u03a0 2i\u22121 Q k\u03a0 T 2i = 0.(3)", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Inherent Ambiguity", "text": "In doing the above non-rigid factorization, Xiao et al. [26] discovered that, the solutions are however fundamentally ambiguous, in the sense that one cannot expect to find the shape bases and shape coefficients uniquely. Such an inherent ambiguity largely explains why nonrigid factorization is fundamentally more difficult than its rigid counterpart. Later, Akhter et al. [2] showed that, quite surprisingly, the fundamental ambiguity does not necessarily lead to an ambiguous shape. In addition, they further proved that using the orthonormality constraints alone is in fact sufficient to recover a unique (unambiguous) non-rigid shape (provided that a previously-overlooked rank-3 constraint on Q k (Eq.-(3)) is accounted for). However, apart from its evident theoretical value, their paper did not propose any optimization algorithm (other than a local search method due to [6]) to efficiently find the correct G k . Instead, the authors argued that \"the real difficulty of in achieving good 3D reconstructions for nonrigid structures...is not the ambiguity of the [basis] constraints, but the complexity of the underlying non-linear optimization\". In this paper we will challenge this argument, by providing a simple yet efficient (optimization) solution to Nonrigid SFM Factorization.", "publication_ref": ["b25", "b1", "b5"], "figure_ref": [], "table_ref": []}, {"heading": "Main Theory", "text": "From now on, let us assume the measurement matrix W is already truncated to rank 3K (by e.g. SVD), the number of shape bases K has been estimated, and all the shape bases are non-degenerate. We start with a known result of NRSFM factorization. This result is in fact a direct consequence of Xiao et al.'s Theorem in [26]. It shows that the above linear system is inherently under-determined (as by (2K 2 \u2212 K) rank deficient), no matter how many image frames are given.\nOn the other hand, this result also provides us with the true dimensionality of the solution space of Q k , and note that Q k is precisely what we are after. However, in their paper, this practical implication had not been explicitly exploited.\nIn the following, we will show how one can take advantage of this result, and derive a practical algorithm that directly leads to a parametrization of this solution space. More precisely, we will prove that the solution space of Q k is actually the null-space of a certain matrix A which can be directly obtained from the input image data. Practical usefulness of this representation is obvious.", "publication_ref": ["b25"], "figure_ref": [], "table_ref": []}, {"heading": "Null-space Representation", "text": "First, denote vec() as the vectorization operator, and q k = vec(Q k ). Using vec(AXB T ) = (B \u2297 A)vec(X), we rewrite the linear system Eq.-(3) as:\n(\u03a0 i \u2297\u03a0 i )(1, :) \u2212 (\u03a0 i \u2297\u03a0 i )(4, :) (\u03a0 i \u2297\u03a0 i )(2, :). q k . = A i q k = 0,(4)\nwhere (\u03a0 i \u2297\u03a0 i )(j, :) denotes the j-th row of (\u03a0 i \u2297\u03a0 i ).\nStacking all such equations from all frames (i = 1, . . . , F ), we then have\nAvec(Q k ) = Aq k = 0,(5)\nwhere\nA = [A T 1 , A T 2 , \u2022 \u2022 \u2022 , A T F ] T\n. This is a linear system of equations over the unknown 9K 2 -vector q k .\nNote that the 9K 2 -vector q k has (3K)(3K + 1)/2 independent entries. It may appear that, given enough frames, i.e. when 2F \u2265 (3K)(3K + 1)/2, q k should be able to be solved via linear least squares. However, this is not the case, because all valid solutions reside in a 2K 2 \u2212K dimensional space as shown in Theorem 3.1. Moreover, Eq.- (5) shows, the solution space is nothing but the null-space of A. In addition, it is easy to verify that the minimum required number of frames for computing the null-space linearly is F \u2265 (5K 2 + 5K)/4.", "publication_ref": ["b4"], "figure_ref": [], "table_ref": []}, {"heading": "The Intersection Theorem", "text": "Combining all the proceeding results, we now arrive at the central theorem of this paper: Theorem 3.2 (Intersection Theorem). Under nondegenerate and noise-free conditions, any correct solution of Q k (i.e. the Gram matrix of a column-triplet of the true Euclidean corrective matrix G k ) must lie in the intersection of the (2K 2 \u2212 K)-dimensional null-space of A and a rank-3 positive semi-definite matrix cone, i.e., Q k belongs to\n{A vec(Q k ) = 0} \u2229 {Q k 0} \u2229 {rank(Q k ) = 3} . (6)\nProof. Denote G k as column triplet of a correct rectifying transform, and\nQ k = G k G T k , then rank(Q k ) = rank(G k ) = 3, Q k 0.\nAdditionally, vec(Q k ) lies in the null space of A as vec(Q k ) gives correct rectification with zero error. Thus G k is a solution to the equation system which means that the equation system is well-defined. DenoteG k as solution to the equation system Eq.-( 6), then rank(Q k ) = 3,Q k 0 and vec(Q k ) lies in the null space of the system of linear constraints on the elementsQ k . Thus all the solutions to the equation system Eq.-( 6) satisfy the condition for correct rectifying transforms. There is no difference between these solutions.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Algorithm Solution", "text": "Armed with the above results (in particular Theorem 3.2), we are now ready to present our simple algorithm to the non-rigid factorization problem.\nRecall that the goal is to recover the true motion matrix R and the true non-rigid shape matrix S from image measurement W, such that W = RS = R(C\u2297I 3 )B. Note that due to the inherent basis ambiguity, it is hopeless to recover a unique B or C. While in previous work many researchers chose to use a pre-selected special shape bases B (or enforce arbitrary priors on the shape bases or shape coefficients) to pin down the undetermined degrees-of-freedom, in this work we will show how one can directly estimate the S without fixing B or C.\nOur algorithm consists of three steps to be applied in sequel: (1) Estimate the (Gram of) corrective matrix G k , (2) Estimate camera rotations R and (3) Estimate the nonrigid shape S. We now explain the three steps in order.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Step-1: Estimate G k by Trace-Minimization", "text": "Our main intersection theorem (Theorem-3.2) naturally leads to an easy algorithm to solve for G k , that is: to find the intersection of the aforementioned null-space and a rank-3 positive semi-definite matrix cone.\nBecause the rank-function itself is not very numericallystably, measurements noise will increase the numerical rank of Q k dramatically, we slightly relax the rank(Q k ) = 3 condition to a rank-minimization problem, i.e. min rank(Q k ). Note that however, rank-minimization is an NP-hard problem in general, and is very difficult to solve exactly. We therefore further relax it to a nuclear-norm minimization form, i.e., min Q k * . Moreover in our case, since Q k is a symmetric positive definite matrix, the nuclear norm is simply its trace [23][4]. Thus we have Q k * = trace(Q k ).\nThen we arrive at the following trace-minimization to solve for the corrective matrix (Q k ). 2 min trace (Q k ) , such that,\nQ k 0, A vec(Q k ) = 0. (7)\nTo avoid a trivial solution at Q k = 0, we express vec(Q k ) in the explicit form of the null-space representation, with proper scaling to exclude the case of having all-zero weights. 3 Easy to see that the above trace-minimization problem is a standard semi-definite programming (SDP). Also note that this SDP is actually of small and fixed size (of 2K 2 \u2212 K) which is independent of the size of the measurement matrix. Thus this SDP can be solved easily and very efficiently by off-the-shelf SDP solvers. Once Q k is found, we use SVD to extract an (exact) rank-3 G k . This solved G k can be directly used to find R and then S. Alternatively, if higher accuracy is desired, one can further improve the numerical accuracy of G k by feeding it as an initial point to a non-linear refinement procedure, such as via the following unconstrained minimization:\nmin G k F i=1 (1 \u2212\u03a0 2iGk G T k\u03a0 T 2\u00ee \u03a02i\u22121G k G T k\u03a0 T 2i\u22121 ) 2 + (2\u03a0 2i\u22121 G k G T k\u03a0 T 2\u00ee \u03a02i\u22121G k G T k\u03a0 T 2i\u22121 ) 2 ,\nwhere the objective function is nothing but the orthonormality condition.", "publication_ref": ["b1", "b2"], "figure_ref": [], "table_ref": []}, {"heading": "4.2.", "text": "Step-2: Compute Rotation Matrix R Conventionally, once G k \u2208 R 3K\u00d73 is solved (w.l.o.g., let's denote it as G 1 ), which is merely a single column-triplet in the full corrective matrix G \u2208 R 3K\u00d73K , the commonlyused next step is to solve for the other K \u2212 1 of independent column-triplets [G 2 , . . . , G K ], and use them to populate the entire matrix G. Brand [6] proposed a linear method to solve for the big G (for affine case). Because these G k s always have rotation ambiguity, in order to align them, Procrustes method must be employed subsequently (c.f. [26][2]). Once the big G is obtained, one then is allowed to compute the camera motion R, the shape coefficients C and the shape bases B, and then reconstruct the non-rigid shape S. However, the above approach is not only rather involved, but also not numerically stable. More importantly, it is not necessary, as shown in [3].\nIn this work, we adopt a simpler approach that directly computes the camera motion R from a single column-triplet G k , without the need to fill in a big and full G matrix. The method goes as follows. Once G k is solved, the rotation at every frame i = 1, \u2022 \u2022 \u2022 , F can be solved by using:\n\u03a0 2i\u22121:2i G k = c ik R i , i = 1, \u2022 \u2022 \u2022 , F.(8)\nNote that we do not need to care about the unknown value of c ik , though its sign ambiguity must be taken care of (c.f. [2]). Finally, the full motion matrix R is formed as R = blkdiag([R 1 , R 2 , . . . , R F ]).", "publication_ref": ["b5", "b2", "b1"], "figure_ref": [], "table_ref": []}, {"heading": "Step-3: Estimate S by Rank-Minimization", "text": "Now we show how to solve the non-rigid shape matrix S. Most conventional methods do this indirectly, in the sense that they often start from solving the big G matrix firstly, and then use pre-selected special shape bases B (such as the first K frame [26], or DCT bases in the dual space [3], or assume the the shape coefficients are also DCT-expandable [14]), then the corresponding coefficient matrix C can be determined, and also the shape matrix S = (C \u2297 I 3 )B.\nIn the next two sub-sections, we will provide two simpler, more direct methods for solving S.", "publication_ref": ["b25", "b2", "b13"], "figure_ref": [], "table_ref": []}, {"heading": "Pseudo Inverse Method", "text": "Recall that our goal is to solve S through the equation of W = RS given W and R. This equation is under-determined because R is a short matrix of size 2F \u00d73F . There should be no unique but an infinite family of solutions to S. However, we also notice that: the low-order linear model, i.e. S = (C \u2297 I 3 )B immediately suggests that rank(S) \u2264 3K.\nTaking into account of both of the above arguments, we reach: a valid solution to the shape matrix S must lie in the intersection of low-rank matrix set of {rank(S) \u2264 3K} and the solution space of equation W = RS. As usual we relax the low-rank condition to rank minimization. Now the shape matrix S must be a solution to the following rank minimization problem: min rank(S), such that, W = RS.\nRemarks. We now make two important remarks: (1) the above rank-minimization problem (in the context of NRSFM) accepts the ground-truth shape matrix S as a solution;\n(2) Computationally, the above solution may be found by the (unique) Moore-Penrose pseudo-inverse solution, i.e.\nS = R \u2020 W = (R T (RR T ) \u22121 )W.\nRemark-1 is simply the main conclusion of [2], which states that: once R is fixed, there is no ambiguity in finding a low rank shape matrix S (condition upon sufficient nondegeneracy assumption).\nRemark-2 was a bit surprising to the authors, as it seems to suggest a simple, linear, and closed-form (though approximate) solution to our rank-minimization problem of ( 9)-which is NP-hard to solve in general.\nFortunately, recent progress in Compressive Sensing has confirmed the correctness of our Remark-2. In particular, we use the following result due to [19] that: the Moore-Penrose pseudo-inverse solution S = R \u2020 W is a unique minimizer that achieves nuclear-norm minimization. For a detailed proof the reader is referred to [19]. From this result, we see that the pseudo-inverse solution is indeed a possible solution that satisfies two necessary conditions (i.e., satisfying both the imaging equation and low rank conditions), though care must be given when discussion the quality of the approximation (i.e., relaxation gap) as well as the existence and uniqueness (multiplicity) issues associated with both the original min-rank problem and the relaxed min-nuclear-norm problem. For now, we settle for numerical/empirical evaluation of the proposed pseudo-inverse method.\nWe have numerically tested the pseudo-inverse method on both synthetic data and real data. Judging only from the numerics in terms of normalized 3D shape-recovery accuracy, the pseudo-inverse solution appears to outperform Xiao et al.'s K-basis method by a large margin, and achieves comparable performance with more recent Metric-Projection [21] and the classic EM-PPCA [25]. The reader is referred to the second last column of Table-1. This is already encouraging, as our method does not use any priors except for the low-rank condition. Note that however, our method is slightly inferior to the more recent DCT trajectory basis method [3] or the CSF method [14] (, both methods rely on strong smoothness prior)-which prompts us to think: can we do any better, without using any prior ? This inferiority also prompted the authors to think further: perhaps the rank-3K condition enforced upon S is not strong enough or sufficient? pondering this question has led us to the following method -the block matrix method-which gives more favorable performance.", "publication_ref": ["b1", "b18", "b18", "b20", "b24", "b2", "b13"], "figure_ref": [], "table_ref": []}, {"heading": "Block Matrix Method", "text": "In the above pseudo-inverse method, we mainly make use of the rank-3K condition that is rank(S) \u2264 3K. This (3F \u00d7 P ) matrix S is simply a stack of P 3D points\n[X i , Y i , Z i ] T over F frames.\nHowever, we realize that, since in reality there are in fact only K shape bases (rather than 3K), the shape matrix S is not a fully-generic rank-3K matrix, but has its special block structure. Ignoring this special structure will add spurious degrees-of-freedom (hence ambiguities) to the problem. Next we will show how to get a stronger (yet meaningful) rank-minimization formulation, considering the nature of the NRSFM factorization.\nIn particular, we re-arrange the rows of S that correspond to X, Y ,and Z coordinate separately, in an F \u00d7 3P block matrix form, denoted by S in below 4 : Then we must have: rank(S ) \u2264 K. Note that this rank-K condition (on S ) is stronger than the above rank-3K condition (on S), and the former captures the essence of the K-order linear combination model. Now, to solve for this re-arranged shape matrix S , we use, again, a rank-minimization formulation:\nS = \uf8ee \uf8ef \uf8f0 X11 ..\nmin rank(S ), such that, W = RS, S = [P X P Y P Z ](I 3 \u2297 S). (10\n)\nThe last matrix equality condition is a compact (shorthand) representation of the re-arrangement relationship between S and S, where P X , P Y , P Z \u2208 R F \u00d73F are some properly defined 0-1-valued \"row-selection\" matrices (similar to the \"permutation matrix\"). Fast numerical implementation. We relax the above rank-minimization to nuclear-norm (i.e. trace-norm) minimization, i.e. min S * . In principle, this nuclear-norm minimization may be solved by a standard SDP solver. However, unlike the case of Eq.-7 where the resulted SD-P has small and fixed size, here this SDP is of size F \u00d7 3P , which renders the SDP technique very inefficient when either P or F is large.\nBelow, we give an efficient numerical implementation, based on fixed point continuation [20]. First, we re-cast the above minimization Eq.- (10) in Lagrangian form as:\nmin \u00b5 S * + 1 2 W \u2212 RS 2 F , such that, S = [P X P Y P Z ](I 3 \u2297 S), (11\n)\nwhere \u00b5 is the continuation (homotopy) parameter which diminishes as the algorithm iterates. Next, the gradient of\n1 2 W \u2212 RS 2\nF with respect to S is obtained as:\ng(S ) = \u2202 1 2 W \u2212 RS 2 F \u2202S = [P X P Y P Z ](I 3 \u2297(R T (RS\u2212W))).(12\n) Then, we solve the minimization of Eq.-(11) via the following two-line iteration update (cf. [20]):\nY (t) = S (t) \u2212 \u03c4 g(S (t) ), S (t+1) = S \u03c4 \u00b5 (Y (t) ), (13\n)\nwhere \u03c4 is the step size of gradient descent, and S v (\u2022) is the matrix shrinkage operator (cf. [20]). Once the iteration converges, we first project the solved S to the nearest rank-K matrix (note: not 3K), then rearrange it to S. 5 5. Experiments", "publication_ref": ["b3", "b19", "b9", "b19", "b19", "b4"], "figure_ref": [], "table_ref": []}, {"heading": "Setup", "text": "We compare our methods against the state-of-the-art methods, which include (1) Xiao et al.'s shape basis method (XCK) [26];(2) Torresani et al.'s EM-PPCA [25]; (3) Metric projection [21]; (4) Trajectory basis method [3]; and (5) Column space fitting (CSF) [14]. 6 To facilitate the comparison, we use the same error metrics as reported in [3] and [14], that is: e R measures the mean error in rotation estimation and e R = 1\nF F i=1 R i \u2212 R i F ,\nwhere R i is the ground truth rotation at frame i and R i the recovered rotation; e 3D measures the normalized mean 3D error in the reconstructed 3D points and e 3D =\n1 \u03c3F P F i=1 P p=1 e ip , \u03c3 = 1 3F F i=1 (\u03c3 ix + \u03c3 iy + \u03c3 iz ),\nwhere \u03c3 ix , \u03c3 iy and \u03c3 iz are the standard deviations in X, Y and Z coordinates of the original shape at frame i.\nExtensive experiments are conduced to test the performance of the proposed methods, on both randomly synthetic data and on real motion capture data. The random synthetic data, which satisfy the low-rank nonrigid model perfectly, are used only for the purpose of algorithm validation, for which our methods have obtained nearly perfect result (with zero error) as we expect; the results are therefore omitted. Instead, only results on real sequences are reported below. The real sequences we have tested include the standard sequences of Drink (1102/41), Pickup (357/41), Yoga (307/41), Stretch (370/41), and Dance (264/75) used in [3], and Face (316/40), Shark (240/91) and Walking (260/55) in [25], where (F/P ) denotes the number of frames (F ) and points (P ).", "publication_ref": ["b25", "b24", "b20", "b2", "b13", "b5", "b2", "b13", "b2", "b24"], "figure_ref": [], "table_ref": []}, {"heading": "Cumulative histograms of errors", "text": "Our first experiment is aimed to give a statistical comparison between the performance of our method and several existing methods. For this purpose we use a real motion capture sequence, here e.g. the Stretch sequence. From the ground-truth 3D point clouds of the sequence as well the true camera matrices, we re-synthesize F frames of image measurements with Gaussian random noise added in, where 5 This block matrix method achieves significantly better results than almost all competing methods, including those of state of the art. However, we are fully aware of that important theoretical discussions are omitted here, due to space reason. In future work, we plan to discuss, e.g. Is the rank minimization problem, in it most general form, has a unique solution only-(it is so at least in our context of NRSFM, as [2] proved), or have multiple solutions ? Will the nuclear norm relaxation find the unique solution, or only one of them-if there are multiple? How big, or how small, is the relaxation gap? Is there some condition similar to RIP, in the context of NRSFM, that can guarantee the gap is zero? 6 We did not use the CSF variant of [15] as they are very similar.\nnoise ratio is defined as Noise Fro / W Fro . Use the obtained data, we test our methods, as well as several other existing methods. We repeat the random test 100 times. Then, we plot the cumulative histograms of the rotation estimation errors, and the 3D reconstruction errors, as shown in Fig. 1. This figure clearly reveals that: our block-matrix method outperforms most of the other methods, and our pseudoinverse method also achieves better results compared with EM-PPCA and XCK. ", "publication_ref": ["b4", "b1", "b5", "b14"], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "Noise performance", "text": "To analyze the behavior of our new methods under noise, we repeat the (above) first experiment at different noise ratios. Example results on the Stretch sequence are given in Fig. 2 which plots the estimation errors as a function of the noise ratio.\nIt is seen, our block matrix method achieves the best performance in terms of the accuracy for rotation estimation and for shape recovery, compared favorably with almost all the other state-of-the-art competitors. Note that our pseudoinverse method also achieves better performance than EM-PPCA, Metric Projection and XCK. ", "publication_ref": [], "figure_ref": ["fig_2"], "table_ref": []}, {"heading": "Compare all methods on all real sequences", "text": "In this subsection, we provide experimental results of all the 5 methods we are benchmarking, on all the real se-quences at hand. Table-1 summarizes our main results, where both the shape reconstruction error (mean 3D error) and the camera rotation error are provided (whenever the ground truth are available). Fig. -3 shows the comparison.\nClearly, our block matrix method achieves the best performance in shape recovery, on almost all of the benchmark sequences (the Shark sequence is an exception, but that possibly due to the fact that this Shark sequence is in fact degenerate [25]). ", "publication_ref": ["b24"], "figure_ref": ["fig_3"], "table_ref": []}, {"heading": "Test on frame-reshuffled data", "text": "A highlight of this work is that our method does not assume any prior knowledge about the problem. For instance, we do not assume the trajectories are smooth across frames, while many other method do make this assumption, either explicitly or implicitly. So, we expect (predict) that our method is immune to random frame-order reshuffle (permutation).\nTo verify this point, we redo the experiments but on frame-reshuffled data, and obtain the following results in Fig. -4. It is seen that both the trajectory basis method and the CSF method perform very badly on the reshuffled sequence, while our method remains unaffected.\nFig. -5 gives a close inspection. The top row compares the trajectories recovered by using the original sequence, and using a frame-reshuffled sequence, while the bottom row shows the normalized mean 3D error for both sequences. From this figure, the trajectory basis method fails to output acceptable results on the frame-permutated sequence, but our method leads to identical results on both cases. This is not surprising as permutating a matrix will not change its rank, and our methods does not assume any frame order or temporal smoothness.", "publication_ref": [], "figure_ref": ["fig_5", "fig_6"], "table_ref": []}, {"heading": "Sample shape reconstruction results", "text": "For visual evaluation, we give result comparison between our block matrix method and the trajectory basis method on a more complex sequence, Dance, see Fig. -6.\nWe also test the Talking Face video 7 , using 500 frames and 68 feature tracks.   images and the resulted 3D points, where the reprojection error is 0.9222 pixels.", "publication_ref": ["b6"], "figure_ref": ["fig_7"], "table_ref": []}, {"heading": "Closing remarks", "text": "This paper advocates a novel prior-free approach to nonrigid factorization. Our method is purely convex, very easy to implement, and is guaranteed to converge to an optimal solution (at least approximately up to certain relaxation). It shows that, contrary to common belief, the NRSFM factorization problem can be solved unambiguously, efficiently and accurately, without using extra priors. This said, however, from a practical point of view, we do not against the use of available prior, as long as the prior is sensible and Table 1. Quantitative comparison of our proposed methods versus the state-of-the-art methods on benchmark video sequences. e3D(P) and e3D(B) denote the 3D errors of our Pseudo-inverse method and Block matrix method respectively.   reflects the physical nature of the problem at hand. It is expected that, using good prior will further improve our solution, and make our method more applicable to complex scenarios.\nIn the present paper, we have concentrated on com-plete measurement case under orthographic camera model. Thanks to recent progress in SFM and Compressive Sensing, the proposed method can be easily adapted to handling missing-data case (e.g. [8,10,12]), outlier case (e.g. [9,18,4]), multibody motion case [17], as well as perspective camera case [10].", "publication_ref": ["b7", "b9", "b11", "b8", "b17", "b3", "b16", "b9"], "figure_ref": [], "table_ref": []}, {"heading": "", "text": "Acknowledgement. This work is funded, in part by Natural Science Foundation of China, and by an ARC Discovery Grant funded by Australia Research Council. The first author Yuchao was a CSC-funded PhD student to ANU, under the supervision of Hongdong and Richard. Yuchao is now a Postdoctoral Research Fellow with Research School of Computer Science of ANU working on an ARC Linkage Grant on human computer interaction with medical imaging application. The authors wish to thank Richard (Prof. Hartley) for invaluable discussions. The second author also had fruitful discussions with Dr. Professor Fredrik Kahl especially on this topic.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Estimation of deformable structure and motion", "journal": "", "year": "2002", "authors": "H Aanaes; F Kahl"}, {"ref_id": "b1", "title": "In defense of orthonormality constraints for nonrigid structure from motion", "journal": "", "year": "2004", "authors": "I Akhter; Y Sheikh; S Khan"}, {"ref_id": "b2", "title": "Nonrigid structure from motion in trajectory space", "journal": "", "year": "2008", "authors": "I Akhter; Y Sheikh; S Khan; T Kanade"}, {"ref_id": "b3", "title": "The generalized tracenorm and its application to structure-from-motion problems", "journal": "", "year": "2008", "authors": "R Angst; C Zach; M Pollefeys"}, {"ref_id": "b4", "title": "Coarse-to-fine low-rank structure-from-motion", "journal": "", "year": "2008", "authors": "A Bartoli; V Gay-Bellile; U Castellani; J Peyras; S Olsen; P Sayd"}, {"ref_id": "b5", "title": "A direct method for 3D factorization of nonrigid motion observed in 2D", "journal": "", "year": "2005", "authors": "M Brand"}, {"ref_id": "b6", "title": "Recovering non-rigid 3D shape from image streams", "journal": "", "year": "2000", "authors": "C Bregler; A Hertzmann; H Biermann"}, {"ref_id": "b7", "title": "Damped newton algorithms for matrix factorization with missing data", "journal": "", "year": "2005", "authors": "A M Buchanan; A W Fitzgibbon"}, {"ref_id": "b8", "title": "Robust principal component analysis", "journal": "J. ACM", "year": "2011", "authors": "E Cand\u00e8s; X Li; Y Ma; J Wright"}, {"ref_id": "b9", "title": "Element-wise factorization for n-view projective reconstruction", "journal": "", "year": "2010", "authors": "Y Dai; H Li; M He"}, {"ref_id": "b10", "title": "A factorization approach to structure from motion with shape priors", "journal": "", "year": "2008", "authors": "A Del Bue"}, {"ref_id": "b11", "title": "Efficient computation of robust low-rank matrix approximations in the presence of missing data using the L1 norm", "journal": "", "year": "2010", "authors": "A Eriksson; A Van Den;  Hengel"}, {"ref_id": "b12", "title": "Piecewise quadratic reconstruction of non-rigid surfaces from monocular sequences", "journal": "", "year": "2010", "authors": "J Fayad; L Agapito; A Del Bue"}, {"ref_id": "b13", "title": "Computing smooth timetrajectories for camera and deformable shape in structure from motion with occlusion", "journal": "PAMI", "year": "2006", "authors": "P Gotardo; A Martinez"}, {"ref_id": "b14", "title": "Non-rigid structure from motion with complementary rank-3 spaces", "journal": "", "year": "2011", "authors": "P Gotardo; A Martinez"}, {"ref_id": "b15", "title": "Perspective nonrigid shape and motion recovery", "journal": "", "year": "2008", "authors": "R Hartley; R Vidal"}, {"ref_id": "b16", "title": "Two-view motion segmentation from linear programming relaxation", "journal": "", "year": "2007-06", "authors": "H Li"}, {"ref_id": "b17", "title": "Consensus set maximization with guaranteed global optimality for robust geometry estimation", "journal": "IEEE", "year": "2009", "authors": "H Li"}, {"ref_id": "b18", "title": "Robust recovery of subspace structures by low-rank representation", "journal": "", "year": "2010", "authors": "G Liu; Z Lin; S Yan; J Sun; Y Yu; Y Ma"}, {"ref_id": "b19", "title": "Fixed point and bregman iterative methods for matrix rank minimization", "journal": "Mathematical Programming, Series A", "year": "2011", "authors": "S Ma; D Goldfarb; L Chen"}, {"ref_id": "b20", "title": "Factorization for non-rigid and articulated structure using metric projections", "journal": "", "year": "2009", "authors": "M Paladini; A D Bue; M Stosic; M Dodig; J Xavier; L Agapito"}, {"ref_id": "b21", "title": "Linear embeddings in non-rigid structure from motion", "journal": "", "year": "2009", "authors": "V Rabaud; S Belongie"}, {"ref_id": "b22", "title": "Guaranteed minimumrank solutions of linear matrix equations via nuclear norm minimization", "journal": "SIAM Review", "year": "2010", "authors": "B Recht; M Fazel; P A Parrilo"}, {"ref_id": "b23", "title": "Non-rigid structure from locally-rigid motion", "journal": "", "year": "2010", "authors": "J Taylor; A D Jepson; K N Kutulakos"}, {"ref_id": "b24", "title": "Nonrigid structure-from-motion: Estimating shape and motion with hierarchical priors. PAMI, 30", "journal": "", "year": "2007", "authors": "L Torresani; A Hertzmann; C Bregler"}, {"ref_id": "b25", "title": "A closed-form solution to non-rigid shape and motion recovery", "journal": "", "year": "2004", "authors": "J Xiao; J Chai; T Kanade"}], "figures": [{"figure_label": "31", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Theorem 3 . 1 .31All the solutions of Q k to linear system Eq.-(3) form a linear subspace of dimensionality (2K 2 \u2212 K).", "figure_data": ""}, {"figure_label": "1", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 1 .1Figure 1. Cumulative histograms of errors tested on the \"Stretch\" sequence. The most left curve gives the best performance. Left: the rotation error; Right: the 3D reconstruction error. Our Block-Matrix method outperforms most of the other existing methods.", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Figure 2 .2Figure 2. Noise performance. (a) Rotation estimation error. (b) Normalized mean 3D error.", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Figure 3 .3Figure 3. Motion capture data experimental results. Left: Rotation estimation error; Right: 3D reconstruction error.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "Fig.-7 shows 3 frames of the original 7 http://www-prima.inrialpes.fr/FGnet/data/01-TalkingFace/", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_5", "figure_caption": "Figure 4 .4Figure 4. Performance on frame order reshuffled sequences. (a) Rotation error. (b) Normalized mean 3D error. (Better viewed in color).", "figure_data": ""}, {"figure_label": "5", "figure_type": "figure", "figure_id": "fig_6", "figure_caption": "Figure 5 .5Figure 5. Comparison of our block matrix method versus the trajectory basis method, on an original input video sequence, as well as on a frame-reshuffled version. (a) Recovered trajectory of one point in the X coordinate by both methods on the original sequence. (b) Recovered trajectory of one point in the X coordinate by both methods on the frame-reshuffled sequence. (c) Normalized mean 3D error for both methods on the original sequence. (d) Normalized mean 3D error for both methods on the framereshuffled sequence.", "figure_data": ""}, {"figure_label": "6", "figure_type": "figure", "figure_id": "fig_7", "figure_caption": "Figure 6 .6Figure 6. Comparison of the 3D reconstruction results on the Dance sequence. The blue dots are the ground truth 3D points, and the red circles show the reconstructed points. Top row: results by the trajectory basis method [3], where the 3D errors are 0.3011, 0.2827, 0.2814 for the 3 frames. Bottom row: our result by the block matrix method, where the 3D errors are 0.2228, 0.0355, 0.1389 for the 3 frames.", "figure_data": ""}, {"figure_label": "7", "figure_type": "figure", "figure_id": "fig_8", "figure_caption": "Figure 7 .7Figure 7. Example 3D deformable shape reconstruction results. Top row: sample frames of the input Face sequence. Bottom row: recovered 3D face shapes by using our block matrix method.", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "X1P Y11 .. Y1P Z11 .. Z1P . . . . . . . . . . . . . . . . . . XF 1 .. XF P YF 1 .. YF P ZF 1 .. ZF P", "figure_data": "\uf8f9\uf8fa \uf8fb ."}], "formulas": [{"formula_id": "formula_0", "formula_text": "W = \uf8ee \uf8ef \uf8f0 x 11 \u2022 \u2022 \u2022 x 1F . . . . . . x F 1 \u2022 \u2022 \u2022 x F P \uf8f9 \uf8fa \uf8fb = \uf8ee \uf8ef \uf8f0 R 1 S 1 . . . R F S F \uf8f9 \uf8fa \uf8fb = \uf8ee \uf8ef \uf8f0 c 11 R 1 \u2022 \u2022 \u2022 c 1K R 1 . . . . . . . . . c F 1 R F \u2022 \u2022 \u2022 c F K R F \uf8f9 \uf8fa \uf8fb \uf8ee \uf8ef \uf8f0 B 1 . . . B K \uf8f9 \uf8fa \uf8fb (1) = R(C \u2297 I 3 )B . = \u03a0B.", "formula_coordinates": [2.0, 74.88, 524.28, 211.48, 103.11]}, {"formula_id": "formula_1", "formula_text": "\u03a0 2i\u22121:2i G k = c ik R i , i = 1, \u2022 \u2022 \u2022 , F, k = 1, \u2022 \u2022 \u2022 , K. (2)", "formula_coordinates": [2.0, 320.82, 232.95, 224.3, 9.65]}, {"formula_id": "formula_2", "formula_text": "Q k \u2208 R 3K\u00d73K formed by Q k = G k G T k as\u03a0 2i\u22121:2i Q k\u03a0 T 2i\u22121:2i = c 2 ik I 2 .", "formula_coordinates": [2.0, 308.86, 265.21, 236.25, 37.11]}, {"formula_id": "formula_3", "formula_text": "\u03a0 2i\u22121 Q k\u03a0 T 2i\u22121 =\u03a0 2i Q k\u03a0 T 2i ,\u03a0 2i\u22121 Q k\u03a0 T 2i = 0.(3)", "formula_coordinates": [2.0, 331.27, 320.6, 213.85, 14.83]}, {"formula_id": "formula_4", "formula_text": "(\u03a0 i \u2297\u03a0 i )(1, :) \u2212 (\u03a0 i \u2297\u03a0 i )(4, :) (\u03a0 i \u2297\u03a0 i )(2, :). q k . = A i q k = 0,(4)", "formula_coordinates": [3.0, 72.45, 360.62, 213.91, 32.64]}, {"formula_id": "formula_5", "formula_text": "Avec(Q k ) = Aq k = 0,(5)", "formula_coordinates": [3.0, 124.22, 442.77, 162.14, 9.68]}, {"formula_id": "formula_6", "formula_text": "A = [A T 1 , A T 2 , \u2022 \u2022 \u2022 , A T F ] T", "formula_coordinates": [3.0, 77.77, 463.61, 94.92, 12.48]}, {"formula_id": "formula_7", "formula_text": "{A vec(Q k ) = 0} \u2229 {Q k 0} \u2229 {rank(Q k ) = 3} . (6)", "formula_coordinates": [3.0, 323.43, 109.62, 221.68, 9.68]}, {"formula_id": "formula_8", "formula_text": "Q k = G k G T k , then rank(Q k ) = rank(G k ) = 3, Q k 0.", "formula_coordinates": [3.0, 308.86, 152.27, 236.24, 23.18]}, {"formula_id": "formula_9", "formula_text": "Q k 0, A vec(Q k ) = 0. (7)", "formula_coordinates": [4.0, 107.09, 121.25, 179.27, 21.61]}, {"formula_id": "formula_10", "formula_text": "min G k F i=1 (1 \u2212\u03a0 2iGk G T k\u03a0 T 2\u00ee \u03a02i\u22121G k G T k\u03a0 T 2i\u22121 ) 2 + (2\u03a0 2i\u22121 G k G T k\u03a0 T 2\u00ee \u03a02i\u22121G k G T k\u03a0 T 2i\u22121 ) 2 ,", "formula_coordinates": [4.0, 50.11, 335.43, 251.99, 20.65]}, {"formula_id": "formula_11", "formula_text": "\u03a0 2i\u22121:2i G k = c ik R i , i = 1, \u2022 \u2022 \u2022 , F.(8)", "formula_coordinates": [4.0, 358.18, 122.86, 186.94, 9.65]}, {"formula_id": "formula_13", "formula_text": "S = R \u2020 W = (R T (RR T ) \u22121 )W.", "formula_coordinates": [4.0, 308.86, 653.86, 108.57, 10.59]}, {"formula_id": "formula_14", "formula_text": "[X i , Y i , Z i ] T over F frames.", "formula_coordinates": [5.0, 50.11, 594.52, 236.25, 22.49]}, {"formula_id": "formula_15", "formula_text": "S = \uf8ee \uf8ef \uf8f0 X11 ..", "formula_coordinates": [5.0, 308.86, 114.92, 64.11, 27.28]}, {"formula_id": "formula_16", "formula_text": "min rank(S ), such that, W = RS, S = [P X P Y P Z ](I 3 \u2297 S). (10", "formula_coordinates": [5.0, 371.02, 242.22, 169.94, 33.65]}, {"formula_id": "formula_17", "formula_text": ")", "formula_coordinates": [5.0, 540.96, 254.6, 4.15, 8.64]}, {"formula_id": "formula_18", "formula_text": "min \u00b5 S * + 1 2 W \u2212 RS 2 F , such that, S = [P X P Y P Z ](I 3 \u2297 S), (11", "formula_coordinates": [5.0, 335.18, 481.73, 205.78, 32.18]}, {"formula_id": "formula_19", "formula_text": ")", "formula_coordinates": [5.0, 540.96, 494.39, 4.15, 8.64]}, {"formula_id": "formula_20", "formula_text": "1 2 W \u2212 RS 2", "formula_coordinates": [5.0, 310.06, 545.4, 46.97, 13.47]}, {"formula_id": "formula_21", "formula_text": "g(S ) = \u2202 1 2 W \u2212 RS 2 F \u2202S = [P X P Y P Z ](I 3 \u2297(R T (RS\u2212W))).(12", "formula_coordinates": [5.0, 308.86, 565.97, 236.25, 32.78]}, {"formula_id": "formula_22", "formula_text": "Y (t) = S (t) \u2212 \u03c4 g(S (t) ), S (t+1) = S \u03c4 \u00b5 (Y (t) ), (13", "formula_coordinates": [5.0, 380.76, 631.87, 160.21, 23.66]}, {"formula_id": "formula_23", "formula_text": ")", "formula_coordinates": [5.0, 540.96, 639.84, 4.15, 8.64]}, {"formula_id": "formula_24", "formula_text": "F F i=1 R i \u2212 R i F ,", "formula_coordinates": [6.0, 50.11, 233.31, 451.89, 24.77]}, {"formula_id": "formula_25", "formula_text": "1 \u03c3F P F i=1 P p=1 e ip , \u03c3 = 1 3F F i=1 (\u03c3 ix + \u03c3 iy + \u03c3 iz ),", "formula_coordinates": [6.0, 51.31, 281.13, 235.05, 14.56]}], "doi": ""}