{"title": "Actively Learning Concepts and Conjunctive Queries under EL r -Ontologies", "authors": "Maurice Funk; Jean Christoph Jung; Carsten Lutz", "pub_date": "2021-05-19", "abstract": "We consider the problem to learn a concept or a query in the presence of an ontology formulated in the description logic EL r , in Angluin's framework of active learning that allows the learning algorithm to interactively query an oracle (such as a domain expert). We show that the following can be learned in polynomial time: (1) EL-concepts, (2) symmetry-free ELI-concepts, and (3) conjunctive queries (CQs) that are chordal, symmetry-free, and of bounded arity. In all cases, the learner can pose to the oracle membership queries based on ABoxes and equivalence queries that ask whether a given concept/query from the considered class is equivalent to the target. The restriction to bounded arity in (3) can be removed when we admit unrestricted CQs in equivalence queries. We also show that EL-concepts are not polynomial query learnable in the presence of ELI-ontologies.", "sections": [{"heading": "Introduction", "text": "In logic based knowledge representation, a significant bottleneck is the construction of logical formulas such as description logic (DL) concepts, queries, and ontologies, as it is laborious and expensive. This is particularly true if the construction involves multiple parties because logic expertise and domain knowledge are not in the same hands. Angluin's model of exact learning, a form of active learning, is able to support the construction of logical formulas in terms of a game-like collaboration between a learner and an oracle [Angluin, 1987b;Angluin, 1987a]. Applied in knowledge representation, the learner can be a logic expert and the oracle a domain expert that is interactively queried by the learner. Alternatively, the oracle can take other forms such as a set of labeled data examples that in some way represents the formula to be learned. The aim is to find an algorithm that, when executed by the learner, constructs the desired formula in polynomial time even when the oracle is not able to provide most informative answers. Landmark results from active learning state that such algorithms exist for learning propositional Horn formulas and finite automata [Angluin et al., 1992;Angluin, 1987a].\nThe aim of this paper is to study active learning of DL concepts and of conjunctive queries (CQs) in the presence of an ontology. Concepts are the main building block of ontologies [Baader et al., 2017] and learning them is important for ontology engineering. CQs are very prominent in ontologymediated querying where data stored in an ABox is enriched with an ontology [Bienvenu et al., 2014]. We concentrate on the EL family of DLs which underlies the OWL EL profile of the OWL 2 ontology language [Kr\u00f6tzsch, 2012] and is frequently used in biomedical ontologies such as SNOMED CT. We consider ontologies formulated in the DLs EL r and ELI where EL r extends EL with range restrictions and ELI extends EL r with inverse roles. In both DLs, concepts can be viewed as a tree-shaped conjunctive query, and from now on we shall treat them as such. In fact, it is not uncommon to use concepts as queries in ontology-mediated querying, which provides an additional motivation for learning them.\nWe now describe the learning protocol in detail. It is an instance of Angluin's model, which we do not repeat here in full generality. The aim is to learn a target CQ q T (x) in the presence of an ontology O. The learner and the oracle both know and agree on the ontology O, the arity of q T , and the concept and role names that are available for constructing q T ; we assume that all concept and role names in O can be used also in q T . The learner can ask two types of queries to the oracle. In a membership query, the learner provides an ABox A and a candidate answer\u0101 and asks whether A, O |= q T (\u0101); the oracle faithfully answers \"yes\" or \"no\". In an equivalence query, the learner provides a hypothesis CQ q H and asks whether q H is equivalent to q T under O; the oracle answers \"yes\" or provides a counterexample, that is, an ABox A and tuple\u0101 such that A, O |= q T (\u0101) and A, O |= q H (\u0101) (positive counterexample) or vice versa (negative counterexample). When we learn a restricted class of CQs such as EL-concepts, we assume that only CQs from that class are admitted in equivalence queries. We are then interested in whether there is a learning algorithm that constructs q T (x), up to equivalence under O, such that at any given time, the running time of the algorithm is bounded by a polynomial in the sizes of q T , of O, and of the largest counterexample given by the oracle so far. This is called polynomial time learnability. A weaker requirement is polynomial query learnability where only the sum of the sizes of the queries posed to the oracle up to the current time point has to be bounded by such a polynomial.\nOur main results are that the following can be learned in polynomial time under EL r -ontologies: (1) EL-concepts, (2) ELI-concepts that are symmetry-free, and (3) CQs that are chordal, symmetry-free, and of bounded arity. In Point (2), symmetry-freeness means that there is no subconcept of the form \u2203r.(C \u2203r \u2212 .D) with r a role name, a condition that has recently been introduced in [Jung et al., 2020], in a slightly less general form where r can also be an inverse role. In Point (3), chordal means that every cycle of length at least four that contains at least one quantified variable has a chord and symmetry-free means that the CQ contains no atoms r(x 1 , y), r(x 2 , y) such that x 1 = x 2 , y is a quantified variable, neither r(x 1 , y) nor r(x 2 , y) occur on a cycle, and there is no atom s(z, z) for any z \u2208 {x 1 , x 2 , y}. An analysis of well-known benchmarks for ontology-mediated querying suggests that the resulting class CQ csf of CQs is sufficiently general to include many relevant CQs that occur in practical applications. Our proofs crucially rely on the use of a finite version of the universal model that is specifically tailored to the class CQ csf . We also show that the restriction to bounded arity can be removed from Point (3) when we admit unrestricted CQs as the argument to equivalence queries. Proving this requires very substantial changes to the learning algorithm.\nIn addition, we prove several negative results. First, we show that none of the classes of CQs in Points (1) to (3) can be learned under EL-ontologies using only membership queries or only equivalence queries (unless P = NP in the latter case). Note that polynomial time learning with only membership queries is important because it is related to whether CQs can be characterized up to equivalence using only polynomially many data examples [ten Cate and Dalmau, 2020]. We also show the much more involved result that none of the classes of CQs in Points (1) to (3) is polynomial query learnable under ELI-ontologies. Note that while polynomial time learnability cannot be expected because subsumption in ELI is EXPTIME-complete, there could well have been a polynomial time learning algorithm with access to an oracle (in the classical sense) for subsumption/query containment under ELI-ontologies that attains polynomial query learnability. Our result rules out this possibility.\nProof details are in the appendix.\nRelated work. Learning EL-ontologies, rather than concepts or queries, was studied in [Konev et al., 2018;Konev et al., 2016]. It turns out that EL-ontologies are not polynomial time learnable while certain fragments thereof are. In contrast, we attain polynomial time learnability also under unrestricted EL-ontologies. See also the surveys [Lehmann and V\u00f6lker, 2014;Ozaki, 2020] and [Ozaki et al., 2020] for a variation less related to the current work. It has been shown in [ten Cate et al., 2013;ten Cate et al., 2018] that unions of CQs (UCQs) are polynomial time learnable, and the presented algorithm can be adapted to CQs. Active learning of CQs with only membership queries is considered in [ten Cate and Dalmau, 2020] where among other results it is shown that ELI-concepts can be learned in polynomial time with only membership queries when the ontology is empty. PAC learnability of concepts formulated in the DL CLASSIC, without ontologies, was studied in [Cohen and Hirsh, 1994b;Cohen and Hirsh, 1994a;Frazier and Pitt, 1996].", "publication_ref": ["b2", "b1", "b0", "b1", "b3", "b3", "b6", "b6", "b6", "b6", "b6", "b3", "b3", "b3"], "figure_ref": [], "table_ref": []}, {"heading": "Preliminaries", "text": "Concepts and Ontologies. Let N C , N R , and N I be countably infinite sets of concept names, role names, and individual names, respectively. A role R takes the form r or r \u2212 where r is a role name and r \u2212 is called an inverse role. If R = s \u2212 is an inverse role, then R \u2212 denotes the role name s.\nAn ELI-concept is formed according to the syntax rule C, D ::\n= | A | C D | \u2203R.C\nwhere A ranges over N C and R over roles. An EL-concept is an ELI-concept that does not use inverse roles. An ELI-ontology O is a finite set of concept inclusions (CIs) C D where C and D range over ELI-concepts. An EL r -ontology is an ELI-ontology where inverse roles occur only in the form of range restrictions \u2203r \u2212 .\nC with C an EL-concept. Note that domain restrictions \u2203r.\nC can be expressed already in EL. An EL-ontology is an ELI-ontology that does not use inverse roles. An EL r -ontology is in normal form if all CIs in it are of one of the forms\nA 1 A 2 A, A 1 \u2203r.A 2 , \u2203r.A 1 A 2 , \u2203r \u2212 . A\nwhere A, A 1 , A 2 are concept names or . An ABox A is a finite set of concept assertions A(a) and role assertions r(a, b) The semantics is defined as usual in terms of interpretations I, which we define to be a (possibly infinite and) nonempty set of concept and role assertions. We use \u2206 I to denote the set of individual names in I, define A I = {a | A(a) \u2208 I} for all A \u2208 N C , and r I = {(a, b) | r(a, b) \u2208 I} for all r \u2208 N R . The extension C I of ELI-concepts C is then defined as usual [Baader et al., 2017]. This definition of interpretation is slightly different from the usual one, but equivalent; its virtue is uniformity as every ABox is a (finite) interpretation. An interpretation I satisfies a CI C D if C I \u2286 D I , and a (concept or role) assertion \u03b1 if \u03b1 \u2208 I or \u03b1 has the form (a). We say that I is a model of an ontology/ABox if it satisfies all concept inclusions/assertions in it and write O |= C D if every model of the ontology O satisfies the CI C D.\nwhere A \u2208 N C \u222a { }, r \u2208 N R ,\nA signature is a set of concept and role names, uniformly referred to as symbols. For any syntactic object O such as an ontology or an ABox, we use sig(O) to denote the symbols used in O and ||O|| to denote the size of O, that is, the length of a word representation of O in a suitable alphabet. CQs and Homomorphisms. A conjunctive query (CQ) takes the form q(x) \u2190 \u03d5(x,\u0233) where \u03d5 is a conjunction of concept atoms A(x) and role atoms r(x, y) with A \u2208 N C and r \u2208 N R . We may write r \u2212 (x, y) in place of r(y, x). Note that the tuplex used in the head q(x) of the CQ may contain repeated occurrences of variables. When we do not want to make the body \u03d5(x,\u0233) explicit, we may denote q(x) \u2190 \u03d5(x,\u0233) simply with q(x). We refer to the variables inx as the answer variables of q. and to the variables in\u0233 as the quantified variables. When we are not interested in order and multiplicity, we treatx and\u0233 as sets of variables. We use var(q) to denote the set of all variables inx and\u0233. The arity of q is the length of tuplex and q is Boolean if it has arity zero. Every CQ q(x) \u2190 \u03d5(x,\u0233) gives rise to an ABox (and thus interpretation) A q obtained from \u03d5(x,\u0233) by viewing variables as individual names and atoms as assertions. A CQ is a ditree if A q is.\nA homomorphism h from interpretation I 1 to interpretation I 2 is a mapping from\n\u2206 I1 to \u2206 I2 such that d \u2208 A I1 implies h(d) \u2208 A I2 and (d, e) \u2208 r I1 implies (h(d), h(e)) \u2208 r I2 . For d i a tuple over \u2206 Ii , i \u2208 {1, 2}, we write I 1 ,d 1 \u2192 I 2 ,d 2 if there is a homomorphism h from I 1 to I 2 with h(d 1 ) =d 2 .\nWith a homomorphism from a CQ q to an interpretation I, we mean a homomorphism from A q to I.\nLet q(x) \u2190 \u03d5(x,\u0233) be a CQ and I an interpretation. A tupled \u2208 (\u2206 I ) |x| is an answer to q on I, written I |= q(d), if there is a homomorphism h from q to I with h(x) =d. Now let O be an ELI-ontology and A an ABox. A tuple\u0101 \u2208 ind(A) |x| is an answer to q on A under O, written A, O |= q(\u0101) if\u0101 is an answer to q on every model of O and A.\nFor q 1 and q 2 CQs of the same arity n and O an ELIontology, we say that q\n1 is contained in q 2 under O, written q 1 \u2286 O q 2 , if for all ABoxes A and\u0101 \u2208 ind(A) n , A, O |= q 1 (\u0101) implies A, O |= q 2 (\u0101). We call q 1 and q 2 equivalent under O, written q 1 \u2261 O q 2 , if q 1 \u2286 O q 2 and q 2 \u2286 O q 1 .\nEvery ELI-concept can be viewed as a unary tree-shaped CQ in an obvious way. For example, the EL-concept A \u2203s.\n\u2203r.B yields the CQ q(x) \u2190 A(x)\u2227s(x, y)\u2227r(x, z)\u2227 B(z). We use ELQ to denote the class of all EL-concepts viewed as a CQ, and likewise for ELIQ and ELI-concepts.\nImportant Classes of CQs. We next define a class of CQs that we show later to admit polynomial time learnability under EL r -ontologies, one of the main results of this paper. Let A be an ABox. A path in A from a to b is a sequence p = R 0 (a 0 , a 1 ), . . . , R n\u22121 (a n\u22121 , a n ) \u2208 A, n \u2265 0, such that a 0 = a and a n = b. We say that p is a cycle of length n if a 0 = a n , all assertions in p are distinct, and all of a 0 , . . . , a n\u22121 are distinct. A chord of cycle p is an assertion R(a i , a j ) with 0 \u2264 i, j < n\u22121 and i / \u2208 {j, j\u22121 mod n, j+1 mod n}. A cycle in a CQ q is a cycle in A q . With CQ csf , we denote the class of CQs\nq(x) \u2190 \u03d5(x,\u0233) that are 1. chordal, that is, every cycle R 0 (x 0 , x 1 ), . . . , R n\u22122 (x n\u22122 , x n\u22121\n) in q of length at least four that contains at least one quantified variable has a chord;\n2. symmetry-free, that is, if \u03d5 contains atoms r(y 1 , x), r(y 2 , x) with y 1 = y 2 , then x is an answer variable or one of the atoms occurs on a cycle or \u03d5 contains an atom s(z, z) for some z \u2208 {x, y 1 , y 2 }.\nIn Point 2, r is a role name and thus there are no restrictions on 'inverse symmetries': \u03d5 may contain atoms r(x, y 1 ), r(x, y 2 ) with x a quantified variable and none of the atoms occurring on a cycle and no reflexive loops present. Note that CQ csf contains all CQs without quantified variables (also called full CQs), all ELQs, and all ELIQs obtained from ELI-concepts that are symmetry-free, that is, that do not contain a subconcept of the form \u2203r.(C \u2203r \u2212 .D) with r a role name. We denote the latter class with ELIQ sf . CQ csf also includes all CQs obtained from such ELIQs by choosing a set of variables and making them answer variables. Note that CQs from CQ csf need not be connected, in fact CQ csf is closed under disjoint union. Every CQ whose graph is a clique or a k-tree (a maximal graph of treewidth k) with k > 1 is in CQ csf . Some concrete examples for CQs in CQ csf are given below, filled circles indicating answer variables: We believe that CQ csf includes many relevant CQs that occur in practical applications. To substantiate this, we have analyzed the 65 queries that are part of three widely used benchmarks for ontology-mediated querying, namely Fishmark, LUBM \u2203 , and NPD [Bail et al., 2012;Lutz et al., 2013;Lanti et al., 2015]. We found that more than 85% of the queries fall into CQ csf while less than 5% fall into ELIQ sf . Universal Models. Let A be an ABox and O an EL rontology. The universal model of A and O, denoted U A,O , is the interpretation obtained by starting with A and then 'chasing' with the CIs in the ontology which adds (potentially infinite) ditrees below every a \u2208 ind(A). The formal definition is in the appendix. The model is universal in that U A,O |= q(\u0101) iff A, O |= q(\u0101) for all CQs q(x) and tuples\u0101 \u2208 ind(A) |x| . It can be useful to represent universal models in a finite way, as for example in the combined approach to ontology-mediated querying [Lutz et al., 2009]. Here, we introduce a finite representation that is tailored towards our class CQ csf .\nThe 3-compact model C 3 A,O of A and O is defined as follows. Let sub(O) be the set of all concepts in O, closed under subconcepts. C 3 A,O uses the individual names from A as well as individual names of the form c a,i,r,C where a \u2208 ind(A), 0 \u2264 i \u2264 4, r is a role name from O, and C \u2208 sub(O). For every role name r, we use C r to denote the conjunction over all C such that \u2203r \u2212 . C \u2208 O, and if the conjunction is empty. Let i \u2295 1 be short for (i mod 4) + 1. Define\nC 3 A,O := A \u222a {A(a) | A, O |= A(a)} \u222a {A(c a,i,r,C ) | O |= C C r A} \u222a {r(a, c a,0,r,C ) | A, O |= \u2203r.C(a)} \u222a {r(c a,i,s,C , c a,i\u22951,r,C ) | O |= C C s \u2203r.C }.\nThere is a homomorphism from U A,O to C 3 A,O that is the identity on ind(A), but in general not vice versa. Nevertheless, C 3 A,O is universal for CQ csf . Lemma 1. Let A be an ABox and O an EL r -ontology. Then\nC 3 A,O is a model of A and O such that for every CQ q(x) \u2208 CQ csf and\u0101 \u2208 ind(A) |x| , C 3 A,O |= q(\u0101) iff A, O |= q(\u0101). C 3 A,O\nis defined so as to avoid spurious cycles of length at most 3 while larger spurious cycles are irrelevant for CQs that are chordal. This explains the superscript \u2022 3 and enables the lemma below. C 3 A,O also avoids spurious predecessors connected via different role names. Spurious predecessors connected via the same role name cannot be avoided, but are irrelevant for CQs that are symmetry-free. Lemma 2. Every cycle in C 3 A,O of length at most three consists only of individuals from ind(A).\nWe also use the direct product I 1 \u00d7 I 2 of interpretations I 1 and I 2 , defined in the standard way (see appendix). For tuples of individuals\u0101 i = (a i,1 , . . . , a i,n ), i \u2208 {1, 2}, we set a 1 \u2297\u0101 2 = ((a 1,1 , a 2,1 ), . . . , (a 1,n , a 2,n )).", "publication_ref": ["b3", "b3", "b6", "b6", "b6"], "figure_ref": [], "table_ref": []}, {"heading": "Learning under EL r -Ontologies", "text": "We establish polynomial time learnability results under EL rontologies for the query classes CQ csf , ELQ, and ELIQ sf . For CQ csf , we additionally have to assume that the arity of CQs to be learned is bounded by a constant or that unrestricted CQs can be used in equivalence queries. When speaking of equivalence queries, we generally imply that the CQs used in such queries must be from the class of CQs to be learned. If this is not the case and unrestricted CQs are admitted in equivalence queries, then we speak of CQ-equivalence queries. When using CQ-equivalence queries, the learned representation of the target query is a CQ, but need not necessarily belong to C (though it is equivalent to a query from C). For w \u2265 0, let CQ csf w be the restriction of CQ csf to CQs of arity at most w. The following are the main results obtained in this section. Theorem 1.\n1. ELQ-and ELIQ sf -queries are polynomial time learnable under EL r -ontologies using membership and equivalence queries;\n2. for every w \u2265 0, CQ csf w -queries are polynomial time learnable under EL r -ontologies using membership and equivalence queries; 3. CQ csf -queries are polynomial time learnable under EL r -ontologies using membership and CQ-equivalence queries.\nBefore providing a proof of Theorem 1, we show that both membership and equivalence queries are needed for polynomial learnability. Let AQ \u2227 denote the class of unary CQs of the form q(\nx) \u2190 A 1 (x) \u2227 \u2022 \u2022 \u2022 \u2227 A n (x)\n, and let a conjunctive ontology be an EL-ontology without role names.\nTheorem 2.\n1. AQ \u2227 -queries are not polynomial query learnable under conjunctive ontologies using only membership queries;\n2. ELQ-queries are not polynomial time learnable (without ontologies) using only CQ-equivalence queries unless P = NP. unrestricted CQs are not polynomial time learnable with only equivalence queries in the classical setting (without ontologies) unless P = NP, even when only unary and binary relations are admitted, see [Cohen, 1995;Haussler, 1989;Hirata, 2000] for related results. The proof of Point 1 follows basic lower bound proofs for abstract learning problems [Angluin, 1987b]. Point 2 is proved by exploiting connections between active learning and inseparability questions studied in [Funk et al., 2019;Jung et al., 2020;Funk, 2019].", "publication_ref": ["b3", "b5", "b2", "b3", "b6", "b3"], "figure_ref": [], "table_ref": []}, {"heading": "Reduction to Normal Form", "text": "We show that the ontology under which we learn can w.l.o.g. be assumed to be in normal form. It is well-known that every EL r -ontology O can be converted into normal form by introducing fresh concept names [Baader et al., 2017]. We use such a conversion to show that, for the relevant classes of CQs, a polynomial time learning algorithm under EL rontologies in normal form can be converted into a polynomial time learning algorithm under unrestricted EL r -ontologies. Care has to be exercised as the fresh concept names can occur in membership and equivalence queries. From now on, we thus assume that ontologies are in normal form. Proposition 1. Let Q \u2208 {ELQ, ELIQ sf , CQ csf w | w \u2265 0}. If queries in Q are polynomial time learnable under EL rontologies in normal form using membership and equivalence queries, then the same is true for unrestricted EL r -ontologies.", "publication_ref": ["b3"], "figure_ref": [], "table_ref": []}, {"heading": "Algorithm Overview", "text": "We start with proving Points 1 and 2 of Theorem 1. Thus let Q \u2208 {ELQ, ELIQ sf , CQ csf w | w \u2265 0}. The algorithm that establishes polynomial time learnability of queries from Q under EL r -ontologies is displayed as Algorithm 1. We next explain some of its details.\nLet O be an EL r -ontology, \u03a3 a finite signature that contains all symbols in O, and ar \u2264 w an arity for the query to be learned with ar = 1 if Q \u2208 {ELQ, ELIQ sf }, all known to the learner and the oracle. Further let q T (\u0233) \u2208 Q be the target query known to the oracle, formulated in signature \u03a3. The algorithm maintains and repeatedly updates a hypothesis CQ q H (x) of arity ar. It starts with the hypothesis\nq \u22a5 (x 0 ) \u2190 {A(x 0 ) | A \u2208 \u03a3\u2229N C }\u222a{r(x 0 , x 0 ) | r \u2208 \u03a3\u2229N R }\nwherex 0 contains only the variable x 0 , repeated ar times. By construction, q \u22a5 \u2286 O q for all CQs q of arity ar that use only symbols from \u03a3. Note that q \u22a5 \u2208 CQ csf w for all w, but q \u22a5 is neither in ELQ nor in ELIQ sf .\nIf q 1 (x 1 ), q 2 (x 2 ), . . . are the hypotheses constructed during a run of the algorithm, then for all i \u2265 1:\n1. q i \u2208 Q and q i \u2286 O q T ; 2. q i \u2286 O q i+1 and q i \u2261 O q i+1 ; 3. |var(q i )| \u2264 |var(q T )|.\nTaken together, Points 1 and 2 mean that the hypotheses approximate the target query from below in an increasingly better way and Point 3 is crucial for proving that we must reach q T after polynomially many steps. The fact that O is in normal form is used to attain Point 3.\nPoint 1 also guarantees that the oracle always returns a positive counterexample A,\u0101 to the equivalence query used to check whether q H \u2261 O q T in the while loop. The algorithm extracts the commonalities of q H (x) and A,\u0101 by means of a direct product with the aim of obtaining a better approximation of the target. The same is done in the case without ontologies [ten Cate et al., 2013] \n(x) \u2208 Q such that q H \u2286 O q H \u2286 O q T .\nThe initial call to refine serves the same purpose as q \u22a5 (x 0 ) need not be in Q, depending on the choice of Q.\nIt is not immediately clear that the described approach achieves the containment in Point 2 since C 3 \nAq H ,O \u00d7 C 3 A,O", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "The refine Subroutine", "text": "The refine subroutine gets as input a CQ q H (x ) that does not need to be in Q, but that satisfies\nq H \u2286 O q T . It produces a query q H (x) from Q such that q H \u2286 O q H \u2286 O q T and |var(q H )| \u2264 |var(q T )|.\nFor notational convenience, we prefer to view q H (x ) as a pair (A,\u0101) where A = A q H and\u0101 =x .\nLet n max denote the maximum length of a chordless cycle in any query in Q, that is n max = 0 for Q \u2208 {ELQ, ELIQ sf } and n max = 3 for Q = CQ csf w , w \u2265 0. We shall use the following. The refine subroutine builds a sequence (B 1 ,b 1 ), (B 2 ,b 2 ), . . . starting with (B 1 ,b 1 ) = (minimize(A,\u0101),\u0101) and exhaustively applying the following step:", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Expand.", "text": "Choose a chordless cycle R 0 (a 0 , a 1 ), . . . , R n\u22121 (a n\u22121 , a n ) in B i with n > n max and, in case that Q = CQ csf w , {a 0 , . . . , a n\u22121 } \u2286b i . 1 Let B i be the ABox obtained by doubling the length of the cycle: start with B i , introduce copies a 0 , . . . , a n\u22121 of a 0 , . . . , a n\u22121 , and then\n\u2022 remove all assertions R(a n\u22121 , a 0 );\n\u2022 add B(a i ) if B(a i ) \u2208 B i ; \u2022 add R(a i , c) if R(a i , c) \u2208 B i with 0 \u2264 i < n and c \u2208 ind(B i ) \\ {a 0 , . . . , a n\u22121 }; \u2022 add R(a i , a j ) if R(a i , a j ) \u2208 B i with 0 \u2264 i, j < n and {i, j} = {0, n \u2212 1}; \u2022 add R(a n\u22121 , a 0 ) and R(a n\u22121 , a 0 ) if R(a n\u22121 , a 0 ) \u2208 B i . A similar construction is used in [Konev et al., 2016]. Let \u03c4 i be the set of tuplesb obtained fromb i = (b 1 , . . . , b k ) by replacing any number of components b j by b j . Use member- ship queries to identifyb i+1 \u2208 \u03c4 i with B i , O |= q T (b i+1 ) and set B i+1 = minimize(B i ,b i+1 ).\nWe prove in the appendix that such ab i+1 always exists and that the Expand step can only be applied polynomially many times. The resulting (B n ,b n ) viewed as a CQ with answer variablesb n is chordal, but not necessarily symmetry-free. To establish also the latter, we compute a sequence of ABoxes B n , B n+1 , . . . by exhaustively applying the following step: \nB i with S(d, b) = r(c, b). If B i , O |= q T (b n ), then B i+1 = minimize(B i ,b n ).\nWe prove in the appendix that only polynomially many applications are possible and that, for B m the resulting ABox, (B m ,b n ) viewed as a CQ is chordal and symmetry-free. Moreover, it is in ELQ if q T is, and likewise for ELIQ sf . Refine returns this CQ as its result. Note that the running time of refine depends exponentially on ar due to the brute force search for a tupleb i+1 \u2208 \u03c4 i in the Expand step.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Unbounded Arity", "text": "To prove the remaining Point 3 of Theorem 1, we have to deal with CQs of unbounded arity and cannot use the refine subroutine presented in Section 3.3. We thus introduce a second version of refine that works rather differently from the previous one. We give an informal description, full details are in the appendix.\nRecall that refinement starts with the product\nP = C 3 Aq H ,O \u00d7 C 3 A,O\n. In Section 3.3, we blow up cycles in P , not distinguishing the ABox part and the existentially generated part of the 3-compact models involved. The second version of refine instead unravels the existentially generated part of the two 3-compact models inside the product P . A full such unraveling would eventually result in U Aq H ,O \u00d7 U A,O , but we interleave with a Minimize step as in Section 3.3 and thus obtain a finite initial piece thereof. Unlike in the previous version of refine, we do not have to redefine the answer variables at all (but note that they may still change outside of refine when we take the product).\nThe above suffices for target CQs from CQ csf in which every variable is reachable from an answer variable. In the general case, disconnected Boolean components might be present (or emerge during unraveling and minimization) that are never unraveled. To address this, we subsequently apply the original version of refine to such components, avoiding the Splitting step and leaving the already unraveled parts untouched. Note that the exponential blowup in the arity is avoided because the original refine is only applied to Boolean subqueries. However, the resulting queries are not guaranteed to be in CQ csf . We can thus not rely on Lemma 1 as before which is why we need CQ-equivalence queries.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Learning under ELI-Ontologies", "text": "When we replace EL r -ontologies with ELI-ontologies, polynomial time learnability can no longer be expected since containment between ELQs under ELI-ontologies is EXPTIMEcomplete [Baader et al., 2008]. In contrast, polynomial query learnability is not ruled out and in fact it is natural to ask whether there is a polynomial time learning algorithm with access to an oracle (in the classical sense) for query containment under ELI-ontologies. Note that such an algorithm would show polynomial query learnability. We answer this question to the negative and show that polynomial query learnability cannot be attained under ELI-ontologies for any of the query classes considered in this paper. This is a consequence of the following result, which also captures learning of unrestricted CQs. Theorem 3. EL-concepts are not polynomial query learnable under ELI-ontologies with membership queries and CQ-equivalence queries.\nFor the proof, we use the ELI-ontologies O n , n \u2265 1, given in Figure 1. There, r = s and s = r. Every O n is associated with a set H n of 2 n potential target concepts of the form\n\u2203\u03c3 1 \u2022 \u2022 \u2022 \u2203\u03c3 n .\u2203r n .A with \u03c3 1 , . . . , \u03c3 n \u2208 {r, s}\nwhere \u2203r n denotes the n-fold nesting of \u2203r. The idea of the proof is to show that if there was an algorithm for learning EL-concepts under ELI-ontologies such that, at any given time, the sum of the sizes of all (membership and CQequivalence) queries asked to the oracle is bounded by a polynomial p(n 1 , n 2 , n 3 ) with n 1 is the size of the target query, n 2 is the size of the ontology, and n 3 is the size of the largest counterexample seen so far, then we can choose n large enough so that the learner needs more than p(n 1 , n 2 , n 3 ) queries to distinguish the targets in H n under O n if the oracle uses a 'sufficiently destructive' strategy to answer the queries. Such a strategy is presented in the appendix, we only give one example that highlights a crucial aspect.\nAssume that the learner poses as an equivalence query the EL-concept C H = \u2203\u03c3 1 \u2022 \u2022 \u2022 \u2203\u03c3 n .\u2203r n .A. Then the \u2203r.\n\u2203s. \nLi \u2203r.Li+1 \u2203s.Li+1 for 0 \u2264 i \u2264 n Li \u2203r.Li+1 for n \u2264 i < 2n L2n A \u2203\u03c3.Li+1 Li for \u03c3 \u2208 {r, s} and 0 \u2264 i \u2264 2n Ki \u2203r.(Ki+1 V r i+1 ) \u2203s.(Ki+1 V s i+1 ) for \u03c3 \u2208 {r, s} and 0 \u2264 i \u2264 n Ki W \u03c3 i+1 \u2203r.Ki+1 for \u03c3 \u2208 {r, s} and n \u2264 i < 2n \u2203\u03c3 \u2212 .(Kj V \u03c3 i ) V \u03c3 i for \u03c3, \u03c3 \u2208 {r, s}, 1 \u2264 i \u2264 n, and i \u2264 j \u2264 2n K2n V \u03c3 i W \u03c3 i A for \u03c3 \u2208 {r, s} and 1 \u2264 i \u2264 n \u2203\u03c3.W \u03c3 i W \u03c3 i for \u03c3 \u2208 {r, s, r \u2212 , s \u2212 }, \u03c3 \u2208 {r, s}, and 1 \u2264 i \u2264 n W r i W s i L0 for 0 \u2264 i \u2264 n \u2203\u03c3.Ki+1 Ki for \u03c3 \u2208 {r, s} and 0 \u2264 i \u2264 2n \u2203\u03c3 \u2212 . U \u03c3 1 for \u03c3 \u2208 {r, s} \u2203\u03c3 \u2212 .U \u03c3 i U \u03c3 i+1 for \u03c3, \u03c3 \u2208 {r, s} and 1 \u2264 i < 2n U r i U s i D for 1 \u2264 i \u2264 2n Ki A D for 0 \u2264 i < 2n Li A D for 0 \u2264 i < 2n Li Lj D for n \u2264 i < j \u2264 2n Ki Kj D for n \u2264 i < j \u2264 2n Li Kj D for n \u2264 i, j \u2264 2n \u2203\u03c3.D D for \u03c3 \u2208 {r, s, r \u2212 , s \u2212 } D L0\nA = {K 0 (a 0 ), W \u03c31 1 (a 0 ), . . . , W \u03c3n n (a 0 )}. It is instructive to ver- ify that A, O |= C H (a 0 ) for all C H \u2208 H n \\ {C H } while A, O |= C H (a 0 ) as this illustrates the use of inverse roles in O n .", "publication_ref": ["b2"], "figure_ref": ["fig_4"], "table_ref": []}, {"heading": "Conclusion", "text": "We conjecture that our results can be extended from EL rontologies to ELH r -ontologies, thus adding role inclusions. In contrast, we do not know how to learn in polynomial time unrestricted ELI-concepts under EL-ontologies, or symmetry-free CQs under EL-ontologies. We would not be surprised if these indeed turn out not to be learnable in polynomial time. It is an interesting question whether our results can be generalized to symmetry-free CQs that admit chordless cycles of length bounded by a constant larger than three. This would require the use of a different kind of compact universal model.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "A Appendix Preliminaries", "text": "We introduce some additional preliminaries that are needed for the lemmas and proofs in the appendix.\nLet O be an EL r -ontology in normal form. We say that an ABox A is O-saturated if A, O |= A(a) implies A(a) \u2208 A for all concept names A and a \u2208 ind(A).\nUniversal Models. The universal model of A and O, denoted U A,O , is the interpretation defined as follows. For every role name r, we use C r to denote the conjunction over all C such that \u2203r \u2212 . C \u2208 O; note that C r = if there is no such range restriction in O. A trace for A and O is a sequence Lemma 4. For an EL r -ontology O and CQs q 1 (x 1 ) and q 2 (x 2 ) of the same arity, the following are equivalent:\nt = ar 1 C 1 r 2 C 2 . . . r n C n , n \u2265 0, such that a \u2208 ind(A), {\u2203r 1 .C 1 , . . . , \u2203r n .C n } \u2286 sub(O), A, O |= \u2203r 1 .C 1 (a), O |= C i C ri \u2203r i+1 .C i+1 for 1 \u2264 i < n. Let T denote\n1. q 1 \u2286 O q 2 ,\n2. there is a homomorphism h from q 2 to U Aq 1 ,O with h(x 1 ) =x 2 .\nLet I 1 , I 2 be interpretations and let h be a mapping from \u2206 I1 to \u2206 I2 . The image of h, denoted img(h), is the set {b \u2208 \u2206 I2 | \u2203a : h(a) = b}. Let g be a homomorphism from an ABox A to a universal model U B,O . Then let g * be defined to be a mapping from ind(A) to ind(B) by setting g * (a) = b when g(a) is a trace of shape bw for w a potentially empty sequence\nr 1 C 1 \u2022 \u2022 \u2022 r n C n .\nDirect Products. The direct product of interpretations I 1 and I 2 is the interpretation I 1 \u00d7 I 2 defined as\n{ (a 1 , a 2 ) | a i \u2208 \u2206 Ii for i \u2208 {1, 2}} \u222a {A(a 1 , a 2 ) | A(a i ) \u2208 I i for i \u2208 {1, 2}} \u222a {r((a 1 , a 2 ), (b 1 , b 2 )) | r(a i , b i ) \u2208 I i for i \u2208 {1, 2}}. Ifd i = (d i,1 , . . . , d i,n ) \u2208 \u2206 Ii for i \u2208 {1, 2}, then we us\u0113 d 1 \u2297d 2 to denote the tuple ((d 1,1 , d 2,1 ), . . . , (d 1,n , d 2,n )).\nThe following are some basic facts about products that are straightforward to show.\nLemma 5. Let I, I 1 and I 2 be interpretations. Then\n1. for i \u2208 {1, 2} there is a homomorphism h from I 1 \u00d7I 2 to I i such that h(d 1 , d 2 ) = d i for all (d 1 , d 2 ) \u2208 \u2206 I1\u00d7I2 ;\n2. if for all i \u2208 {1, 2} there is a homomorphism h i from I to I i with h i (d) = d i , then there is a homomorphism h from I to I 1 \u00d7 I 2 with h(d) = (d 1 , d 2 );\n3. if I 1 and I 2 are models of O, then so is I 1 \u00d7 I 2 .\nSimulations. A simulation from interpretation I 1 to interpretation I 2 is a relation S \u2286 \u2206 I1 \u00d7 \u2206 I2 that satisfies the following conditions:\n1. if A(d) \u2208 I 1 and (d, e) \u2208 S, then A(e) \u2208 I 2 ; 2. if r(d, d ) \u2208 I 1 and (d, e) \u2208 S, then there is an r(e, e ) \u2208 I 2 with (d , e ) \u2208 S .\nWe further say that S is a simulation from I 1 , d 1 to I 2 , d 2 if S is a simulation from I 1 to I 2 with (d 1 , d 2 ) \u2208 S; we write\nI 1 , d 1 I 2 , d 2 if such a simulation S exists.\nThe following are a basic facts about simulations and homomorphisms that are standard to proof. Lemma 6. Let I i be an interpretation and To simplify some of our proofs, it is useful to consider a strengthening of the condition of symmetry-freeness from the definition of CQ csf . We say that a CQ is strongly symmetryfree if \u03d5 contains atoms r(y 1 , x), r(y 2 , x), then x is an answer variable or one of the atoms occurs on a cycle. Thus, the possibility that \u03d5 contains an atom s(z, z) for some z \u2208 {x, y 1 , y 2 } from the original definition of symmetry-freeness is excluded. In the following, we show that every CQ from CQ csf is equivalent to one that is strongly symmetry-free.\nd i \u2208 \u2206 Ii , for i \u2208 {1, 2}. Then I 1 , d 1 I 2 , d 2 and d 1 \u2208 C I1 implies d 2 \u2208 C I2 for all EL-concepts C. Lemma 7. Let O be an EL r -ontology and A 1 , A 2 ABoxes. Then 1. every homomorphism h from A 1 to A 2 can be extended to a homomorphism h from U A1,O to U A2,O such that if a / \u2208 ind(A 1 ) is a trace a = bw, then h (a) is a trace of shape h(a)w , and in particular, a / \u2208 ind(A 1 ) implies h (a) / \u2208 ind(A 2 ); 2. if A 1 , a 1 A 2 , a 2 , then U A1,O , a 1 U A2,O , a 2 . Lemma 8. Let A 1 , A 2 be ABoxes, a 1 \u2208 ind(A i ) for i \u2208 {1,\nTwo CQs q 1 and q 2 of the same arity are equivalent, written q 1 \u2261 q 2 , if q 1 \u2261 \u2205 q 2 for \u2205 the empty ontology.\nLemma 9. For every q \u2208 CQ csf , there is a q \u2208 CQ csf such that q \u2261 q and q is strongly symmetry-free.\nProof. To construct q , start from q. Then introduce, for every quantified variable x that occurs in an atom of the form r(x, x) in q, a fresh quantified variable x and add the atom B(x ) for every atom B(x) in q and S(y, x ) for every atom S(y, x) in q. We say that x is a copy of x.\nIt is clear that q \u2261 q as there is a homomorphism from q to q and by Lemma 4. Moreover, q is strongly symmetry-free. To see this, assume that q contains atoms r(x 1 , y), r(x 2 , y) with y a quantified variable. We distinguish three cases.\nFirst assume r(x 1 , y), r(x 2 , y) are already in q. Since q is symmetry-free, q also contains an atom of the form s(x 1 , x 1 ), s(x 2 , x 2 ), or s(y, y). In the first case, q contains the cycle r(x 1 , y), r \u2212 (y, x 1 ), s \u2212 (x 1 , x 1 ) and thus atom r(x 1 , y) occurs on a cycle in q . In the second case, atom r(x 2 , y) occurs on a cycle and in the third case both atoms do. Now assume that r(x 1 , y) is not in q. Then x 1 is a copy of a variable x 0 1 in q or y is a copy of a variable y 0 in q (or both). In the first case, q contains a cycle of the form r(x 1 , y), r \u2212 (y, x 0 1 ), s(x 1 , x 0 1 ) and thus r(x 1 , y) occurs on a cycle in q . In the second case, q contains a cycle of the form r(x 1 , y), s \u2212 (y, y 0 ), r \u2212 (y 0 , x 1 ) and thus again r(x 1 , y) occurs on a cycle in q .\nThe case that r(x 2 , y) is not in q is symmetric.\nIt might seem that we should change the definition of the class CQ csf to be based on strong symmetry-freeness. This, however, is not possible because the CQ produced by the first version of refine is only symmetry-free, but not strongly symmetry-free. We can also not use the construction from the proof of Lemma 9 as part of refine to attain strong symmetryfreeness as this interferes with minimization, that is, it would no longer be guaranteed that |var(q H )| \u2264 |var(q T )|.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "B Proof of Lemma 1", "text": "The following is easy to show, details are omitted. Proof. It is not difficult to prove that C 3 O,A is indeed a model of A and O, details are omitted. Let q(x) \u2208 CQ csf and\u0101 \u2208 ind(A) |x| . We have to show that C 3 A,O |= q(\u0101) iff A, O |= q(\u0101). By Lemma 9, we can assume w.l.o.g. that q is strongly symmetry-free. The \"if\" direction is trivial by Lemma 3 and because there is an obvious homomorphism from U A,O to C 3 A,O that is the identity on ind(A). We thus concentrate on \"only if\". Let q(x) \u2208 CQ csf and assume that C 3 A,O |= q(\u0101). Then there is a homomorphism h from q to C 3 A,O with h(x) = a. In what follows, we construct a homomorphism g from q to U A,O with g(x) =\u0101. Thus, A, O |= q(\u0101) as required.\nTo start the definition of g, set g(x) = h(x) whenever h(x) \u2208 ind(A). It follows from the construction of C 3", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "A,O", "text": "and U A,O that g is a homomorphism from the restriction of q to the domain of g to U A,O .\nAs a consequence of Lemma 2, if a variable x occurs on a cycle of length 1 or 2 in q, then g(x) is defined at this point. We next define g(x) for all variables x 0 that are on a cycle\nR 0 (x 0 , x 1 ), R 1 (x 1 , x 2 ), R 2 (x 2 , x 0 ) of length 3 in q. Assume that g(x 0 )\nwas not yet defined. It follows from Lemma 2 that then h(x 1 ) = h(x 2 ) \u2208 ind(A), and thus A contains a reflexive R 1 -cycle on h(x 1 ), R 0 = R \u2212 2 , and h(x 0 ) / \u2208 ind(A). Let h(x 1 ) = a. By construction of C 3 A,O , h(x 0 ) = c a,0,r,C for some C and where r = R 0 if R 0 is a role name and r = R 2 otherwise. Set g(x 0 ) = arC. Also after the extension, g is a homomorphism from the restriction of q to the (now extended) domain of g to U A,O . This is easily seen to be a consequence of the definition of the extension and of the construction of C 3 A,O and U A,O . At this point, g(x) is defined for all variables x that occur on a cycle in q. Assume that x is such a variable. If x is an answer variable, then g(x) is clearly already defined. Otherwise chordality of q implies that x also occurs on a cycle of length at most 3 and thus g(x) has been defined above. It remains to define g(x) for variables x that do not occur on a cycle.\nLet q be the subquery of q consisting of all atoms that contain at least one variable x with g(x) undefined at this point. We argue that 1. q is a disjoint union of ditrees such that 2. if g(x) is defined for a variable x in q , then x is the root of a ditree.\nFirst note that ( * ) none of the atoms r(x 1 , x 2 ) in q occur on a cycle in q.\nIn fact, if an atom r(x 1 , x 2 ) in q occurs on a cycle in q, then g(x 1 ) and g(x 2 ) are already defined and thus r(x 1 , x 2 ) is not part of q . For Point 1, first observe that q does not contain a cycle. In fact, any cycle C in q is also a cycle in q, so by ( * ) q does not contain any of the atoms in C. To establish Point 1, it remains to show that q contains no atoms r 1 (x 1 , y), r 2 (x 2 , y) with x 1 = x 2 . By definition of q , one of g(x 1 ), g(y) and one of g(x 2 ), g(y) must be undefined. There are two cases:\n\u2022 g(y) is undefined.\nThen y is a quantified variable and r 1 = r 2 , the latter because r 1 (h(x 1 ), h(y)), r 2 (h(x 2 ), h(y)\n) \u2286 C 3 A,O , h(y) / \u2208 ind(A) as g(y)\nis undefined, and by definition of C 3 A,O . Moreover, by ( * ) none of r 1 (x 1 , y), r 2 (x 2 , y) occurs on a cycle in q. Thus, q is not strongly symmetryfree, a contradiction.\n\u2022 g(x 1 ), g(x 2 ) are undefined.\nThen h(x 1 ) and h(x 2 ) are not in ind(A). From r 1 (h(x 1 ), h(y)), r 2 (h(x 2 ), h(y)) \u2286 C 3 A,O and the definition of C 3 A,O , we obtain h(y) / \u2208 ind(A). We can now argue as in the previous case that y is a quantified variable and r 1 = r 2 , and again obtain a contradiction to q being strongly symmetry-free. Now for Point 2. It suffices to observe that if r(x, y) is an atom in q , then g(y) is undefined. Assume to the contrary that g(y) is already defined. By choice of q , it follows that g(x) is undefined. As g(y) is defined, one of the following applies:\n\u2022 h(y) \u2208 ind(A).\nThen r(h(x), h(y)) \u2208 C 3 A,O and the definition of\nC 3 A,O\nimply that h(x) \u2208 ind(A), in contradiction to g(x) being undefined.\n\u2022 there is an atom s(x , y) in q with h(x ) \u2208 ind(A), and h(y\n) / \u2208 ind(A). From h(x ) \u2208 ind(A), h(y) / \u2208 ind(A), s(h(x ), h(y)), r(h(x), h(y)) \u2208 C 3 A,O and the defi- nition of C 3 A,O , we obtain h(x ) = h(x). But then h(x) \u2208 ind(A), in contradiction to g(x) not yet being defined.\nWe next traverse the ditrees in q in a top-down fashion to extend g. The initial piece of g constructed so far is such that for all variables x, h(x) = c a,i,r,C implies that g(x) is of the form trC. We shall maintain this invariant during the extension of g.\nTo extend g, repeatedly and exhaustively choose atoms r(x, y) \u2208 q with g(x) defined and g(y) undefined. Then h(y) / \u2208 ind(A) and thus h(y) has the form c a,i,r,C . Define g(y) to be g(x)rC. 1. AQ \u2227 -queries are not polynomial query learnable under conjunctive ontologies using only membership queries;\n2. ELQ-queries are not polynomial time learnable (without ontologies) using only CQ-equivalence queries unless P = NP.\nProof. For Point 1, we use a proof strategy that is inspired by basic lower bound proofs for abstract learning problems due to Angluin [Angluin, 1987b]. Here, it is convenient to view the oracle as an adversary who maintains a set S of candidate target concepts that the learner cannot distinguish based on the queries made so far. In our case, S of AQ \u2227 -queries. We have to choose S and the ontology O carefully so that each membership query removes only few candidate targets and after a polynomial number of queries there is still more than one candidate that the learner cannot distinguish. For each n \u2265 1, let\nO n = {A i A i A 1 A 1 \u2022 \u2022 \u2022 A n A n | 1 \u2264 i \u2264 n} and S n = {q(x) \u2190 \u03b1 1 (x) \u2227 \u2022 \u2022 \u2022 \u2227 \u03b1 n (x) | \u03b1 i \u2208 {A i , A i } for all i with 1 \u2264 i \u2264 n}.\nThe set S n contains 2 n queries.\nAssume to the contrary of what is to be shown that AQ \u2227queries are polynomial query learnable under conjunctive ontologies. Then there exists a learning algorithm and polynomial p such that the number of membership queries is bounded by p(n 1 , n 2 ), where n 1 is the size of the target query q T and n 2 is the size of the conjunctive ontology. We choose n such that 2 n > p(r 1 (n), r 2 (n)), where r 1 is a polynomial such that every query q\n(x) \u2208 S m satisfies ||q(x)|| = r 1 (m) and r 2 is a polynomial such that r 2 (m) > ||O m || for every m \u2265 1.\nNow, consider a membership query posed by the learning algorithm with ABox and answer variable (A, a). The oracle responds as follows: Note that the third response is consistent since A must then contain A i (a) and A i (a) for some i and thus O n implies that a is an answer to every query in S n . Moreover the answers are always correct with respect to the updated set S n . Thus the learner cannot distinguish the remaining candidate queries by answers to queries posed to far. It follows that the learning algorithm removes at most p(r 1 (n), r 2 (n)) many queries from S n . By the choice of n, at least two candidate concepts remain in S n after the algorithm is finished. Thus the learner cannot distinguish between them and we have derived a contradiction.\n1. if A, O n |= q(a)\nFor Point 2, we exploit a classic connection between active learning with equivalence queries and certain separability problems. We start by recalling the latter. A labeled KB takes the form K = (O, A, P, N ) with O an ontology, A an ABox, and P, N \u2286 ind(A) n sets of positive and negative examples, respectively, all of them tuples of the same length n. A query q(x) of arity n separates K if 1. A, O |= q(\u0101) for all\u0101 \u2208 P , and\n2. A, O |= q(\u0101) for all\u0101 \u2208 N .\nEvery choice of ontology language L and query language Q gives rise to an L, Q-separability problem which is to decide, given a labeled KB K = (O, A, P, N ) with O formulated in L, whether there is a query q(x) \u2208 Q which separates P and N . We are going to concentrate on the case where the ontology is empty, which we simply refer to as Q-separability. For simplicity, we then drop the ontology from labeled KBs. It was shown in [Jung et al., 2020;Funk, 2019] that ELQ-separability is NP-hard. An analysis of the proof reveals a class C of labeled KBs (A, P, N ) for which ELQ-separability is NP-hard and a polynomial t such that the following conditions are satisfied:\n1. if K is ELQ-separable, then there is a separating ELQquery of size t(n), where n = ||K||; 2. A is a disjoint union of ditrees of depth 1 and the elements of P and N are the roots of these ditrees; 3. only a single role name r is used. Condition 2 implies the following. Claim 1. Given an ABox A that satisfies the properties given in Condition 2, an a \u2208 ind(A), and a unary CQ q(x), it can be decided in polynomal time whether A |= q(a).\nWe only sketch the proof. To check whether there is a homomorphism h from q(x) to A with h(x) = a, we treat each maximal connected component of q separately. For the component that contains x, we start with setting h(x) = a. We then repeatedly extend h to variables y such that q contains some atom r(y, z) or r(z, y) with h(z) already defined. If there are atoms of both forms, then A |= q(a). If there is an atom r(y, z) and h(z) is a non-root in A, then h(y) is the unique predecessor of h(z) in A; and if h(z) is a root, then A |= q(a). If there is an atom r(z, y), then A |= q(a) if h(z) is a non-root. Otherwise, we consider all atoms A(z) in q and set h(y) to some successor c of h(z) in A such that A(c) \u2208 A for all these atoms; if there is no such successor, then again A |= q(a). For components that do not contain x we start with an arbitrarily chosen variable, iterate over all individuals in A as targets, and for each target proceed as described above.\nNow assume that ELQ-queries are polynomial time learnable using only CQ-equivalence queries. Then there exists a learning algorithm L for ELQ-queries and a polynomial p such that at any time, the running time of L so far is bounded by p(n 1 , n 2 ), where n 1 is the size of the target query q T and n 2 is the size of the largest counterexample seen so far. We show how to use L to construct an algorithm L that decides ELQ-separability for the class of labeled KBs C in polynomial time.\nThe new algorithm L takes as input a labeled KB K = (A, P, N ) \u2208 C. Let n = ||K||. L then runs L for at most p(t(n), n) steps.\nWhenever L asks a CQ-equivalence query with q H (x) as the hypothesis, L answers it by testing whether q H separates K. More precisely, L checks whether A |= q H (a) for all a \u2208 P and A |= q H (a) for all a \u2208 N . Note that, by the above claim, this is possible in time polynomial in ||K||. If a check fails for some a \u2208 P , then L answers the equivalence query by giving (A, a) as a positive counterexample to L. If a check fails for some a \u2208 N , then L answers the equivalence query by giving (A, a) as a negative counterexample to L. If all checks succeed, then L terminates and returns \"separable\".\nIf L terminates returning a learned ELQ-query q H , then L tests whether q H separates K. If this is the case, then L returns \"separable\". If L does not terminate within p(t(n), n) steps or returns a query that does not separate K, then L return \"not separable\". The following claim shows correctness of L . Claim 2. L returns \"separable\" iff K is ELQ-separable.\nProof of Claim 2. The \"only if\" direction follows directly from the fact that L only returns \"separable\" if there is a separating CQ. For the \"if\" direction, assume that K is not ELQ-separable. By Condition 1 above, there is an ELQ-query q T of size t(n) that separates K. Note that q T is consistent with the counterexamples that L provides to L. Since by assumption L is able to learn any Q-query of size t(n) with counterexamples of size n in p(t(n), n) steps, it must within this number of steps either ask an equivalence query with a hypothesis that separates K (but may not be equivalent to q T ), or return a Q-query that is equivalent to q T . In both cases L returns \"separable\".", "publication_ref": ["b2", "b6", "b3"], "figure_ref": [], "table_ref": []}, {"heading": "D Proofs for Section 3.1", "text": "It is well-known that every EL r -ontology O can be converted into an EL r -ontology O in normal form by introducing additional concept names [Baader et al., 2017]. For the reduction, it is convenient to use a suitable form of conversion. Lemma 11. Given an EL r -ontology O, one can compute in polynomial time an EL r -ontology O in normal form such that:\nAn EL r -ontology O 2 is a conservative extension of an EL r - ontology O 1 if sig(O 1 ) \u2286 sig(O 2 ),\n1. O is a conservative extension of O, 2. sig(O ) = sig(O) \u222a {X C | C \u2208 sub(O)}, 3. O |= X C \u2261 C for each C \u2208 sub(O).\nProof. Introduce a fresh concept name X C for every C \u2208 sub(O) and define O to contain, for every C \u2208 sub(O), the following concept inclusions and range restrictions:\n\u2022 X C C, C X C if C is a concept name or ; \u2022 X C X D1 , X C X D2 , and X D1 X D2 X C if C = D 1 D 2 ; \u2022 X C \u2203r.X D and \u2203r.X D X C if C = \u2203r.D; \u2022 X C X D for each concept inclusion C D \u2208 O; \u2022 \u2203r \u2212 . X C for each range restriction \u2203r \u2212 . C \u2208 O.\nO is in normal form and can be computed in polynomial time. Moreover, it can be verified that Points 1-3 hold.\nA CQ q can be obtained from a CQ q by attaching ditrees if q can be constructed by choosing variables x 1 , . . . , x n from q and Boolean ditree CQs q 1 , . . . q n whose sets of variables are pairwise disjoint and disjoint from the set of variables in q, and then taking the union of q and q 1 , . . . q n , identifying the root of q i with x i for 1 \u2264 1 \u2264 n. A class of CQs Q is closed under attaching ditrees if every CQ q that can be obtained from a q \u2208 Q by attaching ditrees is also in Q. Note that all of CQ csf , ELQ, and ELIQ sf are closed under attaching ditrees. We prove the following generalization of Proposition 1.\nProposition 2. Let Q be a class of CQs closed under attaching ditrees. If queries in Q are polynomial time learnable under EL r -ontologies in normal form using membership and equivalence queries, then the same is true for unrestricted EL r -ontologies.\nProof. Let L be a polynomial time learning algorithm for Q under ontologies in normal form. We show how L can be modified into an algorithm L that is able to learn Q under unrestricted ontologies in polynomial time.\nGiven an EL r -ontology O and a finite \u03a3 \u2286 N C \u222a N R such that sig(O) \u2286 \u03a3 and sig(q T ) \u2286 \u03a3, algorithm L first computes the ontology O in normal form as per Lemma 11, choosing the fresh concept names X C so that they are not from \u03a3. It then runs L on O and \u03a3 = \u03a3 \u222a {X C | C \u2208 sub(O)}; note that sig(O ) \u2286 \u03a3 as required. In contrast to the learning algorithm, the oracle still works with the original ontology O. To bridge this gap, algorithm L adopts modifications during the run of L , as follows.\nFirst, whenever L asks a membership query A , O |= q T (\u0101), L instead asks the membership query A, O |= q T (\u0101), where A is obtained from A by replacing each assertion X C (x) with the C viewed as an ABox, identifying the root with x.\nBy the following claim, the answer to the modified membership query coincides with that to the original query. Second, whenever L asks an equivalence query q H \u2261 O q T , L instead asks the equivalence query q H \u2261 O q T , where q H is obtained from q H by replacing each assertion X C (x) with the Boolean ditree CQ obtained from ELQ C by quantifying the root, identifying the root with x. Since Q is closed under attaching ditrees, q H can be used in an equivalence query. Furthermore, when the counterexample returned is A, the algorithm replaces it with the restriction A| \u03a3 to signature \u03a3 before passing it on to L .\nApplying the following claim to both q H and q T = q T , the answer to the modified equivalence query coincides with that to the original query. Claim 2. Let q be a CQ that uses only symbols from \u03a3 and let q be obtained from q by replacing each assertion X C (x) with the Boolean ditree CQ obtained from ELQ C by quantifying the root, the root identified with x. Then A| ", "publication_ref": ["b3"], "figure_ref": [], "table_ref": []}, {"heading": "E Proofs for Section 3.3", "text": "We analyze central properties of the refine subroutine. Recall that we first construct a sequence (B 1 ,b 1 ), (B 2 ,b 2 ), . . . using the Expand and Minimize steps. With B i , i \u2265 1, we denote the result of only applying the Expand step to B i , but not the Minimize step. Also recall that the fresh individuals introduced in B i are denoted with a in case that the original individual was a. The following can easily be shown. Lemma 12. Let i \u2265 1. Then B i , a B i , a and B i , a B i , a, for all a \u2208 ind(B i ), and B i , a B i , a and B i , a B i , a , for all fresh individuals a .\nWe start with proving properties of the Expand/Minimize phase. Lemma 13. For all i \u2265 1, the following properties hold:\n1. B i , O |= q T (b i ); 2. B i , O |= q T (b) for someb \u2208 \u03c4 i ;\nProof. We prove both points simultaneously by induction on i. For Point 1, the case i = 1 is immediate since (B 1 ,b 1 ) = minimize(A,\u0101) and A, O |= q T (\u0101), and the case i > 1 is an immediate consequence of the inductive hypothesis (Point 2), the choice ofb i , and the definition of the Minimize step.\nFor Point 2, the induction start and step are identical. Thus let i \u2265 1. Assume that B i was obtained from B i by expanding cycle R 0 (a 0 , a 1 ), . . . , R n\u22121 (a n\u22121 , a n ). By Point 1, there is a homomorphism h from q T to U Bi,O with h(x) =b i . We construct a homomorphism g from q T to\nU B i ,O with g(x) =b for someb \u2208 \u03c4 i , which yields B i , O |= q T (b) as desired. Let us partition var(q T ) into sets M 0 , M 1 , M 2 such that: \u2022 x \u2208 M 0 if h(x) \u2208 {a 0 , . . . , a n\u22121 }, that is, h(x) lies on the expanded cycle; \u2022 x \u2208 M 1 if h(x) / \u2208 ind(B i ), that is, h(x)\nis in the part of U Bi,O generated by existential quantification;\n\u2022 all other variables are in M 2 .\nWe start with setting\ng(x) = h(x) for all x \u2208 M 2 .\nTo define g(x) for the variables in x \u2208 M 0 , we first construct an auxiliary query q T of treewidth 1. If Q \u2208 {ELQ, ELIQ sf }, then q T is simply q T . Now assume that Q = CQ csf . Then q T is obtained by starting with the restriction of q T to the variables in M 0 and then exhaustively choosing and identifying variables x 1 , x 2 such that 1. there is a cycle R 0 (y 0 , y 1 ), R 1 (y 1 , y 2 ), R 3 (y 2 , y 0 ) with\n{x 1 , x 2 } \u2286 {y 0 , y 1 , y 2 } \u2286 M 0 and 2. h(x 1 ) = h(x 2 )\nThe result of identifying an answer variable and a quantified variable is an answer variable. Note that we may also identify two answer variables. We next observe that since q T is chordal, all CQs q T = p 0 , p 1 , . . . , p k = q T encountered during the construction of q T are chordal as well. This can be shown by induction on the index i to the CQs p i . The induction start is clear since q T is chordal. For the induction step, assume that p i contains a cycle C = S 0 (z 0 , z 1 ), . . . , S n\u22121 (z n\u22121 , z n ) of length at least four with at least one quantified variable, where i > 0. Then p i\u22121 contains C or a cycle C that can be obtained from C by replacing some edge S i (z i , z i+1 ) with two edges S i,1 (z i , u), S i,2 (u, z i+1 ) (because u and z i+1 were identified when constructing p i ). In the first case, C has a chord in p i\u22121 and thus also in p i . In the second case, C contains at least one quantified variable since C does and consequently has a chord in p i\u22121 . If this chord is not between z i and z i+1 , then C contains a chord in p. If the chord is between z i and z i+1 , then we are in the first case.\nWe now show that q T has treewidth 1, that is, it takes the form of a disjoint union of (not necessarily directed) trees with multi-edges and self loops. Assume to the contrary that q T contains a cycle C of length exceeding 2. If there is a quantified variable x on C, then q T being chordal implies that x occurs on a cycle of length 3, in contradiction to the construction of q T . Now assume that there is no quantified variable on C. As the image of C under h is a cycle in B i and the cycle chosen by the Expansion step is chordless, the image of C under h must contain all individuals {a 0 , . . . , a n\u22121 }. Since all variables on C are answer variables, this means that all individual in M 0 are fromb, in contradiction to {a 1 , . . . , a n } \u2286b i .\nThis finishes the construction of q T . For defining g(x) for the variables x \u2208 var(q T ), we can now start at some arbitrary variable in each tree in q T and then follow the tree structure, switching between the individuals a 0 , . . . , a n\u22121 and their copies a 0 , . . . , a n\u22121 as necessary. We next make this precise. For each connected component of q T , choose an arbitrary variable z from that component and set\ng(z) = h(z).\nThen exhaustively apply the following rule: if q T contains an atom R(x, y) with g(y) defined and g(x) undefined, set\n\u2022 g(x) = h(x) if g(y) = a i and either h(x) = a i+1 and i < n \u2212 2 or h(x) = a i\u22121 and i > 0;\n\u2022 g(x) = h(x) if g(y) = a i and either h(x) = a i+1 and i < n \u2212 2 or h(x) = a i\u22121 and i > 0;\n\u2022 g(x) = a 0 if g(y) = a n\u22122 and h(x) = a n\u22121 = a 0 ;\n\u2022 g(x) = a 0 if g(y) = a n\u22122 and h(x) = a n\u22121 = a 0 ;\n\u2022 g(x) = a n\u22122 if g(y) = a 0 and h(x) = a n\u22122 ;\n\u2022 g(x) = a n\u22122 if g(y) = a 0 and h(x) = a n\u22122 .\nIt can be verified that in all cases, R(g(x), g(y)) \u2208 B i by construction of B i in the unravelling step. We can next extend g to all variables in M 0 by setting g(y) = g(x) if y was identified with x \u2208 var(q T ) during the construction of q T (note that this implies h(y) = h(x)).\nBy definition, g(x) \u2208 {h(x), h(x) } for all x \u2208 M 0 . Thus, g(x) \u2208 \u03c4 i as announced.\nIt remains to define g(x) for the variables x \u2208 M 1 . By definition of M 1 , h(x) is a trace cw with c \u2208 ind(B i ) and w = \u03b5, that is, x is mapped into the subtree below c in U Bi,O . Now do the following:\n\u2022 if there is a path in q T from some variable z \u2208 M 0 to x, then choose such a z such that the path is shortest (thus, h(z) = c and g(z) has already been defined) and set g(x) = g(z)w;\n\u2022 otherwise, set g(x) = h(x). This is well-defined since, due to Lemma 12, the following holds:\n1. for each c \u2208 ind(B i ), the subtrees below c in U Bi,O and in U B i ,O are identical; 2. for 0 \u2264 j < n, the subtree below a j in U Bi,O and the subtree below a j in U B i ,O are identical.\nSetb = g(x). To prove that B i , O |= q T (b), it remains to show the following. Claim. g is a homomorphism from q T to U B i ,O .\nProof of the claim. Let A(x) be a concept atom in q T . Then\nA(h(x)) \u2208 U Bi,O . If h(x) \u2208 ind(B i ), then g(x)\nwas defined such that, by Lemma 12,\nB i , h(x) B i , g(x). By Lemma 7, U Bi,O , h(x) U B i ,O , g(x)\nand thus by Lemma 6\nA(g(x)) \u2208 U B i ,O . If h(x) / \u2208 ind(B i )\nthen the remark before the claim and the definition of g(x) ensures that A(g(x)) \u2208 U B i ,O . Now let R(x 1 , x 2 ) be a role atom in q T . We distinguish cases according to\nx 1 , x 2 belonging to M 0 , M 1 , M 2 : \u2022 If x 1 , x 2 \u2208 M 0 , then q T contains an atom R(x 1 , x 2 )\nsuch that each x i was identified with x i during the construction of q T . If x 1 = x 2 , then R(g(x 1 ), g(x 2 )) \u2208 B i , as argued in the definition of g for variables from q T . By that definition and the construction of B i , the same is true when x 1 = x 2 . We have g(\nx i ) = g(x i ) for i \u2208 {1, 2}. Thus R(g(x 1 ), g(x 2 )) \u2208 U B i ,O as required.\n\u2022 If x 1 , x 2 \u2208 M 1 , then h(x 1 ) = bv and h(x 2 ) = bw for some b \u2208 ind(B i ) and some non-empty v, w, and R(h(x 1 ), h(x 2 )) \u2208 U Bi,O . By definition of g, we have g(x 1 ) = bv and g(x 2 ) = bw for some b \u2208 {b, b }.\nBy Lemma 12, the subtree below b in\nU B i ,O is iden- tical to the subtree below b in U Bi,O . This implies R(g(x 1 ), g(x 2 )) \u2208 U B i ,O . \u2022 If x 1 , x 2 \u2208 M 2 , then g(x 1 ) = h(x 1 ), g(x 2 ) = h(x 2 ), and R(h(x 1 ), h(x 2 )) \u2208 B i because h is a homomor- phism from q T to U Bi,O and h(x 1 ), h(x 2 ) \u2208 ind(B i ). Since additionally h(x 1 ), h(x 2 ) / \u2208 {a 0 , . . . , a n\u22121 }, R(h(x 1 ), h(x 2 )) \u2208 B i and thus R(g(x 1 ), g(x 2 )) \u2208 U B i ,O . \u2022 If x 1 \u2208 M 0 and x 2 \u2208 M 1 , then h(x 1 ) \u2208 {a 0 , . . . , a n\u22121 }\nand h(x 2 ) takes the form h(x 1 )rC. Moreover, g(x 1 ) \u2208 {h(x 1 ), h(x 1 ) } and g(x 2 ) = g(x 1 )rC. It thus follows from Lemma 12, R(h(x 1 ), h(x 2 )) \u2208 U Bi,O , and the construction of universal models that R(g(x 1 ), g(x 2 )) \u2208\nU B i ,O . \u2022 If x 1 \u2208 M 0 and x 2 \u2208 M 2 , then h(x 1 ) \u2208 {a 0 , . . . , a n\u22121 } and h(x 2 ) \u2208 ind(B i ) \\ {a 0 , . . . , a n\u22121 }. Moreover, g(x 1 ) \u2208 {h(x 1 ), h(x 1 ) } and g(x 2 ) = h(x 2 ). It follows from R(h(x 1 ), h(x 2 )) \u2208 U Bi,O that R(h(x 1 ), h(x 2 )) \u2208 B i . By construction of B i , we thus have R(g(x 1 ), g(x 2 )) \u2208 B i \u2286 U B i ,O . \u2022 if x 1 \u2208 M 1 , x 2 \u2208 M 2 , then h(x 2 ) \u2208 ind(B i ) \\ {a 0 , . . . , a n\u22121 } and h(x 1 ) takes the form h(x 2 )rC with R = r \u2212 . Moreover g(x i ) = h(x i ) for i \u2208 {1, 2}\nand it remains to use Lemma 12 as in previous cases.\nLemma 14. For all i \u2265 1, 1. B i is O-saturated; 2. if h is a homomorphism from q T to U Bi,O with h(x) = b i , then ind(B i ) \u2286 img(h * ); 3. B i+1 ,b i+1 \u2192 B i ,b i ; 4. |ind(B i+1 )| > |ind(B i )|.\nProof. We prove Point 1 by induction on i. For i = 1, recall that the initial ABox A is of the form For Point 2, let h be a homomorphism from q T to U Bi,O with h(x) =b i , and suppose that there is an a \u2208 ind(B i ) that is not in img(h * ). Let B be the result of removing from B i all assertions that involve a. We show that ( * ) h is a homomorphism from q T to U B ,O which witnesses that B , O |= q T (b i ). Hence, a is dropped during the Minimize step, in contradiction to a \u2208 ind(B i ). To see that ( * ) holds, first note that for all b, b \u2208 ind(B i ) \\ {a}, the following holds by Point 1 and construction of universal models:\nC 3 Aq H ,O \u00d7 C 3 A,O or A q \u22a5 for\n( For Point 4, it suffices to show that g is surjective, but not injective. Claim 2. g is surjective.\na) A(b) \u2208 U Bi,O iff A(b) \u2208 U B ,O ; (b) r(b, b ) \u2208 U Bi,O iff r(b, b ) \u2208 U B ,O . From(\nProof of Claim 2. Suppose that g is not surjective. Then ind(B i ) \u2286 img(g). By Lemma 13 Point 1, there is a homomorphism h 1 from q T to U Bi+1,O with h 1 (x) =b i+1 . Let h 2 be the extension of g to a homomorphism from U Bi+1,O to U Bi,O as in Lemma 7 Point 1. Then img(h *\n2 ) = img(g). Composing h 1 and h 2 yields a homomorphism h 3 from q T to U Bi,O with h 3 (x) =b i , but with ind(B i ) \u2286 img(h * 3 ), in contradiction to Point 2.\nFor an injective and surjective function, we use g \u2212 to denote its inverse.\nClaim 3. If g is injective, then r(a, b) \u2208 B i implies r(g \u2212 (a), g \u2212 (b)) \u2208 B i+1 .\nProof of Claim 3. Suppose to the contrary that there is an r(a, b) \u2208 B i with r(g \u2212 (a), g \u2212 (b)) / \u2208 B i+1 . Since g is injective, it is then also a homomorphism from B i+1 to B i \\ {r(a, b)} and using composition-of-homomorphisms argument as in the proof of Claim 2, we find a homomorphism h from q T to U Bi\\{r(a,b)},O . Hence r(a, b) is dropped during the Minimize step, in contradiction to r(a, b) \u2208 B i . Claim 4. g is not an injective homomorphism. Proof of Claim 4. Let R 0 (a 0 , a 1 ), . . . R n\u22121 (a n\u22121 , a n ) \u2208 B i be the chordless cycle that is expanded during the construction of B i+1 from B i . Recall that a 0 = a n . Without loss of generality, assume that R n\u22121 = r n\u22121 is a role name, but not an inverse role. Suppose for contradiction that g is injective. The construction of g, together with g being surjective and injective, implies that exactly one of a j , a j is in ind(B i+1 ) for all j with 0 \u2264 j \u2264 n.\nAssume that a n\u22121 \u2208 ind(B i+1 ) (the case a n\u22121 \u2208 ind(B i+1 ) is analogous) and thus g(a n\u22121 ) = a n\u22121 . We prove by induction on i that a i / \u2208 ind(B i+1 ) for 0 \u2264 i < n, thus obtaining a contradiction to a n\u22121 \u2208 ind(B i+1 ).\nFor the induction start, assume to the contrary of what is to be shown that a 0 \u2208 ind(B i+1 ). Then g(a 0 ) = a 0 and r n\u22121 (a n\u22121 , a 0 ) \u2208 B i implies r n\u22121 (a n\u22121 , a 0 ) \u2208 B i+1 by Claim 3, in contradiction to the definition of the Expand step.\nFor the induction step, let i \u2265 0. We know that a i\u22121 / \u2208 ind(B i+1 ) and thus a i\u22121 \u2208 ind(B i+1 ). Then g(a i\u22121 ) = a i\u22121 . Assume to the contrary of what is to be shown that a i \u2208 ind(B i+1 ). Then g(a i ) = a i and R i\u22121 (a i\u22121 , a i ) \u2208 B i and Claim 3 yield R i\u22121 (a i\u22121 , a i ) \u2208 B i , in contradiction to the definition of the Expand step.\nIt is proved as part of Lemma 17 below that the Expand/Minimize phase terminates after polynomially many steps, let (B n ,b n ) be the result.\nWe next construct a sequence B n , B n+1 , . . . using the Split and Minimize steps. With B i , i \u2265 n, we denote the result of only applying the Split step to B i , but not the Minimize step.\nLemma 15. B i , O |= q T (b n ) for all i \u2265 n.\nProof. We show the lemma by induction on i. For i = n, this is a consequence of Point 1 of Lemma 13. For i > n, it is immediate from the induction hypothesis and the facts that a split is only taking place if B i , O |= q T (b n ), and that the Minimize step preserves this.\nLemma 16. For all i \u2265 n, 1. B i is O-saturated; 2. if h is a homomorphism from q T to U Bi,O with h(x) = b n , then ind(B i ) \u2286 img(h * ); 3. B i+1 ,b n \u2192 B i ,b n ; 4. |ind(B i+1 )| > |ind(B i )|.\nProof. We show Point 1 by induction over i. For Point 2, let h be a homomorphism from q T to U Bi,O with h(x) =b n , and suppose that there is an a \u2208 ind(B i ) that is not in img(h * ). Let B be the result of removing from B i all assertions that involve a. We show that ( * ) h is a homomorphism from q T to U B ,O which witnesses that B , O |= q T (b n ). Hence a is dropped during the Minimize step, in contradiction to a \u2208 ind(B i ). To see that ( * ) holds, first note that for all b, b \u2208 ind(B i ) \\ {a}, the following holds by Point 1 and construction of universal models:\n1. A(b) \u2208 U Bi,O iff A(b) \u2208 U B ,O ; 2. r(b, b ) \u2208 U Bi,O iff r(b, b ) \u2208 U B ,O .\nFrom Point 1, in turn it follows that the subtree in U Bi,O below each b \u2208 ind(B i ) \\ {a} is identical to the subtree in U B ,O below b. In summary, ( * ) follows.\nFor Points 3 and 4, recall that B i+1 is the result of applying the Split and Minimize step to B i . Let b \u2208 ind(B i ) be the individual that is duplicated by the Split step and let b be the fresh individual. We define a mapping h from ind(B i+1 ) to ind(B i ) by taking h(a) = a for all a \u2208 ind(B i ) \u2229 ind(B i+1 ) and h(b\n) = b if b \u2208 ind(B i+1\n), that is, b was not removed during minimization. Clearly, we have h(b n ) = b n . To establish Point 3, we argue that h is a homomorphism. First, let A(a) \u2208 B i+1 . By construction of B i+1 , we also have A(h(a)) \u2208 B i . Now, let r(a, c) \u2208 B i+1 . By definition of the Split step, also r(h(a), h(c)) \u2208 B i .\nFor Point 4, it suffices to verify that h is surjective but not injective. Claim 1. h is surjective. Proof of Claim 1. Assume to the contrary that there is a a \u2208 ind(B i ) such that a / \u2208 img(h). By Lemma 7 Point 1, h can be extended to a homomorphism h 1 from U Bi+1,O to U Bi,O with h 1 (b n ) =b n , such that img(h * 1 ) = img(h). Composing h 1 and a homomorphism h It remains to show that every step runs in polynomial time. For this, let \u2126 = sig(q) be the set of concept and role names that occur in the input query q. Clearly, |\u2126| \u2264 ||q||. Note that none of the applied operations introduces new concept or role names, that is, sig(B i ) \u2286 \u2126, for all i.\nFor Minimize this is the case, because at most |ind(B i )| membership queries are posed in operation (1) and at most |\u2126|\u2022|ind(B i )| 2 membership queries are posed in operation (2).\nFor Expand, note that chordless cycles of length n > n max can be identified in time polynomial in |ind(B)| \u2264 |var(q T )|.\nWe then need at most 2 ar membership queries to identify the right tupleb i+1 \u2208 \u03c4 i .\nFinally, for Split, observe that there are at most |\u2126| \u2022 |ind(B i )| 3 possible triples r(a, b), r(c, b) \u2208 B i . Thus, at most as many membership queries are posed.\nBefore we show that the result of refine is always in the desired class, we give an example that demonstrates the necessity of the Split step. Let\nq T (x 1 , x 2 ) \u2190 A(x 1 ) \u2227 B(x 2 ) \u2227 r(x 1 , x 1 ) \u2227 r(x 2 , x 2 )\nbe the target query and let q(y 1 , y 2 ) \u2190 A(y 1 ) \u2227 B(y 2 ) \u2227 r(y 1 , y) \u2227 r(y 2 , y) be the input to refine. Then the result of the Expand and Minimize phase is q(y 1 , y 2 ) which is not symmetry-free. Thus, the Split step is needed.\nLemma 18. If q T (\u0233) \u2208 Q for Q \u2208 {ELQ, ELIQ sf , CQ csf w | w \u2265 0}, then refine(q(x)) \u2208 Q, for every CQ q(x).\nProof. Let p(\u0233) = refine(q(x)). Assume that there is a symmetry r(x 1 , x), r(x 2 , x), x 1 = x 2 in p(\u0233) such that x / \u2208\u0233, none of the atoms occurs on a cycle, and there is no atom s(z, z) for any z \u2208 {x, x 1 , x 2 }. Note that x i = x due to the last condition, for i \u2208 {1, 2}.\nRecall that the query p(\u0233) is the result of exhaustively applying the steps Split and Minimize. Thus, for every homomorphism h from q T to U Ap,O with h(x) =\u0233, there must be atoms r(y 1 , y), r(y 2 , y) in q T such that h(y) = x, h(y\n1 ) = x 1 , h(y 2 ) = x 2 .\nIt follows that y is not an answer variable of q T . Furthermore there is no atom s(y , y ) for y \u2208 {y, y 1 , y 2 } in q T since otherwise there must be an atom s(h(y ), h(y )) in p. Since q T is in CQ csf for all choices of Q, at least one of the atoms r(y 1 , y), r(y 2 , y) must occur on a cycle. Assume that r(y 1 , y) occurs on a cycle in q T , the case for r(y 2 , y) is similar. Since q T is chordal, r(y 1 , y) must also be part of a cycle r(y 1 , y), S 1 (y, y 3 ), S 2 (y 3 , y 1 ) of length three. Consider the atoms r(h(y 1 ), h(y)) = r(x 1 , x), S 1 (h(y), h(y 3 )) = S 1 (x, h(y 3 )), and S 2 (h(y 3 ), h(y 1 )) = S 2 (h(y 3 ), x 1 ) which occur in p. We distinguish cases.\n\u2022 If h(y 3 ) / \u2208 {x, x 1 }, then r(x 1 , x), S 1 (x, h(y 3 )), S 2 (h(y 3 ), x 1 ) is a cycle of length three in p which contains r(x 1 , x), contradicting our initial assumption.\n\u2022 If h(y 3 ) = x, then S 1 (x, x) is an atom in p, contradicting our initial assumption.\n\u2022 If h(y 3 ) = x 1 , then S 2 (x 1 , x 1 ) is an atom in p, contradicting our initial assumption.\nThus, p is symmetry-free. It remains to show that p(\u0233) is chordal if q T is, an ELQ if q T is, and an ELIQ if q T is. Let p (z) be the intermediate query obtained after the first phase of Expand and Minimize. By non-applicability of Expand, there is no chordless cycle R 0 (x 0 , x 1 ), . . . , R n\u22121 (x n\u22121 , x n ) in p (z) of length n > n max and in case of Q = CQ csf , {x 0 , . . . , x n\u22121 } \u2286z. For Q = CQ csf this means that every cycle in p (z) of length at least four that contains at least one quantified variable has a chord. For Q \u2208 {ELQ, ELIQ sf }, with n max = 0, this means that p (z) does not contain any cycle at all. By Lemma 14 Point 2, we have var(p ) \u2286 img(h * ), for all homomorphisms h from q T to U A p ,O with h(x) =z. Since q T is connected and tree-shaped, p must be connected and tree-shaped. Moreover in the case of q T \u2208 ELQ, all variables a \u2208 img(h * ) are reachable by a path r 0 (a 0 , a 1 ), . . . , r n\u22121 (a n\u22121 , a) from the root a 0 , thus p is ditree-shaped in this case. Thus p (z) \u2208 Q in all cases.\nIt remains to observe that the Split operation preserves these properties, thus p(\u0233) is as required.\nLemma 19. Let O be an EL r -ontology. Let A 1 and A 2 be ABoxes and\u0101 i , i \u2208 {1, 2}, be tuples of individuals from A i of the same length. Moreover, let q(z) be C 3 A1,O \u00d7 C 3 A2,O viewed as CQ with answer variablesz =\u0101 1 \u2297\u0101 2 and let p(x) be the result of refine(q(z)) with respect to some target query q T (\u0233). Then there is a homomorphism h i from p(x) to U Ai,O with h i (x) = (\u0101 i ), for i \u2208 {1, 2}.\nProof. By Lemma 14 Point 3, there is a homomorphism h from p to C 3 A1,O \u00d7 C 3 A2,O with h(x) =z and it is a property of products that there are homomorphisms g i from C 3 A1,O \u00d7C 3 A2,O to C 3 Ai,O with g i (z) =\u0101 i . Composing h and g i yields homomorphisms g i from p to C 3 Ai,O with g i (x) =\u0101 i . It follows then, since p(x) \u2208 CQ csf by Lemma 1 that there are also homomorphisms h i from p(x) to U Ai,O with h i (x) = a i , as required.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "F Proofs for Section 3.4", "text": "We start with describing the second version of the refine subroutine in full detail. It gets as input a CQ q H\n(x ) such that q H \u2286 O q T and produces a CQ q H (x) such that q H \u2286 O q H \u2286 O q T and |var(q H )| \u2264 |var(q T )|.\nThe initial call to refine in Algorithm 1 is dropped when this version of refine is used. Thus, the argument q H (x ) is always the product of two 3-compact models. For notational convenience, we prefer to view q H (x ) as a pair (A,\u0101) where\nA = C 3 A1,O \u00d7 C 3 A2,O and a =\u0101 1 \u2297\u0101 2 . We know that A i , O |= q T (\u0101 i ) for i \u2208 {1, 2}.\nAs in the first version of refine, minimization is a crucial ingredient. However, we minimize in a slightly different way here.\nMinimize. Let B be an ABox that contains all individuals from\u0101 1 \u2297\u0101 2 . Then minimize(B) is the ABox B obtained from B by exhaustively applying the following operation: choose a c \u2208 ind(B) \\ (\u0101 1 \u2297\u0101 2 ) and remove all assertions that involve c. Use a membership query to check whether, for the resulting ABox B , B , O |= q T (\u0101 1 \u2297\u0101 2 ). If this is the case, proceed with B in place of B.\nThe modified refine subroutine constructs a sequence of ABoxes B 1 , B 2 , . . . starting with\nB 1 = minimize(C 3 A1,O \u00d7 C 3 A2,O\n) and such that B i , O |= q T (\u0101 1 \u2297\u0101 2 ) for all i \u2265 1. Note that in contrast to the first version of refine, the individuals in the answer tuple (which correspond to the answer variables) are never modified.\nEach ABox B i+1 is obtained from B i by a local unraveling. All individuals in B 1 are pairs (c 1 , c 2 ) and the same shall be true for the individuals in the ABoxes B 2 , B 3 , . . . . Informally, unraveling replaces components c i that are individuals from ind(C 3 Ai,O ) \\ ind(A i ) with corresponding individuals from ind(U Ai,O ) \\ ind(A i ) in a step-by-step fashion. To make this formal, we call\n(c 1 , c 2 ) \u2208 ind(B i ) unraveled if c i \u2208 ind(U Ai,O ) for each i \u2208 {1, 2}. Note that (c 1 , c 2 ) \u2208 B 1 and c i / \u2208 ind(U Ai,O )\nimplies that c i is of the form c a,i,s,C . The same will be true for all ABoxes B 2 , B 3 , . . . . We now describe the unraveling step.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Unravel. Remove every assertion", "text": "r((c 1 , c 2 ), (d 1 , d 2 )) \u2208 B i with (c 1 , c 2 ) unraveled and (d 1 , d 2 ) not unraveled. Let d j = d j if d j occurs in U Aj ,O and d j = c j rC if d j = c a, ,s,C , for j \u2208 {1, 2}.\nCompensate by adding the following assertions:\n\u2022 r((c 1 , c 2 ), (d 1 , d 2 )); \u2022 A(d 1 , d 2 ) for all A(d 1 , d 2 ) \u2208 B i ; \u2022 r((d 1 , d 2 ), (e 1 , e 2 )) for all r((d 1 , d 2 ), (e 1 , e 2 )) \u2208 B i .\nWe call (d 1 , d 2 ) a copy of (d 1 , d 2 ). Note that unraveling might introduce several copies of the same original element (d 1 , d 2 ) and that (d 1 , d 2 ) might or might not be present after unraveling, the latter being the case when r((c 1 , c 2 ), (d 1 , d 2 )) is the only assertion that mentions (d 1 , d 2 ).\nAfter unraveling, we apply the Minimize step and the resulting ABox is B i+1 .\nWe prove later that the Unravel step can only be applied polynomially many times, let the resulting ABox be B n . Let I denote the set of all individuals in B n that are reachable from some individual in ind(\nA 1 ) \u00d7 ind(A 2 ) in the directed graph G Bn = (ind(B n ), {(a, b) | r(a, b) \u2208 B n }).\nIt is easy to see that all individuals in I are unraveled. However, the restriction of B n to ind(B n ) \\ I might contain individuals that are not unraveled.\nFor example, consider the EL r -ontology O = {A \u2203r.A, B \u2203r.B} and the boolean target query q T \u2190 r(x 1 , x 2 ) \u2227 r(x 2 , x 3 ) \u2227 r(x 3 , x 4 ). At some point during the learning algorithm, the refine subroutine might be called with A = C 3 A1,O \u00d7 C 3 A2,O with A 1 = {A(a)} and A 2 = {B(b)}. By construction of the 3-compact model, A contains a cycle of length 4, consisting of individuals (c a,i,r,A , c b,i,r,B ) for i \u2208 {1, . . . 4}, that is reachable from from ind(A 1 ) \u00d7 ind(A 2 ) = {(a, b)}. The first Minimize step might then remove all individuals from A that are not on the cycle, since there is a homomorphism h from q T to U A,O with h(x i ) = (c a,i,r,A , c b,i,r,B ) for i \u2208 {1, . . . , 4}. Since only the cycle consisting of not unraveled individuals remains, the Unravel step cannot be applied.\nTo deal with this issue, we apply the original refine subroutine from Section 3.3 to B n (with n max = 3), resulting in a sequence (B n ,b n ), (B n+1 ,b n+1 ), . . . whereb n = a 1 \u2297 a 2 , in a slightly adapted way:\n1. the individuals in I are not touched, that is, no cycle that involves an individual from I is considered in the Expansion step nor is any assertion removed during the Minimize step that contains an individual from I;\n2. as a consequence, the Expansion step cannot involve individuals in\u0101 1 \u2297\u0101 2 , and thus the exponential blowup in the arity is avoided. In fact,b n =b n+1 = \u2022 \u2022 \u2022 .\n3. the Splitting step is not applied.\nWe now analyze the second version of refine, starting with the following lemma. Lemma 20. Let i \u2265 1. Every cycle in B i of length at most three consists only of individuals from ind(A 1 ) \u00d7 ind(A 2 ).\nProof. We prove the lemma by induction on i. In the induction start,\nB 1 = minimize(C 3 A1,O \u00d7 C 3 A2,O ). If B 1 contains a cycle r((a 1 , a 2 ), (a 1 , a 2 )) of length 1 with a i / \u2208 A i for some i \u2208 {1, 2}, then r(a 1 , a 1 ) is a cycle of length 1 in C 3 A1,O which is not the case by Lemma 2. Next assume that B 1 contains a cycle r 0 ((a 1 , a 2 ), (b 1 , b 2 )), r 1 ((b 1 , b 2 ), (a 1 , a 2 )) of length 2. Assume w.l.o.g. that a 1 / \u2208 ind(A 1 ). If a 1 = b 1 , then r 0 (a 1 , a 1 ) is a cycle of length 1 in C 3 A1,O , but this is not the case by Lemma 2. If a 1 = b 1 , then r 0 (a 1 , b 1 ), r 1 (b 1 , a 1 ) is a cycle of length 2 in C 3 A1,O\n, which again contradicts Lemma 2. If B 1 contains a cycle r 0 ((a 1 , a 2 ), (b 1 , b 2 )), r 1 ((b 1 , b 2 ), (c 1 , c 2 )), r 2 ((c 1 , c 2 ), (a 1 , a 2 )) of length 3, we can argue similarly that C 3 A1,O contains a cycle of length 1 or 3 that involves an individual not in ind(A i ), again obtaining a contradiction.\nFor the induction step, we show that both the Minimize step and the Unravel step do not create cycles of length 1, 2, or 3 that involve individuals not from ind(A 1 ) \u00d7 ind(A 2 ). Since the Minimize step only removes assertions, it cannot create any new cycles. For the Unravel step, let the lemma hold for B i and let B be B i after the Unravel step. Let r 0 ((a 1 , a 2 ), (b Recall that we first construct a sequence B 1 , B 2 , . . . using the Unravel and Minimize steps. With B i , i \u2265 1, we denote the result of only applying the Unravel step to B i , but not the Minimize step. Lemma 21. For all i \u2265 1, B i , a B i , a and B i , a B i , a, for all a \u2208 ind(B i ) \u2229 ind(B i ), and B i , a B i , a and B i , a B i , a for all copies a \u2208 ind(B i ) \\ ind(B i ) of some a \u2208 ind(B i ).\n1 , b 2 )), r 1 ((b 1 , b 2 ), (c 1 , c 2 )), r 2 ((c 1 , c 2 ), (a 1 , a 2 )) be a new cycle of length 3 in B. Since the cycle is new, one of (a 1 , a 2 ), (b 1 , b 2 ) or (c 1 , c 2 ) must be (d 1 , d 2 ),\nProof. Define a relation S \u2286 ind(B i ) \u00d7 ind(B i ) by taking:\n\u2022 (a, a) \u2208 S, for all a \u2208 ind(B i ) \u2229 ind(B i ), and \u2022 (a, a ) \u2208 S, for all copies a \u2208 ind(B i ) of some element a \u2208 ind(B i ).\nIt is routine to verify that S serves as witness for the claimed simulations from B i to B i , and its inverse S \u2212 serves as witness for the claimed simulations from B i to B i .\nThe next lemma is the most intricate to prove in the analysis of the second version of refine. Lemma 22. For all i \u2265 1, B i , O |= q T (\u0101 1 \u2297\u0101 2 ).\nProof. We prove the lemma by induction on i. For the induction step, consider B i+1 with i \u2265 1. By induction hypothesis, there is a homomorphism h from q T to U Bi,O with h(x) =\u0101 1 \u2297\u0101 2 . By Lemma 9, we can assume that q T is strongly symmetry-free. Let B be the result of applying the unraveling step to B i , and let U be the set of all individuals (d 1 , d 2 ) \u2208 Ind(B i ) such that some assertion r((c 1 , c 2 ), (d 1 , d 2 )) was removed in that step. Note that if (d 1 , d 2 ) \u2208 U , then (d 1 , d 2 ) / \u2208 Ind(A 1 ) \u00d7 Ind(A 2 ). In what follows, we construct a homomorphism g from q T to U B,O with g(x) =\u0101 1 \u2297\u0101 2 . Thus, B, O |= q T (\u0101 1 \u2297\u0101 2 ). By definition of the Minimize step, this implies B i+1 , O |= q T (\u0101 1 \u2297\u0101 2 ) as desired.\nWe first observe the following, which can be proved by a straightforward induction on j. Claim 1. For all j \u2265 0, if R((c 1 , c 2 ), (d 1 , d 2 )) \u2208 B j with (c 1 , c 2 ) unraveled and (d 1 , d 2 ) not unraveled, then R is a role name, but not an inverse role. For a variable x in q T , let us denote with V x the set of all atoms R(x, y) \u2208 q T such that h(y) \u2208 Ind(B i ) is unraveled. We observe the following. Claim 2. Let x \u2208 var(q T ) such that h(x) = (d 1 , d 2 ) \u2208 U . Then there is a role name r such that all atoms in V x are of shape r(y, x) and one of the following is the case: Proof of Claim 2.\n(i) V\nTo show the first part, let R(y 1 , x), S(y 2 , x) \u2208 V x . Since h(x) = (d 1 , d 2 ) is not unraveled, but h(y 1 ) and h(y 2 ) are unraveled, R and S are role names by Claim 1. Moreover, (d 1 , d 2 ) not being unraveled means that at least one one of the d j takes the shape c a,k,r,C for some role name r. By definition of C 3 Aj ,O , for every s(d, c a,k,r,C ) \u2208 C 3 Aj ,O , we have s = r. Hence, for every s(d, (d 1 , d 2 )) \u2208 B i we have s = r as well. Thus, R = S = r and all assertions in V x are based on the same role name r. Now for the second part. Assume that Case (i) does not apply. Then we find r(y 1 , x), r(y 2 , x) \u2208 V x with y 1 = y 2 . Since q T is strongly symmetry-free and x is not an answer variable (which follows from h(x) \u2208 U ) one of the atoms, say r(y 1 , x), occurs on a cycle p in q T . Since q T is chordal, we can assume that p has length at most three. Since h is a homomorphism from q T to U Bi,O , the 'h-image of p' contains a cycle p of length at most three in B i . By Lemma 20, p consists only of elements from ind(A 1 ) \u00d7 ind(A 2 ). Thus h(x) cannot be involved in p , since h(x) = (d 1 , d 2 ) is not unraveled. Consequently, the cycle p has to be of the shape r(y 1 , x), r \u2212 (x, z), s(y 1 , z) and h(y 1 ) = h(z) = (b 1 , b 2 ) \u2208 ind(A 1 )\u00d7ind(A 2 ). It follows that we must have i = 1 since for i > 1, all successors of elements of ind(A 1 )\u00d7ind(A 2 ) are unraveled. We distinguish the following cases:\n\u2022 d 1 \u2208 ind(A 1 ) and d 2 \u2208 ind(A 2 ).\nImpossible because (d 1 , d 2 ) is not unraveled.\n\u2022 \u2022 d 1 has shape c b1,0,r,C and d 2 \u2208 ind(A 2 ).\nThen b 1 is the unique r-predecessor of d 1 in C 3 A1,O that can appear in the first component of an unraveled element. Let r(y, x) \u2208 V x . Because h(y) is unraveled and i = 1, h(y) \u2208 ind(A 1 ) \u00d7 ind(A 2 ). Since B 1 \u2286 C 3 A1,O \u00d7 C 3 A2,O , r(y, x) \u2208 V x thus implies that there is an assertion r(b , d 2 ) \u2208 A 2 such that h(y) = (b 1 , b ). Thus, we are in Case (ii).\n\u2022 d 2 has shape c b2,0,r,C and d 1 \u2208 ind(A 1 ).\nWe argue as in the previous case, but end up in Case (iii).\nThis finishes the proof of Claim 2. For the next claim, we associate with every variable x \u2208 var(q T ) with h(x) \u2208 ind(B i ) the set Z x that consists of all variables y \u2208 var(q T ) such that q T contains a path R 0 (z 0 , z 1 ), . . . , R m\u22121 (z m\u22121 , z m ) from x to y where h(z 1 ), . . . , h(z m ) are all located in the subtree of U Bi,O rooted at h(x), but are different from h(x).\nClaim 3. For all y \u2208 var(q T ) with h(y) / \u2208 ind(B i ), there is at most one x \u2208 var(q T ) with y \u2208 Z x and h(x) \u2208 U .\nProof of Claim 3. Suppose that y \u2208 var(q T ) with h(y) / \u2208 ind(B i ) and that there are distinct variables x 1 , x 2 \u2208 var(q T ) with y \u2208 Z xj and h(x j ) \u2208 U for j \u2208 {1, 2}. Let p 1 = R 0 (z 0 , z 1 ), . . . , R n (z n\u22121 , z n ) and p 2 = S 0 (z 0 , z 1 ), . . . , S m (z m\u22121 , z m ) be paths in q T from x 1 to y and from x 2 to y, respectively, such that h(z j ) = h(x 1 ) for all j \u2208 {1, . . . , n} and h(z j ) = h(x 2 ) for all j \u2208 {1, . . . , m}. Note that h is a homomorphism from p j to the subtree of U Bi,O rooted at h(x j ), for j \u2208 {1, 2}. Since h(y) is both in the subtree below h(x 1 ) and below h(x 2 ), we have h(x 1 ) = h(x 2 ).\nWe analyze the structure of the paths p 1 and p 2 . Let us first verify that all R j and all S j can be assumed to be role names. We do this explicitly only for the R j . Let S denote the subtree of U Bi,O rooted at h(x 1 ), that is, the restriction of U Bi,O to all traces that start with h(x 1 ), including h(x 1 ) itself. By construction of U Bi,O , S is a ditree. Then R 0 must be a role name since R 0 (h(x 1 ), h(z 1 )) \u2208 S, h(x 1 ) is the root of S, and h(z 1 ) in S. Now, let be minimal such that R is an inverse role r \u2212 and consider the atoms R \u22121 (z \u22121 , z ), r \u2212 (z , z +1 ) in q T . Since h is a homomorphism and S is a ditree, we know that R \u22121 = r, and thus there are atoms r(z \u22121 , z ), r(z +1 , z ) in q T . Now, if z \u22121 = z +1 , we can drop these two atoms from the path. Otherwise, since q T is strongly symmetry-free and z is not an answer variable (as h(z ) is in S but different from its root), one of these atoms occurs on a cycle p in q T . Let us assume that this is atom r(z \u22121 , z ), the case of atom r(z +1 , z ) is analogous. Since q T is chordal, we can assume that p has length at most three. Since h is a homomorphism from q T to U Bi,O , the image of p contains a cycle p of length at most three in U Bi,O . Even if h is not injective, the cycle p must contain h(z ) or h(z \u22121 ). However, both possibilities lead to a contradiction. If p contains h(z ), then h(z ) \u2208 ind(A 1 )\u00d7ind(A 2 ) by Lemma 20 but this is not the case since h(z ) is in S and different from h(x 1 ). If p contains h(z \u22121 ), then h(z \u22121 ) must be h(x 1 ), and p witnesses that h(x 1 ) \u2208 ind(A 1 ) \u00d7 ind(A 2 ), in contradiction to h(x 1 ) \u2208 U .\nAt this point, we have established that all R j and S j are role names r j , s j . Since S is a ditree, it follows that m = n and r j = s j for all j. Since z 0 = z 0 and z n = z m , there is some > 0 such that z = z , z \u22121 = z \u22121 . But then q T contains atoms r (z \u22121 , z ), r (z \u22121 , z ). This leads to a contradiction in the same way as above. This finishes the proof of Claim 3.\nWe now define the required homomorphism g in four stages, as follows.\n1. Define g(x) = h(x) for all x \u2208 var(q T ) such that h(x) \u2208 ind(B i ) \\ U or h(x) is in the subtree below some element d / \u2208 U .", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgements", "text": "Supported by the DFG Collaborative Research Center 1320 EASE -Everyday Activity Science and Engineering.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "", "text": "(a) If V x = \u2205, then define g(x) = h(x). We argue that this is well-defined, that is, h(x) \u2208 ind(B).\nSuppose to the contrary that h(x) / \u2208 ind (B). By definition of the unraveling operation, this can only be the case if B i contains only a single assertion that mentions h(x) and this assertion is of shape r((c 1 , c 2 ), h(x)) with (c 1 , c 2 ) unraveled. Since x has to occur in some atom in q T and h is a homomorphism, x occurs in an atom r(z, x) \u2208 q T such that h(z) = (c 1 , c 2 ). Hence, r(z, x) \u2208 V x = \u2205, contradiction.\n(b) If Case (i) applies and V x = {r(y, x)}, define g(x)\nto be the copy (d 1 , d 2 ) of (d 1 , d 2 ) introduced when unraveling r(h(y), h(x)) \u2208 B i . (c) If V x = \u2205 and Case (ii) applies (but Case (i) does not), then define g(x) to be the copy (brC, d 2 ) of (d 1 , d 2 ), where b, C are as in Case (ii) of Claim 2. (d) If V x = \u2205 and Case (iii) applies (but Case (i) does not), analogously define g(x) to be the copy (d 1 , brC). (e) If V x = \u2205 and Case (iv) applies (but Case (i) does not), define g(x) to be the copy (b 1 rC 1 , b 2 rC 2 ) where b 1 , b 2 , C 1 , C 2 are as in Case (iv).\n3. For every x with h(x) \u2208 U and every y \u2208 Z x , h(y) is a trace that starts with h(x), c.f. the definition of U Bi,O . Define g(y) to be the same trace, but with the first element h(x) replaced by g(x). It can be verified that g(y) is indeed an element in U B,O using the fact that, by Lemma 21, the subtrees below g(x) and h(x) in U B,O and U Bi,O , respectively, are identical. 4. For every y with h(y) in the subtree below some (d 1 , d 2 ) \u2208 U but different from (d 1 , d 2 ), and such that y / \u2208 Z x for all x with h(x) \u2208 U , choose some copy (d 1 , d 2 ) of (d 1 , d 2 ) and define g(x) to be the trace h(x) with the first element\nIt is easy to see that the four stages above define g(x) for all x \u2208 var(q T ).\nClaim 4. g is a homomorphism from q T to U B,O with g(x) = a 1 \u2297\u0101 2 . Proof of Claim 4. For g(x) =\u0101 1 \u2297\u0101 2 , observe that h(x) \u2208 ind(A 1 ) \u00d7 ind(A 2 ) for every x \u2208x while U \u2229 (ind(A 1 ) \u00d7 ind(A 2 )) = \u2205. Thus, Stage 1 of the definition of g implies g(x) = h(x). Now, let A(x) \u2208 q T and thus A(h(x)) \u2208 U Bi,O . We distinguish the following cases:\n\u2022 If g(x) was defined in Stage 1, then g(x) = h(x). First assume that g(x) \u2208 Ind(B i ). By Lemma 21, we have B i , h(x) B, g(x) and thus, by Lemma 7 Point 2 U Bi,O , h(x) U B,O , g(x). Hence, also A(g(x)) \u2208 U B,O by Lemma 6. Now assume that g(x) / \u2208 Ind(B i ). Then h(x) = g(x) is a trace and traces in U Bi,O and U B,O that end with the same concept C must satisfy the same concept names. \u2022 If g(x) was defined in Stage 2, then g(x) = (d 1 , d 2 ) is a copy of h(x) = (d 1 , d 2 ) or g(x) = h(x). By Lemma 21, we have B i , h(x) B, g(x), thus A(g(x)) \u2208 U B,O by Lemmas 6 and 7. \u2022 If g(x) was defined in Stage 3 or 4, then h(x) and g(x)\nare both traces that end with the same concept C and, by construction of universal models, thus make true the same concept names. Consequently, A(h(x)) \u2208 U Bi,O implies A(g(x)) \u2208 U B,O . Finally, let r(x, y) \u2208 q T and thus r(h(x), h(y)) \u2208 U Bi,O . We distinguish the following cases:\n\u2022 It cannot be that both h(x) and h(y) are elements of U , by definition of the unraveling step.\n\u2022 If both h(x) and h(y) are not elements of U , then both g(x) and g(y) were defined in the same stage, one of Stage 1, 3, and 4. We can then argue very similar to the case of concept atoms that r(g(x), g(y)) \u2208 U B,O .\n\u2022 If h(x) = (d 1 , d 2 ) \u2208 U and h(y) / \u2208 U , then we distinguish cases:\n-\nby definition of the unraveling step, we have\nWe know that g(x) was defined in Stage 2 and is either h(x) or some copy thereof, and h(y) was defined in Stage 1, thus g(y) = h(y). Consequently, r(g(x), g(y)) \u2208 B \u2286 U B,O . -It cannot be the case that h(y) \u2208 ind(B i ) is unraveled: By Claim 2, S is a role name for every atom S(z, x) \u2208 q T such that h(z) is unraveled. However, this is not the case for the atom r \u2212 (y, x) \u2208 q T we started with.\nand by definition of universal models. We distinguish cases according to Claim 2:\n-  This finishes the proof of Claim 4 and thus of the lemma.\nProof. We prove Point 1 by induction on i. For i = 1, observe that either\nIn the first case both C 3 Ai,O are O-saturated and thus also their product by Lemma 5 Point 3. In the second case, A q \u22a5 is O-saturated since it contains A(x 0 ) for all concept names A \u2208 \u03a3. For the induction step, suppose B i+1 , O |= A(a) for some concept name A and some a \u2208 ind(B i+1 ). By monotonicity, B i , O |= A(a) where B i is the result of applying the unraveling step to B i . By Point 2 of Lemma 3, A(a) \u2208 U B i ,O . We distinguish cases:\n\u2022 If a \u2208 ind(B i ), then a was not affected by the unraveling and B i , a B i , a by Lemma 21, thus For Point 2, let h be a homomorphism from q T to U Bi,O with h(x) =\u0101 1 \u2297\u0101 2 for some i \u2265 2. Assume to the contrary of what is to be shown that there is an a \u2208 ind(B i ) that is not in img(h * ). Let B be the result of removing from B i all assertions that involve a. We show that ( * ) h is a homomorphism from q T to U B ,O and thus witnesses that B , O |= q T (\u0101 1 \u2297\u0101 2 ). Hence, a is dropped during the Minimize step, in contradiction to a \u2208 ind(B i ).\nTo see that ( * ) holds, first note that for all b, b \u2208 ind(B i ) \\ {a}, the following holds by Point 1 and construction of universal models:\nNow for Point 3, we define a mapping h from B i+1 to B i with h(x) =x. Recall that B i+1 is constructed from B i by applying the Unravel and Minimize steps. Let h(s) = a for all a \u2208 ind(B i ) \u2229 ind(B i+1 ) and h(a ) = a for all copies a of a with a \u2208 ind(B i+1 ). It follows from the definition of the unravelling step, that h is a homomorphism as required.\nIt is proved as part of Lemma 25 below that the Unravel/Minimize phase terminates after polynomially many steps, let B n be the result. We next construct a sequence B n , B n+1 , . . . using the modified version of the original refine subroutine, that is, using the Expand and Minimize steps. With B i , i \u2265 n, we denote the result of only applying the Expand step to B i , but not the Minimize step. Lemma 24. For all i \u2265 n,\nProof sketch. Point 1 is a direct consequence of Lemma 13. Points 2 to 4 can be proved in the same way as Points 1 to 4 of Lemma 14. While the proofs of Points 2 and 5 go through without modification, a slight extension is required for the proof of Point 3 in the case that i > 1. There, we start with a homomorphism h from q T to U Bi,O with h(x) =b i , and suppose that there is an a \u2208 ind(B i ) that is not in img(h * ). If a is not reachable from some individual in ind(A 1 )\u00d7ind(A 2 ) in B i viewed as a directed graph, then we can argue as in the proof of Point 2 of Lemma 14, that is, obtain a contradiction against exhaustive application of Minimize to B i\u22121 . If a is reachable, however, this does not work as we do not apply the Minimize step to such individuals in the modified version of the refine subroutine. However, by Point 4, there is a homomorphism h from\nLet h 2 be the extension of h to a homomorphism from U Bi,O to U B1,O as in Lemma 7 Point 1. Then img(h *\n2 ) = img(h). Composing h 1 and h 2 yields a homomorphism h 3 from q T to U Bi,O with h 3 (x) =\u0101 1 \u2297\u0101 2 , but with ind(B i ) \u2286 img(h * 3 ), in contradiction to Point 2 of Lemma 23.\nLemma 25. refine(q(x)) can be computed in time polynomial in ||q T || + ||q|| using membership queries.\nProof. We first note that the length of the sequence B 1 , B 2 , . . . computed in the Unravel/Minimize phase is bounded by |var(q T )| + 1. Indeed, the following is easy to prove by induction on i. For Expand, note that chordless cycles of length n > n max can be identified in time polynomial in |ind(B i )| \u2264 |var(q T )| and constructing the ABox B i+1 from B i is clearly also possible in polynomial time.\nLemma 26. Let O be an EL r -ontology. Let A 1 and A 2 be ABoxes and\u0101 i , i \u2208 {1, 2}, be tuples of individuals from A i of the same length. Moreover, let q(z) be C 3 A1,O \u00d7 C 3 A2,O viewed as CQ with answer variablesz =\u0101 1 \u2297\u0101 2 and let p(x) be the result of refine(q(z)) with respect to some target query q T (\u0233). Then there is a homomorphism h i from p(x) to U Ai,O with h i (x) = (\u0101 i ), for i \u2208 {1, 2}.\nProof. Let B m be the result of refine(q(z)) before it is turned into the CQ p(x). Further, let B denote the restriction of B m to all individuals that are reachable from an individual in ind(A 1 ) \u00d7 ind(A 2 ) in B m , and let B be the restriction of B m to all individuals that are not reachable. Thus B m = B B .\nIt suffices to show that, for i \u2208 {1, 2}, there is a homomorphism h i from B to U Ai,O with h i (x) = (\u0101 i ) and a homo-\nFor the former, note that all individuals in B are unraveled.\nProjection to the left and right components yields the homomorphisms h i as required.\nFor the latter, note that none of the individuals in B is unraveled. In fact, this follows from two obvious properties of the Unravel step and 3-compact canonical models:\n\u2022 if the Unravel step is not applicable to an ABox B i and r(a, b) \u2208 B i with a unraveled, then b is unraveled too; \u2022 if Unraveling (and Minimization) is repeatedly applied to an ABox C 3 A1,O \u00d7 C 3 A2,O , then it never produces any fact r(a, b) with b unraveled, but a not unraveled (because there are no r-edges from individuals of the form c a,i,s,C to individuals from ind( ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "G Proof of Theorem 1", "text": "Let q 0 (x 0 ), q 1 (x 1 ), . . . be the sequence of hypotheses generated by the algorithm.\nLemma 27. For all i \u2265 0:\nProof. Point 1 is a consequence of Lemma 13 Point 1, for the first refine-operation, and Lemma 24 Point 1, for the second refine-operation\nFor Point 2, recall that q i+1 = refine(q\n, for some positive counterexample A,\u0101, viewed as CQ with answer variablesx =x i \u2297\u0101. In case of the first refine-operation there is a homomorphism h from q i+1 to U Aq i ,O with h(x i+1 ) = x i , by Lemma 19. Lemmas 22 and 24 Point 4 give us this homomorphism for the second refine-operation. By Lemma 4, we obtain q i \u2286 O q i+1 .\nFor Point 3, assume to the contrary that\n, for some positive counterexample A,\u0101, viewed as CQ with answer variablesx =x i \u2297\u0101.\nIn case of the first refine-operation there is a homomorphism h 2 from q i+1 to U A,O with h 2 (x i+1 ) =\u0101, by Lemma 19. Again, Lemmas 22 and 24 show that h 2 also exists for the secondrefine-operation. By Lemma 7 Point 1 h 2 can be extended to a homomorphism h 2 from U Aq i+1 ,O to U A,O with h 2 (x i+1 ) =\u0101. Composing h 1 and h 2 yields a homomorphism h from q i to U A,O with h(x) =\u0101. Thus A, O |= q i (\u0101), in contradiction to A,\u0101 being a positive counterexample.\nWe next observe that the sizes of q 0 , q 1 , . . . are nondecreasing.\nLemma 28. For all i \u2265 0: with h(x) =x i+1 . We can compose h and h into a homomorphism g from q T to U Aq i ,O with g(x) =x i . We then obtain var(q i ) \u2286 img(g * ) by Lemma 14 Point 2 for the first refine-operation or Lemma 24 for the second version. Since img(g * ) \u2286 img(h * ), it follows that var(q i ) \u2286 img(h * ).\nPoint 2 is a consequence of Point 1. In fact,\nProof. By Lemma 14 Point 2 in case of the first refineoperation or by Lemma 24 Point 3 in case of the second, we have |var(q i )| \u2264 |var(q T )| for all i \u2265 0.\nLet q , . . . , q u , \u2264 u, be a subsequence of q 1 , q 2 , . . . such that |var(q )| = \u2022 \u2022 \u2022 = |var(q u )|. By Point 2 of Lemma 28, it suffices to show that the length u \u2212 of any such sequence is bounded by a polynomial in |var(q T )| and |\u03a3|. Let h i , for i \u2208 { + 1, . . . , u}, be the homomorphisms from q i to U Aq i\u22121 ,O that exist due to Lemma 27 Point 2.\nNote that h * i is a bijection between var(q i ) and var(q i\u22121 ). Denote with V i the set of all quantified variables x \u2208 var(q i ) which do not occur in a role atom, and define U i = var(q i ) \\ V i . Let us further denote with q x the restriction q| {x} of a query q to a single variable x \u2208 var(q). Clearly, q i can be written as\nNotice that, by definition, each q x i , x \u2208 V i is a query without answer variables.\n) is an answer variable and thus in U i\u22121 . Suppose now that there is a role atom R(z, x) in q i and consider the assertion R(\nThe definition of the universal models yields y \u2208 var(q i\u22121 ), R(y, y) occurs in q i\u22121 , and\nThis finishes the proof of Claim 1.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Claim 1 implies", "text": "We consider now subsequences q , . . . , q u of q , . . . , q u with\nfor all i, it suffices to show that the length of such a sequence is bounded by a polynomial in |var(q T )| and |\u03a3|. Claim 2. For every i \u2208 { + 1, . . . , u }, 1. h * i is a bijection between V i and V i\u22121 , and 2. h i is a bijection between U i and U i\u22121 .\nProof of Claim 2. The first point is a consequence of Claim 1 and the facts that |V i\u22121 | = |V i | and h * i is a bijection between var(q i ) and var(q i\u22121 ). For the second point, suppose that some x \u2208 U i\u22121 is not h i (y) for some y \u2208 U i . Thus, there is some y such that h * i (y) = x and h i (y) is strictly in the subtree rooted at x in U Aq i\u22121 ,O . Since h * i is a bijection, y is the unique variable such that h i (y) is in the subtree rooted at x. We claim that y \u2208 V i . This implies x \u2208 V i\u22121 , by the first point, and contradicts the assumption x \u2208 U i\u22121 . To see y \u2208 V i , suppose the contrary, that is, y \u2208 U i . If y is an answer variable, then h i (y) is an answer variable and thus in U i , contradiction. Otherwise, there is some R(y, z) in q i . Since h i (y) is strictly below x, this leads to a contradiction as follows. If z = y, then h * i (z) = h * i (y) contradicts the fact that h * i is a bijection. If, on the other hand, z = y, then h i is not a homomorphism since there is no self-loop R(h i (y), h i (y)) in U Aq i\u22121 ,O , by definition of the universal model. This finishes the proof of Claim 2.\nSanctioned by the first point in Claim 2, in what follows we assume for the sake of readability that h * i (x) = x for all x \u2208 V i and i \u2208 { + 1, . . . , u }. Hence, V = \u2022 \u2022 \u2022 = V u . Now, observe that, for all i \u2208 { + 1, . . . , u }, one of the following is the case:\n2. there is some\n, in contradiction to Point 3 of Lemma 27. It thus remains to bound the number of times each of these points can be satisfied along q , . . . , q u . We start with Point 1. Claim 3. The number of i \u2208 { + 1, . . . , u } such that the inverse of h i is not a homomorphism from\nProof of Claim 4. Let I be the set of all i as in the claim. Let i \u2208 I. We distinguish two cases.\nSince h i is a homomorphism, the number n i of atoms in\nBy definition of the universal model and since O is in normal form, there is an atom A(x) in q x i\u22121 such that there is a homomorphism from q x i to U {A(a)},O . We claim that A(x) is not an atom in any query q x j with j > i and j \u2208 I. Indeed, if A(x) occurs in q x j for such j, then q x j \u2286 O q x i . The homomorphisms h i+1 , . . . , h j witness that q\n, and thus all these queries are actually equivalent, in contradiction to the definition of I. where the first summand accomodates the number of i where Point 1 is satisfied and the second summand accomodates the number of i where Point 2 is satisfied.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "H Proofs for Section 4", "text": "Theorem 3. EL-concepts are not polynomial query learnable under ELI-ontologies with membership queries and CQ-equivalence queries.\nProof. Assume to the contrary of what is to be shown that EL-concepts are polynomial query learnable under ELIontologies when unrestricted CQs can be used in equivalence queries. Then there exists a learning algorithm and a polynomial p such that at any time, the sum of the sizes of the inputs to membership and equivalence queries made so far is bounded by p(n 1 , n 2 , n 3 ), where n 1 is the size of C T , n 2 is the size of O, and n 3 is the size of the largest counterexample seen so far.\nWe choose n such that 2 n > p(q 1 (n), q 2 (n), q 3 (n)) + 1 where q 1 , q 2 , q 3 are polynomials such that for every n \u2265 1, q 1 (n) \u2265 ||H|| for all H \u2208 H n , q 2 (n) \u2265 ||O n ||, and q 3 (n) bounds from above the size of all counterexamples returned by the oracle that we craft below.\nConsider now O n and H n as defined in Section 4. We let the oracle maintain a set of hypotheses H, starting with H = H n and then proceeding to subsets thereof, in such a way that at any point in time the learner cannot distinguish between any of the candidate targets in H.\nMore precisely, consider a membership query with ABox A and individual a 0 . The oracle responds as follows:\n1. if A, O n |= L 0 (a 0 ), then answer yes; 2. if A, O n |= K 0 (a 0 ) and there are \u03c3 1 , . . . , \u03c3 n \u2208 {r, s} with A, O n |= W \u03c3i i (a 0 ) for 1 \u2264 i \u2264 n, then answer yes and remove \u2203\u03c3 1 \u2022 \u2022 \u2022 \u2203\u03c3 n .\u2203r n .A from H; 3. otherwise, answer no and remove all H with A, O n |= H(a 0 ) from H. Higher up rules have higher priority, e.g., Case 2 is applied only if Case 1 does not apply. It is not hard to verify that the answers are correct regarding the hypothesis set H that remains after the answer is given.\nNow consider an equivalence query with CQ q H (x 0 ). The oracle responds as follows:\n1\nAgain, higher up rules have higher priority and the answers are always correct with respect to the updated set H. For Case 3, we remark that the counterexample\nWe argue that the cases are exhaustive. Assume that Cases 1 and 2 do not apply. Let q H be the restriction of q H to variables that are reachable from x 0 in the undirected graph\nand let q H be the restriction of q H to the variables that are not reachable.\nNon-applicability of Case 1 implies that there is a homomorphism h from q H to U {L0(a0)},On with h(x 0 ) = a 0 . Consequently, q H can only contain the symbols r, s, A as well as the concept names U \u03c3 i . Moreover, if there is an atom A(x) in q H , then x is reachable from x 0 in G q H on an r/s-path of length exactly 2n whose last n components are all r.\nWe next show that q H contains an atom A(x). If it does not, in fact, then h is also a homomorphism from q H to U { (a0)},On due to the first CI in O n , and we find a homomorphism h from q H to U {L0(a1)},On . Combining h and h yields a homomorphism g from q H to U { (a0),L0(a1)},On with g(x 0 ) = a 0 , in contradiction to Case 2 not being applicable.\nSo q H contains an atom A(x). As argued above, x is then reachable from x 0 along an r/s-path of length exactly 2n whose last n components are all r. Let the first n components be \u03c3 1 , . . . , \u03c3 n . Then\nand thus Case 3 is applicable.\nWe next observe the following. Claim. If A and a 0 were given as a membership query and Cases 1 and 2 of membership queries do not apply, then ||A|| \u2265 |{H \u2208 H n | A, O n |= H(a 0 )}|. Proof of the claim. We may assume w.l.o.g. that A is connected, that is, the undirected graph G A = (ind(A), {{a, b} | t(a, b) \u2208 A}) is connected. Since Cases 1 and 2 of membership queries do not apply, (a) A, O n |= L 0 (a 0 ) and (b) there are no \u03c3 1 , . . . , \u03c3 n \u2208 {r, s} such that A, O n |= K 0 (a 0 ) and A, O n |= W \u03c3i i (a 0 ) for 1 \u2264 i \u2264 n. By the construction of O n , these properties imply the following for 0 \u2264 i \u2264 2n:\n(c) A contains no r/s-path of length i from a 0 to some a with A, O n |= L i (a).\nIn fact, the existence of such a path implies A, O n |= L 0 (a 0 ).\n(d) A contains no r/s-path of length i from a 0 to some a with A, O n |= K i (a) and assertions W \u03c31 1 (a 1 ), . . . , W \u03c3n n (a n ) where \u03c3 1 , . . . , \u03c3 n \u2208 {r, s}. In fact, the existence of such a path and such assertions implies A, O n |= K 0 (a 0 ) and A, O n |= W \u03c3i i (a 0 ) for 1 \u2264 i \u2264 n.\n(e) A contains no r/s-paths p 1 , p 2 of length i that end at the same individual and such that p 1 starts with an r-edge while p 2 starts with an s-edge.\nIn fact, the existence of such paths and the connectedness of A implies A, O n |= D(a 0 ), thus A, O n |= L 0 (a 0 ). We now sketch the construction of a model I of A and O n . Let W \u2286 {0, . . . , n} contain i iff A contains an assertion W \u03c3 i (a) for some \u03c3 \u2208 {r, s} and a \u2208 ind(A). The following interpretations are used as building blocks for I:\n\u2022 an L i -path, n \u2264 i \u2264 2n, is an r-path of length 2n \u2212 i that makes makes L i+j true at the node at distance j \u2208 {0, . . . , n \u2212 i} from the start of the path and that makes true A at the end of the path; \u2022 a K i -path, n \u2264 i \u2264 2n, is defined as follows; let be maximal such that {i \u2212 n, . . . , } \u2286 W; then a K i -path is an r-path of length \u2212 (i \u2212 n) that makes K i+j true at the node at distance j \u2208 {0, . . . , } from the start of the path and that makes true A at the node at distance 2n\u2212i (if it exists); in addition, the start of the path might make true any of the concept names V \u03c3 j , \u03c3 \u2208 {r, s} and 1 \u2264 j \u2264 n, which are then all also made true by all other nodes on the path; \u2022 an L i -tree, 1 \u2264 i < n, is a binary r/s-tree of depth n \u2212 i that makes L i+j true at every node on level j \u2208 {0, . . . , n \u2212 i}; in addition, every node on level n \u2212 i is the start of an L n -path; \u2022 a K i -tree, 1 \u2264 i < n, is a binary r/s-tree of depth n \u2212 i that makes true K i+j at every node on level j \u2208 {0, . . . , n \u2212 1} and V \u03c3 i+j at every node on level at least j that is a \u03c3-successor of its parent; in addition, every node on level n \u2212 i is the start of a K 0 -path; moreover, the root might make true any of the concept names V \u03c3 j , \u03c3 \u2208 {r, s} and 1 \u2264 j \u2264 i, which are then all also made true by all other nodes in the tree. In all of the above, any node that has an incoming r/s-path of length i \u2208 {1, . . . , 2n} that starts with \u03c3 \u2208 {r, s} is additionally labeled with concept name U \u03c3 i . Moreover, the beginning of the path/root of the tree may be labeled with concept names of the form U \u03c3 i . Then any node on depth i + j, with i + j \u2264 2n, is labeled with U \u03c3 i+j . Now, the announced model I is constructed by starting with A and doing the following:\n1. exhaustively apply all concept inclusions in O n that have a concept name on the right-hand side; 2. at every a \u2208 ind(A), attach an infinite tree in which every node has two successors, one for each role name r, s, and in which no concept names are made true; 3. if a \u2208 L I i , 0 \u2264 i < n, then attach at a an L i -tree; 4. if a \u2208 K I i , 0 \u2264 i < n, then attach at a a K i -tree; 5. if a \u2208 L I i , n \u2264 i \u2264 2n, then attach at a an L i -path; 6. if a \u2208 K I i , n \u2264 i \u2264 2n, then attach at a a K i -path; 7. if W \u03c3 i (a) \u2208 A for some a, then make W \u03c3 i true everywhere in I. \nAssume to the contrary of what is to be shown that a H = a H . We distinguish four cases:\nThen there is a path from a 0 to a H in I labeled \u03c3 1 \u2022 \u2022 \u2022 \u03c3 2n and a path from a 0 to a H labeled \u03c3 1 \u2022 \u2022 \u2022 \u03c3 2n . By construction of I, these paths must already exist in A. From H = H , we thus obtain a contradiction to (e).\n\u2022 \u2022 d H = a H , d H = a H . Symmetric to previous case.\n\u2022\nWe first show that d H and d H are not in an L i -tree, 0 \u2264 i < n. Assume to the contrary that d H is (the case of d H is symmetric). Then it occurs on level 2n \u2212 i in the tree, since d H \u2208 A I . Since an L i -tree was attached to a H , we must have A, O n |= L i (a H ). Moreover, there is an r/s-path in I from a 0 to a H of length i, the prefix of \u03c3 1 \u2022 \u2022 \u2022 \u03c3 2n of this length. By construction of I, this path must already be in A. This is in contradiction to (c). We next show that d H and d H are not in a K i -tree, 0 \u2264 i < n. Assume to the contrary that d H is (the case of d H is symmetric). Then it occurs on level 2n \u2212 i in the tree, since d H \u2208 A I . By definition of such trees (and the attached paths), this implies that W = {1, . . . , n} and thus A contains assertions W \u03c3 1 1 (a 1 ), . . . , W \u03c3 n n (a n ). We must further have A, O n |= K i (a H ) and there is an r/s-path in I, thus in A from a 0 to a H of length i. This is in contradiction to (d). Thus, d H and d H are both in an L i -path or in a K i -path, n \u2264 i \u2264 2n. If they are in different such paths, then A, O n |= D(a H ), which is in contradiction to (c) as A is connected. Thus, they must be in the same L i -path or in the same K i -path. Since each such path contains a single element d with d \u2208 A I , we obtain d H = d H . From H = H , it thus follows that there are two different paths of length i in I from a 0 to a H , the prefixes of this length of \u03c3 1 \u2022 \u2022 \u2022 \u03c3 2n and of \u03c3 1 \u2022 \u2022 \u2022 \u03c3 2n . This is in contradiction to (e).\nThis finishes the proof of the claim.\nWe can use the claim to show the following invariant:\n( * ) at any point in time, the sum m of the sizes of the inputs to membership and equivalence queries made so far is not smaller than the number of candidates that were removed from H.\nNote in fact that only Cases 2 and 3 of membership queries and Cases 3 and 6 of equivalence queries may remove candidates from H and that they all remove only one candidate for each query posed with the exception of Case 3 of membership queries which can remove multiple candidate. However, the claim implies that the number of removed candidates in Case 3 of membership queries is bounded from above by the size of the query posed. It is clear that there is a polynomial q 3 such that the size of all counterexamples returned by the oracle is at most q 3 (n). The overall sum of the sizes of posed membership and equivalence queries is bounded by p(q 1 (n), q 2 (n), q 3 (n)). It thus follows from ( * ) that at most p(q 1 (n), q 2 (n), q 3 (n)) candidate concepts have been removed from H n . By the choice of n, at least two candidate concepts remain in H after the algorithm finished. Thus, the learner cannot distinguish between them, and we have derived a contradiction.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Learning conjunctions of Horn clauses", "journal": "Mach. Learn", "year": "1992", "authors": " Angluin"}, {"ref_id": "b1", "title": "Learning regular sets from queries and counterexamples", "journal": "Inf. Comput", "year": "1987", "authors": " Angluin;  Dana Angluin"}, {"ref_id": "b2", "title": "Pushing the EL envelope further", "journal": "", "year": "1987", "authors": "; Angluin ; Dana Angluin;  Baader"}, {"ref_id": "b3", "title": "Ontology-based data access: A study through disjunctive datalog, CSP, and MM-SNP", "journal": "Frazier and Pitt", "year": "1994", "authors": " Baader"}, {"ref_id": "b4", "title": "Concept-by-Example in EL Knowledge Bases", "journal": "", "year": "2019", "authors": ""}, {"ref_id": "b5", "title": "Kouichi Hirata. On the hardness of learning acyclic conjunctive queries", "journal": "", "year": "1989", "authors": "David Haussler;  Haussler"}, {"ref_id": "b6", "title": "Conjunctive query answering in the description logic EL using a relational database system", "journal": "Springer", "year": "2009", "authors": ""}, {"ref_id": "b7", "title": "Balder ten Cate, Phokion G. Kolaitis, Kun Qian, and Wang-Chiew Tan. Active learning of GAV schema mappings", "journal": "", "year": "2008", "authors": "Cate ; Dalmau ; Cate ; Victor Dalmau"}], "figures": [{"figure_label": "", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "and a, b \u2208 N I . We use ind(A) to denote the set of individual names that are used in A and may write r \u2212 (a, b) in place of r(b, a). An ABox is a ditree if the directed graph (ind(A), {(a, b) | r(a, b) \u2208 A}) is a tree and there are no multi-edges, that is, r(a, b), s(a, b) \u2208 A implies r = s.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Minimize. Let B be an ABox andb a tuple such that B, O |= q T (b). Then minimize(B,b) is the ABox B obtained from B by exhaustively applying the following operations: (1) choose c \u2208 ind(B) \\b and remove all assertions that involve c. Use a membership query to check whether, for the resulting ABox B \u2212 , B \u2212 , O |= q T (b). If so, proceed with B \u2212 in place of B. (2) choose r(a, b) \u2208 B and use a membership query to check whether B \\ {r(a, b)}, O |= q T (b). If so, proceed with B \\ {r(a, b)} in place of B.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Split.Choose r(a, b), r(c, b) \u2208 B i such that b / \u2208b n and neither r(a, b) nor r(c, b) occurs on a cycle. Construct B i by removing r(a, b) from B i , taking a fresh individual b , and adding B(b ) for all B(b) \u2208 B i and S(d, b ) for all S(d, b) \u2208", "figure_data": ""}, {"figure_label": "1", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "Figure 1 :1Figure 1: ELI-ontology On oracle returns \"no\" and positive counterexample A = {K 0 (a 0 ), W \u03c31 1 (a 0 ), . . . , W \u03c3n n (a 0 )}. It is instructive to verify that A, O |= C H (a 0 ) for all C H \u2208 H n \\ {C H } while A, O |= C H (a 0 ) as this illustrates the use of inverse roles in O n .", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_5", "figure_caption": "the set of all traces for A and O. Then U A,O := A \u222a {A(a) | A, O |= A(a)} \u222a {A(trC) | trC \u2208 T and O |= C C r A} \u222a {r(t, trC) | trC \u2208 T} The following two lemmas are the main properties of U A,O . They connect the notions of the universal model, homomorphisms, and queries and are well known. Lemma 3. Let A be an ABox and O an EL r -ontology. Then 1. U A,O is a model of A and O; 2. for every CQ q(x) and\u0101 \u2208 ind(A) |x| , U A,O |= q(\u0101) iff A, O |= q(\u0101).", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_6", "figure_caption": "2}, and O an EL r -ontology. If there is a simulation S from A 1 to A 2 with (a 1 , a 2 ) \u2208 S, then A 1 , O |= C(a 1 ) implies A 2 , O |= C(a 2 ) for all EL-concepts C. Now we continue with a proof of a central property of the 3-compact model.Lemma 2. Every cycle in C 3A,O of length at most three consists only of individuals from ind(A).Proof. The statement is clear by construction of C 3A,O for cycles of length 1. It is also clear for cycles of length 2 since for any pair of individuals of which at least one is of the form c a,i,r,C , the ABox C 3 A,O contains at most one assertion that involves both of them. Now for cycles of length 3. Assume to the contrary of what is to be shown that C 3 A,O contains a cycle of length 3 that contains an individual not from ind(A). First assume that there is an individual a \u2208 ind(A) on the cycle. Since all individuals of the form c b,i,r,C that are on the cycle are adjacent to a on the cycle, b = a and i = 0 for all such c b,i,r,C . This implies that a is the only individual from a \u2208 ind(A) on the cycle. But then the cycle contains two distinct individuals of the form c a,0,r,C that are connected by an edge, which is never the case in C 3 A,O . Now assume that the cycle contains only individuals of the form c b,i,r,C . Then all these individuals are connected in C 3 A,O by an edge. This is impossible due to the use of the index i in the construction of C 3 A,O .", "figure_data": ""}, {"figure_label": "10", "figure_type": "figure", "figure_id": "fig_7", "figure_caption": "Lemma 10 .10Let A be an ABox and O an EL r -ontology. Further let c a,i,r,C \u2208 \u2206 C 3 A,O and trC \u2208 \u2206 U A,O . Then C 3 A,O , c a,i,r,C U A,O , trC. Lemma 1. Let A be an ABox and O an EL r -ontology. Then C 3 A,O is a model of A and O such that for every CQ q(x) \u2208 CQ csf and\u0101 \u2208 ind(A) |x| , C 3 A,O |= q(\u0101) iff A, O |= q(\u0101).", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_8", "figure_caption": "If h(x) \u2208 ind(A), then it is immediate by definition of C 3 A,O and U A,O that r(h(x), h(y)) \u2208 C 3 A,O implies r(g(x), g(y)) \u2208 U A,O . If h(x) / \u2208 ind(A), we need to additionally invoke Lemma 10, applied to h(x) = c a ,i ,r ,C and to g(x) = tr C . By construction, g satisfies all binary atoms in q and thus in q. All unary atoms are satisfied, too, because of the invariant mentioned above and by definition of C 3 A,O and U A,O .", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_9", "figure_caption": "for no q(x) \u2208 S n , then answer no 2. if A, O n |= q(a) for a single q(x) \u2208 S n , then answer no and remove q(x) from S n 3. if A, O n |= q(a) for more than one q(x) \u2208 S n , then answer yes.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_10", "figure_caption": "every model of O 2 is a model of O 1 , and for every model I 1 of O 1 , there exists a model I 2 of O 2 such that S I1 = S I2 for all symbols S / \u2208 sig(O 2 ) \\ sig(O 1 ).", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_11", "figure_caption": "Claim 1. A , O |= q(\u0101) iff A, O |= q(\u0101) for all CQs q that use only symbols from \u03a3. Proof of Claim 1. For \"if\", suppose that A, O |= q(\u0101) and let I be a model of A and O . Then I is a model of O since O is a conservative extension of O. By Property 3 of Lemma 11, I is a model of A. Hence I |= q(\u0101) as required. For \"only if\", suppose that A , O |= q(\u0101) and let I be a model of A and O. Since O is a conservative extension of O, there is a model I of O that coincides with I on all symbols from \u03a3. By Property 3 of Lemma 11, I is a model of A . Since sig(q) \u2286 \u03a3 and I and I coincide on \u03a3, it follows that I |= q(\u0101) as required.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_12", "figure_caption": "\u03a3 , O |= q H (\u0101) iff A, O |= q H (\u0101) for all ABoxes A. Proof of Claim 2. For \"if\", suppose A, O |= q(\u0101) and let I be a model of A| \u03a3 and O . Since q and O contain only symbols from \u03a3, A| \u03a3 , O |= q(\u0101). Since O is a conservative extension of O, I is also a model of O. Thus I |= q(\u0101) and by Property 3 of Lemma 11, I |= q (\u0101) follows as required. For \"only if\", suppose A| \u03a3 , O |= q (\u0101) and let I be a model of A and O. Since O contains only symbols from \u03a3, I| \u03a3 is a model of A| \u03a3 and since O is a conservative extension of O, there is a model I of O that coincides on all symbols from \u03a3 with I| \u03a3 . Thus I |= q (\u0101) and by Property 3 of Lemma 11, I| \u03a3 |= q(\u0101). Then I |= q(\u0101) since q uses only symbols from \u03a3, as required.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_13", "figure_caption": "all uses of the subrouting refine and that B 1 ,b 1 = minimize(A,\u0101). In the first case, both C 3 Aq H ,O and C 3 A,O are O-saturated and thus their product is also O-saturated by Lemma 5 Point 3. In the second case A q \u22a5 is O-saturated since it contains A(x 0 ) for all concept names A \u2208 \u03a3. Moreover, the Minimize step does not remove any concept assertions. For the induction step, suppose B i+1 , O |= A( a) for some concept name A and some a \u2208 ind(B i+1 ) with a either a \u2208 ind(B i ) or a for some a \u2208 ind(B i ). By monotonicity, B i , O |= A( a) where B i is the result of applying the Expand step to B i before the Minimize step. By Lemma 12, B i , a B i , a and thus B i , O |= A(a) by Lemma 8. By induction, we know that A(a) \u2208 B i , and the application of the rules ensures that A( a) \u2208 B i+1 .", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_14", "figure_caption": "a), in turn, it follows that the subtree in U Bi,O below each b \u2208 ind(B i ) \\ {a} is identical to the subtree in U B ,O below b. Now ( * ) is an easy consequence. For Points 3 and 4, define a mapping g from ind(B i+1 ) to ind(B i ) by taking g(a) = a for all a \u2208 ind(B i ) \u2229 ind(B i+1 ) and g(a ) = a for all a \u2208 ind(B i+1 ) \\ ind(B i ). For Point 3, we verify the following Claim. Claim 1. g is a homomorphism from B i+1 to B i with g(b i+1 ) =b i . Proof of Claim 1. If A(a) \u2208 B i+1 , then A(a) \u2208 B i by definition of the Minimize step, and Lemma 12 implies that A(g(a)) \u2208 B i , as required. If r(a, b) \u2208 B i+1 , then r(a, b) \u2208 B i . The definition of the Expand step then yields r(g(a), g(b)) \u2208 B i , as required.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_15", "figure_caption": "For i = n, this follows from Lemma 14 Point 1. For the induction step, suppose B i+1 , O |= A(\u00e2) for some a \u2208 ind(B i+1 ), with a either a \u2208 ind(B i ) or a for some a \u2208 ind(B i ). Let B i be the result of applying the Split step, but not yet the Minimize step. Then B i , O |= A(\u00e2) by monotonicity. By Lemma 12 we have B i , a B i , a and thus B i , O |= A(a) by Lemma 8. By the induction hypothesis, we have A(a) \u2208 B i and the definition of the Split step ensures A(a) \u2208 B i+1 .", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_16", "figure_caption": "2 from q T to U Bi+1,O with h 2 (x) = b n (which exists by Lemma 15) yields a homomorphism h 3 from q T to U Bi,O with h 3 (x) =b n such that a / \u2208 img(h * 3 ), in contradiction to Point 2. Claim 2. h is not injective. Proof of Claim 2. Assume to the contrary that h is injective. Then at most one of b \u2208 ind(B i+1 ) or b \u2208 ind(B i+1 ). Again, h can be extended to a homomorphism h 1 from U Bi+1,O to U Bi,O by Lemma 7 Point 1. Composing h 1 and a homomorphism h 2 from q T to U Bi+1,O with h 2 (x) =b n (exists by Lemma 15) yields a homomorphism g from q T to U Bi,O with g(x) =b n . Recall that there is a symmetry r(a, b), r(c, b) \u2208 B i . If neither b or b are in ind(B i+1 ), then b / \u2208 img(g * ), in contradiction to Point 2. If b \u2208 ind(B i+1 ), then the Minimize step removed b in the construction of B i+1 . It follows that there is a homomorphism g from q T to U Bi,O with g (x) =b n and such that there is no r(x, y) \u2208 q T with r(g (x), g (y)) = r(c, b). This contradicts B i being the result of the Minimize step. The case for b \u2208 ind(B i+1 ) is symmetric. Thus both b and b are in ind(B i+1 ). We analyze the time requirement of the refine subroutine. Lemma 17. refine(q(x)) can be computed in time polynomial in ||q T || + ||q|| (but exponential in ar) using membership queries. Proof. Let (B 1 ,b 1 ), (B 2 ,b 2 ), . . . be the sequence constructed by the Expand/Minimize phase. By Lemma 14 Point 2, |ind(B i )| \u2264 |var(q T )| for all i \u2265 1. By Lemma 14 Point 4, the number of individuals in the ABoxes B i increases in every step. Thus the number n of steps is at most |var(q T )|. Now let B n , B n+1 , . . . be the sequence constructed by the Split/Minimize phase. We can argue in the same way, using Lemma 16 Point 2 and Lemma 16 Point 4 that the number m \u2212 n of steps is at most |var(q T )|.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_17", "figure_caption": "a new individual created by the Unravel. But by the definition of the Unravel step, replacing (d 1 , d 2 ) with (d 1 , d 2 ) in the cycle must yield a cycle in B i which contradicts the induction hypothesis. The same argument can be applied to cycles of length 1 and 2.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_18", "figure_caption": "x is a singleton; (ii) d 1 has the form c b,0,r,C and for every r(y, x) \u2208 V x , A 2 contains an assertion r(b , d 2 ) with h(y) = (b, b ); (iii) d 2 has the form c b,0,r,C and for every r(y, x) \u2208 V x , A 1 contains an assertion r(b , d 1 ) with h(y) = (b , b); (iv) d 1 has the form c b1,0,r,C1 , d 2 has the form c b2,0,r,C2 , and h(y) = (b 1 , b 2 ) for every r(y, x) \u2208 V x .", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_19", "figure_caption": "d 1 has shape c b1,0,r,C1 and d 2 has shape c b2,0,r,C2 . By definition of the models C 3 Ai,O and since inB 1 \u2286 C 3 A1,O \u00d7 C 3 A2,O , (b 1 , b 2 ) is the unique unraveled rpredecessor of (d 1 , d 2 ) in B i = B 1 .Then we are in Case (iv).", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "Learning queries q T from ELQ / ELIQ sf / CQ csf w under an EL r -ontology O. procedure LEARNCQ q H (x) := refine(q \u22a5 (x 0 )) while q H \u2261 O q T (equivalence query) do Let A,\u0101 be the positive counterexample returned and let q H (x ) be C 3", "figure_data": "Algorithm 1 Aq H ,O \u00d7 C 3 A,O viewed as a CQwith answer variablesx =x \u2297\u0101q H (x) := refine(q H (x ))return q H (x)Note that Points 1 and 2 of Theorem 2 imply the same state-ments for all relevant query classes, that is, ELQ, ELIQ sf ,CQ csf , CQ csf w for all w \u2265 1, and CQ, in place of the classesmentioned in the theorem. In particular, Point 2 implies that"}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_3", "figure_caption": "The induction start is immediate since U A1,O \u00d7 U A2,O |= q T (\u0101 1 \u2297 a 2 ) and there is a homomorphism from U A1,O \u00d7 U A2,O to C 3 A1,O \u00d7 C 3 A2,O that is the identity on\u0101 1 \u2297\u0101 2 . Thus, C 3 A1,O \u00d7 C 3 A2,O , O |= q T (\u0101 1 \u2297\u0101 2 ). It remains to note that B 1 = minimize(C 3 A1,O \u00d7 C 3 A2,O) and that the Minimize step preserves B 1 , O |= q T (\u0101 1 \u2297\u0101 2 ).", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "= | A | C D | \u2203R.C", "formula_coordinates": [2.0, 403.17, 178.85, 97.82, 8.74]}, {"formula_id": "formula_1", "formula_text": "A 1 A 2 A, A 1 \u2203r.A 2 , \u2203r.A 1 A 2 , \u2203r \u2212 . A", "formula_coordinates": [2.0, 324.43, 310.2, 224.14, 11.72]}, {"formula_id": "formula_2", "formula_text": "where A \u2208 N C \u222a { }, r \u2208 N R ,", "formula_coordinates": [2.0, 315.0, 351.48, 123.15, 9.76]}, {"formula_id": "formula_3", "formula_text": "\u2206 I1 to \u2206 I2 such that d \u2208 A I1 implies h(d) \u2208 A I2 and (d, e) \u2208 r I1 implies (h(d), h(e)) \u2208 r I2 . For d i a tuple over \u2206 Ii , i \u2208 {1, 2}, we write I 1 ,d 1 \u2192 I 2 ,d 2 if there is a homomorphism h from I 1 to I 2 with h(d 1 ) =d 2 .", "formula_coordinates": [3.0, 54.0, 187.4, 451.88, 44.1]}, {"formula_id": "formula_4", "formula_text": "1 is contained in q 2 under O, written q 1 \u2286 O q 2 , if for all ABoxes A and\u0101 \u2208 ind(A) n , A, O |= q 1 (\u0101) implies A, O |= q 2 (\u0101). We call q 1 and q 2 equivalent under O, written q 1 \u2261 O q 2 , if q 1 \u2286 O q 2 and q 2 \u2286 O q 1 .", "formula_coordinates": [3.0, 54.0, 334.47, 243.0, 42.53]}, {"formula_id": "formula_5", "formula_text": "q(x) \u2190 \u03d5(x,\u0233) that are 1. chordal, that is, every cycle R 0 (x 0 , x 1 ), . . . , R n\u22122 (x n\u22122 , x n\u22121", "formula_coordinates": [3.0, 61.47, 549.88, 235.53, 36.17]}, {"formula_id": "formula_6", "formula_text": "C 3 A,O := A \u222a {A(a) | A, O |= A(a)} \u222a {A(c a,i,r,C ) | O |= C C r A} \u222a {r(a, c a,0,r,C ) | A, O |= \u2203r.C(a)} \u222a {r(c a,i,s,C , c a,i\u22951,r,C ) | O |= C C s \u2203r.C }.", "formula_coordinates": [3.0, 319.98, 574.39, 235.02, 52.61]}, {"formula_id": "formula_7", "formula_text": "C 3 A,O is a model of A and O such that for every CQ q(x) \u2208 CQ csf and\u0101 \u2208 ind(A) |x| , C 3 A,O |= q(\u0101) iff A, O |= q(\u0101). C 3 A,O", "formula_coordinates": [3.0, 315.0, 679.68, 243.0, 26.42]}, {"formula_id": "formula_8", "formula_text": "x) \u2190 A 1 (x) \u2227 \u2022 \u2022 \u2022 \u2227 A n (x)", "formula_coordinates": [4.0, 99.66, 555.42, 108.66, 9.65]}, {"formula_id": "formula_9", "formula_text": "q \u22a5 (x 0 ) \u2190 {A(x 0 ) | A \u2208 \u03a3\u2229N C }\u222a{r(x 0 , x 0 ) | r \u2208 \u03a3\u2229N R }", "formula_coordinates": [4.0, 315.0, 663.28, 243.0, 11.72]}, {"formula_id": "formula_10", "formula_text": "1. q i \u2208 Q and q i \u2286 O q T ; 2. q i \u2286 O q i+1 and q i \u2261 O q i+1 ; 3. |var(q i )| \u2264 |var(q T )|.", "formula_coordinates": [5.0, 61.47, 105.39, 126.45, 40.09]}, {"formula_id": "formula_11", "formula_text": "(x) \u2208 Q such that q H \u2286 O q H \u2286 O q T .", "formula_coordinates": [5.0, 138.2, 353.05, 158.8, 10.9]}, {"formula_id": "formula_12", "formula_text": "Aq H ,O \u00d7 C 3 A,O", "formula_coordinates": [5.0, 235.79, 396.68, 60.5, 14.77]}, {"formula_id": "formula_13", "formula_text": "q H \u2286 O q T . It produces a query q H (x) from Q such that q H \u2286 O q H \u2286 O q T and |var(q H )| \u2264 |var(q T )|.", "formula_coordinates": [5.0, 54.0, 504.04, 243.0, 31.57]}, {"formula_id": "formula_14", "formula_text": "\u2022 add B(a i ) if B(a i ) \u2208 B i ; \u2022 add R(a i , c) if R(a i , c) \u2208 B i with 0 \u2264 i < n and c \u2208 ind(B i ) \\ {a 0 , . . . , a n\u22121 }; \u2022 add R(a i , a j ) if R(a i , a j ) \u2208 B i with 0 \u2264 i, j < n and {i, j} = {0, n \u2212 1}; \u2022 add R(a n\u22121 , a 0 ) and R(a n\u22121 , a 0 ) if R(a n\u22121 , a 0 ) \u2208 B i . A similar construction is used in [Konev et al., 2016]. Let \u03c4 i be the set of tuplesb obtained fromb i = (b 1 , . . . , b k ) by replacing any number of components b j by b j . Use member- ship queries to identifyb i+1 \u2208 \u03c4 i with B i , O |= q T (b i+1 ) and set B i+1 = minimize(B i ,b i+1 ).", "formula_coordinates": [5.0, 315.0, 171.28, 243.0, 139.94]}, {"formula_id": "formula_15", "formula_text": "B i with S(d, b) = r(c, b). If B i , O |= q T (b n ), then B i+1 = minimize(B i ,b n ).", "formula_coordinates": [5.0, 315.0, 426.96, 243.0, 21.71]}, {"formula_id": "formula_16", "formula_text": "P = C 3 Aq H ,O \u00d7 C 3 A,O", "formula_coordinates": [5.0, 315.0, 620.16, 243.0, 24.16]}, {"formula_id": "formula_17", "formula_text": "\u2203\u03c3 1 \u2022 \u2022 \u2022 \u2203\u03c3 n .\u2203r n .A with \u03c3 1 , . . . , \u03c3 n \u2208 {r, s}", "formula_coordinates": [6.0, 86.7, 523.49, 177.59, 11.72]}, {"formula_id": "formula_18", "formula_text": "Li \u2203r.Li+1 \u2203s.Li+1 for 0 \u2264 i \u2264 n Li \u2203r.Li+1 for n \u2264 i < 2n L2n A \u2203\u03c3.Li+1 Li for \u03c3 \u2208 {r, s} and 0 \u2264 i \u2264 2n Ki \u2203r.(Ki+1 V r i+1 ) \u2203s.(Ki+1 V s i+1 ) for \u03c3 \u2208 {r, s} and 0 \u2264 i \u2264 n Ki W \u03c3 i+1 \u2203r.Ki+1 for \u03c3 \u2208 {r, s} and n \u2264 i < 2n \u2203\u03c3 \u2212 .(Kj V \u03c3 i ) V \u03c3 i for \u03c3, \u03c3 \u2208 {r, s}, 1 \u2264 i \u2264 n, and i \u2264 j \u2264 2n K2n V \u03c3 i W \u03c3 i A for \u03c3 \u2208 {r, s} and 1 \u2264 i \u2264 n \u2203\u03c3.W \u03c3 i W \u03c3 i for \u03c3 \u2208 {r, s, r \u2212 , s \u2212 }, \u03c3 \u2208 {r, s}, and 1 \u2264 i \u2264 n W r i W s i L0 for 0 \u2264 i \u2264 n \u2203\u03c3.Ki+1 Ki for \u03c3 \u2208 {r, s} and 0 \u2264 i \u2264 2n \u2203\u03c3 \u2212 . U \u03c3 1 for \u03c3 \u2208 {r, s} \u2203\u03c3 \u2212 .U \u03c3 i U \u03c3 i+1 for \u03c3, \u03c3 \u2208 {r, s} and 1 \u2264 i < 2n U r i U s i D for 1 \u2264 i \u2264 2n Ki A D for 0 \u2264 i < 2n Li A D for 0 \u2264 i < 2n Li Lj D for n \u2264 i < j \u2264 2n Ki Kj D for n \u2264 i < j \u2264 2n Li Kj D for n \u2264 i, j \u2264 2n \u2203\u03c3.D D for \u03c3 \u2208 {r, s, r \u2212 , s \u2212 } D L0", "formula_coordinates": [6.0, 318.39, 74.79, 233.92, 343.5]}, {"formula_id": "formula_19", "formula_text": "A = {K 0 (a 0 ), W \u03c31 1 (a 0 ), . . . , W \u03c3n n (a 0 )}. It is instructive to ver- ify that A, O |= C H (a 0 ) for all C H \u2208 H n \\ {C H } while A, O |= C H (a 0 ) as this illustrates the use of inverse roles in O n .", "formula_coordinates": [6.0, 315.0, 450.08, 243.0, 53.49]}, {"formula_id": "formula_20", "formula_text": "t = ar 1 C 1 r 2 C 2 . . . r n C n , n \u2265 0, such that a \u2208 ind(A), {\u2203r 1 .C 1 , . . . , \u2203r n .C n } \u2286 sub(O), A, O |= \u2203r 1 .C 1 (a), O |= C i C ri \u2203r i+1 .C i+1 for 1 \u2264 i < n. Let T denote", "formula_coordinates": [8.0, 54.0, 187.4, 243.0, 41.83]}, {"formula_id": "formula_21", "formula_text": "1. q 1 \u2286 O q 2 ,", "formula_coordinates": [8.0, 61.47, 416.62, 53.09, 9.65]}, {"formula_id": "formula_22", "formula_text": "r 1 C 1 \u2022 \u2022 \u2022 r n C n .", "formula_coordinates": [8.0, 93.0, 525.7, 60.45, 9.65]}, {"formula_id": "formula_23", "formula_text": "{ (a 1 , a 2 ) | a i \u2208 \u2206 Ii for i \u2208 {1, 2}} \u222a {A(a 1 , a 2 ) | A(a i ) \u2208 I i for i \u2208 {1, 2}} \u222a {r((a 1 , a 2 ), (b 1 , b 2 )) | r(a i , b i ) \u2208 I i for i \u2208 {1, 2}}. Ifd i = (d i,1 , . . . , d i,n ) \u2208 \u2206 Ii for i \u2208 {1, 2}, then we us\u0113 d 1 \u2297d 2 to denote the tuple ((d 1,1 , d 2,1 ), . . . , (d 1,n , d 2,n )).", "formula_coordinates": [8.0, 54.0, 569.77, 452.69, 71.08]}, {"formula_id": "formula_24", "formula_text": "1. for i \u2208 {1, 2} there is a homomorphism h from I 1 \u00d7I 2 to I i such that h(d 1 , d 2 ) = d i for all (d 1 , d 2 ) \u2208 \u2206 I1\u00d7I2 ;", "formula_coordinates": [8.0, 61.47, 684.24, 235.53, 20.61]}, {"formula_id": "formula_25", "formula_text": "I 1 , d 1 I 2 , d 2 if such a simulation S exists.", "formula_coordinates": [8.0, 315.0, 210.31, 182.07, 9.65]}, {"formula_id": "formula_26", "formula_text": "d i \u2208 \u2206 Ii , for i \u2208 {1, 2}. Then I 1 , d 1 I 2 , d 2 and d 1 \u2208 C I1 implies d 2 \u2208 C I2 for all EL-concepts C. Lemma 7. Let O be an EL r -ontology and A 1 , A 2 ABoxes. Then 1. every homomorphism h from A 1 to A 2 can be extended to a homomorphism h from U A1,O to U A2,O such that if a / \u2208 ind(A 1 ) is a trace a = bw, then h (a) is a trace of shape h(a)w , and in particular, a / \u2208 ind(A 1 ) implies h (a) / \u2208 ind(A 2 ); 2. if A 1 , a 1 A 2 , a 2 , then U A1,O , a 1 U A2,O , a 2 . Lemma 8. Let A 1 , A 2 be ABoxes, a 1 \u2208 ind(A i ) for i \u2208 {1,", "formula_coordinates": [8.0, 315.0, 245.94, 243.0, 159.13]}, {"formula_id": "formula_27", "formula_text": "R 0 (x 0 , x 1 ), R 1 (x 1 , x 2 ), R 2 (x 2 , x 0 ) of length 3 in q. Assume that g(x 0 )", "formula_coordinates": [9.0, 315.0, 267.65, 243.0, 20.61]}, {"formula_id": "formula_28", "formula_text": ") \u2286 C 3 A,O , h(y) / \u2208 ind(A) as g(y)", "formula_coordinates": [9.0, 511.62, 693.62, 46.38, 12.48]}, {"formula_id": "formula_29", "formula_text": "C 3 A,O", "formula_coordinates": [10.0, 275.96, 260.41, 20.33, 12.47]}, {"formula_id": "formula_30", "formula_text": ") / \u2208 ind(A). From h(x ) \u2208 ind(A), h(y) / \u2208 ind(A), s(h(x ), h(y)), r(h(x), h(y)) \u2208 C 3 A,O and the defi- nition of C 3 A,O , we obtain h(x ) = h(x). But then h(x) \u2208 ind(A), in contradiction to g(x) not yet being defined.", "formula_coordinates": [10.0, 73.93, 311.39, 223.07, 69.75]}, {"formula_id": "formula_31", "formula_text": "O n = {A i A i A 1 A 1 \u2022 \u2022 \u2022 A n A n | 1 \u2264 i \u2264 n} and S n = {q(x) \u2190 \u03b1 1 (x) \u2227 \u2022 \u2022 \u2022 \u2227 \u03b1 n (x) | \u03b1 i \u2208 {A i , A i } for all i with 1 \u2264 i \u2264 n}.", "formula_coordinates": [10.0, 315.0, 165.07, 240.18, 64.83]}, {"formula_id": "formula_32", "formula_text": "(x) \u2208 S m satisfies ||q(x)|| = r 1 (m) and r 2 is a polynomial such that r 2 (m) > ||O m || for every m \u2265 1.", "formula_coordinates": [10.0, 315.0, 327.2, 243.0, 30.66]}, {"formula_id": "formula_33", "formula_text": "1. if A, O n |= q(a)", "formula_coordinates": [10.0, 322.47, 399.25, 78.98, 9.65]}, {"formula_id": "formula_34", "formula_text": "2. A, O |= q(\u0101) for all\u0101 \u2208 N .", "formula_coordinates": [10.0, 322.47, 695.2, 123.33, 8.96]}, {"formula_id": "formula_35", "formula_text": "An EL r -ontology O 2 is a conservative extension of an EL r - ontology O 1 if sig(O 1 ) \u2286 sig(O 2 ),", "formula_coordinates": [11.0, 315.0, 390.65, 243.0, 22.91]}, {"formula_id": "formula_36", "formula_text": "1. O is a conservative extension of O, 2. sig(O ) = sig(O) \u222a {X C | C \u2208 sub(O)}, 3. O |= X C \u2261 C for each C \u2208 sub(O).", "formula_coordinates": [11.0, 322.47, 490.6, 179.94, 41.55]}, {"formula_id": "formula_37", "formula_text": "\u2022 X C C, C X C if C is a concept name or ; \u2022 X C X D1 , X C X D2 , and X D1 X D2 X C if C = D 1 D 2 ; \u2022 X C \u2203r.X D and \u2203r.X D X C if C = \u2203r.D; \u2022 X C X D for each concept inclusion C D \u2208 O; \u2022 \u2203r \u2212 . X C for each range restriction \u2203r \u2212 . C \u2208 O.", "formula_coordinates": [11.0, 326.46, 582.57, 231.54, 94.45]}, {"formula_id": "formula_38", "formula_text": "1. B i , O |= q T (b i ); 2. B i , O |= q T (b) for someb \u2208 \u03c4 i ;", "formula_coordinates": [12.0, 322.47, 472.49, 139.1, 26.08]}, {"formula_id": "formula_39", "formula_text": "U B i ,O with g(x) =b for someb \u2208 \u03c4 i , which yields B i , O |= q T (b) as desired. Let us partition var(q T ) into sets M 0 , M 1 , M 2 such that: \u2022 x \u2208 M 0 if h(x) \u2208 {a 0 , . . . , a n\u22121 }, that is, h(x) lies on the expanded cycle; \u2022 x \u2208 M 1 if h(x) / \u2208 ind(B i ), that is, h(x)", "formula_coordinates": [12.0, 315.0, 618.36, 243.0, 75.53]}, {"formula_id": "formula_40", "formula_text": "g(x) = h(x) for all x \u2208 M 2 .", "formula_coordinates": [13.0, 114.34, 92.12, 122.31, 9.65]}, {"formula_id": "formula_41", "formula_text": "{x 1 , x 2 } \u2286 {y 0 , y 1 , y 2 } \u2286 M 0 and 2. h(x 1 ) = h(x 2 )", "formula_coordinates": [13.0, 61.47, 196.32, 151.63, 25.64]}, {"formula_id": "formula_42", "formula_text": "g(z) = h(z).", "formula_coordinates": [13.0, 149.23, 665.26, 52.54, 8.74]}, {"formula_id": "formula_43", "formula_text": "A(h(x)) \u2208 U Bi,O . If h(x) \u2208 ind(B i ), then g(x)", "formula_coordinates": [13.0, 315.0, 492.64, 192.89, 9.76]}, {"formula_id": "formula_44", "formula_text": "B i , h(x) B i , g(x). By Lemma 7, U Bi,O , h(x) U B i ,O , g(x)", "formula_coordinates": [13.0, 315.0, 503.71, 243.0, 22.74]}, {"formula_id": "formula_45", "formula_text": "A(g(x)) \u2208 U B i ,O . If h(x) / \u2208 ind(B i )", "formula_coordinates": [13.0, 315.0, 514.67, 243.0, 24.26]}, {"formula_id": "formula_46", "formula_text": "x 1 , x 2 belonging to M 0 , M 1 , M 2 : \u2022 If x 1 , x 2 \u2208 M 0 , then q T contains an atom R(x 1 , x 2 )", "formula_coordinates": [13.0, 326.46, 563.06, 231.54, 25.43]}, {"formula_id": "formula_47", "formula_text": "x i ) = g(x i ) for i \u2208 {1, 2}. Thus R(g(x 1 ), g(x 2 )) \u2208 U B i ,O as required.", "formula_coordinates": [13.0, 334.93, 632.39, 223.07, 22.74]}, {"formula_id": "formula_48", "formula_text": "U B i ,O is iden- tical to the subtree below b in U Bi,O . This implies R(g(x 1 ), g(x 2 )) \u2208 U B i ,O . \u2022 If x 1 , x 2 \u2208 M 2 , then g(x 1 ) = h(x 1 ), g(x 2 ) = h(x 2 ), and R(h(x 1 ), h(x 2 )) \u2208 B i because h is a homomor- phism from q T to U Bi,O and h(x 1 ), h(x 2 ) \u2208 ind(B i ). Since additionally h(x 1 ), h(x 2 ) / \u2208 {a 0 , . . . , a n\u22121 }, R(h(x 1 ), h(x 2 )) \u2208 B i and thus R(g(x 1 ), g(x 2 )) \u2208 U B i ,O . \u2022 If x 1 \u2208 M 0 and x 2 \u2208 M 1 , then h(x 1 ) \u2208 {a 0 , . . . , a n\u22121 }", "formula_coordinates": [14.0, 65.46, 57.16, 231.55, 120.44]}, {"formula_id": "formula_49", "formula_text": "U B i ,O . \u2022 If x 1 \u2208 M 0 and x 2 \u2208 M 2 , then h(x 1 ) \u2208 {a 0 , . . . , a n\u22121 } and h(x 2 ) \u2208 ind(B i ) \\ {a 0 , . . . , a n\u22121 }. Moreover, g(x 1 ) \u2208 {h(x 1 ), h(x 1 ) } and g(x 2 ) = h(x 2 ). It follows from R(h(x 1 ), h(x 2 )) \u2208 U Bi,O that R(h(x 1 ), h(x 2 )) \u2208 B i . By construction of B i , we thus have R(g(x 1 ), g(x 2 )) \u2208 B i \u2286 U B i ,O . \u2022 if x 1 \u2208 M 1 , x 2 \u2208 M 2 , then h(x 2 ) \u2208 ind(B i ) \\ {a 0 , . . . , a n\u22121 } and h(x 1 ) takes the form h(x 2 )rC with R = r \u2212 . Moreover g(x i ) = h(x i ) for i \u2208 {1, 2}", "formula_coordinates": [14.0, 65.46, 222.74, 231.54, 120.44]}, {"formula_id": "formula_50", "formula_text": "Lemma 14. For all i \u2265 1, 1. B i is O-saturated; 2. if h is a homomorphism from q T to U Bi,O with h(x) = b i , then ind(B i ) \u2286 img(h * ); 3. B i+1 ,b i+1 \u2192 B i ,b i ; 4. |ind(B i+1 )| > |ind(B i )|.", "formula_coordinates": [14.0, 54.0, 380.03, 445.94, 83.93]}, {"formula_id": "formula_51", "formula_text": "C 3 Aq H ,O \u00d7 C 3 A,O or A q \u22a5 for", "formula_coordinates": [14.0, 54.0, 484.08, 243.0, 26.46]}, {"formula_id": "formula_52", "formula_text": "a) A(b) \u2208 U Bi,O iff A(b) \u2208 U B ,O ; (b) r(b, b ) \u2208 U Bi,O iff r(b, b ) \u2208 U B ,O . From(", "formula_coordinates": [14.0, 315.0, 131.63, 165.29, 38.53]}, {"formula_id": "formula_53", "formula_text": "Claim 3. If g is injective, then r(a, b) \u2208 B i implies r(g \u2212 (a), g \u2212 (b)) \u2208 B i+1 .", "formula_coordinates": [14.0, 315.0, 477.28, 243.0, 20.61]}, {"formula_id": "formula_54", "formula_text": "Lemma 15. B i , O |= q T (b n ) for all i \u2265 n.", "formula_coordinates": [15.0, 54.0, 269.81, 172.43, 9.72]}, {"formula_id": "formula_55", "formula_text": "Lemma 16. For all i \u2265 n, 1. B i is O-saturated; 2. if h is a homomorphism from q T to U Bi,O with h(x) = b n , then ind(B i ) \u2286 img(h * ); 3. B i+1 ,b n \u2192 B i ,b n ; 4. |ind(B i+1 )| > |ind(B i )|.", "formula_coordinates": [15.0, 54.0, 355.28, 445.94, 84.51]}, {"formula_id": "formula_56", "formula_text": "1. A(b) \u2208 U Bi,O iff A(b) \u2208 U B ,O ; 2. r(b, b ) \u2208 U Bi,O iff r(b, b ) \u2208 U B ,O .", "formula_coordinates": [15.0, 61.47, 679.53, 157.81, 25.32]}, {"formula_id": "formula_57", "formula_text": ") = b if b \u2208 ind(B i+1", "formula_coordinates": [15.0, 348.92, 147.15, 91.11, 9.76]}, {"formula_id": "formula_58", "formula_text": "q T (x 1 , x 2 ) \u2190 A(x 1 ) \u2227 B(x 2 ) \u2227 r(x 1 , x 1 ) \u2227 r(x 2 , x 2 )", "formula_coordinates": [16.0, 66.58, 253.26, 217.83, 10.62]}, {"formula_id": "formula_59", "formula_text": "Lemma 18. If q T (\u0233) \u2208 Q for Q \u2208 {ELQ, ELIQ sf , CQ csf w | w \u2265 0}, then refine(q(x)) \u2208 Q, for every CQ q(x).", "formula_coordinates": [16.0, 54.0, 347.39, 243.0, 21.77]}, {"formula_id": "formula_60", "formula_text": "1 ) = x 1 , h(y 2 ) = x 2 .", "formula_coordinates": [16.0, 54.0, 471.21, 243.0, 20.61]}, {"formula_id": "formula_61", "formula_text": "(x ) such that q H \u2286 O q T and produces a CQ q H (x) such that q H \u2286 O q H \u2286 O q T and |var(q H )| \u2264 |var(q T )|.", "formula_coordinates": [16.0, 315.0, 520.8, 243.0, 31.57]}, {"formula_id": "formula_62", "formula_text": "A = C 3 A1,O \u00d7 C 3 A2,O and a =\u0101 1 \u2297\u0101 2 . We know that A i , O |= q T (\u0101 i ) for i \u2208 {1, 2}.", "formula_coordinates": [16.0, 315.0, 584.98, 452.1, 23.79]}, {"formula_id": "formula_63", "formula_text": "B 1 = minimize(C 3 A1,O \u00d7 C 3 A2,O", "formula_coordinates": [17.0, 110.02, 108.28, 126.37, 12.69]}, {"formula_id": "formula_64", "formula_text": "(c 1 , c 2 ) \u2208 ind(B i ) unraveled if c i \u2208 ind(U Ai,O ) for each i \u2208 {1, 2}. Note that (c 1 , c 2 ) \u2208 B 1 and c i / \u2208 ind(U Ai,O )", "formula_coordinates": [17.0, 54.0, 240.2, 243.0, 31.68]}, {"formula_id": "formula_65", "formula_text": "r((c 1 , c 2 ), (d 1 , d 2 )) \u2208 B i with (c 1 , c 2 ) unraveled and (d 1 , d 2 ) not unraveled. Let d j = d j if d j occurs in U Aj ,O and d j = c j rC if d j = c a, ,s,C , for j \u2208 {1, 2}.", "formula_coordinates": [17.0, 54.0, 300.88, 243.0, 41.61]}, {"formula_id": "formula_66", "formula_text": "\u2022 r((c 1 , c 2 ), (d 1 , d 2 )); \u2022 A(d 1 , d 2 ) for all A(d 1 , d 2 ) \u2208 B i ; \u2022 r((d 1 , d 2 ), (e 1 , e 2 )) for all r((d 1 , d 2 ), (e 1 , e 2 )) \u2208 B i .", "formula_coordinates": [17.0, 65.46, 348.5, 219.7, 40.32]}, {"formula_id": "formula_67", "formula_text": "A 1 ) \u00d7 ind(A 2 ) in the directed graph G Bn = (ind(B n ), {(a, b) | r(a, b) \u2208 B n }).", "formula_coordinates": [17.0, 54.0, 519.74, 243.0, 20.72]}, {"formula_id": "formula_68", "formula_text": "B 1 = minimize(C 3 A1,O \u00d7 C 3 A2,O ). If B 1 contains a cycle r((a 1 , a 2 ), (a 1 , a 2 )) of length 1 with a i / \u2208 A i for some i \u2208 {1, 2}, then r(a 1 , a 1 ) is a cycle of length 1 in C 3 A1,O which is not the case by Lemma 2. Next assume that B 1 contains a cycle r 0 ((a 1 , a 2 ), (b 1 , b 2 )), r 1 ((b 1 , b 2 ), (a 1 , a 2 )) of length 2. Assume w.l.o.g. that a 1 / \u2208 ind(A 1 ). If a 1 = b 1 , then r 0 (a 1 , a 1 ) is a cycle of length 1 in C 3 A1,O , but this is not the case by Lemma 2. If a 1 = b 1 , then r 0 (a 1 , b 1 ), r 1 (b 1 , a 1 ) is a cycle of length 2 in C 3 A1,O", "formula_coordinates": [17.0, 315.0, 291.98, 243.0, 103.37]}, {"formula_id": "formula_69", "formula_text": "1 , b 2 )), r 1 ((b 1 , b 2 ), (c 1 , c 2 )), r 2 ((c 1 , c 2 ), (a 1 , a 2 )) be a new cycle of length 3 in B. Since the cycle is new, one of (a 1 , a 2 ), (b 1 , b 2 ) or (c 1 , c 2 ) must be (d 1 , d 2 ),", "formula_coordinates": [17.0, 315.0, 519.23, 243.0, 43.51]}, {"formula_id": "formula_70", "formula_text": "(i) V", "formula_coordinates": [18.0, 59.54, 544.3, 20.2, 8.96]}], "doi": ""}