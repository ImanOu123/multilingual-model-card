{"title": "The Option-Critic Architecture", "authors": "Pierre-Luc Bacon; Jean Harb; Doina Precup", "pub_date": "2016-12-03", "abstract": "Temporal abstraction is key to scaling up learning and planning in reinforcement learning. While planning with temporally extended actions is well understood, creating such abstractions autonomously from data has remained challenging. We tackle this problem in the framework of options [Sutton, Precup & Singh, 1999; Precup, 2000]. We derive policy gradient theorems for options and propose a new option-critic architecture capable of learning both the internal policies and the termination conditions of options, in tandem with the policy over options, and without the need to provide any additional rewards or subgoals. Experimental results in both discrete and continuous environments showcase the flexibility and efficiency of the framework.", "sections": [{"heading": "Introduction", "text": "Temporal abstraction allows representing knowledge about courses of action that take place at different time scales. In reinforcement learning, options (Sutton, Precup, and Singh 1999;Precup 2000) provide a framework for defining such courses of action and for seamlessly learning and planning with them. Discovering temporal abstractions autonomously has been the subject of extensive research efforts in the last 15 years (McGovern and Barto 2001;Stolle and Precup 2002;Menache, Mannor, and Shimkin 2002;\u015e im\u015fek and Barto 2009;Silver and Ciosek 2012), but approaches that can be used naturally with continuous state and/or action spaces have only recently started to become feasible (Konidaris et al. 2011;Niekum 2013;Mann, Mannor, and Precup 2015;Mankowitz, Mann, and Mannor 2016;Kulkarni et al. 2016;Vezhnevets et al. 2016;Daniel et al. 2016).\nThe majority of the existing work has focused on finding subgoals (useful states that an agent should reach) and subsequently learning policies to achieve them. This idea has led to interesting methods but ones which are also difficult to scale up given their \"combinatorial\" flavor. Additionally, learning policies associated with subgoals can be expensive in terms of data and computation time; in the worst case, it can be as expensive as solving the entire task.\nWe present an alternative view, which blurs the line between the problem of discovering options from that of learning options. Based on the policy gradient theorem (Sutton et al. 2000), we derive new results which enable a gradual learning process of the intra-option policies and termination functions, simultaneously with the policy over them. This approach works naturally with both linear and non-linear function approximators, under discrete or continuous state and action spaces. Existing methods for learning options are considerably slower when learning from a single task: much of the benefit comes from re-using the learned options in similar tasks. In contrast, we show that our approach is capable of successfully learning options within a single task without incurring any slowdown and while still providing benefits for transfer learning.\nWe start by reviewing background related to the two main ingredients of our work: policy gradient methods and options. We then describe the core ideas of our approach: the intra-option policy and termination gradient theorems. Additional technical details are included in the appendix. We present experimental results showing that our approach learns meaningful temporally extended behaviors in an effective manner. As opposed to other methods, we only need to specify the number of desired options; it is not necessary to have subgoals, extra rewards, demonstrations, multiple problems or any other special accommodations (however, the approach can take advantage of pseudo-reward functions if desired). To our knowledge, this is the first end-to-end approach for learning options that scales to very large domains at comparable efficiency.", "publication_ref": ["b24", "b15", "b22", "b16", "b3", "b20", "b8", "b19", "b14", "b12", "b10", "b27", "b4", "b23"], "figure_ref": [], "table_ref": []}, {"heading": "Preliminaries and Notation", "text": "A Markov Decision Process consists of a set of states S, a set of actions A, a transition function P : S \u00d7A \u2192 (S \u2192 [0, 1]) and a reward function r : S \u00d7 A \u2192 R. For convenience, we develop our ideas assuming discrete state and action sets. However, our results extend to continuous spaces using usual measure-theoretic assumptions (some of our empirical results are in continuous tasks). A (Markovian stationary) policy is a probability distribution over actions conditioned on states, \u03c0 : S \u00d7 A \u2192 [0, 1]. In discounted problems, the value function of a policy \u03c0 is defined as the expected return:\nV \u03c0 (s) = E \u03c0 [ \u221e t=0 \u03b3 t r t+1 | s 0 = s] and its action-value function as Q \u03c0 (s, a) = E \u03c0 [ \u221e t=0 \u03b3 t r t+1 | s 0 = s, a 0 = a],\nwhere \u03b3 \u2208 [0, 1) is the discount factor. A policy \u03c0 is greedy with respect to a given action-value function Q if \u03c0(s, a) > 0 iff a = argmax a Q(s, a ). In a discrete MDP, there is at least one optimal policy which is greedy with re-spect to its own action-value function.\nPolicy gradient methods (Sutton et al. 2000;Konda and Tsitsiklis 2000) address the problem of finding a good policy by performing stochastic gradient descent to optimize a performance objective over a given family of parametrized stochastic policies, \u03c0 \u03b8 . The policy gradient theorem (Sutton et al. 2000) provides expressions for the gradient of the average reward and discounted reward objectives with respect to \u03b8. In the discounted setting, the objective is defined with respect to a designated start state (or distribution)\ns 0 : \u03c1(\u03b8, s 0 ) = E \u03c0 \u03b8 [ \u221e t=0 \u03b3 t r t+1 | s 0 ]. The policy gradient theorem shows that: \u2202\u03c1(\u03b8,s0) \u2202\u03b8 = s \u00b5 \u03c0 \u03b8 (s | s 0 ) a \u2202\u03c0 \u03b8 (a|s) \u2202\u03b8 Q \u03c0 \u03b8 (s, a), where \u00b5 \u03c0 \u03b8 (s | s 0 ) = \u221e t=0 \u03b3 t P (s t = s | s 0\n) is a discounted weighting of the states along the trajectories starting from s 0 . In practice, the policy gradient is estimated from samples along the on-policy stationary distribution. (Thomas 2014) showed that neglecting the discount factor in this stationary distribution makes the usual policy gradient estimator biased. However, correcting for this discrepancy also reduces data efficiency. For simplicity, we build on the framework of (Sutton et al. 2000) and discuss how to extend our results according to (Thomas 2014).\nThe options framework (Sutton, Precup, and Singh 1999;Precup 2000) formalizes the idea of temporally extended actions. A Markovian option \u03c9 \u2208 \u2126 is a triple (I \u03c9 , \u03c0 \u03c9 , \u03b2 \u03c9 ) in which I \u03c9 \u2286 S is an initiation set, \u03c0 \u03c9 is an intra-option policy, and \u03b2 \u03c9 : S \u2192 [0, 1] is a termination function. We also assume that \u2200s \u2208 S, \u2200\u03c9 \u2208 \u2126 : s \u2208 I \u03c9 (i.e., all options are available everywhere), an assumption made in the majority of option discovery algorithms. We will discuss how to dispense with this assumption in the final section. (Sutton, Precup, and Singh 1999;Precup 2000) show that an MDP endowed with a set of options becomes a Semi-Markov Decision Process (Puterman 1994, chapter 11), which has a corresponding optimal value function over options V \u2126 (s) and option-value function Q \u2126 (s, \u03c9). Learning and planning algorithms for MDPs have their counterparts in this setting. However, the existence of the underlying MDP offers the possibility of learning about many different options in parallel : this is the idea of intraoption learning, which we leverage in our work.", "publication_ref": ["b23", "b6", "b23", "b26", "b23", "b26", "b24", "b24"], "figure_ref": [], "table_ref": []}, {"heading": "Learning Options", "text": "We adopt a continual perspective on the problem of learning options. At any time, we would like to distill all of the available experience into every component of our system: value function and policy over options, intra-option policies and termination functions. To achieve this goal, we focus on learning option policies and termination functions, assuming they are represented using differentiable parameterized function approximators.\nWe consider the call-and-return option execution model, in which an agent picks option \u03c9 according to its policy over options \u03c0 \u2126 , then follows the intra-option policy \u03c0 \u03c9 until termination (as dictated by \u03b2 \u03c9 ), at which point this procedure is repeated. Let \u03c0 \u03c9,\u03b8 denote the intra-option policy of option \u03c9 parametrized by \u03b8 and \u03b2 \u03c9,\u03d1 , the termination function of \u03c9 parameterized by \u03d1. We present two new results for learning options, obtained using as blueprint the policy gradient theorem (Sutton et al. 2000). Both results are derived under the assumption that the goal is to learn options that maximize the expected return in the current task. However, if one wanted to add extra information to the objective function, this could readily be done so long as it comes in the form of an additive differentiable function.\nSuppose we aim to optimize directly the discounted return, expected over all the trajectories starting at a designated state s 0 and option \u03c9 0 , then: \u03c1(\u2126, \u03b8, \u03d1, s 0 , \u03c9\n0 ) = E \u2126,\u03b8,\u03c9 [ \u221e t=0 \u03b3 t r t+1 | s 0 , \u03c9 0 ].\nNote that this return depends on the policy over options, as well as the parameters of the option policies and termination functions. We will take gradients of this objective with respect to \u03b8 and \u03d1. In order to do this, we will manipulate equations similar to those used in intra-option learning (Sutton, Precup, and Singh 1999, section 8). Specifically, the definition of the option-value function can be written as:\nQ \u2126 (s, \u03c9) = a \u03c0 \u03c9,\u03b8 (a | s) Q U (s, \u03c9, a) ,(1)\nwhere Q U : S \u00d7 \u2126 \u00d7 A \u2192 R is the value of executing an action in the context of a state-option pair:\nQ U (s, \u03c9, a) = r(s, a) + \u03b3 s P (s | s, a) U (\u03c9, s ) . (2)\nNote that the (s, \u03c9) pairs lead to an augmented state space, cf. (Levy and Shimkin 2011). However, we will not work explicitly with this space; it is used only to simplify the derivation. The function U : \u2126 \u00d7 S \u2192 R is called the option-value function upon arrival, (Sutton, Precup, and Singh 1999, equation 20). The value of executing \u03c9 upon entering a state s is given by:\nU (\u03c9, s ) = (1 \u2212 \u03b2 \u03c9,\u03d1 (s ))Q \u2126 (s , \u03c9) + \u03b2 \u03c9,\u03d1 (s )V \u2126 (s ) (3)\nNote that Q U and U both depend on \u03b8 and \u03d1, but we do not include these in the notation for clarity. The last ingredient required to derive policy gradients is the Markov chain along which the performance measure is estimated. The natural approach is to consider the chain defined in the augmented state space, because state-option pairs now play the role of regular states in a usual Markov chain. If option \u03c9 t has been initiated or is executing at time t in state s t , then the probability of transitioning to (s t+1 , \u03c9 t+1 ) in one step is:\nP (s t+1 , \u03c9 t+1 | s t , \u03c9 t ) = a \u03c0 \u03c9t,\u03b8 (a | s t ) P(s t+1 | s t , a)( (1 \u2212 \u03b2 \u03c9t,\u03d1 (s t+1 ))1 \u03c9t=\u03c9t+1 + \u03b2 \u03c9t,\u03d1 (s t+1 )\u03c0 \u2126 (\u03c9 t+1 | s t+1 ))(4)\nClearly, the process given by ( 4) is homogeneous. Under mild conditions, and with options available everywhere, it is in fact ergodic, and a unique stationary distribution over state-option pairs exists.\nWe will now compute the gradient of the expected discounted return with respect to the parameters \u03b8 of the intra-option policies, assuming that they are stochastic and differentiable. From (1 , 2), it follows that:\n\u2202Q \u2126 (s, \u03c9) \u2202\u03b8 = a \u2202\u03c0 \u03c9,\u03b8 (a | s) \u2202\u03b8 Q U (s, \u03c9, a) + a \u03c0 \u03c9,\u03b8 (a | s) s \u03b3 P (s | s, a) \u2202U (\u03c9, s ) \u2202\u03b8 .\nWe can further expand the right hand side using ( 3) and ( 4), which yields the following theorem:\nTheorem 1 (Intra-Option Policy Gradient Theorem). Given a set of Markov options with stochastic intra-option policies differentiable in their parameters \u03b8, the gradient of the expected discounted return with respect to \u03b8 and initial condition (s 0 , \u03c9 0 ) is:\ns,\u03c9 \u00b5 \u2126 (s, \u03c9 | s 0 , \u03c9 0 ) a \u2202\u03c0 \u03c9,\u03b8 (a | s) \u2202\u03b8 Q U (s, \u03c9, a) ,\nwhere \u00b5 \u2126 (s, \u03c9 | s 0 , \u03c9 0 ) is a discounted weighting of stateoption pairs along trajectories starting from (s 0 , \u03c9 0 ):\n\u00b5 \u2126 (s, \u03c9 | s 0 , \u03c9 0 ) = \u221e t=0 \u03b3 t P (s t = s, \u03c9 t = \u03c9 | s 0 , \u03c9 0 ).\nThe proof is in the appendix. This gradient describes the effect of a local change at the primitive level on the global expected discounted return. In contrast, subgoal or pseudoreward methods assume the objective of an option is simply to optimize its own reward function, ignoring how a proposed change would propagate in the overall objective.\nWe now turn our attention to computing gradients for the termination functions, assumed this time to be stochastic and differentiable in \u03d1. From (1, 2, 3), we have:\n\u2202Q \u2126 (s, \u03c9) \u2202\u03d1 = a \u03c0 \u03c9,\u03b8 (a | s) s \u03b3 P (s | s, a) \u2202U (\u03c9, s ) \u2202\u03d1 .\nHence, the key quantity is the gradient of U . This is a natural consequence of the call-and-return execution, in which the \"goodness\" of termination functions can only be evaluated upon entering the next state. The relevant gradient can be further expanded as:\n\u2202U (\u03c9, s ) \u2202\u03d1 = \u2212 \u2202\u03b2 \u03c9,\u03d1 (s ) \u2202\u03d1 A \u2126 (s , \u03c9) + \u03b3 \u03c9 s P (s , \u03c9 | s , \u03c9) \u2202U (\u03c9 , s ) \u2202\u03d1 ,(5)\nwhere A \u2126 is the advantage function (Baird 1993) \nover options A \u2126 (s , \u03c9) = Q \u2126 (s , \u03c9) \u2212 V \u2126 (s ). Expanding \u2202U (\u03c9 ,s ) \u2202\u03d1\nrecursively leads to a similar form as in theorem (1) but where the weighting of state-option pairs is now according to a Markov chain shifted by one time step: \u00b5 \u2126 (s t+1 , \u03c9 t | s t , \u03c9 t\u22121 ) (details are in the appendix).\nTheorem 2 (Termination Gradient Theorem). Given a set of Markov options with stochastic termination functions differentiable in their parameters \u03d1, the gradient of the expected discounted return objective with respect to \u03d1 and the initial condition (s 1 , \u03c9 0 ) is:\n\u2212 s ,\u03c9 \u00b5 \u2126 (s , \u03c9 | s 1 , \u03c9 0 ) \u2202\u03b2 \u03c9,\u03d1 (s ) \u2202\u03d1 A \u2126 (s , \u03c9) ,\nwhere \u00b5 \u2126 (s , \u03c9 | s 1 , \u03c9 0 ) is a discounted weighting of state-option pairs from (s 1 , \u03c9 0 ):\n\u00b5 \u2126 (s, \u03c9 | s 1 , \u03c9 0 ) = \u221e t=0 \u03b3 t P (s t+1 = s, \u03c9 t = \u03c9 | s 1 , \u03c9 0 ).\nThe advantage function often appears in policy gradient methods (Sutton et al. 2000) when forming a baseline to reduce the variance in the gradient estimates. Its presence in that context has to do mostly with algorithm design. It is interesting that in our case, it follows as a direct consequence of the derivation and gives the theorem an intuitive interpretation: when the option choice is suboptimal with respect to the expected value over all options, the advantage function is negative and it drives the gradient corrections up, which increases the odds of terminating. After termination, the agent has the opportunity to pick a better option using \u03c0 \u2126 . A similar idea also underlies the interrupting execution model of options (Sutton, Precup, and Singh 1999) in which termination is forced whenever the value of Q \u2126 (s , \u03c9) for the current option \u03c9 is less than V \u2126 (s ). (Mann, Mankowitz, and Mannor 2014) recently studied interrupting options through the lens of an interrupting Bellman Operator in a valueiteration setting. The termination gradient theorem can be interpreted as providing a gradient-based interrupting Bellman operator. Based on theorems 1 and 2, we can now design a stochastic gradient descent algorithm for learning options. Using a two-timescale framework (Konda and Tsitsiklis 2000), we propose to learn the values at a fast timescale while updating the intra-option policies and termination functions at a slower rate.", "publication_ref": ["b23", "b11", "b0", "b23", "b24", "b13", "b6"], "figure_ref": [], "table_ref": []}, {"heading": "Algorithms and Architecture", "text": "We refer to the resulting system as an option-critic architecture, in reference to the actor-critic architectures (Sutton 1984). The intra-option policies, termination functions and policy over options belong to the actor part of the system while the critic consists of Q U and A \u2126 . The option-critic architecture does not prescribe how to obtain \u03c0 \u2126 since a variety of existing approaches would apply: using policy gradient methods at the SMDP level, with a planner over the options models, or using temporal difference updates. If \u03c0 \u2126 is the greedy policy over options, it follows from (2) that the corresponding one-step off-policy update target g\n(1) t is:\ng (1) t = r t+1 + \u03b3 (1 \u2212 \u03b2 \u03c9t,\u03d1 (s t+1 )) a \u03c0 \u03c9t,\u03b8 (a | s t+1 ) Q U (s t+1 , \u03c9 t , a) + \u03b2 \u03c9t,\u03d1 (s t+1 ) max \u03c9 a \u03c0 \u03c9,\u03b8 (a | s t+1 ) Q U (s t+1 , \u03c9, a) ,\nwhich is also the update target of the intra-option Q-learning algorithm of (Sutton, Precup, and Singh 1999). A prototypical implementation of option-critic which uses intra-option Q-learning is shown in Algorithm 1. The tabular setting is assumed only for clarity of presentation. We write \u03b1, \u03b1 \u03b8 and \u03b1 \u03d1 for the learning rates of the critic, intra-option policies and termination functions respectively.\nAlgorithm 1: Option-critic with tabular intra-option Qlearning s \u2190 s 0 Choose \u03c9 according to an -soft policy over options \u03c0 \u2126 (s) repeat\nChoose a according to \u03c0 \u03c9,\u03b8 (a | s) Take action a in s, observe s , r 1. Options evaluation:\n\u03b4 \u2190 r \u2212 Q U (s, \u03c9, a) if s is non-terminal then \u03b4 \u2190 \u03b4 + \u03b3(1 \u2212 \u03b2 \u03c9,\u03d1 (s ))Q \u2126 (s , \u03c9) + \u03b3\u03b2 \u03c9,\u03d1 (s ) max \u03c9 Q \u2126 (s ,\u03c9) end Q U (s, \u03c9, a) \u2190 Q U (s, \u03c9, a) + \u03b1\u03b4 2. Options improvement: \u03b8 \u2190 \u03b8 + \u03b1 \u03b8 \u2202 log \u03c0 \u03c9,\u03b8 (a | s) \u2202\u03b8 Q U (s, \u03c9, a) \u03d1 \u2190 \u03d1 \u2212 \u03b1 \u03d1 \u2202\u03b2 \u03c9,\u03d1 (s ) \u2202\u03d1 (Q \u2126 (s , \u03c9) \u2212 V \u2126 (s ))\nif \u03b2 \u03c9,\u03d1 terminates in s then choose new \u03c9 according to -soft(\u03c0 \u2126 (s )) s \u2190 s until s is terminal Learning Q U in addition to Q \u2126 is computationally wasteful both in terms of the number of parameters and samples. A practical solution is to only learn Q \u2126 and derive an estimate of Q U from it. Because Q U is an expectation over next\nstates, Q U (s, \u03c9, a) = E s \u223cP [r(s, a) + \u03b3U (\u03c9, s ) | s, \u03c9, a], it follows that g (1)\nt is an appropriate estimator. We chose this approach for our experiment with deep neural networks in the Arcade Learning Environment.", "publication_ref": ["b25", "b24"], "figure_ref": [], "table_ref": []}, {"heading": "Experiments", "text": "We first consider a navigation task in the four-rooms domain (Sutton, Precup, and Singh 1999). Our goal is to evaluate the ability of a set of options learned fully autonomously to recover from a sudden change in the environment. (Sutton, Precup, and Singh 1999) presented a similar experiment for a set of pre-specified options; the options in our results have not been specified a priori.\nInitially the goal is located in the east doorway and the initial state is drawn uniformly from all the other cells. After 1000 episodes, the goal moves to a random location in the lower right room. Primitive movements can fail with probability 1/3, in which case the agent transitions randomly to one of the empty adjacent cells. The discount factor was 0.99, and the reward was +1 at the goal and 0 otherwise. We chose to parametrize the intra-option policies with Boltzmann distributions and the terminations with sigmoid functions. The policy over options was learned using intra-option Q-learning. We also implemented primitive actor-critic (denoted AC-PG) using a Boltzmann policy. We also compared option-critic to a primitive SARSA agent using Boltzmann exploration and no eligibility traces. For all Boltzmann policies, we set the temperature parameter to 0.001. All the weights were initialized to zero. As can be seen in Figure 2, when the goal suddenly changes, the option-critic agent recovers faster. Furthermore, the initial set of options is learned from scratch at a rate comparable to primitive methods. Despite the simplicity of the domain, we are not aware of other methods which could have solved this task without incurring a cost much larger than when using primitive actions alone (McGovern and Barto 2001;\u015e im\u015fek and Barto 2009). Figure 3: Termination probabilities for the option-critic agent learning with 4 options. The darkest color represents the walls in the environment while lighter colors encode higher termination probabilities.\nIn the two temporally extended settings, with 4 options and 8 options, termination events are more likely to occur near the doorways (Figure 3), agreeing with the intuition that they would be good subgoals. As opposed to (Sutton, Precup, and Singh 1999), we did not encode this knowledge ourselves but simply let the agents find options that would maximize the expected discounted return. In the Pinball domain (Konidaris and Barto 2009), a ball must be guided through a maze of arbitrarily shaped polygons to a designated target location. The state space is continuous over the position and velocity of the ball in the xy plane. At every step, the agent must choose among five discrete primitive actions: move the ball faster or slower, in the vertical or horizontal direction, or take the null action. Collisions with obstacles are elastic and can be used to the advantage of the agent. In this domain, a drag coefficient of 0.995 effectively stops ball movements after a finite number of steps when the null action is chosen repeatedly. Each thrust action incurs a penalty of \u22125 while taking no action costs \u22121. The episode terminates with +10000 reward when the agent reaches the target. We interrupted any episode taking more than 10000 steps and set the discount factor to 0.99.", "publication_ref": ["b24", "b15", "b3", "b24", "b7"], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "Pinball Domain", "text": "We used intra-option Q-learning in the critic with linear function approximation over Fourier bases (Konidaris et al. 2011) of order 3. We experimented with 2, 3 or 4 options. We used Boltzmann policies for the intra-option policies and linear-sigmoid functions for the termination functions. The learning rates were set to 0.01 for the critic and 0.001 for both the intra and termination gradients. We used an epsilongreedy policy over options with = 0.01. In (Konidaris and Barto 2009), an option can only be used and updated after a gestation period of 10 episodes. As learning is fully integrated in option-critic, by 40 episodes a near optimal set of options had already been learned in all settings. From a qualitative point of view, the options exhibit temporal extension and specialization (fig. 4). We also observed that across many successful trajectories the red option would consistently be used in the vicinity of the goal.", "publication_ref": ["b8", "b7"], "figure_ref": ["fig_2"], "table_ref": []}, {"heading": "Arcade Learning Environment", "text": "We applied the option-critic architecture in the Arcade Learning Environment (ALE) (Bellemare et al. 2013) using a deep neural network to approximate the critic and represent the intra-option policies and termination functions. We used the same configuration as (Mnih et al. 2013) for the first 3 convolutional layers of the network. We used 32 convolutional filters of size 8\u00d78 and stride of 4 in the first layer, 64 filters of size 4 \u00d7 4 with a stride of 2 in the second and 64 3 \u00d7 3 filters with a stride of 1 in the third layer. We then fed the output of the third layer into a dense shared layer of 512 neurons, as depicted in Figure 6. We fixed the learning rate for the intra-option policies and termination gradient to 0.00025 and used RMSProp for the critic.  We represented the intra-option policies as linear-softmax of the fourth (dense) layer, so as to output a probability distribution over actions conditioned on the current observation. The termination functions were similarly defined using sigmoid functions, with one output neuron per termination.\nThe critic network was trained using intra-option Qlearning with experience replay. Option policies and terminations were updated on-line. We used an -greedy policy over options with = 0.05 during the test phase (Mnih et al. 2013).\nAs a consequence of optimizing for the return, the termination gradient tends to shrink options over time. This is expected since in theory primitive actions are sufficient for solving any MDP. We tackled this issue by adding a small \u03be = 0.01 term to the advantage function, used by the termination gradient: A \u2126 (s, \u03c9) + \u03be = Q \u2126 (s, \u03c9) \u2212 V \u2126 (s) + \u03be. This term has a regularization effect, by imposing an \u03be-margin between the value estimate of an option and that of the \"optimal\" one reflected in V \u2126 . This makes the advantage function positive if the value of an option is near the optimal one, thereby stretching it. A similar regularizer was proposed in (Mann, Mankowitz, and Mannor 2014).\nAs in (Mnih et al. 2016), we observed that the intra-option policies would quickly become deterministic. This problem seems to pertain to the use of policy gradient methods with deep neural networks in general, and not from option-critic itself. We applied the regularizer prescribed by (Mnih et al. 2016), by penalizing for low-entropy intra-option policies. Finally, the baseline Q \u2126 was added to the intra-option policy gradient estimator to reduce its variance. This change provided substantial improvements (Harb 2016) in the quality of the intra-option policy distributions and the overall agent performance as explained in Figure 7.\nWe evaluated option-critic in Asterisk, Ms. Pacman, Seaquest and Zaxxon. For comparison, we allowed the system to learn for the same number of episodes as (Mnih et al. 2013) and fixed the parameters to the same values in all four domains. Despite having more parameters to learn, optioncritic was capable of learning options that would achieve the goal in all games, from the ground up, within 200 episodes (Figure 8). In Asterisk, Seaquest and Zaxxon, option-critic surpassed the performance of the original DQN architecture based on primitive actions. The eight options learned in each game are learned fully end-to-end, in tandem with the feature representation, with no prior specification of a subgoal or pseudo-reward structure.\nThe solution found by option-critic was easy to interpret in the game of Seaquest when learning with only two options. We found that each option specialized in a behavior sequence which would include either the up or the down button. Figure 9 shows a typical transition from one option to the other, first going upward with option 0 then switching to option 1 downward. Options with a similar structure were also found in this game by (Krishnamurthy et al. 2016) using an option discovery algorithm based on graph partitioning.", "publication_ref": ["b1", "b17", "b17", "b13", "b18", "b18", "b5", "b17", "b9"], "figure_ref": ["fig_5", "fig_6"], "table_ref": []}, {"heading": "Related Work", "text": "As option discovery has received a lot of attention recently, we now discuss in more detail the place of our approach with respect to others. (Comanici and Precup 2010) used a gradient-based approach for improving only the termination function of semi-Markov options; termination was modeled by a logistic distribution over a cumulative measure of the features observed since initiation. (Levy and Shimkin 2011) also built on policy gradient methods by constructing explicitly the augmented state space and treating stopping events as additional control actions. In contrast, we do not need to construct this (very large) space directly. (Silver and Ciosek 2012) dynamically chained options into longer temporal sequences by relying on compositionality properties. Earlier work on linear options (Sorg and Singh 2010) also used compositionality to plan using linear expectation models for options. Our approach also relies on the Bellman equations and compositionality, but in conjunction with policy gradient methods.\nSeveral very recent papers also attempt to formulate option discovery as an optimization problem with solutions that are compatible with function approximation. (Daniel et al. 2016) learn return-optimizing options by treating the termination functions as hidden variables, and using EM to learn them. (Vezhnevets et al. 2016) consider the problem of learning options that have open-loop intra-option policies, also called macro-actions. As in classical planning, action sequences that are more frequent are cached. A mapping from states to action sequences is learned along with a commitment module, which triggers re-planning when necessary. In contrast, we use closed-loop policies throughout, which are reactive to state information and can provide better solutions. (Mankowitz, Mann, and Mannor 2016) propose a gradient-based option learning algorithm, assuming a particular structure for the initiation sets and termination functions. Under this framework, exactly one option is active in any partition of the state space. (Kulkarni et al. 2016)  shows a trajectory in the game, with \"white\" representing a segment during which option 1 was active and \"black\" for option 2.\nuse the DQN framework to implement a gradient-based option learner, which uses intrinsic rewards to learn the internal policies of options, and extrinsic rewards to learn the policy over options. As opposed to our framework, descriptions of the subgoals are given as inputs to the option learners. Option-critic is conceptually general and does not require intrinsic motivation for learning the options.", "publication_ref": ["b2", "b11", "b20", "b21", "b4", "b27", "b12", "b10"], "figure_ref": [], "table_ref": []}, {"heading": "Discussion", "text": "We developed a general gradient-based approach for learning simultaneously the intra-option policies and termination functions, as well as the policy over options, in order to optimize a performance objective for the task at hand. Our ALE experiments demonstrate successful end-to-end learning of options in the presence of nonlinear function approximation. As noted, our approach only requires specifying the number of options. However, if one wanted to use additional pseudo-rewards, the option-critic framework would easily accommodate it. In this case, the internal policies and termination function gradients would simply need to be taken with respect to the pseudo-rewards instead of the task reward. A simple instance of this idea, which we used in some of the experiments, is to use additional rewards to encourage options that are indeed temporally extended by adding a penalty whenever a switching event occurs. Our approach can work seamlessly with any other heuristic for biasing the set of options towards some desirable property (e.g. compositionality or sparsity), as long as it can be expressed as an additive reward structure. However, as seen in the results, such biasing is not necessary to produce good results. The option-critic architecture relies on the policy gradient theorem, and as discussed in (Thomas 2014), the gradient estimators can be biased in the discounted case. By introducing factors of the form \u03b3 t t i=1 (1 \u2212 \u03b2 i ) in our updates (Thomas 2014, eq (3)), it would be possible to obtain unbiased estimates. However, we do not recommend this approach since the sample complexity of the unbiased estimators is generally too high and the biased estimators performed well in our experiments.\nPerhaps the biggest remaining limitation of our work is the assumption that all options apply everywhere. In the case of function approximation, a natural extension to initiation sets is to use a classifier over features, or some other form of function approximation. As a result, determining which options are allowed may have similar cost to evaluating a policy over options (unlike in the tabular setting, where options with sparse initiation sets lead to faster decisions). This is akin to eligibility traces, which are more expensive than using no trace in the tabular case, but have the same complexity with function approximation. If initiation sets are to be learned, the main constraint that needs to be added is that the options and the policy over them lead to an ergodic chain in the augmented state-option space. This can be expressed as a flow condition that links initiation sets with terminations. The precise description of this condition, as well as sparsity regularization for initiation sets, is left for future work.\na \u03c0 \u03c9t (a| s t ) \u03b3 P(s t+1 | s t , a) (1 \u2212 \u03b2 \u03c9t (s t+1 ))1 \u03c9t=\u03c9t+1 + \u03b2 \u03c9t (s t+1 )\u03c0 \u2126 (\u03c9 t+1 | s t+1 ) .\nWhen conditioning the process from (s t , \u03c9 t\u22121 ), the discounted probability of transitioning to s t+1 , \u03c9 t is:\nP (1)\n\u03b3 (s t+1 , \u03c9 t | s t , \u03c9 t\u22121 ) = (1 \u2212 \u03b2 \u03c9t\u22121 (s t ))1 \u03c9t=\u03c9t\u22121 + \u03b2 \u03c9t\u22121 (s t )\u03c0 \u2126 (\u03c9 t | s t ) a \u03c0 \u03c9t (a | s t ) \u03b3 P (s t+1 | s t , a) .\nMore generally, the k-steps discounted probabilities can be expressed recursively as follows:\nP (k)\n\u03b3 (s t+k , \u03c9 t+k | s t , \u03c9 t ) = \nwhere ( 7) follows from the assumption that \u03b8 only appears in the intra-option policies. Substituting ( 7) into ( 6) yields a recursion which, using the previous remarks about augmented process can be transformed into: \u2202Q \u2126 (s, \u03c9) \u2202\u03b8 = ", "publication_ref": ["b26"], "figure_ref": [], "table_ref": []}, {"heading": "Proof of the Termination Gradient Theorem", "text": "The expected sum of discounted rewards starting from (s 1 , \u03c9 0 ) is given by:\nU (\u03c9 0 , s 1 ) = E \u221e t=1 \u03b3 t\u22121 r t s 1 , \u03c9 0 .\nWe start by expanding U as follows: U (\u03c9, s ) = (1 \u2212 \u03b2 \u03c9,\u03d1 (s ))Q \u2126 (s , \u03c9) + \u03b2 \u03c9,\u03d1 (s )V \u2126 (s )\n= (1 \u2212 \u03b2 \u03c9,\u03d1 (s )) \u00b5 \u2126 (s , \u03c9|s 1 , \u03c9 0 ) \u2202\u03b2 \u03c9,\u03d1 (s ) \u2202\u03d1 A \u2126 (s , \u03c9) .", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgements", "text": "The authors gratefully acknowledge financial support for this work by the National Science and Engineering Research Council of Canada (NSERC) and the Fonds de recherche du Quebec -Nature et Technologies (FRQNT).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Appendix Augmented Process", "text": "If \u03c9 t has been initiated or is executing at time t, then the discounted probability of transitioning to (s t+1 , \u03c9 t+1 ) is:\n\u03b3 (s t+1 , \u03c9 t+1 | s t , \u03c9 t ) =", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Advantage updating", "journal": "", "year": "1993", "authors": "L C Baird"}, {"ref_id": "b1", "title": "The arcade learning environment: An evaluation platform for general agents", "journal": "Journal of Artificial Intelligence Research", "year": "2013", "authors": "M G Bellemare; Y Naddaf; J Veness; M Bowling"}, {"ref_id": "b2", "title": "Optimal policy switching algorithms for reinforcement learning", "journal": "", "year": "2010", "authors": "G Comanici; D Precup"}, {"ref_id": "b3", "title": "Skill characterization based on betweenness", "journal": "", "year": "2009", "authors": "O \u015e Im\u015fek; A G Barto"}, {"ref_id": "b4", "title": "Probabilistic inference for determining options in reinforcement learning", "journal": "", "year": "2016", "authors": "C Daniel; H Van Hoof; J Peters; G Neumann"}, {"ref_id": "b5", "title": "Learning options in deep reinforcement learning. Master's thesis", "journal": "", "year": "2016", "authors": "J Harb"}, {"ref_id": "b6", "title": "Actor-critic algorithms", "journal": "", "year": "2000", "authors": "V R Konda; J N Tsitsiklis"}, {"ref_id": "b7", "title": "Skill discovery in continuous reinforcement learning domains using skill chaining", "journal": "", "year": "2009", "authors": "G Konidaris; A Barto"}, {"ref_id": "b8", "title": "Autonomous skill acquisition on a mobile manipulator", "journal": "", "year": "2011", "authors": "G Konidaris; S Kuindersma; R A Grupen; A G Barto"}, {"ref_id": "b9", "title": "Hierarchical reinforcement learning using spatio-temporal abstractions and deep neural networks", "journal": "", "year": "2016", "authors": "R Krishnamurthy; A S Lakshminarayanan; P Kumar; B Ravindran"}, {"ref_id": "b10", "title": "Hierarchical deep reinforcement learning: Integrating temporal abstraction and intrinsic motivation", "journal": "", "year": "2016", "authors": "T Kulkarni; K Narasimhan; A Saeedi; J Tenenbaum"}, {"ref_id": "b11", "title": "Unified inter and intra options learning using policy gradient methods", "journal": "", "year": "2011", "authors": "K Y Levy; N Shimkin"}, {"ref_id": "b12", "title": "Adaptive skills, adaptive partitions (ASAP)", "journal": "", "year": "2016", "authors": "D J Mankowitz; T A Mann; S Mannor"}, {"ref_id": "b13", "title": "Timeregularized interrupting options (TRIO)", "journal": "", "year": "2014", "authors": "T A Mann; D J Mankowitz; S Mannor"}, {"ref_id": "b14", "title": "Approximate value iteration with temporally extended actions", "journal": "Journal of Artificial Intelligence Research", "year": "2015", "authors": "T A Mann; S Mannor; D Precup"}, {"ref_id": "b15", "title": "Automatic discovery of subgoals in reinforcement learning using diverse density", "journal": "", "year": "2001", "authors": "A Mcgovern; A G Barto"}, {"ref_id": "b16", "title": "Q-cutdynamic discovery of sub-goals in reinforcement learning", "journal": "", "year": "2002", "authors": "I Menache; S Mannor; N Shimkin"}, {"ref_id": "b17", "title": "Playing atari with deep reinforcement learning", "journal": "", "year": "2013", "authors": "V Mnih; K Kavukcuoglu; D Silver; A Graves; I Antonoglou; D Wierstra; M A Riedmiller"}, {"ref_id": "b18", "title": "Asynchronous methods for deep reinforcement learning", "journal": "", "year": "2016", "authors": "V Mnih; A P Badia; M Mirza; A Graves; T P Lillicrap; T Harley; D Silver; K Kavukcuoglu"}, {"ref_id": "b19", "title": "Semantically Grounded Learning from Unstructured Demonstrations", "journal": "John Wiley & Sons, Inc", "year": "2000", "authors": "S Niekum"}, {"ref_id": "b20", "title": "Compositional planning using optimal option models", "journal": "", "year": "2012", "authors": "D Silver; K Ciosek"}, {"ref_id": "b21", "title": "Linear options. In AAMAS", "journal": "", "year": "2010", "authors": "J Sorg; S P Singh"}, {"ref_id": "b22", "title": "Learning options in reinforcement learning", "journal": "", "year": "2002", "authors": "M Stolle; D Precup"}, {"ref_id": "b23", "title": "Policy gradient methods for reinforcement learning with function approximation", "journal": "", "year": "2000", "authors": "R S Sutton; D A Mcallester; S P Singh; Y Mansour"}, {"ref_id": "b24", "title": "Between mdps and semi-mdps: A framework for temporal abstraction in reinforcement learning", "journal": "Artificial Intelligence", "year": "1999", "authors": "R S Sutton; D Precup; S P Singh"}, {"ref_id": "b25", "title": "Temporal Credit Assignment in Reinforcement Learning", "journal": "", "year": "1984", "authors": "R S Sutton"}, {"ref_id": "b26", "title": "Bias in natural actor-critic algorithms", "journal": "", "year": "2014", "authors": "P Thomas"}, {"ref_id": "b27", "title": "Strategic attentive writer for learning macro-actions", "journal": "", "year": "2016", "authors": "A S Vezhnevets; V Mnih; J Agapiou; S Osindero; A Graves; O Vinyals; K Kavukcuoglu"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 1 :1Figure 1: Diagram of the option-critic architecture. The option execution model is depicted by a switch \u22a5 over the contacts . A new option is selected according to \u03c0 \u2126 only when the current option terminates.", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 2 :2Figure2: After a 1000 episodes, the goal location in the fourrooms domain is moved randomly. Option-critic (\"OC\") recovers faster than the primitive actor-critic (\"AC-PG\") and SARSA(0). Each line is averaged over 350 runs.", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Figure 4 :4Figure 4: Pinball: Sample trajectory of the solution found after 250 episodes of training using 4 options All options (color-coded) are used by the policy over options in successful trajectories. The initial state is in the top left corner and the goal is in the bottom right one (red circle).", "figure_data": ""}, {"figure_label": "5", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Figure 5 :5Figure 5: Learning curves in the Pinball domain.", "figure_data": ""}, {"figure_label": "6", "figure_type": "figure", "figure_id": "fig_5", "figure_caption": "Figure 6 :6Figure 6: Deep neural network architecture. A concatenation of the last 4 images is fed through the convolutional layers, producing a dense representation shared across intra-option policies, termination functions and policy over options.", "figure_data": ""}, {"figure_label": "7", "figure_type": "figure", "figure_id": "fig_6", "figure_caption": "Figure 7 :7Figure 7: Seaquest: Using a baseline in the gradient estimators improves the distribution over actions in the intra-option policies, making them less deterministic. Each column represents one of the options learned in Seaquest. The vertical axis spans the 18 primitive actions of ALE. The empirical action frequencies are coded by intensity.", "figure_data": ""}, {"figure_label": "89", "figure_type": "figure", "figure_id": "fig_7", "figure_caption": "Figure 8 :Figure 9 :89Figure 8: Learning curves in the Arcade Learning Environment. The same set of parameters was used across all four games: 8 options, 0.01 termination regularization, 0.01 entropy regularization, and a baseline for the intra-option policy gradients.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_8", "figure_caption": "\u03b3 (s t+1 , \u03c9 t+1 | s t , \u03c9 t ) P (k\u22121) \u03b3 (s t+k , \u03c9 t+k | s t+1 , \u03c9 t+1 ) , P (k) \u03b3 (s t+k , \u03c9 t+k\u22121 | s t , \u03c9 t\u22121 ) = st+1 \u03c9t P (1) \u03b3 (s t+1 , \u03c9 t | s t , \u03c9 t\u22121 ) P (k\u22121) \u03b3 (s t+k , \u03c9 t+k\u22121 | s t+1 , \u03c9 t ) .Proof of the Intra-Option Policy Gradient TheoremTaking the gradient of the option-value function:\u2202Q \u2126 (s, \u03c9) \u2202\u03b8 = \u2202 \u2202\u03b8 a \u03c0 \u03c9,\u03b8 (a | s) Q U (s,\u03c9, a) = a \u2202\u03c0 \u03c9,\u03b8 (a|s) \u2202\u03b8 Q U (s, \u03c9, a)+ \u03c0 \u03c9,\u03b8 (a|s) \u2202Q U (s, \u03c9, a) \u2202\u03b8 = a \u2202\u03c0 \u03c9,\u03b8 (a | s) \u2202\u03b8 Q U (s, \u03c9, a)+ \u03c0 \u03c9,\u03b8 (a | s) s \u03b3 P (s | s, a) \u2202U (\u03c9, s ) \u2202\u03b8 , \u03b2 \u03c9,\u03d1 (s ))1 \u03c9 =\u03c9 + \u03b2 \u03c9,\u03d1 (s )\u03c0 \u2126 (\u03c9 | s ) \u2202Q \u2126 (s , \u03c9 ) \u2202\u03b8 .", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_9", "figure_caption": "a\u2202\u03c0 \u03c9,\u03b8 (a | s) \u2202\u03b8 Q U (s, \u03c9, a)+ a \u03c0 \u03c9,\u03b8 (a | s) s \u03b3 P (s | s, a) \u03c9 \u03b2 \u03c9,\u03d1 (s )\u03c0 \u2126 (\u03c9 | s ) + (1 \u2212 \u03b2 \u03c9,\u03d1 (s ))1 \u03c9 =\u03c9 \u2202Q \u2126 (s , \u03c9 ) \u2202\u03b8 \u03b3 (s , \u03c9 |s, \u03c9) a \u2202\u03c0 \u03c9 ,\u03b8 (a|s ) \u2202\u03b8 Q U (s , \u03c9 , a).The gradient of the expected discounted return with respect to \u03b8 is then:\u2202Q \u2126 (s 0 , \u03c9 0 ) \u2202\u03b8 = s, \u03c9|s 0 , \u03c9 0 ) a \u2202\u03c0 \u03c9,\u03b8 (a | s) \u2202\u03b8 Q U (s, \u03c9, a) .", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_10", "figure_caption": "s | s , a) U (\u03c9 , s ) .The gradient of U is then:\u2202U (\u03c9, s ) \u2202\u03d1 = \u2202\u03b2 \u03c9,\u03d1 (s ) \u2202\u03d1 (V \u2126 (s ) \u2212 Q \u2126 (s , \u03c9)) \u2212A\u2126(s ,\u03c9) + (1 \u2212 \u03b2 \u03c9,\u03d1 (s )) a \u03c0 \u03c9,\u03b8 (a|s ) s \u03b3 P (s |s , a) \u2202U (\u03c9, s ) \u2202\u03d1 .Using the structure of the augmented process:", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "V \u03c0 (s) = E \u03c0 [ \u221e t=0 \u03b3 t r t+1 | s 0 = s] and its action-value function as Q \u03c0 (s, a) = E \u03c0 [ \u221e t=0 \u03b3 t r t+1 | s 0 = s, a 0 = a],", "formula_coordinates": [1.0, 319.5, 636.39, 238.5, 26.5]}, {"formula_id": "formula_1", "formula_text": "s 0 : \u03c1(\u03b8, s 0 ) = E \u03c0 \u03b8 [ \u221e t=0 \u03b3 t r t+1 | s 0 ]. The policy gradient theorem shows that: \u2202\u03c1(\u03b8,s0) \u2202\u03b8 = s \u00b5 \u03c0 \u03b8 (s | s 0 ) a \u2202\u03c0 \u03b8 (a|s) \u2202\u03b8 Q \u03c0 \u03b8 (s, a), where \u00b5 \u03c0 \u03b8 (s | s 0 ) = \u221e t=0 \u03b3 t P (s t = s | s 0", "formula_coordinates": [2.0, 54.0, 166.6, 238.5, 49.65]}, {"formula_id": "formula_2", "formula_text": "0 ) = E \u2126,\u03b8,\u03c9 [ \u221e t=0 \u03b3 t r t+1 | s 0 , \u03c9 0 ].", "formula_coordinates": [2.0, 319.5, 166.53, 238.49, 23.16]}, {"formula_id": "formula_3", "formula_text": "Q \u2126 (s, \u03c9) = a \u03c0 \u03c9,\u03b8 (a | s) Q U (s, \u03c9, a) ,(1)", "formula_coordinates": [2.0, 354.09, 273.03, 203.91, 20.67]}, {"formula_id": "formula_4", "formula_text": "Q U (s, \u03c9, a) = r(s, a) + \u03b3 s P (s | s, a) U (\u03c9, s ) . (2)", "formula_coordinates": [2.0, 326.33, 333.67, 231.68, 21.11]}, {"formula_id": "formula_5", "formula_text": "U (\u03c9, s ) = (1 \u2212 \u03b2 \u03c9,\u03d1 (s ))Q \u2126 (s , \u03c9) + \u03b2 \u03c9,\u03d1 (s )V \u2126 (s ) (3)", "formula_coordinates": [2.0, 320.94, 447.49, 237.06, 10.71]}, {"formula_id": "formula_6", "formula_text": "P (s t+1 , \u03c9 t+1 | s t , \u03c9 t ) = a \u03c0 \u03c9t,\u03b8 (a | s t ) P(s t+1 | s t , a)( (1 \u2212 \u03b2 \u03c9t,\u03d1 (s t+1 ))1 \u03c9t=\u03c9t+1 + \u03b2 \u03c9t,\u03d1 (s t+1 )\u03c0 \u2126 (\u03c9 t+1 | s t+1 ))(4)", "formula_coordinates": [2.0, 319.58, 583.78, 238.43, 45.72]}, {"formula_id": "formula_7", "formula_text": "\u2202Q \u2126 (s, \u03c9) \u2202\u03b8 = a \u2202\u03c0 \u03c9,\u03b8 (a | s) \u2202\u03b8 Q U (s, \u03c9, a) + a \u03c0 \u03c9,\u03b8 (a | s) s \u03b3 P (s | s, a) \u2202U (\u03c9, s ) \u2202\u03b8 .", "formula_coordinates": [3.0, 55.67, 89.32, 236.36, 58.52]}, {"formula_id": "formula_8", "formula_text": "s,\u03c9 \u00b5 \u2126 (s, \u03c9 | s 0 , \u03c9 0 ) a \u2202\u03c0 \u03c9,\u03b8 (a | s) \u2202\u03b8 Q U (s, \u03c9, a) ,", "formula_coordinates": [3.0, 69.25, 246.37, 211.16, 27.41]}, {"formula_id": "formula_9", "formula_text": "\u00b5 \u2126 (s, \u03c9 | s 0 , \u03c9 0 ) = \u221e t=0 \u03b3 t P (s t = s, \u03c9 t = \u03c9 | s 0 , \u03c9 0 ).", "formula_coordinates": [3.0, 54.0, 303.41, 231.06, 14.5]}, {"formula_id": "formula_10", "formula_text": "\u2202Q \u2126 (s, \u03c9) \u2202\u03d1 = a \u03c0 \u03c9,\u03b8 (a | s) s \u03b3 P (s | s, a) \u2202U (\u03c9, s ) \u2202\u03d1 .", "formula_coordinates": [3.0, 55.2, 429.15, 237.46, 27.85]}, {"formula_id": "formula_11", "formula_text": "\u2202U (\u03c9, s ) \u2202\u03d1 = \u2212 \u2202\u03b2 \u03c9,\u03d1 (s ) \u2202\u03d1 A \u2126 (s , \u03c9) + \u03b3 \u03c9 s P (s , \u03c9 | s , \u03c9) \u2202U (\u03c9 , s ) \u2202\u03d1 ,(5)", "formula_coordinates": [3.0, 66.08, 537.4, 226.42, 52.9]}, {"formula_id": "formula_12", "formula_text": "over options A \u2126 (s , \u03c9) = Q \u2126 (s , \u03c9) \u2212 V \u2126 (s ). Expanding \u2202U (\u03c9 ,s ) \u2202\u03d1", "formula_coordinates": [3.0, 54.0, 599.29, 238.5, 36.72]}, {"formula_id": "formula_13", "formula_text": "\u2212 s ,\u03c9 \u00b5 \u2126 (s , \u03c9 | s 1 , \u03c9 0 ) \u2202\u03b2 \u03c9,\u03d1 (s ) \u2202\u03d1 A \u2126 (s , \u03c9) ,", "formula_coordinates": [3.0, 344.08, 84.78, 189.34, 27.85]}, {"formula_id": "formula_14", "formula_text": "\u00b5 \u2126 (s, \u03c9 | s 1 , \u03c9 0 ) = \u221e t=0 \u03b3 t P (s t+1 = s, \u03c9 t = \u03c9 | s 1 , \u03c9 0 ).", "formula_coordinates": [3.0, 330.02, 131.58, 227.98, 23.16]}, {"formula_id": "formula_15", "formula_text": "g (1) t = r t+1 + \u03b3 (1 \u2212 \u03b2 \u03c9t,\u03d1 (s t+1 )) a \u03c0 \u03c9t,\u03b8 (a | s t+1 ) Q U (s t+1 , \u03c9 t , a) + \u03b2 \u03c9t,\u03d1 (s t+1 ) max \u03c9 a \u03c0 \u03c9,\u03b8 (a | s t+1 ) Q U (s t+1 , \u03c9, a) ,", "formula_coordinates": [4.0, 56.55, 184.65, 233.4, 70.23]}, {"formula_id": "formula_16", "formula_text": "\u03b4 \u2190 r \u2212 Q U (s, \u03c9, a) if s is non-terminal then \u03b4 \u2190 \u03b4 + \u03b3(1 \u2212 \u03b2 \u03c9,\u03d1 (s ))Q \u2126 (s , \u03c9) + \u03b3\u03b2 \u03c9,\u03d1 (s ) max \u03c9 Q \u2126 (s ,\u03c9) end Q U (s, \u03c9, a) \u2190 Q U (s, \u03c9, a) + \u03b1\u03b4 2. Options improvement: \u03b8 \u2190 \u03b8 + \u03b1 \u03b8 \u2202 log \u03c0 \u03c9,\u03b8 (a | s) \u2202\u03b8 Q U (s, \u03c9, a) \u03d1 \u2190 \u03d1 \u2212 \u03b1 \u03d1 \u2202\u03b2 \u03c9,\u03d1 (s ) \u2202\u03d1 (Q \u2126 (s , \u03c9) \u2212 V \u2126 (s ))", "formula_coordinates": [4.0, 79.31, 464.5, 176.11, 123.81]}, {"formula_id": "formula_17", "formula_text": "states, Q U (s, \u03c9, a) = E s \u223cP [r(s, a) + \u03b3U (\u03c9, s ) | s, \u03c9, a], it follows that g (1)", "formula_coordinates": [4.0, 319.5, 56.49, 238.5, 23.85]}, {"formula_id": "formula_18", "formula_text": "a \u03c0 \u03c9t (a| s t ) \u03b3 P(s t+1 | s t , a) (1 \u2212 \u03b2 \u03c9t (s t+1 ))1 \u03c9t=\u03c9t+1 + \u03b2 \u03c9t (s t+1 )\u03c0 \u2126 (\u03c9 t+1 | s t+1 ) .", "formula_coordinates": [8.0, 54.0, 114.22, 239.63, 35.62]}, {"formula_id": "formula_19", "formula_text": "P (1)", "formula_coordinates": [8.0, 57.26, 182.43, 16.98, 12.07]}, {"formula_id": "formula_20", "formula_text": "P (k)", "formula_coordinates": [8.0, 55.66, 255.24, 17.41, 12.07]}, {"formula_id": "formula_22", "formula_text": "U (\u03c9 0 , s 1 ) = E \u221e t=1 \u03b3 t\u22121 r t s 1 , \u03c9 0 .", "formula_coordinates": [8.0, 359.22, 439.47, 159.06, 30.59]}], "doi": ""}