{"title": "Compilation of Aggregates in ASP", "authors": "Giuseppe Mazzotta", "pub_date": "", "abstract": "Answer Set Programming (ASP) is a well-known problem-solving formalism in computational logic. Nowadays, ASP is used in many real world scenarios thanks to ASP solvers. Standard evaluation of ASP programs suffers from an intrinsic limitation, knows as Grounding Bottleneck, due to the grounding of some rules that could fit all the available memory. As a result, there exist instances of real world problems that are untractable using the standard Ground & Solve approach. In order to tackle this problem, different strategies have been proposed. Among them we focus on a recent approach based on compilation of problematic constraints as propagators, which revealed to be very promising but is currently limited to constraints without aggregates. Since aggregates are widely used in ASP, in this paper we extend such an approach also to constraints containing aggregates. Good results, that proof the effectiveness of the proposed approach, have been reached.", "sections": [{"heading": "Introduction", "text": "Answer Set Programming (ASP) [6] is a well-known problem-solving formalism in computational logic that is based on the stable model semantics [18]. ASP systems, such as CLINGO [16] and DLV [1], made possible the development of many real-world applications. As a matter of fact, in the recent years, ASP has been widely used for solving problems of game theory [3], natural language processing [23], natural language understanding [11], robotics [15], scheduling [13], and more [14].\nA key role in the development of applications is played by system performances. Since ASP system are involved in many real world applications, efficient ASP systems are needed and then the improvement of those systems is an interesting research topic in computational logic.\nTraditional ASP systems are based on the ground & solve approach [19]. Stable model computation starts with, a grounder module that transforms the input program (containing variables) in its propositional counterpart by substituting variables with possible constants appearing in the program. Afterward, a solver module will compute the stable models for the grounded program implementing an extension of the Conflict Driven Clause Learning (CDCL) algorithm [19].\nAs observed in different contexts [8], the ground & solve approach suffers from an intrinsic limitation: the combinatorial blow-up of the grounding due to some rules, known as grounding bottleneck.\nIn particular, the grounding of these rules could consume all the available memory and then the solver module cannot compute stable models. As a result, there are many problems that are not tractable with the standard approach due to grounding bottleneck.\nIn order to tackle this problem different approaches have been proposed. One of these strategies is based on the lazy grounding of the rules during model computation. In this approach, the grounder and the solver are continuously working together in an iterative way. The idea behind lazy grounding is essentially to ground a rule only when its body is satisfied, then the instantiated rules will be added to the solver and then the model computation process restarts. Lazy grounding turns out to be very efficient in solving grounding bottleneck problem but obtain bad search performance. In order to improve the performance of lazy-grounding approach, the concept of laziness has been relaxed and different strategies have been proposed [25]. Recently, a different solution was proposed in order to solve this issue. The propsed approach is based on the compilation of problematic constraints as propagators [8,9]. Basically, Cuteri et al. [9] proposed to translate (or compile) some non-ground constraints into a dedicated C++ procedure in order to skip the grounding of these constraints and simulate them in the solver with this ad-hoc procedure. This approach reveals to be very promising but, unfortunately, is limited to simple constraints that does not contain aggregates. Since aggregates are widely used in ASP and their grounding could be very large, we decided to extend the benefits of the compilation based approach also to constraints that contain aggregates. At early stage of our research, we focused on the compilation of constraints containing count aggregates only and preliminary results were encouraging. Performances of the solver WASP [2] were improved on tested benchmarks. Then, we decided to push forward this idea and try to extend the compilation also to constraints with sum aggregates and also to simple rules.", "publication_ref": ["b5", "b17", "b15", "b0", "b2", "b22", "b10", "b14", "b12", "b13", "b18", "b18", "b7", "b24", "b7", "b8", "b8", "b1"], "figure_ref": [], "table_ref": []}, {"heading": "Background and Existing Solutions 2.1 Answer Set Programming", "text": "An ASP program \u03c0 is a set of rules of the form:\nh 1 | . . . | h n : \u2212b 1 , . . . , b m .\nwhere n + m > 0, h 1 | . . . |h n is a disjunction of atoms referred to as head, and b 1 , . . . , b m is a conjunction of literals referred to as body. If n = 0, then the rule is called constraint, whereas if m = 0 the rule is called fact.\nAn atom a is an expression of the form p(t 1 , . . . ,t k ) where p is a predicate of arity k and t 1 , . . . ,t k are terms. A term is an alphanumeric string that could be either a variable or a constant. According to Prolog notation, if a term starts with a capital letter is a variable otherwise is constant. If \u2200i \u2208 {1, . . . , k}, t i is a constant then the atom a is said ground. A literal is an atom a or its negation \u223c a where \u223c denotes the negation as failure. Given a literal l it is said positive if l = a, negative if l =\u223c a. Given a positive literal l = a, we define the complement, l =\u223c a, instead, for a negative literal l =\u223c a, l = \u223c a = a. ASP supports also aggregate atoms. An aggregate atom is of the form f (S) T , where f (S) is an aggregate function, \u2208 {=, <, \u2264, >, \u2265} is a predefined comparison operator, and T is a term referred to as guard. An aggregate function is of the form f (S), where S is a set term and f \u2208 {#count, #sum} is an aggregate function symbol. A set term S is a pair that is either a symbolic set or a ground set. A symbolic set is a pair {Terms : Conj}, where Terms is a list of variables and Conj is a conjunction of standard atoms, that is, Conj does not contain aggregate atoms. A ground set, instead, is a set of pairs of the form (t : conj), where t is a list of constants and conj is a conjunction of ground atoms. Given a program \u03c0 we define the positive dependency graph G \u03c0 =< V, E > as a directed graph where V = {p : p is a predicate term appearing in \u03c0} and E = {(u, v) : u \u2208 V, v \u2208 V and \u2203r \u2208 \u03c0 s.t. \u2203 a positive literal l and an atom a s.t. l is of the form u(t 1 , ...,t k ) and l appears in the body of r, and a is of the form v(t 1 , ...,t n ) and a appears in the head of r}. \u03c0 is said to be recursive if G \u03c0 is a cyclic graph. Given a program \u03c0, we define U \u03c0 , the Herbrand Universe, as the set of all constants appearing in \u03c0 and B \u03c0 , the Herbrand Base, as the set of all possible ground atoms that can be built using predicate in \u03c0 and constants in U \u03c0 . B denotes B \u03c0 \u222a B \u03c0 . Given a rule r and the Herbrand Universe U \u03c0 , we define ground(r) as the set of all possible instantiations of r that can be built by assigning variables in r to constant in U \u03c0 . Given a program \u03c0, instead, ground(\u03c0) = r\u2208\u03c0 ground(r). An interpretation I is a set of literals. In particular, I is total if \n\u2200a \u2208 B \u03c0 (a \u2208 I\u2228 \u223c a \u2208 I) \u2227 (a \u2208 I \u2192\u223c a / \u2208 I). A", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Example 2.1 Let A be an aggregate atom", "text": "A = #count{(1 : p(1, 1)), (2 : p(2, 1)), (3 : p(3, 1))} > 1 and let I = {p(1, 1), p(2, 1), \u223c p(3, 1)}. I(S) = [1, 2], I( f (S)) = 2 since f = #count so the aggregate atom A is true w.r.t. I. An interpretation I is a model for \u03c0 if \u2200 r \u2208 ground(\u03c0)(\u2200 l \u2208 body(r), l \u2208 I) \u2192 (\u2203a \u2208 head(r) : a \u2208 I).\nThe FLP-reduct of \u03c0, denoted by \u03c0 I , is the set of rules obtained from \u03c0 by deleting those rules whose body is false w.r.t I. Let I be a model for \u03c0, I is a stable model for \u03c0 if there is no I \u2282 I such that I is a model for \u03c0 I . Given a program \u03c0, \u03c0 is coherent if it admits at least one stable model otherwise is incoherent.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Existing Literature", "text": "In order to solve the grounding bottleneck problem, several attempts have been made [17], including language extensions (such as constraint programming [22,4], difference logic [16,24]) and lazy grounding techniques [12,20,26]. Hybrid formalisms are efficiently evaluated by coupling an ASP system with a solver for the other theory, thus circumventing the grounding bottleneck. Lazy grounding implementations instantiate a rule only when its body is satisfied to prevent the grounding of rules which are unnecessary during the search of an answer set. Albeit lazy grounding techniques obtained good preliminary results, their performance is still not competitive with state-of-the-art systems [17]. Lazy grounding has been also extended to support aggregates [5]. To the best of my knowledge, this normalization strategies is limited to monotone aggregates with a lower bound. This approach turns out to be very promising outperfoming the ground & and solve system CLINGO on benchmarks were the grounding is really hard.\nAnother existing approach is proposed by Cuteri et al. [8,9] and is based on the compilation of constraints into a dedicated procedure, called propagator, that supports the solver in the model computation process. There exists two different implementations of this approach, namely lazy and eager. In more details, given an ASP program P and a set of constraint C such that C \u2286 P, if the program P \\ C is unsatisfiable then the original program is also unsatisfiable. Otherwise, if P \\ C admits at least one model I and constraints in C are satisfied w.r.t. I, then I is a model for the original program. Starting from this description the lazy implementation build a procedure that automatically understands if a candidate model I satisfies constraints in C. If some of these constraints are not satisfied then they will be lazily instantiated in the solver and the model computations starts again, otherwise the process stops returning the model I. The eager implementation is based on a different approach. Indeed, in this case the propagator procedure is completely involved in the model computation process. Every time that the solver assign a truth value to a literal, either true or false, the propagator is notified and it simulates the instantiation of the constraints in C without storing it in memory, and if it is possible it makes some inferences on the truth values of the literals that have not been assigned yet, in order to prevent constraints failure. Results obtained with this compilation-based approach are very promising but currently the eager approach supports only simple constraints without aggregates. ", "publication_ref": ["b16", "b21", "b3", "b15", "b23", "b11", "b19", "b25", "b16", "b4", "b7", "b8"], "figure_ref": [], "table_ref": []}, {"heading": "Research Goal", "text": "Approaches based on compilation of constraints revealed to be very promising, outperforming traditional systems in many comparisons. However, a significant number of problems, especially hard combinatorial problems from ASP competitions feature aggregates that are not yet supported by compilation-based approaches. Aggregates are among the standardized knowledge modeling constructs that make ASP effective in representing complex problems. So, the extension of the existing compilation approach is an interesting research topic in order to extend the benefits of the compilation to all those ASP programs that cannot be solved by traditional approached. For this reason, we decided to tackle this problem starting from the compilation of constraints containing aggregates. In particular, a first attempt has been proposed in the paper [21]. In particular, we presented an extension of the eager compilation for constraints containing #count aggregates and promising results have been obtained. The next natural step is to extend the compilation approach also to #sum aggregate. Moreover, we also consider to extend the compilation approach also to rules, whereas now it is limited to constraints.\nTherefore, our research goals are as follows:\n\u2022 Extend the eager compilation approach also to #sum aggregates.\n\u2022 Support the eager compilation of rules without recursion.\n\u2022 Support the eager compilation of simple programs containing recursive rules.\n\u2022 Support, also, the compilation of disjunctive and choice rules in order to provide a complete compilation of ASP program, providing a novel approach to compute stable models of an ASP program.\nIn principle it can be also combined with the lazy normalization [5]. However this would not be a trivial combination and might be subject of future research once the compilation approach will be extended to a larger class of programs.", "publication_ref": ["b20", "b4"], "figure_ref": [], "table_ref": []}, {"heading": "Current Research Status", "text": "Up to now we have extended the compilation to constraints containing #count aggregates. Moreover, we currently have a preliminary implementation of a technique that is able to compile constraints containing also #sum aggregates, whose performance is still not satisfactory. It turns out that compiling #sum aggregates requires several additional optimization techniques and dedicated data structures.\nIn order to show the working principles of our approach in presence of #count aggregates, we present the following example. Example 4.1 Let : \u2212a(X, Z), c(Z), #count{Y : b(X,Y )} >= 2 be a constraint, then there are several possible propagation steps that can be done. Note that a propagation step is done to avoid possible violations of the constraint.\n\u2022 Aggregate propagation. Let I = {a(1, 1), c(1)} be an interpretation and assume that the solver assigns b(1, 1) to true. Starting from b(1, 1) it is possible to propagate all the undefined values of the form b(1, ) to false, since if b(1, 2) becomes true the count returns 2 that is greater than or equal to 2 and thus the constraint is violated.\n\u2022 Body literal propagation. Let I = {b(1, 1), b(1, 2)} be an interpretation and assume that the solver assigns a(1, 1) to true. Note that I satisfies the aggregate, therefore starting from a(1, 1) it is possible to propagate c(1) to false because if c(1) becomes true then the constraint is violated.\nIn general, the propagator starts building all possible instantiations of the constraint and looks for undefined values that could be propagated. If there is a constraint instantiation such that each body literal is true, then we have to check if the count has reached the aggregate's guard minus one. In this case, we can propagate the aggregate body to false. Note that in this simple case we can just propagate undefined values of b but if the aggregate body is more complex propagation is not so simple. Since literals in the aggregate are in conjunction, in order to propagate a conjunction as false we need only one literal false and then for each possible conjunction we can propagate the last undefined literal of that conjunction.\nOn the other hand, if there is a constraint instantiation such that exactly one literal is undefined and the aggregate is true then the undefined literal could be propagated as false. So, the propagator procedure is a complex and custom procedure that stores partial interpretation and implements optimized join techniques in order to build constraint instantiation.\nIn Algorithm 1, we report a simplified pseudo code propagator for the constraint described in the example. In particular, here we focus only on one propagation case. The complete propagator is based on several procedures, one for every literal in the body of the constraint or in the aggregate body, whose algorithms are similar to Algorithm 1.\nNotation In ordered to better understand Algorithm 1 lets introduce some utility functions. Let l be a ground literal of the form a(1, 2) we define:\n\u2022 getPredicateName() returns the predicate name of l, e.g., \"a\"\n\u2022 getTermAt(integer i) return the i-th term of l, e.g., l.getTermAt(0) return 1\nThe goal of the proposed procedure is to simulate the grounding of the constraint after a literal becomes true. In particular, assume that a(1, 2) becomes true, then the procedure is invoked passing a(1, 2). So X will be assigned to 1 and Z to 2 (lines 2 and 3, respectively). Afterward, true and undefined values of c matching Z are searched. If the procedure finds a true value of c matching Z then it evaluates the aggregate propagation. If the aggregate is also true then a conflict is found. Otherwise, if the aggregate's guard -1 has been reached the procedure makes a propagation to ensure that the aggregate is made false. On the other hand, if the procedure finds an undefined value of c, then it can be propagated as false only when the aggregates is true. Implementation. We started from the baseline system presented in [10]. The approach has been extended to support the compilation of the propagation of aggregates. In particular, the compiler has been implemented in C++, and its output, that is the propagator procedure itself, is also C++ code compliant to the WASP propagator interface, and is loaded in the ASP solver as a C++ dynamic library. The source code is not available yet, since we are in a development stage and we are working on a more robust and stable version.\nExperimental Settings. We carried our an experimental evaluation to empirically assessed the performance gain of the proposed approach w.r.t. the base solver WASP. Namely, we considered two hard benchmarks of the ASP competitions [7], namely Combined Configuration and Abstract Dialectical Frameworks, featuring some constraints containing #count aggregates.\nIn Combined Configuration, the problem is to configure an artifact by combining several components in order to achieve some goals; whereas in Abstract Dialectical Frameworks the problem is to find all statements which are necessarily accepted or rejected in a given abstract argumentation framework. In both benchmarks we compile all constraints with aggregates supported by our implementation (i.e., constraints with exactly one #count aggregate). The experiments were run on an Intel Xeon CPU E7-8880 v4 2.20GHz, time and memory were limited to 10 minutes and 4 GB, respectively.\nResults. The results are presented in Figure 3a and Figure 3b as two cactus plots. Overall, our approach is able to boost the performance of WASP, with the result of obtaining smaller execution times, on average, and more solved instances (3 more instances for Combined Configuration and 7 more for Abstract Dialectical Frameworks). The results are very promising, also considering the fact that the benchmarks in the ASP competitions are more oriented towards the evaluation of solving techniques.", "publication_ref": ["b9", "b6"], "figure_ref": ["fig_4", "fig_4"], "table_ref": []}, {"heading": "Conclusion", "text": "In this paper we provided an overview of new strategies to deal with grounding bottleneck in presence of aggregates. Our research is currently focused on compilation based approach, in particular, on eager compilation of problematic constraints possibly containing #count aggregates. Obtained results were very promising and the extension of this approach to cover other aggregates and rules might lead to an improved of the performance of existing ASP solvers. In particular, we are currently able to compile only simple constraints and also constraint with aggregates but our goal is to move towards the compilation of general rules. A first attempt has been made together with a rewriter that uses rules to rewrite aggregates, but we are in development stage and no experimental analysis has been conducted yet. The crucial point of the overall work is how to generate procedures that have to be smart enough to save as much space as possible, in order to avoid grounding bottleneck, but at the same time they have to be also time efficient. We plan to extend the experimental analysis in order to include different benchmarks and to ensure that our approach is able to solve programs that are currently not solvable by state-ofthe-art solvers. Moreover, we also plan to evaluate the impact of our techniques also on problems that are not affected by grounding bottleneck, in order to estimate the overhead of our approach also in this case. Such analysis might lead to a better understanding of the solving procedure and it can lead to the  implementation of (automated) systems that are able to reason, in some way, about the sub-program to compile and afterward create a procedure that is strictly customized on that sub-program.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "The ASP System DLV2. In: LPNMR, LNCS 10377", "journal": "Springer", "year": "2017", "authors": "Mario Alviano; Francesco Calimeri; Carmine Dodaro; Davide Fusc\u00e0; Nicola Leone; Simona Perri; Francesco Ricca; Pierfrancesco Veltri; Jessica Zangari"}, {"ref_id": "b1", "title": "Advances in WASP. In: LPNMR, LNCS 9345", "journal": "Springer", "year": "2015", "authors": "Mario Alviano; Carmine Dodaro; Nicola Leone & Francesco; Ricca "}, {"ref_id": "b2", "title": "Modeling and Reasoning about NTU Games via Answer Set Programming", "journal": "", "year": "2016", "authors": "Giovanni Amendola; Gianluigi Greco; Nicola Leone & Pierfrancesco;  Veltri"}, {"ref_id": "b3", "title": "Constraint answer set solver EZCSP and why integration schemas matter", "journal": "TPLP", "year": "2017", "authors": "Marcello Balduccini & Yuliya;  Lierler"}, {"ref_id": "b4", "title": "Enhancing Lazy Grounding with Lazy Normalization in Answer-Set Programming", "journal": "AAAI Press", "year": "2019-01-27", "authors": ""}, {"ref_id": "b5", "title": "Answer set programming at a glance", "journal": "Commun. ACM", "year": "2011", "authors": "Gerhard Brewka; Thomas Eiter & Miroslaw;  Truszczynski"}, {"ref_id": "b6", "title": "Design and results of the Fifth Answer Set Programming Competition", "journal": "Artif. Intell", "year": "2016", "authors": "Francesco Calimeri; Martin Gebser; Marco Maratea & Francesco; Ricca "}, {"ref_id": "b7", "title": "Constraints, lazy constraints, or propagators in ASP solving: An empirical analysis", "journal": "TPLP", "year": "2017", "authors": "Bernardo Cuteri; Carmine Dodaro; Francesco Ricca & Peter;  Sch\u00fcller"}, {"ref_id": "b8", "title": "", "journal": "Partial Compilation of ASP Programs. TPLP", "year": "2019", "authors": "Bernardo Cuteri; Carmine Dodaro; Francesco Ricca & Peter;  Sch\u00fcller"}, {"ref_id": "b9", "title": "Overcoming the Grounding Bottleneck Due to Constraints in ASP Solving: Constraints Become Propagators", "journal": "", "year": "2020", "authors": "Bernardo Cuteri; Carmine Dodaro; Francesco Ricca & Peter;  Sch\u00fcller"}, {"ref_id": "b10", "title": "A Logic-Based Question Answering System for Cultural Heritage", "journal": "JELIA", "year": "2019", "authors": "Bernardo Cuteri; Kristian Reale & Francesco; Ricca "}, {"ref_id": "b11", "title": "GASP: Answer Set Programming with Lazy Grounding", "journal": "Fundam. Inform", "year": "2009", "authors": "Alessandro Dal Pal\u00f9; Agostino Dovier; Enrico Pontelli & Gianfranco;  Rossi"}, {"ref_id": "b12", "title": "Nurse Scheduling via Answer Set Programming", "journal": "Springer", "year": "2017", "authors": "Carmine Dodaro; & Marco Maratea"}, {"ref_id": "b13", "title": "Applications of Answer Set Programming", "journal": "", "year": "2016", "authors": "Esra Erdem; Michael Gelfond; & Nicola Leone"}, {"ref_id": "b14", "title": "Applications of ASP in Robotics. KI", "journal": "", "year": "2018", "authors": ""}, {"ref_id": "b15", "title": "Theory Solving Made Easy with Clingo 5", "journal": "Torsten Schaub & Philipp Wanko", "year": "2016", "authors": "Martin Gebser; Roland Kaminski; Benjamin Kaufmann; Max Ostrowski"}, {"ref_id": "b16", "title": "Evaluation Techniques and Systems for Answer Set Programming: a Survey", "journal": "Francesco Ricca & Torsten Schaub", "year": "2018", "authors": "Martin Gebser; Nicola Leone; Marco Maratea; Simona Perri"}, {"ref_id": "b17", "title": "Classical Negation in Logic Programs and Disjunctive Databases", "journal": "New Generation Comput", "year": "1991", "authors": "Michael Gelfond; & Vladimir Lifschitz"}, {"ref_id": "b18", "title": "Grounding and Solving in Answer Set Programming", "journal": "AI Magazine", "year": "2016", "authors": "Benjamin Kaufmann; Nicola Leone; Simona Perri & Torsten;  Schaub"}, {"ref_id": "b19", "title": "The First Version of a New ASP Solver: ASPeRiX", "journal": "Springer", "year": "2009", "authors": ""}, {"ref_id": "b20", "title": "Compilation of Aggregates in ASP: Preliminary Results", "journal": "", "year": "2020-10-13", "authors": "Giuseppe Mazzotta; Bernardo Cuteri; Carmine Dodaro & Francesco; Ricca "}, {"ref_id": "b21", "title": "ASP modulo CSP: The clingcon system", "journal": "TPLP", "year": "2012", "authors": ""}, {"ref_id": "b22", "title": "Modeling Variations of First-Order Horn Abduction in Answer Set Programming", "journal": "Fundam. Inform", "year": "2016", "authors": "Peter Sch\u00fcller"}, {"ref_id": "b23", "title": "SMT-Based Constraint Answer Set Solver EZSMT (System Description", "journal": "", "year": "2016", "authors": "Benjamin Susman; & Yuliya Lierler"}, {"ref_id": "b24", "title": "Degrees of Laziness in Grounding -Effects of Lazy-Grounding Strategies on ASP Solving", "journal": "Springer", "year": "2019-06-03", "authors": ""}, {"ref_id": "b25", "title": "Blending Lazy-Grounding and CDNL Search for Answer-Set Solving", "journal": "LP-NMR", "year": "2017", "authors": "Antonius Weinzierl"}], "figures": [{"figure_label": "", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "literal l is true w.r.t I if l \u2208 I, otherwise it is false. A ground conjunction conj of atoms is true w.r.t I if all atoms in conj are true, otherwise, if at least one atom is false then conj is false w.r.t. I. Let I(S) denote the multiset [t 1 |(t 1 , . . . ,t n ) : conj \u2208 S \u2227 conj is true w.r.t. I]. The evaluation I( f (S)) of an aggregate function f (S) w.r.t. I is the result of the application of f on I(S).", "figure_data": ""}, {"figure_label": "12", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 1 :Figure 2 :12Figure 1: Solving using Ground & Solve approach", "figure_data": ""}, {"figure_label": "127", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Algorithm 1 2 X 7 if127Example of propagator for one literal. Input : A literal l of the form a(X, Z). Output: List of propagated literals. 1 if l.getPredicateName() == \"a\" then tupleU == \u22a5 then 8 tuplesUC = undefinedLiteralsC.getValuesMatching(Z) 9 foreach tupleC \u2208 tuplesC \u222a tuplesUC do 10 if tupleC \u2208 tuplesUC then 11 tupleU = tupleC 12 if tupleU == \u22a5 then 13 tuplesB = trueLiteralsB.getValuesMatching(X) 14 if tuplesB.size() \u2265 2 then 15 conflict detected on propagator 16 else if tuplesB.size() == 1 then 17 foreach undefinedb \u2208 undefinedLiteralsB.getValuesMatching(X)", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Abstract dialectical frameworks.", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "Figure 3 :3Figure 3: Preliminary experimental results on two hard benchmarks taken from ASP competition.", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "h 1 | . . . | h n : \u2212b 1 , . . . , b m .", "formula_coordinates": [2.0, 252.26, 339.58, 107.49, 10.81]}, {"formula_id": "formula_1", "formula_text": "\u2200a \u2208 B \u03c0 (a \u2208 I\u2228 \u223c a \u2208 I) \u2227 (a \u2208 I \u2192\u223c a / \u2208 I). A", "formula_coordinates": [3.0, 79.23, 74.37, 216.68, 10.98]}, {"formula_id": "formula_2", "formula_text": "A = #count{(1 : p(1, 1)), (2 : p(2, 1)), (3 : p(3, 1))} > 1 and let I = {p(1, 1), p(2, 1), \u223c p(3, 1)}. I(S) = [1, 2], I( f (S)) = 2 since f = #count so the aggregate atom A is true w.r.t. I. An interpretation I is a model for \u03c0 if \u2200 r \u2208 ground(\u03c0)(\u2200 l \u2208 body(r), l \u2208 I) \u2192 (\u2203a \u2208 head(r) : a \u2208 I).", "formula_coordinates": [3.0, 79.23, 161.72, 453.55, 67.95]}], "doi": "10.4204/EPTCS.345.45"}