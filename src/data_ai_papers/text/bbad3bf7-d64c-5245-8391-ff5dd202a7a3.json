{"title": "Loop Formulas for Circumscription", "authors": "Joohyung Lee; Fangzhen Lin", "pub_date": "", "abstract": "Clark's completion is a simple nonmonotonic formalism and a special case of many nonmonotonic logics. Recently there has been work on extending completion with \"loop formulas\" so that general cases of nonmonotonic logics such as logic programs (under the answer set semantics) and McCain-Turner causal logic can be characterized by propositional logic in the form of \"completion + loop formulas\". In this paper, we show that the idea is applicable to McCarthy's circumscription in the propositional case. We also show how to embed propositional circumscription in logic programs and in causal logic, inspired by the uniform characterization of \"completion + loop formulas\".", "sections": [{"heading": "Introduction", "text": "Clark's predicate completion (Clark 1978) is a simple and intuitive nonmonotonic formalism. Normally it is applicable when the knowledge base is given as a set of rules, and works when the rules do not yield a cycle.\nDespite these limitations, surprisingly perhaps, predicate completion has been used to solve some problems that were thought to require more sophisticated nonmonotonic logics. For instance, Reiter (1991) showed that under certain reasonable assumptions, successor state axioms can be computed from action effect axioms by predicate completion, and thus solved the frame problem when there are no state constraints. For state constraints, Lin (1995) argued that they should be encoded using a notion of causality, and once they are encoded this way, successor state axioms can once again be computed using predicate completion for a class of causal rules that includes almost all of the benchmark planning domains (Lin 1995;2003). The implementation of the fragment of McCain and Turner causal logic (McCain & Turner 1997) in the Causal Calculator (CCALC) 1 is also based on completion; CCALC has been successfully applied to several challenge problems in the theory of commonsense knowledge.\nIn logic programming where predicate completion is best known and commonly referred to as program completion semantics, its relationships with other semantics, especially the answer set semantics (also known as the stable model semantics) of Gelfond and Lifschitz (1988), have been studied quite extensively. First of all, it is well known that an answer set for a normal (non-disjunctive) logic program is also a model of its completion, while the converse, generally, does not hold. Fages (1994) showed that a certain syntactic condition, which is now called \"tightness,\" is sufficient for establishing the equivalence between them. Erdem and Lifschitz (2003) generalized Fages' theorem and extended it to programs with nested expressions (in the sense of (Lifschitz, Tang, & Turner 1999)) in the bodies of rules.\nInstead of looking for conditions that will guarantee the equivalence between the completion semantics and the answer set semantics, Lin and Zhao (2002) considered how to strengthen completion to make it equivalent to the answer set semantics. The idea is that, since cycles are what cause the mismatch between the models of the completion and the answer sets for a program, one should address the problems raised by them directly. Just like the completion semantics captures the intuition that for a predicate to be true, one of the bodies of the rules with the predicate as the head must be true, for each loop, Lin and Zhao associated with it a loop formula that captures the intuition that for the atoms in the loop to be true, there must be a rule whose head is in the loop, and whose body is true but its positive part does not have any atom in the loop. They showed that an interpretation is an answer set for a logic program iff it satisfies the completion and all loop formulas of the program. SAT-based answer set solvers ASSAT (Lin & Zhao 2002) and CMODELS-2 (Giunchiglia, Lierler, & Maratea 2004) are based on this idea.\nAs it turned out, program completion and loop formulas are not limited to non-disjunctive logic programs. Lee and Lifschitz (2003) extended the Lin/Zhao theorem to disjunctive logic programs and, more generally, to arbitrary programs with nested expressions. Lee (2004) showed that a similar result can be obtained for McCain and Turner causal logic and based on this, discussed the relationship between causal logic and logic programs.\nGiven these results, one wonders how far this idea of \"completion + loop formulas\" can go. Is it general enough to capture other nonmonotonic logics? In this paper, we answer this question positively for circumscription (McCarthy 1980;1986) in the propositional case.", "publication_ref": ["b0", "b21", "b14", "b14", "b16", "b17", "b4", "b3", "b2", "b9", "b13", "b13", "b6", "b7", "b8", "b18", "b19"], "figure_ref": [], "table_ref": []}, {"heading": "Logical Preliminaries", "text": "A literal is a (propositional) atom or the negation of an atom. A (propositional) formula is formed from literals using propositional connectives. A clause is a finite set of literals. We identify a clause C with the disjunction of its elements. It is well known that any formula can be transformed into an equivalent set of clauses. Given a set X of literals, X is the set of literals complementary to literals in X. In the following, given a language L, we identify an interpretation of L with a set of atoms in L.\nWe assume some variables ranging over 0-place connectives ( , \u22a5), and quantify over them. For instance, we write \u2200z(z \u2228 p), where p is an atom, to denote ( \u2228 p) \u2227 (\u22a5 \u2228 p), and similarly \u2203z(z \u2228 p) to denote ( \u2228 p) \u2228 (\u22a5 \u2228 p).\nIn the following, we sometimes write a formula A as A(P ) or A(P, Q) for tuples P and Q of atoms. This way, when z is a tuple of variables and atoms of the same length as P , we use A(z) or A(z, Q) to denote the result of simultaneously replacing each element of P in A by the corresponding element of z. In this notation we sometimes allow a set in place of a tuple when there is no confusion. On the other hand, for convenience, we sometimes treat a tuple as the corresponding set.\nFor P = (P 1 , ...P n ), Q = (Q 1 , ...Q n ), P \u2264 Q stands for 1\u2264i\u2264n (P i \u2283 Q i ), P = Q stands for 1\u2264i\u2264n (P i \u2261 Q i ), P < Q stands for (P \u2264 Q) \u2227 \u00ac(P = Q).\nLet P and Z be tuples of atoms, and A(P, Z) a formula. The circumscription of P in A(P, Z) with atoms in Z allowed to vary, is the following formula: A(P, Z) \u2227 \u00ac\u2203pz(A(p, z) \u2227 p < P ).\n(\n)1\nThe formula is denoted by CIRC[A(P, Z); P ; Z], which may also be written as CIRC[A(P ); P ] when Z is empty.\nThe following is a model-theoretic account of circumscription. For two interpretations I, J of the same signature, we write I \u2264 P ;Z J 2 if \u2022 I and J agree on all atoms that are not in P and Z, and \u2022 for each P i \u2208 P , if P i \u2208 I then P i \u2208 J.\nWe write I < P ;Z J if I \u2264 P ;Z J but not J \u2264 P ;Z I.\nAn interpretation I is a model of (1) iff it is minimal on P with Z allowed to vary, that is,\n\u2022 I is a model of A(P, Z), and \u2022 there is no model J of A(P, Z) such that J < P ;Z I.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Positive Dependency Graphs and Loops", "text": "A clause like p \u2228 q \u2228 \u00acr can be rewritten as (r \u2227 \u00acq) \u2283 p or (r \u2227 \u00acp) \u2283 q. So if one wants to count ways an atom can be derived, this clause needs to be counted for both p and q. In general, if a clause C contains an atom p, then \u00ac(C \\ {p}) 3 implies p. This motivates the following definition of a (positive) dependency graph of a set of clauses. 2 We may even write I \u2264 P J when Z is empty. 3 \u00ac(C \\{p}) is equal to V l\u2208C\\{p} l according to our convention of identifying a clause with the disjunction of its literals. The dependency graph of A 1 (P ) on P Definition 1 The (positive) dependency graph of a set A of clauses on a set P of atoms is the directed graph G such that \u2022 the vertices of G are the atoms in P , and \u2022 for each clause C in A, G has an edge from each atom in C \u2229 P to each atom in C \u2229 P .\nA nonempty set L of atoms is called a loop of A on P if, for every pair p, p of atoms in L, there exists a path of nonzero length from p to p in the dependency graph of A on P such that all the vertices in this path belong to L.\nFor example, let P = (p, q, r, s), and let A 1 (P ) be the set of clauses: {p \u2228 \u00acq, \u00acp \u2228 q, r \u2228 \u00acs, \u00acr \u2228 s, p \u2228 r}. The dependency graph of A 1 (P ) on P , shown in Figure 1, has two loops: {p, q}, {r, s}. Definition 2 Given a formula A, if B is a finite set of clauses that is logically equivalent to A, then the dependency graph of B on P is called the dependency graph of A on P under B. Similarly, loops of B on P are called loops of A on P under B.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Computing Propositional Circumscription", "text": "We begin with the simple case when there are no constants (atoms) allowed to vary.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Fixed Constants", "text": "For any formula A and any tuple P of atoms, we denote by A(P ) the result of replacing every atom of P in A by \u22a5. The following proposition follows from the definition of circumscription straightforwardly: Proposition 1 CIRC[A(P ); P ] is equivalent to the conjunction of A(P ) and\nK \u2283 \u00acA(K)(2)\nfor each nonempty subset K of P , where K stands for the conjunction of all elements in K.\nIn fact, including all subsets of P is unnecessary. We will now discuss how Proposition 1 can be improved. As mentioned above, a clause C that contains an atom p is equivalent to \u00ac(C \\ {p}) \u2283 p. More generally, by Theorem 2 of (Lin 2001), for any formula A and any atom p, A |= \u00acA(p) \u2283 p. Furthermore, \u00acA(p) is the weakest such condition in the sense that for any other formula B that does not mention p, if A |= B \u2283 p, then A |= B \u2283 \u00acA(p). In other words, \u00acA(p) is the weakest sufficient condition for p in A. Now to form the completion of p, one just makes the weakest sufficient condition also its necessary condition. Definition 3 The completion of a formula A(P ) on P is the theory formed by taking the union of A(P ) and the set consisting of the formulas p \u2283 \u00acA(p)\n(3)\nfor each p \u2208 P .\nIt is easy to see that a model of CIRC[A(P ); P ] is also a model of the completion of A(P ) on P , but the converse does not hold in general. Theorem 1 Let A(P ) be a formula, and B a finite set of clauses equivalent to A. CIRC[A(P ); P ] is equivalent to the union of the completion of A(P ) on P and the set consisting of the formulas L \u2283 \u00acA(L)\nfor each loop L of A(P ) on P under B.\nWe call formula ( 4) the (conjunctive) loop formula of L for CIRC[A(P ); P ] under B.\nNote that compared with Proposition 1, Theorem 1 tells us that, for a model X of a formula A(P ) to be a model of CIRC[A(P ); P ], it is sufficient to check whether every singleton subset of X and every loop of A in X satisfies formulas (2).\nClearly, a circumscription is equivalent to the completion when there are no loops: Corollary 1 For any formula A(P ), if there is an equivalent finite set B of clauses such that there are no loops of A(P ) on P under B, then CIRC[A(P ); P ] is equivalent to the completion of A(P ) on P .\nFor example, let A 2 (P ) be the formula p \u2228 q where P = (p, q). A 2 (P ) has three models, {p}, {q} and {p, q}, among which {p, q} is not a model of CIRC[A 2 (P ); P ] because {p} < P {p, q}. Since there are no loops of A 2 (P ) on P , Corollary 1 gives us another way of computing the models of the circumscription, by just computing the models of the completion, {p \u2228 q, p \u2283 \u00acq, q \u2283 \u00acp}.\nA 1 (P ) on P = (p, q, r, s) in the previous section is an example that contains loops. A 1 (P ) has three models, {p, q}, {r, s} and {p, q, r, s}, among which the last is not a model of CIRC[A 1 (P ); P ] because {p, q} < P {p, q, r, s}. Theorem 1 gives us another way of computing the models of the circumscription, by computing the models of the completion and loop formulas. First, the completion of A 1 (P ) on P is the union of A 1 (P ) and\n{p \u2283 q \u2228 \u00acr \u2228 (r \u2261 s), q \u2283 p \u2228 (r \u2261 s) \u2228 \u00ac(p \u2228 r), r \u2283 s \u2228 \u00acp \u2228 (p \u2261 q), s \u2283 r \u2228 (p \u2261 q) \u2228 \u00ac(p \u2228 r)} from (3).\nWe see that the models of the completion are the three models of A 1 (P ) above. There are two loops of A 1 (P ) on P , {p, q} and {r, s}, and their loop formulas are p \u2227 q \u2283 \u00acr and r \u2227 s \u2283 \u00acp each. Among the models of the completion of A 1 (P ) on P , {p, q, r, s} does not satisfy any loop formula, so that it is not a model of CIRC[A 1 (P ); P ]. The other two satisfy every loop formula, and are models of the circumscription. Furthermore, it is easy to see that CIRC[A 1 ; p, q] is equivalent to CIRC[A 1 ; P ]. The completion of A 1 on (p, q) is a subset of the completion of A 1 on P , so that all three models of A 1 still satisfy the completion of A 1 on (p, q). {p, q, r, s} still does not satisfy the only loop formula p\u2227q \u2283 \u00acr for CIRC[A 1 ; p, q], which is also a loop formula for CIRC[A 1 ; P ].\nAccording to Theorem 1, to compute the circumscription of P in A(P ) with all other atoms fixed, one first converts A to a finite set B of clauses, constructs the dependency graph of B on P , computes the loops of the dependency graph, and then computes the completion and loop formulas.\nComputationally, there are a few problems here. First of all, without introducing new atoms, the size of B could be exponential in the number of atoms in A, although the size of the dependency graph of B is always polynomial. The second problem is that the number of loops can be exponential.\nFrom the complexity point of view, we cannot do much about the second problem as SAT is in NP, and the problem of finding a model of circumscription is \u03a3 P 2 -hard. For the first problem, one can introduce new atoms when converting A to its clausal form to avoid combinatorial blow-up when distributing \"\u2228\" over \"\u2227.\" One can also try to construct a dependency graph directly without actually generating the set of clauses. However, a formula may be equivalent to many different sets of clauses, which in turn may yield different dependency graphs. Intuitively, for our purpose, everything being equal, the fewer loops that a dependency graph has the better. We believe that in general, given a formula A, it is computationally hard to find a set of clauses for A that would yield the smallest number of loops. But we do not have a proof, and it remains an open question.", "publication_ref": ["b15"], "figure_ref": [], "table_ref": []}, {"heading": "Varied Constants", "text": "The following fact (Lifschitz 1985, Proposition 2) shows how to eliminate varied constants in general: Fact 1 CIRC[A(P, Z); P ; Z] is equivalent to A(P, Z) \u2227 CIRC[\u2203zA(P, z); P ].\nThus circumscription with varied constants reduces to the basic case where Theorem 1 applies.\nAlternatively, we have the following result by modifying the definitions of a dependency graph and a loop. Intuitively, paths are allowed to have varied atoms and their negations as intermediate vertices. Definition 4 The (positive) dependency graph of a set A of clauses on P with Z allowed to vary is the directed graph G such that \u2022 the vertices of G are the literals in P \u222a Z \u222a Z, and \u2022 for each clause C in A, G has an edge from each literal l in C \u2229(P \u222aZ \u222aZ) to each literal in C \\ {l}\u2229(P \u222aZ \u222aZ).\nA nonempty set L 0 of literals is called an extended loop of A on P with Z allowed to vary if, for every pair p, p of literals in L 0 , there exists a path of nonzero length from p to p in the dependency graph of A on P with Z allowed to vary such that all the vertices in this path belong to L 0 . A nonempty set L = L 0 \\ (Z \u222a Z) is called a loop of A on P with Z allowed to vary.\nFor example, let P = {p, q}, Z = {z} and A 3 (P, Z) be the set of clauses {p \u2283 \u00acz, \u00acz \u2283 q, q \u2283 p}. The dependency graph of A 3 (P, Z) on P with Z allowed to vary is shown in Figure 2. It has only one extended loop, {p, q, \u00acz}, and so has only one loop, {p, q}.\nThe above definition of a loop is intuitive, but here is an alternative, more economical definition in terms of the number of loops we get. For a set A of clauses, by S(A) we denote the set of clauses C in A such that C does not contain a pair of complementary literals and there is no proper subset C of C such that C \u2208 A. Given a set A of clauses and a tuple of atoms Z = (z 1 , . . . , z n ), B Z is defined as follows.\n\u2022 B () = A, \u2022 B (z1,...,z k ) = S(B (z1,...,z k\u22121 ) ) \u222a {C 1 \u222a C 2 : C 1 \u222a {z k }, C 2 \u222a {\u00acz k } \u2208 S(B (z1,...,z k\u22121 ) )}.\nWe call S(B Z ) the Z-collapsed set of A.\nLet A Z be the Z-collapsed set of A and let A Z be the set of clauses in A Z that do not mention Z. Loops of the dependency graph of A Z on P are called loops of A on P with Z allowed to vary. A loop according to this alternative definition is also a loop according to the definition above, but not vice versa. The following result holds under either definition.\nHere is a counterpart of Proposition 1, where we allow some atoms to vary. Proposition 2 CIRC[A(P, Z); P ; Z] is equivalent to the conjunction of A(P, Z) and K \u2283 \u2200z\u00acA(K, z) for each nonempty subset K of P .", "publication_ref": ["b10"], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "Definition 5", "text": "The completion of a formula A(P, Z) on P with Z allowed to vary is the theory formed by taking the union of A(P, Z) and the set consisting of the formulas p \u2283 \u2200z\u00acA(p, z) for each p \u2208 P . Theorem 2 Let A(P, Z) be a formula, and B a finite set of clauses equivalent to A(P, Z). CIRC[A(P, Z); P ; Z] is equivalent to the union of the completion of A(P, Z) on P with Z allowed to vary and the set consisting of the formulas\nL \u2283 \u2200z\u00acA(L, z) (5)\nfor each loop L of A(P, Z) on P with Z allowed to vary.\nWe call formula ( 5) the (conjunctive) loop formula of L for CIRC[A(P, Z); P ; Z] under B.\nA 3 (P, z) above has two models, {p, q} and {z}, but the first is not a model of CIRC[A 3 (P, z); P ; z], though it satisfies the completion of A 3 (P, z) on P , {p \u2283 q, q \u2283 p}. There is only one loop of A 3 (P, z) on P with z allowed to vary, {p, q}, and its loop formula is p \u2227 q \u2283 \u22a5. Only the interpretation {z} satisfies both the completion and the loop formula.\nSimilarly to Corollary 1, we get the following corollary to Theorem 2:\nCorollary 2 For any formula A(P, Z), if there is an equivalent finite set B of clauses such that there are no loops of A(P, Z) on P with Z allowed to vary under B, then CIRC[A(P, Z); P ; Z] is equivalent to the completion of A(P, Z) on P with Z allowed to vary.\nRelating to Some Known Results Reiter (1982) was the first to show some relationships between Clark's predicate completion and circumscription. He proved that if a theory is Horn in a predicate P , then the circumscription of P logically entails P 's completion. In the propositional case, our new contributions are as follows. First, we extended the notion of completion to arbitrary theories, not just those that are Horn. Second, we showed that it is always the case that circumscription of an atom p entails p's completion. Third, we gave a general syntactic condition that guarantees the equivalence between circumscription and completion. Lastly, and most importantly, we defined notions of loops and loop formulas, and showed that circumscription can be reduced to completion plus loop formulas.\nTraditionally, computing circumscription means finding classes of first-order theories for which circumscription is equivalent to first-order theories (e.g. (Lifschitz 1985;1987) and (Doherty, \u0141ukaszewicz, & Sza\u0142as 1997) ). In the propositional case, circumscription is always equivalent to a propositional theory. So the problem in the propositional case is not whether circumscription can be reduced to propositional logic, but how well this can be done.\nIn logic programming, when the positive dependency graph of a program has no loops, the program is called \"tight\", and the answer sets for such a tight program are exactly the models of the completion. Corollaries 1 and 2 in this paper address a similar syntactic condition for circumscription in the propositional case. In the following, we show that some of the known results about circumscription can be easily explained by our corollaries.\nWe say an occurrence of an atom in a formula is positive if it is in the range of an even number of negations, and negative otherwise (assuming that \u2283 and \u2261 have been eliminated in favor of other connectives). A formula A(P ) is positive (relative to P ) if all occurrences of P in it are positive, and negative if all occurrences of P are negative. 4 We see that if A(P ) is positive (or negative) relative to P , then there is an equivalent set of clauses whose dependency graph on P has no loops, so that CIRC[A(P ); P ] is equivalent to the completion of A(P ) on P . The result can also be extended when some atoms are allowed to vary. The following is the propositional case of Proposition 2a from (Lifschitz 1987).\nProposition 3 If A(p, Z) is positive relative to an atom p, then CIRC[A(p, Z); p; Z] is equivalent to A(p, Z) \u2227 \u00ac\u2203z(p \u2227 A(\u22a5, z)).(6)\nProof.\nCIRC[A(p, Z); p; Z] \u2261 A(p, Z) \u2227 (p \u2283 \u2200z\u00acA(p, z)) \u2261 A(p, Z) \u2227 \u00ac\u2203z(p \u2227 A(\u22a5, z)).\nThe first equivalence holds because there exists a set of clauses equivalent to A(p, Z) such that the dependency graph of A(p, Z) under it has no loops, so that Corollary 2 applies.\nThe form of circumscription in ( 6) is the propositional case of what Lifschitz (1987) called pointwise circumscription.\nProposition 3 can be extended to parallel circumscription:\nProposition 4 (Lifschitz 1987, Proposition 5) If P is a tuple of atoms p 1 , . . . , p n and A(P, Z) is positive relative to each p i , then CIRC[A(P, Z); P ; Z] \u2261 i CIRC[A(P, Z); p i ; Z].\nProof. Again, this is easy to see from the facts that there exists a set of clauses equivalent to A(P, Z) such that the dependency graph of A(P, Z) under it has no loops, and that the completion of A(P, Z) on P is equivalent to the conjunction of each completion of A(p i , Z) on p i .\nIn fact, Corollary 2 presents us a much more general condition than the one in Proposition 3 (and 4) that shows the equivalence between the circumscription of the form (1) and pointwise circumscription. For example, consider CIRC[(p \u2283 q) \u2227 (q \u2283 r); q, r]. There are no loops of the formula, and consequently the circumscription is equivalent to its corresponding pointwise circumscription according to Corollary 2. But the conjunction in the formula cannot be divided into two parts so that q,r are positive in one part and negative in the other, so Proposition 3 does not apply.\nSometimes it is easy to observe that the dependency graphs of some circumscriptions have the same loops.\nProposition 5 (Lifschitz 1987) If B(P ) is negative relative to P , then CIRC[A(P ) \u2227 B(P ); P ] is equivalent to CIRC[A(P ); P ] \u2227 B(P ).\nProof. There exists a set B (P ) of clauses which is equivalent to B(P ) and is negative relative to P . Notice that A(P ) \u2227 B (P ) and A(P ) have the same dependency graph on P , hence have the same loops. We see that the completion and loop formulas of A(P ) \u2227 B (P ) on P and those of A(P ) on P are equivalent to each other when we notice that B (P ) is entailed by B (P ).\nHowever, if some atoms are allowed to vary, then A(P ) \u2227 B(P ) may have more loops than A(P ) (A 3 (P, z) for example), and B(P ) may not be easily \"factored out\".", "publication_ref": ["b20", "b10", "b11", "b1", "b11", "b11", "b11"], "figure_ref": [], "table_ref": []}, {"heading": "Embedding Circumscription in Other Nonmonotonic Logics", "text": "As mentioned in the introduction, the idea of \"completion + loop formulas\" has been applied to logic programs in (Lin & Zhao 2002;Lee & Lifschitz 2003) and to McCain-Turner causal logic in (Lee 2004). The characterizations of these nonmonotonic logics in terms of propositional logic are useful tools for comparing the formalisms. Based on this idea, Lee (2004) showed how to embed logic programs in causal logic.\nInspired by a similar characterization for circumscription, we show how to relate circumscription to logic programs and to causal logic. The propositions below can be proved by turning each formalism into \"completion+loop formulas\" and then show that the translations are equivalent to each other.", "publication_ref": ["b13", "b7", "b8", "b8"], "figure_ref": [], "table_ref": []}, {"heading": "Logic Programming", "text": "For a literal l, by l not we denote not l if l is positive, and l otherwise. Let A(P ) be a finite set of clauses. For each clause C \u2208 A(P ), the corresponding rule C P is ; p\u2208C\u2229P p \u2190 , q\u2208C\\P q not By \u03c3 A we denote the set of all atoms that occur in A.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Proposition 6", "text": "For any finite set A(P ) of clauses, a set of atoms is a model of CIRC[A(P ); P ] iff it is an answer set for the logic program\n{C P : C \u2208 A(P )} \u222a {a ; not a : a \u2208 \u03c3 A \\P }.\nWe may even embed circumscription with varied constants in logic programs. Given a finite set A(P, Z) of clauses, \u03a0 A;P ;Z is the following logic program. Let A Z be the Z-collapsed set of A.\n\u2022 For each clause C in A Z that does not mention Z, \u03a0 A;P ;Z has the rule C P , \u2022 For every other clause C in A Z , \u03a0 A;P ;Z has the rule \u2190 , p\u2208C p not ,\n\u2022 For each atom a \u2208 \u03c3 A \\P , \u03a0 A;P ;Z has the rule a ; not a.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Proposition 7", "text": "For any finite set A(P, Z) of clauses, a set of atoms is a model of CIRC[A(P, Z); P ; Z] iff it is an answer set for the logic program \u03a0 A;P ;Z .", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "McCain-Turner Causal Logic", "text": "McCain-Turner causal logic is a useful formalism for describing effects of actions, and is a basis of action language C+ , which is a high level language for describing transition systems. Proposition 8 Let A(P ) be a finite set of clauses. An interpretation is a model of CIRC[A(P ); P ] iff it is a model of the causal theory {C \u2229 (P \u222a P )\u21d0\u00ac(C \\ (P \u222a P )) : C \u2208 A} \u222a {\u00acr\u21d0\u00acr : r \u2208 \u03c3 A } \u222a {r\u21d0r : r \u2208 \u03c3 A \\P } whose signature is \u03c3 A .\nProposition 8 is similar to the propositional case of Proposition 1 of (Lifschitz 1997). Extending the result to circumscription with varied constants is similar to the case with logic programs and is omitted here due to the lack of space.", "publication_ref": ["b12"], "figure_ref": [], "table_ref": []}, {"heading": "Conclusion", "text": "To recast, the following are our main contributions (all in the propositional case):\n\u2022 Extend completion to arbitrary theories.\n\u2022 Introduce a notion of a positive dependency graph for a finite set of clauses, and based on it, notions of loops and loop formulas.\n\u2022 Show that circumscription is equivalent to completion plus loop formulas, and based on this result, embed circumscription in other nonmonotonic logics.\nThese results are of both theoretical interest and practical importance. A major obstacle in implementing a reasoning system for propositional circumscription is that checking if an assignment is a model of a circumscription is NP-hard.\nIn comparison, checking if an assignment is a model of a formula in propositional logic or an answer set for a nondisjunctive logic program can be done efficiently. By Theorems 1 and 2, if a given formula has no loop or has only a polynomial number of loops and these loops can be computed in polynomial time, then checking if an assignment is a model of circumscription can be done in polynomial time as well. Hopefully, many applications of circumscription will belong to this class, just as many logic programs for practical problems are \"tight\" or \"tight on the models of completion\". Alternatively, one could implement circumscription in logic programming systems like DLV and GnT using Propositions 6 and 7. 5 Note that we could have defined a loop to allow a path of length 0, which corresponds to each atom. In this sense, the second part of completion is just a set of loop formulas, and circumscribing a theory can be regarded as just adding loop formulas to it.\nFor future work, there is a need to better understand how loops can be computed. More importantly, there is a need to extend the results of this paper to the first-order case.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgements", "text": "We are grateful to Selim Erdogan, Paolo Ferraris, Vladimir Lifschitz, Hudson Turner and the anonymous referees for useful comments. Joohyung Lee was partially supported by the Texas Higher Education Coordinating Board under Grant 003658-0322-2001. Fangzhen Lin's work has been supported in part by HK RGC under CERG HKUST6205/02E, and by the NSFC under its major research program \"Basic Theory and Core Techniques of Non-Canonical Knowledge\".", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Logic and Data Bases", "journal": "Plenum Press", "year": "1978", "authors": "K Clark"}, {"ref_id": "b1", "title": "Computing circumscription revisited: A reduction algorithm", "journal": "Journal of Automated Reasoning", "year": "1997", "authors": "P Doherty; W \u0141ukaszewicz; A Sza\u0142as"}, {"ref_id": "b2", "title": "Tight logic programs", "journal": "Theory and Practice of Logic Programming", "year": "2003", "authors": "E Erdem; V Lifschitz"}, {"ref_id": "b3", "title": "Consistency of clark's completion and existence of stable of stable models", "journal": "Journal of Methods of Logic in Computer Science", "year": "1994", "authors": "F Fages"}, {"ref_id": "b4", "title": "The stable model semantics for logic programming", "journal": "", "year": "1988", "authors": "M Gelfond; V Lifschitz"}, {"ref_id": "b5", "title": "", "journal": "Nonmonotonic causal theories. Artificial Intelligence", "year": "2004", "authors": "E Giunchiglia; J Lee; V Lifschitz; N Mccain; H Turner"}, {"ref_id": "b6", "title": "SATbased answer set programming", "journal": "", "year": "2004", "authors": "E Giunchiglia; Y Lierler; M Maratea"}, {"ref_id": "b7", "title": "Loop formulas for disjunctive logic programs", "journal": "", "year": "2003", "authors": "J Lee; V Lifschitz"}, {"ref_id": "b8", "title": "Nondefinite vs. definite causal theories", "journal": "", "year": "2004", "authors": "J Lee"}, {"ref_id": "b9", "title": "Nested expressions in logic programs", "journal": "Annals of Mathematics and Artificial Intelligence", "year": "1999", "authors": "V Lifschitz; L R Tang; H Turner"}, {"ref_id": "b10", "title": "Computing circumscription", "journal": "", "year": "1985", "authors": "V Lifschitz"}, {"ref_id": "b11", "title": "Readings in nonmonotonic reasoning", "journal": "Morgan Kaufmann", "year": "1987", "authors": "V Lifschitz"}, {"ref_id": "b12", "title": "On the logic of causal explanation", "journal": "Artificial Intelligence", "year": "1997", "authors": "V Lifschitz"}, {"ref_id": "b13", "title": "ASSAT: Computing answer sets of a logic program by SAT solvers", "journal": "", "year": "2002", "authors": "F Lin; Y Zhao"}, {"ref_id": "b14", "title": "Embracing causality in specifying the indirect effects of actions", "journal": "", "year": "1985", "authors": "F Lin"}, {"ref_id": "b15", "title": "On strongest necessary and weakest sufficient conditions", "journal": "Artificial Intelligence", "year": "2001", "authors": "F Lin"}, {"ref_id": "b16", "title": "Compiling causal theories to successor state axioms and STRIPS-like systems", "journal": "Journal of Artificial Intelligence Research", "year": "2003", "authors": "F Lin"}, {"ref_id": "b17", "title": "Causal theories of action and change", "journal": "", "year": "1997", "authors": "N Mccain; H Turner"}, {"ref_id": "b18", "title": "Circumscription-a form of non-monotonic reasoning", "journal": "Artificial Intelligence", "year": "1980", "authors": "J Mccarthy"}, {"ref_id": "b19", "title": "Applications of circumscription to formalizing common sense knowledge", "journal": "Artificial Intelligence", "year": "1986", "authors": "J Mccarthy"}, {"ref_id": "b20", "title": "Circumscription implies predicate completion (sometimes)", "journal": "", "year": "1982", "authors": "R Reiter"}, {"ref_id": "b21", "title": "The frame problem in the situation calculus: a simple solution (sometimes) and a completeness result for goal regression", "journal": "Academic Press", "year": "1991", "authors": "R Reiter"}], "figures": [{"figure_label": "", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure1: The dependency graph of A 1 (P ) on P", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 2 :2Figure 2: The dependency graph of A 2 on P with varied z", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": ")1", "formula_coordinates": [2.0, 284.65, 408.38, 7.74, 8.97]}, {"formula_id": "formula_1", "formula_text": "K \u2283 \u00acA(K)(2)", "formula_coordinates": [2.0, 415.53, 472.99, 142.36, 9.96]}, {"formula_id": "formula_2", "formula_text": "for each p \u2208 P .", "formula_coordinates": [2.0, 319.44, 694.57, 62.67, 9.96]}, {"formula_id": "formula_4", "formula_text": "{p \u2283 q \u2228 \u00acr \u2228 (r \u2261 s), q \u2283 p \u2228 (r \u2261 s) \u2228 \u00ac(p \u2228 r), r \u2283 s \u2228 \u00acp \u2228 (p \u2261 q), s \u2283 r \u2228 (p \u2261 q) \u2228 \u00ac(p \u2228 r)} from (3).", "formula_coordinates": [3.0, 54.0, 491.63, 227.94, 37.2]}, {"formula_id": "formula_5", "formula_text": "\u2022 B () = A, \u2022 B (z1,...,z k ) = S(B (z1,...,z k\u22121 ) ) \u222a {C 1 \u222a C 2 : C 1 \u222a {z k }, C 2 \u222a {\u00acz k } \u2208 S(B (z1,...,z k\u22121 ) )}.", "formula_coordinates": [4.0, 54.0, 195.88, 247.95, 38.56]}, {"formula_id": "formula_6", "formula_text": "L \u2283 \u2200z\u00acA(L, z) (5)", "formula_coordinates": [4.0, 142.45, 548.13, 150.05, 9.96]}, {"formula_id": "formula_7", "formula_text": "Proposition 3 If A(p, Z) is positive relative to an atom p, then CIRC[A(p, Z); p; Z] is equivalent to A(p, Z) \u2227 \u00ac\u2203z(p \u2227 A(\u22a5, z)).(6)", "formula_coordinates": [4.0, 319.52, 590.56, 238.41, 38.63]}, {"formula_id": "formula_8", "formula_text": "CIRC[A(p, Z); p; Z] \u2261 A(p, Z) \u2227 (p \u2283 \u2200z\u00acA(p, z)) \u2261 A(p, Z) \u2227 \u00ac\u2203z(p \u2227 A(\u22a5, z)).", "formula_coordinates": [4.0, 328.96, 653.23, 219.5, 20.93]}, {"formula_id": "formula_9", "formula_text": "{C P : C \u2208 A(P )} \u222a {a ; not a : a \u2208 \u03c3 A \\P }.", "formula_coordinates": [5.0, 337.4, 248.99, 202.52, 10.32]}], "doi": ""}