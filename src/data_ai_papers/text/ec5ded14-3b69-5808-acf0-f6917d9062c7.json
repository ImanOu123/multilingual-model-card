{"title": "Mining Coherent Gene Clusters from Three-Dimensional Microarray Data *", "authors": "Daxin Jiang; Jian Pei; Murali Ramanathan; Chun Tang; Aidong Zhang", "pub_date": "", "abstract": "Extensive studies have shown that mining microarray data sets is important in bioinformatics research and biomedical applications. In this paper, we explore a novel type of 3dimensional microarray data sets, which records the expression levels of various genes under a set of samples during a series of time points. In particular, we propose the mining of coherent gene clusters from such data sets. Each cluster contains a subset of genes and a subset of samples such that the genes are coherent on the samples along the time series. The coherent gene clusters may identify the samples corresponding to some phenotypes (e.g., diseases), and suggest the candidate genes correlated to the phenotypes. We present two efficient algorithms, namely the Sample-Gene Search and the Gene-Sample Search, to mine the complete set of coherent gene clusters. We empirically evaluate the performance of our approaches on both a real microarray data set and synthetic data sets. The test results have shown that our approaches are both efficient and effective to find meaningful coherent gene clusters.", "sections": [{"heading": "INTRODUCTION", "text": "The recent microarray technology can measure the expression levels of thousands of genes simultaneously. It is an important research problem in bioinformatics and clinical research to explore the patterns in microarray data sets. For example, in drug development, gene expression patterns may reflect gene-level responses to different drug treatments and provide deep insights into the nature of the diseases.\nMost microarray data sets can be divided into two categories. On the one hand, the time-series data sets record the expression levels of various genes during important biological processes over a series of time points. The sample data sets account the expression levels of various genes across related samples. Both time-series data sets and sample data sets can be represented by a 2-dimensional gene expression matrix of real values. In a gene expression matrix, the rows are the genes and the columns are either samples (in sample data sets) or ordered time points (in time-series data sets), while each cell represents the expression level of a certain gene on a certain sample or at a certain time point.\nIn a 2-dimensional n \u00d7 m matrix of n genes and m samples/time points, a gene can be treated as a point in an m-dimensional sample/time point space and a sample/time point can be treated as a point in an n-dimensional gene space. However, when we say a k-dimensional (k = 2, 3) microarray data set, we mean the data set contains k types of variables (e.g., genes, samples and time points).\nWith the latest advances in the microarray technology, the expression levels of a set of genes under a set of samples can be monitored synchronically during a series of time points [20]. Different from the previous 2-dimensional data sets, these new data sets have three dimensions (types of variables): genes, samples and time. We call such data sets gene-sample-time (GST) data sets, or 3-dimensional microarray data for short. Figure 1(a) elaborates the structure of a 3-d microarray data set.\nIn general, each cell m k i,j in a 3-d microarray data set represents the expression level of gene g i under sample s j at time point t k . Interestingly, a 3-dimensional data set can also be viewed as a two-dimensional matrix, such that each cell m i,j contains the time series with respect to gene g i under sample s j , as shown in Figure 1(b).\nThe previous studies on 2-dimensional microarray data (e.g., [7,2,15,1]) indicate that high correlations may exist between the gene expression patterns and some diseases. It is natural to extend the similar analysis to 3-d microarray data. That is, it is interesting to identify a subset of genes G and a subset of samples S in a 3-d microarray data set such that each gene g \u2208 G has coherent patterns across the samples in S during the time series. For example, in Figure 1, gene g i1 , g i2 and g i3 show coherent patterns across samples s j1 , s j2 and s j3 , respectively. We call such subsets of genes and samples a coherent gene cluster. What is the biological meaning of the coherent gene clusters? The coherent gene clusters provide valuable hypothesis for biologists. The samples in a cluster may correspond to a phenotype, such as the patients having a disease, while the corresponding set of genes may suggest the candidate genes correlated to the disease.\nThe functions of genes in an organism are highly complicated. There are typically multiple coherent clusters in a data set. Different clusters may correlate to different phenotypes, such as age and gender. Therefore, to avoid missing any valuable hypothesis, it is necessary to mine all the coherent clusters in the data set.\nMany previous studies investigate the mining of interesting patterns from 2-dimensional microarray matrices. For example, various clustering algorithms can identify the coexpressed genes showing coherent patterns during the timeseries (e.g., [17,12,15,8]). Moreover, both supervised or unsupervised approaches are proposed to partition the samples into homogeneous groups (e.g., [4,14,9,16]). Additionally, statistical approaches have been proposed to validate the significance of the mining results (e.g., [3,18,5]). However, all previous studies target at 2-dimensional microarray data sets. The models of clusters in those previous studies are different from our 3-d coherent gene clusters. Those algorithms cannot be extended directly to solve our problem.\nRecently, the pattern-based clustering approaches (e.g., [19]) have been developed to discover subsets of objects following similar patterns on subsets of attributes. Conceptually, a pattern-based cluster is a coherent gene cluster. If we treat the 3-d microarray data sets as a 2-dimensional array of time series, as shown in Figure 1(b), then pattern-based clusters and coherent gene clusters may have some similarity at the first look. However, in some pattern-based approaches, a cluster requires that each pair of objects in the cluster must be coherent on each pair of attributes. Such a requirement is often too strong in practice. Our coherent gene clustering relaxes the constraints on the object dimension. Therefore, each traditional pattern-based cluster is a coherent gene cluster, but not necessarily true vice versa.\nIn this paper, we tackle the problem of mining coherent patterns from gene-sample-time microarray data sets and make the following contributions.\nFirst, we propose a model of coherent gene clusters in 3-d microarray data sets. We justify that the model is meaningful for biomedical research.\nSecond, we identify the computational challenges and conduct a systematic research on mining coherent gene clusters from 3-d microarray data sets. We develop two approaches, namely the Gene-Sample Search and the Sample-Gene Search, to mine the complete set of coherent gene clusters. We illustrate and compare the efficiency and scalability of both approaches.\nLast, we conduct an extensive empirical evaluation on both real data sets and synthetic data sets. Our results show that our proposed methods can find coherent gene clusters interesting to biomedical research from real data sets. The results on synthetic data sets also show that our algorithms are both efficient and scalable.\nThe rest of the paper is organized as follows. Section 2 defines the problem. Section 3 describes the preprocessing step of computing the maximal coherent samples sets for each individual gene. Section 4 presents two algorithms to mine coherent gene clusters. In Section 5, our methods are evaluated using real and synthetic data sets. Related work is discussed in Section 6. Section 7 concludes the paper.", "publication_ref": ["b19", "b6", "b1", "b14", "b0", "b16", "b11", "b14", "b7", "b3", "b13", "b8", "b15", "b2", "b17", "b4", "b18"], "figure_ref": ["fig_0", "fig_0", "fig_0", "fig_0"], "table_ref": []}, {"heading": "PROBLEM DESCRIPTION", "text": "Given a set of n genes G-Set = {g 1 , . . . , g n } and a set of l samples S-Set = {s 1 , . . . , s l }, we can measure the expression levels of the genes on the samples. The results form a conventional 2-dimensional microarray matrix M = {mi,j}, where mi,j is the expression level of gene gi\n(1 \u2264 i \u2264 n) on sample s j (1 \u2264 j \u2264 l).\nIf such microarray experiments are conducted synchronically on all genes and all samples at time instants t 1 , . . . , t T , the results form a 3-dimensional microarray matrix M = {m t i,j }, where (1 \u2264 t \u2264 T ). A 3-d microarray matrix M = {m t i,j } can also be viewed as a 2-d matrix M = {m i,j } such that m i,j is a vector of m 1 i,j , . . . , m T i,j . Hereafter, we do not strictly distinguish the two notations. Instead, whenever mi,j is written, the vector is referred to.\nIn this paper, we are interested in finding those genes that are coherent on a subset of samples during the whole time series. There are various methods to measure the correlation between two time series. However, for gene expression data, users are often interested in the overall trends of the expression levels instead of the absolute magnitudes. Therefore, we choose the Pearson's correlation coefficient as the coherence measure, since it is robust to shifting and scaling patterns [22]. Specifically, given two vectors m i,j 1 and m i,j 2 of gene g i , the coherence \u03c1(m i,j 1 , m i,j 2 ) is defined as\nT t=1 (m t i,j 1 \u2212 m i,j 1 )(m t i,j 2 \u2212 m i,j 2 ) T t=1 (m t i,j 1 \u2212 m i,j 1 ) 2 T t=1 (m t i,j 2 \u2212 m i,j 2 ) 2 ,\nwhere\nmi,j = T t=1 m t i,j T\nis the mean of the expression levels of gene gi on sample sj. The correlation coefficient ranges between \u22121 and 1. The larger the value, the more coherent are the two vectors.\nA gene g i is coherent across a subset of samples S \u2286 S-Set, if given any pair of samples sj 1 , sj 2 \u2208 S, \u03c1(mi,j 1 , mi,j 2 ) \u2265 \u03b4, where \u03b4 is a minimum coherence threshold specified by the user. For a subset of genes G \u2286 G-Set and a subset of samples S \u2286 S-Set, if every gene g i \u2208 G is coherent across samples in S, we call gene set G coherent on sample set S. (G \u00d7 S) is called a coherent gene cluster. A coherent gene cluster having u genes and v samples is said a (u, v)-coherent gene cluster.\nTrivially, for any gene g i and any sample s j , ({g i }\u00d7{s j }) is a (1, 1)-coherent gene cluster, and (G-Set\u00d7{s j }) and ({g i }\u00d7 S-Set) are trivial (|G-Set|, 1)-and (1, |S-Set|)-coherent gene clusters, respectively. To avoid this triviality, we require that a coherent gene cluster should consist of at least two genes and two samples.\nGiven a coherent gene cluster (G \u00d7 S), for any subsets G \u2286 G and S \u2286 S, (G \u00d7 S ) is also a coherent gene cluster. To avoid such redundancy, a coherent gene cluster (G \u00d7 S) is maximal if there exists no any other coherent gene cluster (G \u00d7 S ) such that G \u2286 G , S \u2286 S and at least one equality does not hold. Moreover, a user may not be interested in very small clusters, which are often formed by chance. Thus, a user can specify the minimum numbers of genes and samples in a cluster. Generally, given min g and min s as user defined minimum gene size and sample size thresholds, a cluster (G \u00d7 S) is called significant if |G| \u2265 ming and |S| \u2265 mins.\nProblem definition Given a 3-dimensional microarray matrix M , a minimum coherence threshold \u03b4, a minimum gene size threshold min g and a minimum sample size threshold min s , the problem of mining coherent gene clusters is to find the complete set of significant maximal coherent gene clusters in M with respect to the parameters. Hereafter, a significant maximal coherent gene cluster is called a coherent gene cluster for short.", "publication_ref": ["b21"], "figure_ref": [], "table_ref": []}, {"heading": "MAXIMAL COHERENT SAMPLE SETS", "text": "We propose two algorithms computing maximal coherent gene clusters. In both algorithms, to compute coherent gene clusters, we need to check whether a subset of genes are coherent on a subset of samples. To facilitate the tests, for each gene g k , we compute the sets of samples S such that (1) |S| \u2265 min s ; (2) g k is coherent on S; and (3) there exists no superset S \u2283 S such that g k is also coherent on S . S is called a maximal coherent sample set of g k . Please note that, in general, a gene may have more than one maximal coherent sample set.\nFor a gene g k , all of its maximal coherent sample sets can be computed efficiently using the following 2-step process.\nIn the first step, we test whether gene g k is coherent on each pair of samples (si, sj). A binary triangle matrix {ci,j} is populated, where 1 \u2264 i < j \u2264 |S-Set|. c i,j = 1 if gene g k is coherent on samples s i and s j , i.e., \u03c1(m k,i , m k,j ) \u2265 \u03b4, otherwise, ci,j = 0.\nOnce the matrix {ci,j} is populated, the problem of finding g k 's maximal coherent sample sets can be reduced to the problem of finding all maximal cliques of size at least min s in graph G k = (S-Set, E), where (s i , s j ) is an edge in the graph if and only if ci,j = 1. A clique S is called maximal if there exists no any other clique S such that S \u2282 S . Please note that there may exist more than one maximal clique in a graph.\nUnlike the conventional clique problem where the clique of the maximal size is found, here, we need to find the complete set of maximal cliques in the graph. It is well known that the conventional clique problem is NP-complete. So is the problem of finding the complete set of maximal cliques. Fortunately, the real 3-d microarray data sets are often sparse and the number of samples is typically below one hundred. For each gene, the number of maximal cliques is quite small and the samples can often be partitioned into exclusive small subsets. Our experimental results show that, with efficient search and pruning techniques, it is still practical to find the complete set of maximal cliques. In the following, we will show how to find the maximal cliques of a sample set by a depth-first search in a sample set enumeration tree.\nGiven a set of samples S = {s1, . . . , s l }, the set 2 S (i.e., all combinations of samples) can be enumerated systematically. These subsets can be further partitioned. For example, the first subset can be further divided into three exclusive sub-subsets: (1) the ones having samples a and b; (2) the ones having samples a and c but no b; and (3) {a, d}.\nThe tree shown in Figure 2 is called a set enumeration tree [13] with respect to {a, b, c, d}. It provides a conceptual tool to enumerate the complete set of combinations systematically.\nWe can conduct a recursive, depth-first search of the sample set enumeration tree to detect the maximal cliques of the samples. Given a set of samples S, the set enumeration tree has 2 |S| nodes. However, we never need to materialize such a tree. Instead, we only need to keep a path from the root of the tree to the node we are searching as a working set, which contains at most (|S| + 1) nodes.\nClearly, in the set enumeration tree, each node contains a unique subset of samples. Thus we can use the subset of samples to refer to the node. At node\n{s i 1 , . . . , s i k } (1 \u2264 i 1 < \u2022 \u2022 \u2022 < i k \u2264 l),\nwe also keep a list T ail, which contains the samples that can be used to extend the node to larger subsets of samples in the subtree. We have the following result.\nLemma 3.1. At node v = {si 1 , . . . , si k } of the sample set enumeration tree, where (1 \u2264 i 1 < \u2022 \u2022 \u2022 < i k \u2264 l), a sample s j \u2208 T ail if (1) j \u2264 i k ; or (2) there exists some 1 \u2264 l \u2264 k such that c i l ,j = 0. Moreover, for v's parent node v = {si 1 , . . . , si k\u22121 }, v's T ail is a subset of that of v .\nWe can prune any subtree that cannot lead to a coherent sample set of at least mins samples.\nPruning Rule 3.1 (Pruning small sample sets). At a node v = {s i 1 , . . . , s i k }, the subtree of v can be pruned if (k + |T ail|) < min s .\nInput: the 3-d data set, the coherence threshold \u03b4; minimum sample size threshold mins; Output: the maximal coherent sample sets for each gene; Method:\nfor each gene g k do generate matrix c i,j for g k ; // depth-first search for i = 1 to (l \u2212 min s + 1) do call search-clique({s i }, {s i+1 , . . . , s l }); end-for end-for  For example, for a set of l samples, even the complete set of sample combinations can be divided into l exclusive subsets as shown before, we only need to search the first (l \u2212 mins + 1) subsets, since each of the last (mins \u2212 1) subsets contains less than min s samples.\nMoreover, if the samples at the current node and its T ail are subsumed by some maximal coherent sample set found so far, then the recursive search can also be pruned, since it cannot lead to any new maximal coherent sample set.\nPruning Rule 3.2 (Pruning subsumed sets). At a node v = {si 1 , . . . , si k }, if {si 1 , . . . , si k } \u222a T ail is a subset of some maximal coherent sample set, then the subtree of the node can be pruned.\nBased on the above lemma and pruning rules, the preprocessing algorithm is presented in Figure 3. For the readers familiar with the techniques of depth-first mining of maximal/closed frequent patterns, the ideas of pruning here share the similar spirit with the pruning in frequent closed itemset mining (e.g., [10]). However, one key difference is that the frequent pattern mining conducts counting on databases, and we do not need to scan the database for any counting once the triangle matrix {ci,j} is materialized. The correctness of the preprocessing algorithm can be shown. Limited by space, we omit the details here.", "publication_ref": ["b12", "b9"], "figure_ref": ["fig_1", "fig_4"], "table_ref": []}, {"heading": "THE MINING ALGORITHMS", "text": "A na\u00efve method to find the maximal coherent gene clusters is to test every possible combination of genes and samples thoroughly. After all the coherent gene clusters are found, we can identify and report the maximal ones. The na\u00efve method is very costly and thus infeasible for real data sets. For example, suppose we have 1, 000 genes and 20 samples.  How can we search the huge space efficiently and prune unpromising subspaces sharply? When computing the maximal coherent sample sets (Figure 3), we systematically enumerate combinations of samples in a recursive depth-first search, and develop techniques to prune unpromising subspaces aggressively. Stimulated by the similar spirit, here we can also systematically enumerate the combinations of genes and samples, and prune unfruitful combinations.\nBasically, we have two alternatives. On the one hand, we can enumerate all combinations of samples systematically. For each subset of samples, we can find the maximal subsets of genes that form coherent gene clusters on the samples, and check whether the clusters are maximal. This method is called the Sample-Gene Search. On the other hand, we can let the gene enumeration go first. For each subset of genes, we find the maximal subsets of samples that form coherent gene clusters with the genes, and check whether the clusters are maximal. The method is called the Gene-Sample Search.\nThe frameworks of the Sample-Gene Search and the Gene-Sample Search are shown in Figure 4. Proper pruning techniques should be developed to prune unpromising combinations and search branches as early as possible.\nA first look at Figure 4 may suggest that the two methods are symmetric. However, since genes and samples are not symmetric in the problem, the technical details are in fact substantially different. We are mining coherent gene clusters on samples. As long as the genes respond coherently on the same subset of samples, they belong to the same cluster. However, the expression patterns of different genes in the same cluster on one sample can be very different!", "publication_ref": [], "figure_ref": ["fig_4", "fig_5", "fig_5"], "table_ref": []}, {"heading": "Sample-Gene Search", "text": "In the Sample-Gene Search, we need to address the following issues. First, as we enumerate the combinations of samples systematically, for each subset of samples, how can we find the maximal sets of genes such that the genes are coherent on the samples? Second, during the sample set enumeration, which sample sets can be pruned? Third, similar to the situation in Pruning rule 3.2, can we identify and \n{g 1 .b 1 , g 2 .b 1 , g 2 .b 2 , g 3 .b 1 , g 4 .b 1 , g 5 .b 1 } s 2 {g 1 .b 1 , g 2 .b 1 , g 3 .b 1 , g 4 .b 1 } s 3 {g 1 .b 1 , g 3 .b 1 , g 4 .b 1 } s 4 {g 1 .b 1 , g 2 .b 1 , g 3 .b 1 } s 5 {g 1 .b 1 , g 2 .b 2 , g 3 .b 1 , g 4 .b 2 , g 5 .b 1 } s 6 {g 4 .b 2 , g 5 .b 1 } (b)\nThe inverted lists for samples prune the searches that cannot lead to any potential maximal coherent clusters?. Last, how can we determine whether a coherent gene cluster is subsumed by the others? We answer the above questions in this subsection.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Maximal Coherent Gene Sets for Sample Sets", "text": "For each combination of samples S, we need to compute the maximal coherent gene set GS such that the genes in GS are coherent on S and no proper superset G \u2283 G S also has this property.\nClearly, for a gene g, if there exists a maximal coherent sample set Sg such that S \u2286 Sg, then g \u2208 GS. In other words, GS can be derived by one scan of the maximal coherent sample sets of all genes. If a maximal coherent sample set is a superset of S, then the corresponding gene g is inserted into G S .\nIt is expensive to scan the complete list of maximal coherent sample sets of all genes once for every combination of samples. An efficient solution is to use an inverted list.\nSuppose we have 5 genes and 6 samples. The maximal coherent sample sets for each gene are listed in Figure 5(a).\nWe label each maximal coherent sample set by the gene g k , and the set-id, b j , in the gene. For example, gene g 2 has two maximal coherent sample sets,\ng 2 .b 1 = {s 1 , s 2 , s 4 } and g 2 .b 2 = {s 1 , s 5 }.\nFor each sample s, we make up the inverted list Ls as the list of all maximal coherent sample sets containing s, as shown in Figure 5(b). Now, when we want to compute the maximal coherent gene sets for a subset of samples, say {s 1 , s 2 , s 3 }, we do not need to search the complete list in Figure 5 ", "publication_ref": [], "figure_ref": ["fig_6", "fig_6", "fig_6"], "table_ref": []}, {"heading": "Pruning Irrelevant Samples", "text": "For a combination of samples S = {s i 1 , . . . , s i k }, where i 1 < \u2022 \u2022 \u2022 < i k , let S tail be the set of samples that can be used to extend S to a larger set S \u2282 S \u222a S tail such that there are at least ming genes coherent on S . Clearly, a sample s j \u2208 S tail if j \u2264 i k . Moreover, if the maximal coherent gene set of S \u222a {s j } contains less than min g genes, then s j \u2208 S tail , either. This is in the similar spirit of Lemma 3.1. For example, in our running example (Figure 5), sample s 6 cannot be used to extend sample set S = {s2}, since there is no gene coherent on both s2 and s6.\nMoreover, similar to Pruning rule 3.1, if |S| + |S tail | < min s , then S cannot lead to any coherent gene cluster having min s or more samples, and thus can be pruned.", "publication_ref": [], "figure_ref": ["fig_6"], "table_ref": []}, {"heading": "Pruning Unpromising Coherent Gene Clusters", "text": "Similar to the situation in Pruning rule 3.2, we can prune the unpromising combinations that cannot lead to any new maximal coherent gene cluster. Here, two pruning techniques can be applied.\nFor example, in our running example (Figure 5), suppose we find the maximal coherent gene cluster ({g1, g3} \u00d7 {s1, s2, s3, s5}) before we search sample set S = {s1, s3}. For S = {s 1 , s 3 }, S tail = {s 5 } and G S\u222aS tail = {g 1 , g 3 }. That is, both S \u222a S tail and G S\u222aS tail are subsumed by the maximal coherent gene cluster. The recursive search of S cannot lead to any maximal coherent gene cluster and thus can be pruned.\nIn general, suppose we are searching a sample combination S . If there exists a maximal coherent gene cluster (G \u00d7 S) found before such that S \u222a S tail \u2286 S and G S \u222aS tail \u2286 G, then any recursive search from S results in a coherent gene cluster subsumed by (G \u00d7 S), and thus can be pruned.\nMoreover, if there exists a maximal coherent gene cluster (G \u00d7 S) found before such that S \u2286 S and every maximal coherent sample set containing S also contains S, then the recursive search of S cannot lead to any maximal coherent gene cluster either, and thus can be pruned. For example, suppose we search the sample set S = {s2} after we find the maximal coherent gene cluster ({g 1 , g 2 , g 3 , g 4 } \u00d7 {s 1 , s 2 }) in our running example (Figure 5). From Figure 5(a), we can see that every maximal coherent sample set containing s 2 also contains s1. In other words, there exists no maximal coherent gene cluster containing s 2 but no s 1 . Thus, the search of S can be pruned.", "publication_ref": [], "figure_ref": ["fig_6", "fig_6", "fig_6"], "table_ref": []}, {"heading": "Determining maximal coherent gene clusters", "text": "When we search a combination of samples S, we need to check whether GS \u00d7 S is a maximal coherent gene cluster. We look at those maximal coherent gene clusters (G \u00d7 S ) such that S \u2283 S. Clearly, since we conduct depth-first search in the set enumeration tree, such maximal coherent gene clusters should be reported either before S is searched, or in the subtree rooted at S.\nBased on the above discussion, we have the Sample-Gene Search algorithm in Figure 6.", "publication_ref": [], "figure_ref": ["fig_8"], "table_ref": []}, {"heading": "Gene-Sample Search", "text": "The framework of Gene-Sample Search is symmetric to that of Sample-Gene Search. That is, we enumerate the combinations of genes systematically. For each combination of genes, we compute the maximal sets of samples that the genes are coherent on. Many pruning techniques in Sample-Gene Search have the symmetric versions in Gene-Sample Search. Limited by space, we omit the details here. Instead, we only focus on the differences between the two approaches.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Determining Coherent Gene Clusters", "text": "The concept of coherent sample sets for a gene can be generalized for a set of genes. Given a set of genes G, a Input: the maximal coherent samples sets for genes, // from the algorithm in Figure 3 Output: the complete set of coherent gene clusters Method:\ngenerate the inverted list for samples as described in Section 4.  maximal coherent sample set with respect to G is a set of samples SG such that (1) genes in G are coherent on SG; and (2) there exists no S \u2283 S G that samples in G are also coherent on S . Please note that there can be more than one maximal coherent sample set for a given set of genes.\nHow can we compute the maximal coherent sample sets efficiently? Interestingly, SG can be computed by some simple intersection operations. For example, suppose S {g 1 } = {(s 1 , s 2 , s 3 )} and S {g 2 } = {(s 2 , s 3 , s 4 ), (s 5 , s 7 )}. Then, {s 2 , s 3 } is the only maximal sample set that both g 1 and g2 are coherent on. That is, S {g 1 ,g 2 } = {(s2, s3)}. In other words, we can derive S {g 1 ,g 2 } from {s1, s2, s3} \u2229 {s2, s3, s4} and {s 1 , s 2 , s 3 } \u2229 {s 5 , s 7 }.\nIn general, if gene set G = G 1 \u222a G 2 , then S G can be derived from S G 1 and S G 2 by the function find-max-coherentsample-sets in Figure 7.", "publication_ref": [], "figure_ref": ["fig_4"], "table_ref": []}, {"heading": "Pruning Irrelevant Genes and Unpromising Coherent Gene Clusters", "text": "Similar to the idea in Section 4.1.2, we can prune genes that cannot be used to extend the current combination of genes. Given a set of genes G = {g i 1 , . . . , g i k }, where 1 \u2264 i i < \u2022 \u2022 \u2022 < i k , a gene g j cannot be used to extend G to a larger set of genes if j \u2264 i k or none of the maximal coherent sample set with respect to G \u222a {gj} has at least mins samples. Moreover, let G tail be the set of genes that can be used to extend G. If |G| + |G tail | < min g , then G should be pruned.\nBased on the same idea in Section 4.1.3, we can use the maximal coherent gene clusters to prune the unpromising coherent gene clusters. Suppose we are searching a gene combination G 1 . Let S 1 be one maximal coherent sample set with respect to G 1 , i.e., S 1 \u2208 S G 1 . If there exists a max- \n\u2208 S G 2 do let S k = S i \u2229 S j ; if |S k | \u2265 mins then insert S k into S G 1 \u222aG 2 ; end-for end-for for each S k \u2208 S G 1 \u222aG 2 do if S k is a proper subset of S \u2208 S G 1 \u222aG 2 then S G 1 \u222aG 2 = S G 1 \u222aG 2 \u2212 {S k }; end-for output S G 1 \u222aG 2 ;\nFigure 7: Computing maximal coherent sample set for a set of genes. imal coherent gene cluster (G \u00d7 S) such that S1 \u2286 S and G 1 \u2286 G, then S 1 should be removed from the list of the maximal coherent sample sets S G 1 , since it cannot lead to any maximal coherent gene cluster. Moreover, if S G 1 becomes empty after the pruning, then G1 should be pruned, since any recursive search from G1 cannot lead to any maximal coherent gene cluster.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Merging Coherent Genes in the Tail List", "text": "In our running example, the maximal coherent sample sets with respect to gene g 1 and g 3 are identical. Then, for any coherent gene cluster (G\u00d7S) such that g 1 \u2208 G, (G\u222a{g 3 }\u00d7S) must also be a coherent gene cluster. Thus, we can search {g1, ge} in a shoot.\nIn general, we have the following result.\nLemma 4.1. When search a combination of genes G, if there exist genes {g j 1 , . . . , g j k } \u2286 G tail such that they are coherent on every maximal coherent sample set of G, then there exists no maximal coherent gene cluster containing G but no {gj 1 , . . . , gj k }.\nBased on Lemma 4.1, we can immediately merge genes {g j 1 , . . . , g j k } to G at the current node, and thus shrink the number of recursions. The computation time is saved as well, since we only need to check the coherent gene clusters, prune the irrelevant genes or unpromising gene clusters for all these genes in one shoot.\nIn our experiments on real data sets, we observe many genes can be merged by Lemma 4.1. The real-world 3dimensional microarray data sets are typically sparse and genes are coherent on a quite small number of sample sets. As a consequence, the performance of Gene-Sample Search can be improved substantially by this optimization.\nOne may ask, \"Do we have a symmetric pruning for Sample-Gene Search?\" We can apply the similar optimization technique for sample-gene. That is, a sample sj is merged into current combination of samples S as long as the inverted list of S is a subset of that of s j . However, such a situation is rare in practice, since it is rare that, for two different sample sets S1 and S2, the maximal coherent gene sets with respect to S1 and S2 are identical.\nBased on the above discussion, we have the Gene-Sample Search algorithm as shown in Figure 8.\nInput and output: same as the Sample-Gene Search algorithm (Figure 6) Method:\nfor \ni = 1 to (|G-Set| \u2212 min g ) do let G = {g i }\n(S G = \u2205) then return; while G tail = \u2205 do let i = min{j|g j \u2208 G tail }; let G tail = G tail \u2212 {g i }; call recursive-search(G \u222a {g i }, G tail ); end-while for each sample set S i in S G do output (G \u00d7 S i )\nas a maximal coherent gene cluster if it is not subsumed by any maximal coherent gene cluster found before end-for End ", "publication_ref": [], "figure_ref": ["fig_9", "fig_8"], "table_ref": []}, {"heading": "EXPERIMENTAL RESULTS", "text": "We implemented and tested our approaches on both a real 3-d microarray data set and synthetic data sets. The system is implemented in Java. The tests are conducted on a Sun Ultra 10 work station with a 440MHz CPU and 256 MB main memory.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "The Data Sets", "text": "The real data set. We use the real three-dimensional gene expression data set reported in [20]. It consists of the microarray measurements of 4, 324 genes in 13 multiple sclerosis (MS) patients before and at 1, 2, 4, 8, 24, 48, 120 and 168 hours after IFN-\u03b2 treatments. MS patients show heterogeneous responses to IFN-\u03b2 treatments. For example, the patients with relapsing MS respond better to IFN-\u03b2 treatments than the patients with progressive disease do. However, relapsing MS patients also exhibit considerable interindividual heterogeneity in their clinical responses to IFN-\u03b2 therapies. So far, the effects of IFN-\u03b2 treatment at the genomic level in humans are poorly understood. Researchers are interested in distinguishing the heterogeneous clinical response to IFN-\u03b2 therapy among the patients. On the other hand, characterized gene expression dynamics correlated to the heterogeneous responses potentially help in exploring the causing mechanisms at the molecular level. Synthetic data. We observe that the preprocessing, i.e., mining the maximal coherent sample sets for each individual gene, is relatively fast. The major bottleneck in mining coherent gene clusters is in the latter part. Therefore, instead of generating 3-d synthetic data sets, we simulate the table of maximal coherent sample sets for genes such as in Figure 5(a). Initially, an empty table is created. Then, a certain number of coherent gene clusters (G \u00d7 S) are randomly generated. For each g \u2208 G, S is inserted into the table as one maximal coherent sample set with respect to g. In addition to the size of the synthetic data set, i.e., the total number of genes in G-Set and the number of samples in S-Set, the synthetic data generator takes the following parameters: (1) k, the number of coherent gene clusters in the data set; (2) maxgene and mingene, the maximal and minimal numbers of genes in a coherent gene cluster, respectively; and (3) max sample and min sample , the maximal and minimal numbers of samples in a cluster, respectively.\nWe generate the data sets by setting min gene = 10 and min sample = 5. max sample is set to the same value of |S-Set|, and maxgene is set to 1000. In practice, only a small number of genes are correlated with a phenotype [7]. When the size of the data set grows, we expect to see more coherent gene clusters. To simulate the situation, we set k to |G-Set|\u2022|S-Set| 3000\n.", "publication_ref": ["b19", "b6"], "figure_ref": ["fig_6"], "table_ref": []}, {"heading": "Results on the MS Microarray Data", "text": "We apply our algorithms on the MS microarray data with ming = 15, mins = 3 and \u03b4 = 0.8. In total, 21 coherent gene clusters are reported. To better understand the mining results, we feed the genes in each cluster to Onto-Express (http://vortex.cs.wayne.edu/Projects.html) and obtain a hierarchy of functional annotations in terms of Gene Ontology for each cluster. An example of gene ontology tree for cluster 17 is shown in Figure 9(a). Then, we further investigate the genes and samples in the clusters. Some interesting observations are obtained as follows.\nFirst, as expected, the majority genes in the clusters are involved in cellular processes and physiological processes, while genes involved in other biological processes (e.g., development, behavior and viral life cycle) are not highly represented (Figure 9(b)). Moreover, among the genes involved in cellular process, those involved in cell communication and cell growth and/or maintenance are predominant (Figure 9(c)). Since IFN-\u03b2 is known to have anti-proliferative activities, the high population of cellular process genes involved in cell growth and/or maintenance is biologically plausible.\nSecond, a bunch of genes (e.g., in cluster 10, genes H38522, AA704613, N 92443, N 75595, etc.) that are well known for transcriptional signaling and cellular signaling can be identified in the resulted clusters. Those genes, together with the other genes in the same cluster that are unknown or poorly understood, may serve as switches in the genetic network and hence play an essential role in the biological processes. Thus, studying the time-series of the genes in the coherent gene clusters may greatly help people understand the regulatory mechanisms behind the response to IFN-\u03b2 treatment.\nLast, coherent gene clusters also consist of different groupings of samples, which provide promising hypothesis for different phenotypes. For example, in the MS microarray data, the expression data from patients with different responses to IFN-\u03b2 treatment are collected. Among the 21 reported clusters, only 2 clusters (cluster 10 and 17) consist of 4 samples, while other clusters only consist of the min s number of samples. Therefore, those two clusters may become good candidates for target phenotype. Based on the clinical records of the patients, and combined with the gene information from the clusters, the interpretation of the sample groups is currently under investigation. ", "publication_ref": [], "figure_ref": ["fig_10", "fig_10", "fig_10"], "table_ref": []}, {"heading": "Effects of the Parameters", "text": "The maximal coherent gene cluster is defined with respect to three parameters, i.e., the minimum number of genes min g , the minimum number of samples min s and the coherence threshold \u03b4. We test the effect of the parameters on the real 3-d data set. Figure 10(a) shows the number of coherent gene clusters when ming varies from 5 to 100, mins = 3 and \u03b4 = 0.8. Clearly, the number of coherent gene clusters in the data set decreases when min g increases. The result concurs the intuition: with a lower min g value, we can catch more clusters with more or less genes. As a matter of fact, with fixed mins and \u03b4, let Bi be the complete set of coherent blocks when ming = i. Then, we can show B 1 \u2287 . . . B i \u2287 . . . B n .\nFigure 10(b) shows the number of coherent gene clusters with respect to various min s when min g and \u03b4 are fixed to 10 and 0.8, respectively. This result can be explained in a way similar to the situation of min g . Figure 10(c) shows the effect of \u03b4 on the number of coherent gene clusters in the data set, with min g = 10 and min s = 3. When we lower the coherence threshold, more combinations of samples are \"coherent\" by chance with respect to a minimum of ming genes. Interestingly, the three curves in Figure 10 share similar trends. That is, when the value of the parameter (represented by the X axis) increases, the number of coherent gene clusters (represented by the Y axis) goes down. The curve drops sharply until a \"knot\" is met, then the curve goes stably to the right. For example, we can see the \"knots\" of min g = 20 in Figure 10(a), min s = 4 in Figure 10(b) and \u03b4 = 0.85 in Figure 10(c). These \"knots\" indicate that there exist stable and significant coherent gene clusters in the real data set. They are highly correlated, involving a statistically significant number of genes and samples. The \"knots\" also suggest the best settings of the parameters to avoid the coherent gene clusters formed just by chance.", "publication_ref": [], "figure_ref": ["fig_0", "fig_0", "fig_0", "fig_0", "fig_0", "fig_0", "fig_0"], "table_ref": []}, {"heading": "Scalability", "text": "We first test the efficiency of the preprocessing (algorithm in Figure 3) on various random subsets (by sampling) of the real microarray data set. The size of the subsets varies from 500 to 4324 genes, and all the samples are included. For each size, we sampled 30 subsets and calculate the average runtime. Figure 11(a) illustrates the scalability for the preprocessing step. As we discussed in Section 3, the real 3-d microarray data sets are often sparse. With the efficient pruning techniques, the preprocessing algorithm is linearly scalable to the size of the data sets.\nWe then test the scalability of both Gene-Sample Search and Sample-Gene Search on synthetic data sets. We set min s = 5, min g = 10, and \u03b4 = 0.8. We first fix the number of samples to 30, and report the runtime with respect to number of genes (Figure 11(b)). We can see both approaches show an approximately linear scalability with respect to the number of genes. Figure 11(c) shows the scalability for both approaches under different sizes of sample sets (from 30 to 100), when the number of genes is fixed to 3000. We can see both approaches scale well with respect to the number of samples. Since the number of genes for a microarray data is typically by far larger than that of the samples, the enumer- ation of genes is much more expensive than the enumeration of samples. This explains why the Sample-Gene Search is faster than the Gene-Sample Search.", "publication_ref": [], "figure_ref": ["fig_4", "fig_0", "fig_0", "fig_0"], "table_ref": []}, {"heading": "The Effect of Lemma 4.1", "text": "Lemma 4.1 can identify the genes g i that can be merged into the current combination of genes, and thus can reduce the number of recursions in the mining. We use some samples of the real microarray data set (each subset contains 100 to 1000 genes and 12 patients) to compare the performance of the Gene-Sample Search with and without the optimization. The comparison is conducted in three aspects: (1) the maximal number of recursion levels in the Gene-Sample Search; (2) the number of gene combinations in the Gene-Sample Search; and (3) the runtime. Figure 12 shows the results. We can clearly see that (1) the maximal number of recursion levels can be reduced substantially (Figure 12(a));\n(2) with the optimization, the total number of gene combinations needed to be checked goes down sharply (12(b)); and (3) the runtime is much shorter when the optimization is applied (12(c)). The results strongly confirm that the optimization is effective for Gene-Sample Search.\nWe also apply the spirit of Lemma 4.1 on the Sample-Gene Search, and conduct similar tests. However, we can hardly see any significant improvement brought by the optimization. As we discussed in Section 4.2.3, due to the sparsity of the microarray data, many genes can be merged because they are coherent on the same sample set. However, few samples would be merged together since usually the maximal coherent gene sets with respect to two different sample sets are not identical.", "publication_ref": [], "figure_ref": ["fig_0", "fig_0"], "table_ref": []}, {"heading": "RELATED WORK", "text": "This research is related to previous work on clustering 2dimensional microarray data and frequent itemset mining.\nAs introduced in Section 1, there are two categories of two-dimensional microarray data sets: time series data sets and sample data sets. For time series data sets, various algorithms (e.g. [17,15,8]) have focused on clustering on the gene dimension. That is, co-expressed genes are grouped based on their expression patterns during the time series. On the other hand, different approaches (e.g. [4,21,16]) have been proposed to partition the sample data sets along the sample dimension to find their macroscopic phenotypes as well as to detect informative genes which manifest the sample partition. However, all the cluster models in those previous studies are substantially different from our coherent gene clusters. As a consequence, those algorithms cannot be extended directly to solve our problem.\nIn [6], Cheng and Church introduce the concept of bicluster to measure the coherence between genes and conditions (either time series or samples). Given a set of genes and a set of conditions, a bicluster is a subset of genes coherent with a subset of conditions. Yang et al. [22] propose a move-based algorithm to find biclusters more efficiently. Both algorithms in [6] and [22] adopt heuristic search approaches, and thus cannot guarantee to find the complete set of biclusters in the data set.\nIn [19], Wang  We borrow some important ideas from previous studies on frequent itemset mining. First, the framework of our approaches is similar in spirit to that of pattern-growth methods for frequent pattern mining. Second, the pruning techniques in our approaches share some interesting similarities with the methods of mining frequent closed itemsets (e.g., [10]). However, there are two essential differences between the frequent pattern mining methods and the approaches developed in this paper. On the one hand, the coherent gene clusters are inherently different from frequent itemsets. Thus, the similarity between the two categories of methods is only at the level of spirit (e.g., set enumeration and pruning). The technical details are dramatically different. On the other hand, new techniques such as the inverted lists are adopted to tackle the particular microarray data.", "publication_ref": ["b16", "b14", "b7", "b3", "b20", "b15", "b5", "b21", "b5", "b21", "b18", "b9"], "figure_ref": [], "table_ref": []}, {"heading": "CONCLUSIONS", "text": "In this paper, we investigate a novel type of three-dimensional microarray data sets and propose a new problem of mining coherent gene clusters from such data sets. We conduct a systematic study to develop two mining methods: the Sample-Gene Search and the Gene-Sample Search. Our extensive performance study on both a real microarray data set and synthetic data sets shows that there exist interesting and significant coherent gene clusters in the real data set, and both the algorithms have good performance. Since the number of genes in the microarray data is typically by far larger than the number of samples, the Sample-Gene Search usually outperforms the Gene-Sample Search.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "ACKNOWLEDGEMENTS", "text": "We are grateful to the anonymous reviewers for their insightful comments.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Distinct types of diffuse large b-cell lymphoma identified by gene expression profiling", "journal": "Nature", "year": "2000-02", "authors": "A A Alizadeh"}, {"ref_id": "b1", "title": "Broad patterns of gene expression revealed by clustering analysis of tumor and normal colon tissues probed by oligonucleotide array", "journal": "", "year": "1999-06", "authors": "U Alon"}, {"ref_id": "b2", "title": "Calculation of the minimum number of replicate spots required for detection of significant gene expression fold change in microarray experiments", "journal": "Bioinformatics", "year": "2002", "authors": "M A Black; R W Doerge"}, {"ref_id": "b3", "title": "Class discovery in gene expression data", "journal": "", "year": "2001", "authors": "A Ben-Dor"}, {"ref_id": "b4", "title": "Bootstrapping cluster analysis: Assessing the reliability of conclusions from microarray experiments", "journal": "", "year": "", "authors": "M K Kerr; G A Churchill"}, {"ref_id": "b5", "title": "Biclustering of expression data", "journal": "", "year": "2000", "authors": "Y Cheng; G Church"}, {"ref_id": "b6", "title": "Molecular classification of cancer: Class discovery and class prediction by gene expression monitoring", "journal": "Science", "year": "1999-10", "authors": "T R Golub"}, {"ref_id": "b7", "title": "Interactive Exploration of Coherent Patterns in Time-Series Gene Expression Data", "journal": "", "year": "", "authors": "D Jiang"}, {"ref_id": "b8", "title": "Analysis of Molecular Profile Data Using Generative and Discriminative Methods", "journal": "Physiological Genomics", "year": "2000", "authors": "E J Moler"}, {"ref_id": "b9", "title": "CLOSET: An efficient algorithm for mining frequent closed itemsets", "journal": "", "year": "", "authors": "Pei J "}, {"ref_id": "b10", "title": "A Fast Algorithm for Maximal Pattern-based Clusterin", "journal": "", "year": "", "authors": "Pei J "}, {"ref_id": "b11", "title": "Large-Scale Clustering of cDNA-Fingerprinting Data", "journal": "Genome Research", "year": "1999", "authors": "R Herwig"}, {"ref_id": "b12", "title": "Search through systematic set enumeration", "journal": "", "year": "", "authors": "R Rymon"}, {"ref_id": "b13", "title": "Comparison of discrimination methods for the classification of tumors using gene expression data", "journal": "J. of the American Statistical Association", "year": "", "authors": "S Dudoit"}, {"ref_id": "b14", "title": "Interpreting patterns of gene expression with self-organizing maps: Methods and application to hematopoietic differentiation", "journal": "", "year": "1999-03", "authors": "P Tamayo"}, {"ref_id": "b15", "title": "Mining phenotypes and informative genes from gene expression data", "journal": "", "year": "", "authors": "C Tang"}, {"ref_id": "b16", "title": "Systematic determination of genetic network architecture", "journal": "Nature Genet", "year": "1999", "authors": "S Tavazoie"}, {"ref_id": "b17", "title": "Significance Analysis of Microarrays Applied to the Ionizing Radiation Response", "journal": "", "year": "2001-04", "authors": "V G Tusher"}, {"ref_id": "b18", "title": "Clustering by Pattern Similarity in Large Data Sets", "journal": "", "year": "2002", "authors": "H Wang"}, {"ref_id": "b19", "title": "Genomic effects of interferon-b in multiple sclerosis patients. Accepted pending revisions", "journal": "Journal of Immunology", "year": "2003", "authors": "B Weinstock-Guttman"}, {"ref_id": "b20", "title": "Clustering of high-dimensional microarray data via iterative feature filtering using normalized cuts", "journal": "Bioinformatics", "year": "2001", "authors": "E P Xing; R M Karp;  Cliff"}, {"ref_id": "b21", "title": "\u03b4-cluster: Capturing Subspace Correlation in a Large Data Set", "journal": "", "year": "2002", "authors": "J Yang"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 1 :1Figure 1: The structure of 3-d microarray data", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 2 :2Figure 2: Enumeration of combinations of samples.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "For example, consider a set of samples S = {a, b, c, d}. The complete set of non-empty combinations of samples can be divided into 4 exclusive subsets: (1) the ones having sample a; (2) the ones having sample b but no a; (3) the ones having sample c but no a or b; and (4) {d}. They are shown as the immediate children of the root in Figure 2.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Procedure: search-clique(head, tail) // head records the samples in the current node suppose s i is the last sample in head, remove samples s j from tail such that c i,j = 0; // Lemma 3.1 if (|head \u222a tail| < min s ) // Pruning 3.1 or (head \u222a tail \u2282 S) s.t. S is a maximal clique // Pruning 3.2 then return; //abort the recursive search if tail = \u2205 then output a maximal clique; else do let j = min{k|s k \u2208 tail} and tail = tail \u2212 {s j }; call search-clique(head \u222a {s j }, tail); until tail = \u2205; return;", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "Figure 3 :3Figure 3: Computing maximal coherent sample sets.", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_5", "figure_caption": "Figure 4 :4Figure 4: The frameworks of the Sample-Gene Search and the Gene-Sample Search.", "figure_data": ""}, {"figure_label": "5", "figure_type": "figure", "figure_id": "fig_6", "figure_caption": "Figure 5 :5Figure 5: The maximal coherent sample sets and the inverted lists.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_7", "figure_caption": "(a). Instead, we only need to get the intersection of the inverted lists of the samples s 1 , s 2 and s 3 , which is {g 1 .b 1 , g 3 .b 1 , g 4 .b 1 }. By this intersection, we know that {g 1 , g 3 , g 4 } is the maximal coherent gene set.", "figure_data": ""}, {"figure_label": "6", "figure_type": "figure", "figure_id": "fig_8", "figure_caption": "Figure 6 :6Figure 6: The Sample-Gene Search algorithm.", "figure_data": ""}, {"figure_label": "8", "figure_type": "figure", "figure_id": "fig_9", "figure_caption": "Figure 8 :8Figure 8: The Gene-Sample Search algorithm.", "figure_data": ""}, {"figure_label": "9", "figure_type": "figure", "figure_id": "fig_10", "figure_caption": "Figure 9 :9Figure 9: The gene ontology tree and the distribution of functions for genes in cluster 17.", "figure_data": ""}, {"figure_label": "31011", "figure_type": "figure", "figure_id": "fig_11", "figure_caption": "3 Figure 10 :Figure 11 :31011Figure 10: The effects of the parameters on the number of clusters.", "figure_data": ""}, {"figure_label": "12", "figure_type": "figure", "figure_id": "fig_12", "figure_caption": "Figure 12 :12Figure 12: Effect of Lemma 4.1 for Gene-Sample Search.", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "The Sample-Gene Search depth-first enumerate subsets of samples for each subset of samples S do find the maximal subsets of genes G s.t. G \u00d7 S is a coherent gene cluster; test whether (G \u00d7 S) is a maximal coherent gene cluster; end-for", "figure_data": "The Gene-Sample Searchdepth-first enumerate subsets of genesfor each subset of genes G dofind the maximal subsets of samples Ss.t. G \u00d7 S is a coherent gene cluster;test whether (G \u00d7 S) is a maximal coherent genecluster;end-for"}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "Gene Maximal coherent sample sets g 1 {s 1 , s 2 , s 3 , s 4 , s 5 } g 2 {s 1 , s 2 , s 4 }, {s 1 , s 5 } g 3 {s 1 , s 2 , s 3 , s 4 , s 5 } g 4 {s 1 , s 2 , s 3 }, {s 5 , s 6 } g 5 {s 1 , s 5 , s 6 } (a) The maximal coherent sample sets for genes", "figure_data": "SampleThe inverted lists 1"}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_2", "figure_caption": "1.1; for i = 1 to (|S-Set| \u2212 mins) do let S = {s i } and S tail = {s i+1 , . . . , s |S-Set| }; call recursive-search(S, S tail );", "figure_data": "end-forProcedure: recursive-search(S, S tail ) remove irrelevant samples from S tail as described in Section 4.1.2;if (|S| + |S tail | < mins) then return; derive the intersection of inverted lists for samplesin S as described in Section 4.1.1;if S can be pruned by the criteria inSection 4.1.3 then return;while S tail = \u2205 do let i = min{j|s j \u2208 S tail }; let tail = tail \u2212 {s i }; call recursive-search(S \u222a {s i }, S tail ); end-whilederive the maximal coherent gene set G S ; output (G S \u00d7 S) as a maximal coherent gene cluster if it is not subsumed by any maximal coherent genecluster found beforeEnd"}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_3", "figure_caption": "Function find-max-coherent-sample-sets Input: gene sets G 1 and G 2 , sets of maximal coherent sample sets S G 1 and S G 2 ; Output: the maximal coherent sample sets w.r.t. G 1 \u222a G 2 Method: let S G 1 \u222aG 2 = \u2205; for each maximal coherent sample set S i \u2208 S G 1 do for each maximal coherent sample set S j", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_4", "figure_caption": "and G tail = {g i+1 , . . . , g |G-Set| }; call recursive-search(G, G tail ); end-for Procedure: recursive-search(G, G tail ) remove irrelevant genes from G tail as described in Section 4.2.2; if (|G| + |G tail | < ming) then return; merge coherent genes in G tail as described in Section 4.2.3; for each maximal coherent sample set S i \u2208 S G do if S i can be pruned by the second criteria in Section 4.2.2 then remove S i from S G ; end-for if", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "(1 \u2264 i \u2264 n) on sample s j (1 \u2264 j \u2264 l).", "formula_coordinates": [2.0, 316.81, 366.74, 239.11, 20.27]}, {"formula_id": "formula_1", "formula_text": "T t=1 (m t i,j 1 \u2212 m i,j 1 )(m t i,j 2 \u2212 m i,j 2 ) T t=1 (m t i,j 1 \u2212 m i,j 1 ) 2 T t=1 (m t i,j 2 \u2212 m i,j 2 ) 2 ,", "formula_coordinates": [2.0, 358.92, 583.36, 175.03, 30.64]}, {"formula_id": "formula_2", "formula_text": "mi,j = T t=1 m t i,j T", "formula_coordinates": [2.0, 343.05, 621.29, 68.7, 16.75]}, {"formula_id": "formula_3", "formula_text": "{s i 1 , . . . , s i k } (1 \u2264 i 1 < \u2022 \u2022 \u2022 < i k \u2264 l),", "formula_coordinates": [3.0, 316.81, 541.18, 239.11, 20.34]}, {"formula_id": "formula_4", "formula_text": "Lemma 3.1. At node v = {si 1 , . . . , si k } of the sample set enumeration tree, where (1 \u2264 i 1 < \u2022 \u2022 \u2022 < i k \u2264 l), a sample s j \u2208 T ail if (1) j \u2264 i k ; or (2) there exists some 1 \u2264 l \u2264 k such that c i l ,j = 0. Moreover, for v's parent node v = {si 1 , . . . , si k\u22121 }, v's T ail is a subset of that of v .", "formula_coordinates": [3.0, 316.81, 600.9, 239.11, 52.85]}, {"formula_id": "formula_5", "formula_text": "{g 1 .b 1 , g 2 .b 1 , g 2 .b 2 , g 3 .b 1 , g 4 .b 1 , g 5 .b 1 } s 2 {g 1 .b 1 , g 2 .b 1 , g 3 .b 1 , g 4 .b 1 } s 3 {g 1 .b 1 , g 3 .b 1 , g 4 .b 1 } s 4 {g 1 .b 1 , g 2 .b 1 , g 3 .b 1 } s 5 {g 1 .b 1 , g 2 .b 2 , g 3 .b 1 , g 4 .b 2 , g 5 .b 1 } s 6 {g 4 .b 2 , g 5 .b 1 } (b)", "formula_coordinates": [5.0, 100.75, 141.89, 165.34, 67.4]}, {"formula_id": "formula_6", "formula_text": "g 2 .b 1 = {s 1 , s 2 , s 4 } and g 2 .b 2 = {s 1 , s 5 }.", "formula_coordinates": [5.0, 53.79, 510.1, 239.1, 20.28]}, {"formula_id": "formula_7", "formula_text": "\u2208 S G 2 do let S k = S i \u2229 S j ; if |S k | \u2265 mins then insert S k into S G 1 \u222aG 2 ; end-for end-for for each S k \u2208 S G 1 \u222aG 2 do if S k is a proper subset of S \u2208 S G 1 \u222aG 2 then S G 1 \u222aG 2 = S G 1 \u222aG 2 \u2212 {S k }; end-for output S G 1 \u222aG 2 ;", "formula_coordinates": [6.0, 333.75, 125.21, 203.4, 90.96]}, {"formula_id": "formula_8", "formula_text": "i = 1 to (|G-Set| \u2212 min g ) do let G = {g i }", "formula_coordinates": [7.0, 83.43, 89.34, 110.15, 18.16]}, {"formula_id": "formula_9", "formula_text": "(S G = \u2205) then return; while G tail = \u2205 do let i = min{j|g j \u2208 G tail }; let G tail = G tail \u2212 {g i }; call recursive-search(G \u222a {g i }, G tail ); end-while for each sample set S i in S G do output (G \u00d7 S i )", "formula_coordinates": [7.0, 70.74, 224.38, 154.58, 71.96]}], "doi": ""}