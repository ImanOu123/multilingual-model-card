{"title": "Completeness and Diversity in Depth-First Proof-Number Search with Applications to Retrosynthesis", "authors": "Christopher Franz; Georg Mogk; Thomas Mrziglod; Kevin Schewior;  Frankfurt;  Germany", "pub_date": "", "abstract": "We revisit Depth-First Proof-Number Search (DFPN), a well-known algorithm for solving twoplayer games. First, we consider the completeness property of the algorithm and its variants, i.e., whether they always find a winning strategy when there exists one. While it is known that the standard version is not complete, we show that the combination with the simple Threshold Controlling Algorithm is complete, solving an open problem from the area. Second, we modify DFPN to compute a diverse set of solutions rather than just a single one. Finally, we apply this new variant in Chemistry to the synthesis planning of new target molecules (Retrosynthesis). In this domain a diverse set of many solutions is desirable. We apply additional modifications from the literature to the algorithm and show that it outperforms Monte-Carlo Tree-Search, another well-known algorithm for the same problem, according to a natural diversity measure.", "sections": [{"heading": "Introduction", "text": "A challenging problem in AI is solving two-player games: Formally, one is given a directed graph, which in our case is finite. The game takes place by moving a token, initially on a given start node, between the nodes of the graph. At all times, depending on which node the token is on, either Player 0 or Player 1 may move the token along one of the outgoing edges to another node. Upon any such move, depending on the rules of the game, either of the players may win. The goal is to efficiently compute a winning strategy for either of the players or to decide that no such strategy exists.\nThe applications of this problem reach far beyond actual games such as Chess and Go [Pearl, 1984]. In particular, in this paper we consider applications to chemical synthesis planning [Heifets and Jurisica, 2012;Segler et al., 2018;Kishimoto et al., 2019]. Indeed, the problem of finding a plan (a route) to synthesize a given target molecule from commercially available molecules can be modeled such that a winning strategy for Player 0 corresponds to a synthesis route for the target molecule.\nWithout loss of generality, consider the problem of finding a winning strategy for Player 0 or deciding that no such strategy exists. A well-known algorithm for doing so when the input graph is a tree is the Proof-Number Search (PNS) [Allis et al., 1994]. This algorithm explores the tree starting from the start node along edges. In that context, one speaks of a node v being proved (disproved) when the algorithm has explored a set of nodes that certify that there is (not) a winning strategy for Player 0. To eventually prove or disprove the start node, each node of the tree is equipped with both a proof number and a disproof number. They are lower bounds on the number of nodes that have to be proved or disproved, respectively, to prove or disprove the corresponding node. These two numbers steer the order in which PNS explores nodes. A popular [Kishimoto and M\u00fcller, 2004a;Schaeffer et al., 2005] variant of this algorithm is the Depth-First Proof-Number Search (DFPN) [Nagai, 2002], which is more efficient with respect to both time and memory.\nIn practice, however, the input graph is often not a tree: For instance, in Chess, positions may be repeated. Also in Chemistry, a single molecule may be part of two different routes for synthesizing the same molecule, but as part of different reactions. On the emerging general graphs, several issues arise. Whether a player has won, may not just depend on the current position of the game, but also on the history of the game. This leads to the Graph History Interaction Problem [Campbell, 1985], which can be handled [Kishimoto and M\u00fcller, 2004b;Kishimoto, 2005] but, if unhandled, causes DFPN to provide incorrect outputs. Further, DFPN/PNS over-or underestimate the actual proof and disproof numbers due to double counting, an issue that can be mitigated, e.g., [Kishimoto, 2010], but not efficiently solved [Gao, 2021].\nArguably, the most severe issue about DFPN on general graphs is that it is not complete any more [Kishimoto and M\u00fcller, 2008], i.e., it is possible that there exists a winning strategy, but DFPN runs into an infinite loop rather than outputting the strategy. As proved in the same paper however, DFPN is complete on directed acyclic graphs. Refinements of DFPN that seem to be complete in experiments are dfpn(r) [Kishimoto, 2005] and DFPN with the Threshold Controlling Algorithm (TCA) [Kishimoto, 2010], but no proofs of completeness for such variants are known.\nA second and more practical concern with the state-of-theart DFPN is that it outputs an arbitrary winning strategy. In-deed, in practice, winning strategies may differ with respect to their quality, and a preferred output would be a qualitymaximizing winning strategy. In our specific application and arguably other applications, the quality of a synthesis route is, however, not well-defined and a matter of debate. Indeed, it is not clear how to choose the trade-off between quality measures such as safety, yield or difficulty of the route. Therefore, the ideal output seems to be a \"diverse\" set of routes, from which the user can pick.\nIn this paper, we address both concerns. First, we provide a proof of the completeness of DFPN with TCA, a variant for which completeness has been posed as an open problem [Kishimoto, 2010]. Second, we provide a general variant of DFPN which outputs a set of multiple solutions. We then experimentally evaluate the diversity of the output. We compare these results with the commonly used Monte-Carlo Tree Search (MCTS) [Browne et al., 2012].", "publication_ref": ["b12", "b8", "b0", "b7", "b12", "b12", "b2", "b8", "b9", "b10", "b6", "b8", "b9", "b10", "b10", "b2"], "figure_ref": [], "table_ref": []}, {"heading": "Our Contribution", "text": "The main theoretical contribution of this paper is a proof of completeness of DFPN with TCA in the general case. In other words, we show that DFPN with TCA always outputs a winning strategy when there exists one. Our proof can be viewed as an extension of the argument by Kishimoto and M\u00fcller [2008] for directed acyclic graphs. The main technical ingredient is a lemma that relates the distance of nodes from the start node, the crucial quantity used by TCA, to the length of a certain longest path from the start node to that node, the crucial quantity used in the aforementioned proof.\nWith that lemma at hand, only relatively minor modifications to the aforementioned proofs are needed.\nWe also contribute to the understanding of (regular) DFPN on general graphs by providing a simplified counterexample to the completeness. In contrast to the original example by Kishimoto and M\u00fcller [2008] that consists of 17 nodes, our example only consists of 10 nodes.\nTo address the need for a diverse set of solutions in applications such as retrosynthesis, we propose a novel modification of PNS and its variants that generates a set of solutions. Since PNS is an (up to tie breaking) deterministic algorithm, we cannot hope for a (large) set of solutions by running it multiple times. Instead, when the algorithm finds a solution, we first declare the last node of the solution as winning for Player 1 when visited through the same path. This strictly keeps the algorithm from finding the same solution again. To find a diverse set of solutions, we also modify proof and disproof numbers of the nodes that are part of the found solution by adding penalties. Then we iterate until time runs out.\nIn the experimental part of the paper, we consider the algorithm DFPN-E [Kishimoto et al., 2019] and adapt it to output a set of solutions in the described way. Note that this algorithm is a variant of DFPN that does not address the incompleteness issue; we still choose it here because it has been successfully applied to retrosynthesis. We call the algorithm that emerges DFPN* and apply it to retrosynthesis as well. We show that the diversity of routes found with DFPN* is greater than it is with MCTS. For a selection of 60 molecules with different levels of difficulty, we use both MCTS and DFPN* to identify potential synthesis routes for each molecule. We compare the results with respect to number of synthesized molecules, complexity of synthesis, diversity, and number of identified synthesis routes.\nNote that the term diversity is not sharply defined in this context, however, among chemists it means that different chemical ideas are observed between the individual synthetic routes. We use the total number of different intermediate molecules observed across the set of routes as a proxy for that measure.", "publication_ref": ["b8", "b8", "b8"], "figure_ref": [], "table_ref": []}, {"heading": "Further Related Work", "text": "Besides PNS and variants, other classic algorithms for solving two-player games include the \u03b1\u03b2 search [Knuth and Moore, 1975], in which scores are used to estimate the advantage of the players in certain situations, and the more recent Monte-Carlo Tree Search (MCTS) [Browne et al., 2012], which introduces randomization. While the most important literature on PNS has been mentioned, we still refer to the survey [Kishimoto et al., 2012].\nThe term retrosynthesis was first established by E. J. Corey [1967]. Subsequently, many different approaches to computer-assisted synthesis were developed; an overview of the most important ones can be found in [Szymku\u0107 et al., 2016]. Starting from the target molecule, the general approach is to recursively split up molecules by applying chemical reaction rules \"inversely\", i.e., by replacing the product with the reactants, until only buyable molecules are left. A winning strategy in the aforementioned game can be interpreted as doing exactly that.\nIndeed, search algorithms have been very successful for retrosynthesis. For instance, A*-Search [Chen et al., 2020;Badowski et al., 2019] and Monte-Carlo Tree Search [Segler et al., 2018;MLPDS, 2020] are used in various tools. In 2012, regular PNS was used for retrosynthesis [Heifets and Jurisica, 2012], whereas DFPN was first applied as part of the DFPN-E algorithm [Kishimoto et al., 2019] and later within the CompRet tool [Shibukawa et al., 2020].\nAlthough the topic of diversity is arguably quite important for various applications, there are relatively few sources in the literature. For instance, finding a set of synthesis plans has been looked at [Fagerberg et al., 2018] but not with explicit attention to diversity. Some first approaches to create diversity specific to chemistry can be found in [Schwaller et al., 2020]. Diversity has also been considered recently from a more theoretical point of view [Baste et al., 2020].", "publication_ref": ["b11", "b2", "b8", "b4", "b12", "b3", "b1", "b12", "b8", "b12", "b5", "b12", "b2"], "figure_ref": [], "table_ref": []}, {"heading": "Preliminaries", "text": "Basic Definitions. The input graph is a directed graph G = (V, E) where v 0 \u2208 V is the start node. Further, V is partitioned into V 0 and V 1 , the sets of nodes of Player 0 and Player 1, also referred to as AND and OR nodes, respectively. The sets W 0 and W 1 , the sets of winning nodes of Player 0 and Player 1, respectively, are disjoint subsets of V . Without loss of generality, we assume that \u2022 all neighbors of nodes in V 0 are in V 1 and vice versa.\n\u2022 for all v \u2208 V it holds that \u03b4 out G (v) = \u2205 if and only if v \u2208 W 0 \u222a W 1 . A play P is a sequence of v 0 , v 1 , . . . , v k such that for all i \u2208 {0, . . . , k \u2212 1}, we have v i+1 \u2208 N out G (v i ).\nIf P is a path in G, i.e., it contains each node at most once, we say P is winning for Player i \u2208 {0, 1} if v k \u2208 W i . If v 0 , . . . , v k\u22121 is a path and v k \u2208 {v 0 , . . . , v k\u22121 } (the last move closes a cycle), we assume the play is winning for either of the players, e.g., Player 0 wins or the Player i with v k\u22121 / \u2208 V i wins [Kishimoto and M\u00fcller, 2004b].\nA strategy for Player i \u2208 {0, 1} is a function \u03c3 :\nV i \u2192 V such that \u03c3(v) \u2208 N out G (v) for all v \u2208 V i .\nA pair of strategies for both players naturally induces a play (that stops the first time it is winning for one of the players). For i \u2208 {0, 1}, we say that a strategy \u03c3 i for Player 1 is a winning strategy if \u03c3 i and each strategy \u03c3 1\u2212i for Player 1 \u2212 i induces a play that is winning for Player i.\nProof-Number Search. Proof-Number Search (PNS) [Allis et al., 1994] explores G starting from v 0 , i.e., initially v 0 is explored, and all other nodes are not explored. No edges are explored at that time. PNS iteratively expands nodes v that were previously not expanded. This way, PNS learns if v \u2208 W i for i \u2208 {0, 1}, and all edges in \u03b4 out G (v) as well as v's children N out G (v) are explored. Note that, since G is not necessarily a tree, such endpoints have possibly been explored prior to the expansion of v.\nA node r is called proved if a winning strategy for Player 0 can be inferred from the explored part of G; if a winning strategy for Player 1 can be inferred, it is called disproved. A node that is neither proved nor disproved is said to be unproved.\nThe (dis)proof number of an explored node r is defined to be the minimum number of explored unproved nodes that have to be (dis)proved for r to be (dis)proved. Clearly, the (dis)proof number of a (dis)proved node is 0; by convention the proof number of a disproved node and the disproof number of a proved node is defined to be \u221e.\nFor any explored node v, PNS maintains estimates pn(v) and dn(v) for the proof and disproof numbers, respectively, of v. For any unexpanded node v \u2208 V (in particular, v 0 at initialization), PNS sets pn(v) = 1 and dn(v) = 1 in accordance with the definition of the actual proof and disproof numbers.\nIn each iteration, PNS selects a most promising node to expand. To do so, it first selects v 0 . If the currently selected node v has already been expanded, PNS distinguishes two cases.\nIf v \u2208 V 0 , PNS next selects a node c in N out (v) min- imizing pn(c). Otherwise, i.e., if v \u2208 V 1 , it selects a node c in N out G (v) minimizing dn(c).\nOnce PNS has selected an unexpanded node, it expands this node.\nAfter expanding a node, PNS first sets pn(v) = 1 and dn(v) = 1 for the newly explored nodes v (as described above). Then it updates pn(v) and dn(v) for all the nodes v selected between the expansion that just happened and the expansion before that, in reverse order of selecting. In particular, in case of the just expanded node, PNS may have learned that v \u2208 W i for i \u2208 {0, 1}, or a cycle has just been closed. In accordance with the definition of the actual proof and disproof numbers, upon learning Player 0 wins, it sets pn(v) = 0 and dn(v) = \u221e; upon learning that Player 1 wins, it sets pn(v) = \u221e and dn(v) = 0. In all other cases, for v \u2208 V 0 it sets pn(v) := min\nc\u2208N out G (v) pn(c); dn(v) := c\u2208N out G (v) dn(c), (1) and for v \u2208 V 1 it sets pn(v) := c\u2208N out G (v)\npn(c); dn(v) := min\nc\u2208N out G (v) dn(c). (2\n)\nIf G is an out-tree, it is easy to see that pn(v) and dn(v) reflect the actual (dis)proof numbers. In a general graph, however, as can be seen, e.g., in the graph shown in Figure 1, this is not necessarily the case.\nDepth-First Proof-Number Search. Depth-First Proof-Number Search (DFPN) [Nagai, 2002] does not start the search for the most promising node from v 0 in each iteration. Instead, when node v is currently selected, it tries to use thresholds th pn (v) and th dn (v) to decide whether the path taken from v 0 to v is part of a path that PNS would take. In particular, if\npn(v) < th pn (v); dn(v) < th dn (v),(3)\nthen it continues the search like PNS would, and otherwise it backtracks one step. The values of pn and dn are only recomputed at the node that DFPN is currently considering. The thresholds are determined as follows. Initially, th pn (v 0 ) := \u221e and th dn (v\n0 ) := \u221e. Suppose from node v, node c 1 is selected next, i.e., if v \u2208 V 0 (v \u2208 V 1 ), c 1 has the smallest value of pn (dn) among N out (v). If |N out (v)| = 1,\nthe thresholds for c 1 are taken over from v. Otherwise, let c 2 be a node that has the smallest value of pn (dn) among\nN out (v) \\ {c 1 }. If v \u2208 V 0 , th pn (c 1 ) := min{th pn (v), pn(c 2 ) + 1}, th dn (c 1 ) := th dn (v) \u2212 dn(v) + dn(c 1 ),(4)\nand if v \u2208 V 1 , th pn (c 1 ) := th pn (v) \u2212 pn(v) + pn(c 1 ), th dn (c 1 ) := min{th dn (v), dn(c 2 ) + 1}.\nGraph History Interaction Problem. As pointed out in [Palay, 1983], DFPN and PNS as stated above are not necessarily correct on graphs that contain cycles: A Proof or a disproof of some node v that is found when v is visited through some path P cannot certainly be reused when v is visited through some path P \u2032 \u0338 = P . This is called the Graph History Interaction Problem. As a general solution [Kishimoto and M\u00fcller, 2004b;Kishimoto, 2005], one can, upon (dis)proving a node when visiting it through P , save the (dis)proof only with respect to P . When visiting v again through P \u2032 , it can be verified if the previously found proof is still valid. For further details, we refer the reader to the aforementioned works.\nThreshold Controlling Algorithm. To break infinite loops, the Threshold Controlling Algorithm (TCA) [Kishimoto, 2010] maintains a value md(v) for every node v \u2208 V . It represents the (minimum) distance between v 0 and v in the\nv 0 v 1 v 2 v 3 v 4 v 5 v 6 v 7 v 8 v 9\nFigure 1: The graph G that shows that DFPN is not complete. The nodes in V0 and V1 are depicted as squares and circles, respectively.\nexplored part of G. Whenever a node v is visited that has an unproved old child c, i.e., md(c) \u2264 md(v), TCA adjusts th pn (v) and th dn (v) such that DFPN does not backtrack. In particular, it sets th pn (v) to max{th pn (v), pn(v) + 1} and th dn (v) to max{th dn (v), dn(v) + 1}, so that (3) is satisfied.\nThe fact that the thresholds have been increased is passed to subsequent recursive calls of the algorithm, prompting these calls to also increase the corresponding thresholds, until a node is expanded or a cycle is closed (i.e., progress is made).", "publication_ref": ["b8", "b0", "b12", "b12", "b8", "b9", "b10"], "figure_ref": [], "table_ref": []}, {"heading": "Completeness of DFPN with TCA", "text": "We start this section with (re-)justifying variants of DFPN by giving a counter example to the completeness of DFPN that is significantly simpler than the known counter example [Kishimoto and M\u00fcller, 2008]. In the second subsection, we then prove completeness of DFPN with TCA.", "publication_ref": ["b8"], "figure_ref": [], "table_ref": []}, {"heading": "Simpler Counter Example without TCA", "text": "We consider the graph shown in Figure 1. In that graph, DFPN visits v 6 and v 7 alternatingly from v 1 via v 2 , v 4 , v 6 and v 3 , v 5 , v 7 , respectively, in an infinite loop. In particular, it never expands v 8 . When W 0 = {v 9 } and W 1 = \u2205, DFPN therefore never discovers the only winning strategy for Player 0 from v 0 , which includes v 9 .", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Proof of Completeness with TCA", "text": "The purpose of this section is to prove the following theorem. Theorem 1. DFPN with TCA is complete.\nIn the proof, we assume towards a contradiction that DFPN with TCA runs into an infinite loop. First, we remove all the parts of G that are irrelevant during the infinite loop, obtaining a new graph L = (V \u2032 , E \u2032 ). More precisely, let P \u22c6 := v 0 , . . . , v \u22c6 be the largest path that is a prefix of P throughout the infinite loop. Then\n\u2022 V \u2032 contains all vertices in P \u22c6 , all vertices visited during the loop, and all their children; \u2022 E \u2032 contains all edges in P \u22c6 and outgoing edges from vertices visited during the loop. For instance, for the loop considered in Subsection 3.1, L would consist of all nodes but v 9 and all edges but the one leading to v 9 .\nFor a node, v \u2208 V \u2032 , we now define its level \u2113(v) to be the length of the longest v 0 -v path in L. Note that in the proof for DFPN on directed acyclic graphs [Kishimoto and M\u00fcller, 2008], levels are also used but defined on G rather than L. Let \u2113 max be the maximal level of any node in L. The fundamental property of L is the following.\nConsider a call during the infinite loop at some node n c that eventually returns because the threshold condition is not met anymore, i.e., pn(n c ) \u2265 th pn (n c ) or dn(n c ) \u2265 th dn (n c ). Denote by M the set of nodes (including n c ) at which the threshold condition had been violated in the meantime. Lemma 1. Consider some m \u2208 M . There is no node o \u2208 V \u2032 \\ {m} with \u2113(o) \u2265 \u2113(m) such that there exists a path from o to m in L.\nNote that the statement is trivially true in acyclic graphs, in which an v 0 -o path can always be extended by an o-m path to a longer path, but not in cyclic graphs. We provide a proof.\nProof of Lemma 1. Suppose such a node o exists, and denote by P \u2032 the o-m path in L. First note that o must be visited during the infinite loop. The reason is that otherwise\n\u2022 either o is part of P \u22c6 , in which case the only v 0 -o path in L (a prefix of P \u22c6 ) could be extended by an o-m path in L, contradicting \u2113(o) \u2265 \u2113(m); \u2022 or o is a child of a node visited during the loop with N out L (o) = \u2205, contradicting the fact that P \u2032 exists. Next, note that for any node p in P \u2032 (in particular m) it must hold that md(o) < md(p) during the loop. This is because otherwise there must exist a node p \u2032 on P \u2032 with successor p \u2032\u2032 on P \u2032 such that md(p \u2032 ) \u2265 md(p \u2032\u2032 ) . Upon visiting p \u2032 , TCA would then increase the thresholds. This already contradicts the assumption that DFPN with TCA is in an infinite loop because it would eventually make progress by either expanding an unexpanded node or finding a new cycle. Now consider the v 0 -o path P \u2032\u2032 of length \u2113(o) in L. Since \u2113(o) \u2265 \u2113(m), P \u2032\u2032 cannot be extended to a v 0 -m path by P \u2032 . The reason for that must be that P \u2032\u2032 intersects P \u2032 at some node p 0 . By the same argument as above, applied to the p 0 -o subpath of P \u2032\u2032 , it holds that md(p 0 ) < md(o).\nHence, md(o) < md(p 0 ) < md(o); a contradiction.\nThe remaining part of the proof is quite similar to the proof of completeness of directed acyclic graphs [Kishimoto and M\u00fcller, 2008]. Indeed, we call a node v \u2208 V \u2032 consistent if it fulfills (1) and (2) (as equations rather than assignments) and inconsistent otherwise. We also define the inconsistency tuple to be (N \u2113max , N \u2113max\u22121 , . . . , N 0 ) where, for i \u2208 {\u2113 max , . . . , 0}, N i is the number of inconsistent nodes at level i of L. We call\nL i-consistent if N \u2113max = N \u2113max\u22121 = \u2022 \u2022 \u2022 = N i = 0.\nUsing Lemma 1, the proofs of the following two lemmata are now quite similar to the completeness proof on acyclic graphs [Kishimoto and M\u00fcller, 2008]. Lemma 2. Let n \u2208 V \u2032 , suppose L is \u2113(n)-consistent, and pn(n) < th pn (n) as well as dn(n) < th dn (n) holds. If the algorithm now searches n, it will expand a node or find a new cycle before the call returns.\nFor the next lemma, recall that a tuple (a 1 , a 2 , . . . , a k ) is lexicographically smaller than a tuple (b\n1 , b 2 , . . . , b k ), de- noted (a 1 , a 2 , . . . , a k ) < lex (b 1 , b 2 , . . . , b k ), if for some i, it holds that a 1 = b 1 , a 2 = b 2 , . . . , a i = b i and a i+1 < b i+1 . Lemma 3.\nSuppose not all nodes in L are consistent. Denote by T and U the inconsistency tuples right before n c is searched and right after the call has returned, respectively. Then U < lex T .\nWe provide the remaining proofs in the full version.", "publication_ref": ["b8", "b8", "b8"], "figure_ref": [], "table_ref": []}, {"heading": "Adaptation of DFPN to Multiple Solutions", "text": "Since the algorithm is deterministic, running it multiple times would only lead to the same solution each time. To find multiple solutions, we modify PNS and its variants, we change the values of pn and dn for some nodes such that the last found solution becomes invalid. Here, the choice of nodes controls the type of diversity we obtain for the set of found solutions. However, since we might end up at these exact nodes by following a different path, we do not want to completely neglect such nodes. For that we keep track of the path we used to get to such a node and store it. If we encounter the same node again, we check if the path that was used to reach it was stored. If so, the node will stay disproved, otherwise we can use it again.\nTo further control the diversity of the solutions, the algorithm penalizes every node used by a found winning strategy. This happens by adding a penalty p AND to the values of pn for every AND-node v \u2208 V 1 in a path to a node selected by the above diversity controlling strategy: pn(v) := pn(v) + p AND . Adding a penalty p OR to the values of pn for all v \u2208 V 0 represents an additional approach. Afterwards the values of pn and dn of all previous nodes get updated according to (1) and (2). The penalties are adjustable. Higher penalties lead to more diverse routes but longer computation times.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Application to Retrosynthesis", "text": "Retrosynthetic planning is, as described in the introduction, the task of finding one or multiple suitable routes for the synthesis of a given target molecule. This challenge can also be modeled as a two player game in the following way: Here, one identifies the molecules with the nodes from which Player 0 may move, and the reactions with the nodes from which Player 1 may move. If a molecule is the product of a reaction or a reaction requires a certain molecule, a directed edge is added between the corresponding nodes. The node corresponding to the target molecule is the start node. Player 0 wins if a node corresponding to a buyable molecule is reached, and Player 1 wins if a dead end (not corresponding to a buyable molecule) is reached or a node is visited for the second time. Now a winning strategy for Player 0 represents a synthesis plan for the target molecule. If there exists a winning strategy for Player 1, the target molecule cannot be synthesized.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Heuristic Edge Cost in DFPN-E", "text": "Earlier we mentioned the DFPN-E algorithm by Kishimoto et al. [2019], which uses a heuristic function that evaluates the cost of using a certain edge from a molecule n to its child (i.e., reaction) c: h(n, c) = min(M pn , \u230a\u2212 log(P (n, a) + \u03f5) + 1\u230b), where the constant M pn is used to limit the size of h, and the constant \u03f5 prevents a calculation of log(0).\nFor every template (i.e., a class of reactions) a in a given database, P (n, a) represents the probability of this template a being used to synthesize the molecule n. template a to molecule n results in the reaction c, the child of n. While calculating pn(n), the value of h is added to pn(c) for all c \u2208 N out G (n). Additionally the computation of th pn (c 1 ) in ( 4) is modified to th pn (c 1 ) := min(th pn (n), pn(c 2 ) + \u03c3) \u2212 h(n, c 1 ), where \u03c3 is the so called threshold controlling parameter. It is used to limit the number of visits to the same node in a trade off to a potentially less precise search.", "publication_ref": ["b8"], "figure_ref": [], "table_ref": []}, {"heading": "Multiple Solutions in DFPN*", "text": "To obtain our algorithm DFPN* for Restrosynthesis, we apply a diversity controlling strategy from the framework from Section 4 to DFPN-E. More specifically, the single node we choose to disprove as part of our diversity controlling strategy is a deepest reaction in the found route, i.e., a reaction reached through a longest path from the target molecule. By doing so, we force the algorithm to find shorter routes without destroying too many possible routes. The reason we choose a reaction rather than a molecule to disprove is that disproving a molecule leads to a disproof of a reaction anyway. For the same reason, we set p OR = 0.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Experiments", "text": "In order to verify whether the MCTS and the DFPN* provide different quality levels in diversity, we performed computer experiments. We analyze a sample data set consisting of 60 molecules 1 . These are collected from different sources: 40 molecules picked up from a public benchmark data set on synthesizability [Ertl and Schuffenhauer, 2009] and 20 drug-like molecules were provided by Bayer chemists. These molecules have been classified by synthesis chemists from easy to challenging in synthesis. For these molecules we have determined synthesis routes by applying both DFPN* and MCTS.", "publication_ref": ["b5"], "figure_ref": [], "table_ref": []}, {"heading": "Setup", "text": "We use an Artificial Neural Network (ANN) to estimate the success probability P (n, a) that the molecule n can be synthesized in one step with the reaction template a. To train the ANN, we had a total of 31 million reactions at our disposal. These reactions were collected from several public and nonpublic data sources: 60% from publications and 40% from Bayer's internal laboratory journals.\nBased on the reaction database we have generated, after extensive data cleaning and preprocessing, 8,616,239 pairs (n, a) of molecules n and reaction templates a. In total, we have identified 270,605 reaction templates. The input to the neural network is the molecule n (converted to a Morgan fingerprint). The output is a vector of length 270,605, which indicates for each template the probability that the template can be successfully applied to n.\nTheoretically, more than 270,000 edges would be attached to each node. However, this is a priori reduced by similar heuristic rules described in [Segler et al., 2018] to a maximum of 35 edges.\nRecall DFPN-E is used as a foundation for our DFPN* algorithm. Constants such as M pn and \u03f5 are set as in [Kishimoto et al., 2019] (M pn = 20 and \u03f5 = 10 \u221230 ). The only constant we changed is the threshold controlling parameter \u03c3 (they call it \u03b4). Kishimoto et al. use \u03c3 = 2, whereas we set \u03c3 = 3, because it resulted in better overall solutions in our experiments. The penalties p AND and p OR from Section 4 were set to p AND = 10 and p OR = 0. In addition to the aforementioned solution to the Graph History Interaction Problem and the Threshold Controlling Algorithm, the DFPN* also implements a maximum search depth, limiting the amount of reactions that need to be executed consecutively for each synthesis. We set it to 7 and the maximum branching factor (i.e., the maximum amount of reactions for a molecule) to 50.\nFor MCTS we used the current version of [MLPDS, 2020] and, to match the parameters of DFPN*, the exploration constant was set to 2.0, the maximum depth to 7, and the maximum branching to 50. Chemicals were labeled buyable according to the chemical suppliers for Bayer Research.", "publication_ref": ["b12", "b8"], "figure_ref": [], "table_ref": []}, {"heading": "Results", "text": "MCTS and DFPN* were each run on a single core. The computing time varied between 120 s, 300 s, 600 s, 900 s, and 1200 s. The maximum number of routes was set to 500 for  both algorithms. After finishing the computation, the 500 routes with maximum success probability were picked from the set of found routes. We consider the following performance indicators: The number of molecules solved, the number of routes found per target molecule, the mean number of reactions per route, and the number of intermediate molecules for all routes of a target molecule (see Table 1). Here, the number of solved molecules is the most important quality criterion for the search algorithms. Both algorithms deliver similar results with a slight advantage for the DFPN*.\nIt turns out that that the number of routes that MCTS finds is much larger than that number for DFPN*. However, the sheer number of routes is arguably not important without considering their diversity.\nAs a measure of diversity, we use the total number of different intermediates used across all routes. If the same molecules always appear in different routes for a target molecule, this indicates that only little is changed in the routes; perhaps only the order of the reactions is switched.\nAlthough MCTS provides significantly more routes, the number of different molecules is actually much larger for the DFPN*; the routes of the DFPN* are more diverse.\nThe number of reactions per route is a measure of the synthesis effort. The average route length for DFPN* is shorter than for MCTS. This means that the higher diversity of the DFPN* is not caused by longer routes. On average, even one reaction step less is required than with MCTS.\nFigure 2 shows the evolution of diversity over computation time. In Figure 3, we see the evolution of the mean number of reactions per route of a solute target over computation time. We observe that the diversity advantages of DFPN* continues to expand, while with more computation time in MCTS, more costly routes tend to be found.", "publication_ref": [], "figure_ref": ["fig_0", "fig_1"], "table_ref": ["tab_1"]}, {"heading": "Conclusion", "text": "In this paper, we provided a proof of completeness of DFPN with TCA, adapted DFPN to finding multiple solutions, and conducted first experiments. Directions for future work include further experiments (in particular, comparisons with the other approaches discussed in Section 1.2) and considering parallelized verisons of PNS.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgements", "text": "We thank Yannic Alber for his help with the experiments.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "solved target molecules only", "text": "Proceedings of the Thirty-First International Joint Conference on Artificial Intelligence  ", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Maarten van der Meulen, and H. Jaap van den Herik. Proof-number search", "journal": "Artificial Intelligence", "year": "1994", "authors": "Allis "}, {"ref_id": "b1", "title": "Selection of cost-effective yet chemically diverse pathways from the networks of computer-generated retrosynthetic plans", "journal": "Chem. Sci", "year": "2019", "authors": "[ Badowski"}, {"ref_id": "b2", "title": "Diversity of solutions: An exploration through the lens of fixed-parameter tractability theory", "journal": "", "year": "1985", "authors": ""}, {"ref_id": "b3", "title": "Learning retrosynthetic planning with neural guided A* search", "journal": "", "year": "2020", "authors": "[ Chen"}, {"ref_id": "b4", "title": "General methods for the construction of complex molecules", "journal": "Pure and Applied Chemistry", "year": "1967", "authors": "; E J Corey;  Corey"}, {"ref_id": "b5", "title": "Estimation of synthetic accessibility score of drug-like molecules based on molecular complexity and fragment contributions", "journal": "Journal of Cheminformatics", "year": "2009", "authors": "Peter Ertl; Ansgar Schuffenhauer; ; Fagerberg"}, {"ref_id": "b6", "title": "On computation complexity of true proof number search. arXiv/cs.CC, abs/2102.04907, 2021. [Heifets and Jurisica, 2012] Abraham Heifets and Igor Jurisica. Construction of new medicines via game proof search", "journal": "", "year": "2012", "authors": "2021] Chao Gao;  Gao"}, {"ref_id": "b7", "title": "Akihiro Kishimoto and Martin M\u00fcller. Df-pn in go: An application to the one-eye problem", "journal": "", "year": "2004", "authors": "[ Kishimoto;  M\u00fcller"}, {"ref_id": "b8", "title": "Depth-first proof-number search with heuristic edge cost and application to chemical synthesis planning", "journal": "", "year": "2004", "authors": "Akihiro M\u00fcller; Martin Kishimoto; ; M\u00fcller;  Kishimoto"}, {"ref_id": "b9", "title": "Correct and efficient search algorithms in the presence of repetitions. PhD thesis", "journal": "", "year": "2005", "authors": " Kishimoto ; Akihiro;  Kishimoto"}, {"ref_id": "b10", "title": "Dealing with infinite loops, underestimation, and overestimation of depth-first proof-number search", "journal": "", "year": "1975", "authors": " Kishimoto; ; Kishimoto; E Donald; Ronald W Knuth"}, {"ref_id": "b11", "title": "An analysis of alpha-beta pruning", "journal": "", "year": "1975", "authors": "Moore "}, {"ref_id": "b12", "title": "CompRet: A comprehensive recommendation framework for chemical synthesis planning with algorithmic enumeration", "journal": "Addison-Wesley Longman Publishing Co., Inc", "year": "1983", "authors": "; A Nagai; J Nagai ; Andrew;  Palay;  Schaeffer"}], "figures": [{"figure_label": "2", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 2 :2Figure 2: Comparison of Diversity: Distributions of the mean total number of intermediate molecules per solved target molecule.", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 3 :3Figure 3: Comparison of Synthesis Effort: Distributions of the mean number of reactions per route for each solved target molecule.", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "Comparison of MCTS and DFPN*.", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "\u2022 for all v \u2208 V it holds that \u03b4 out G (v) = \u2205 if and only if v \u2208 W 0 \u222a W 1 . A play P is a sequence of v 0 , v 1 , . . . , v k such that for all i \u2208 {0, . . . , k \u2212 1}, we have v i+1 \u2208 N out G (v i ).", "formula_coordinates": [2.0, 326.46, 682.66, 231.55, 22.18]}, {"formula_id": "formula_1", "formula_text": "V i \u2192 V such that \u03c3(v) \u2208 N out G (v) for all v \u2208 V i .", "formula_coordinates": [3.0, 54.0, 145.87, 240.78, 21.86]}, {"formula_id": "formula_2", "formula_text": "If v \u2208 V 0 , PNS next selects a node c in N out (v) min- imizing pn(c). Otherwise, i.e., if v \u2208 V 1 , it selects a node c in N out G (v) minimizing dn(c).", "formula_coordinates": [3.0, 54.0, 550.11, 243.0, 34.39]}, {"formula_id": "formula_3", "formula_text": "c\u2208N out G (v) pn(c); dn(v) := c\u2208N out G (v) dn(c), (1) and for v \u2208 V 1 it sets pn(v) := c\u2208N out G (v)", "formula_coordinates": [3.0, 315.0, 86.05, 243.0, 73.41]}, {"formula_id": "formula_4", "formula_text": "c\u2208N out G (v) dn(c). (2", "formula_coordinates": [3.0, 474.35, 136.72, 79.78, 17.25]}, {"formula_id": "formula_5", "formula_text": ")", "formula_coordinates": [3.0, 554.13, 137.04, 3.87, 8.64]}, {"formula_id": "formula_6", "formula_text": "pn(v) < th pn (v); dn(v) < th dn (v),(3)", "formula_coordinates": [3.0, 361.2, 299.65, 196.8, 9.65]}, {"formula_id": "formula_7", "formula_text": "0 ) := \u221e. Suppose from node v, node c 1 is selected next, i.e., if v \u2208 V 0 (v \u2208 V 1 ), c 1 has the smallest value of pn (dn) among N out (v). If |N out (v)| = 1,", "formula_coordinates": [3.0, 315.0, 361.42, 243.0, 30.87]}, {"formula_id": "formula_8", "formula_text": "N out (v) \\ {c 1 }. If v \u2208 V 0 , th pn (c 1 ) := min{th pn (v), pn(c 2 ) + 1}, th dn (c 1 ) := th dn (v) \u2212 dn(v) + dn(c 1 ),(4)", "formula_coordinates": [3.0, 315.0, 414.64, 243.0, 43.11]}, {"formula_id": "formula_10", "formula_text": "v 0 v 1 v 2 v 3 v 4 v 5 v 6 v 7 v 8 v 9", "formula_coordinates": [4.0, 64.55, 59.42, 221.4, 41.54]}, {"formula_id": "formula_11", "formula_text": "L i-consistent if N \u2113max = N \u2113max\u22121 = \u2022 \u2022 \u2022 = N i = 0.", "formula_coordinates": [4.0, 315.0, 494.53, 242.99, 20.61]}, {"formula_id": "formula_12", "formula_text": "1 , b 2 , . . . , b k ), de- noted (a 1 , a 2 , . . . , a k ) < lex (b 1 , b 2 , . . . , b k ), if for some i, it holds that a 1 = b 1 , a 2 = b 2 , . . . , a i = b i and a i+1 < b i+1 . Lemma 3.", "formula_coordinates": [4.0, 315.0, 611.3, 243.0, 45.35]}], "doi": ""}