{"title": "Torch-Struct: Deep Structured Prediction Library", "authors": "Alexander M Rush; Cornell Tech", "pub_date": "", "abstract": "The literature on structured prediction for NLP describes a rich collection of distributions and algorithms over sequences, segmentations, alignments, and trees; however, these algorithms are difficult to utilize in deep learning frameworks. We introduce Torch-Struct, a library for structured prediction designed to take advantage of and integrate with vectorized, auto-differentiation based frameworks. Torch-Struct includes a broad collection of probabilistic structures accessed through a simple and flexible distribution-based API that connects to any deep learning model. The library utilizes batched, vectorized operations and exploits auto-differentiation to produce readable, fast, and testable code. Internally, we also include a number of general-purpose optimizations to provide cross-algorithm efficiency. Experiments show significant performance gains over fast baselines. Case studies demonstrate the benefits of the library. Torch-Struct is available at https://github.com/ harvardnlp/pytorch-struct.", "sections": [{"heading": "Introduction", "text": "Structured prediction is an area of machine learning focusing on representations of spaces with combinatorial structure, as well as algorithms for inference and parameter estimation over these structures. Core methods include both tractable exact approaches like dynamic programming and spanning tree algorithms as well as heuristic techniques such linear programming relaxations and greedy search.\nStructured prediction has played a key role in the history of natural language processing. Example methods include techniques for sequence labeling and segmentation (Lafferty et al., 2001;Sarawagi and Cohen, 2005), discriminative dependency and constituency parsing (Finkel et al., 2008;McDonald et al., 2005), unsupervised learning for Figure 1: Distribution of binary trees over an 1000token sequence. Coloring shows the marginal probabilities of every span. Torch-Struct is an optimized collection of common CRF distributions used in NLP that is designed to integrate with deep learning frameworks. labeling and alignment (Vogel et al., 1996;Goldwater and Griffiths, 2007), approximate translation decoding with beam search (Tillmann and Ney, 2003), among many others.\nIn recent years, research into deep structured prediction has studied how these approaches can be integrated with neural networks and pretrained models. One line of work has utilized structured prediction as the final layer for deep models (Collobert et al., 2011;Durrett and Klein, 2015). Another has incorporated structured prediction within deep learning models, exploring novel models for latentstructure learning, unsupervised learning, or model control (Johnson et al., 2016;Yogatama et al., 2016;Wiseman et al., 2018). We aspire to make both of these use-cases as easy to use as standard neural networks.\nThe practical challenge of employing structured  Lines of code (LoC) is from the log-partition (A( )) implementation. T/S is the tokens per second of a batched computation, computed with batch 32, N = 25, C = 20, K = 5, L = 3 (K80 GPU run on Google Colab).\nprediction is that many required algorithms are difficult to implement efficiently and correctly. Most projects reimplement custom versions of standard algorithms or focus particularly on a single welldefined model class. This research style makes it difficult to combine and try out new approaches, a problem that has compounded with the complexity of research in deep structured prediction. With this challenge in mind, we introduce Torch-Struct with three specific contributions:\n\u2022 Modularity: models are represented as distributions with a standard flexible API integrated into a deep learning framework.\n\u2022 Completeness: a broad array of classical algorithms are implemented and new models can easily be added.\n\u2022 Efficiency: implementations target computational/memory efficiency for GPUs and the backend includes extensions for optimization.\nIn this system description, we first motivate the approach taken by the library, then present a technical description of the methods used, and finally present several example use cases.", "publication_ref": ["b21", "b31", "b9", "b24", "b34", "b11", "b33", "b3", "b5", "b15", "b37", "b35"], "figure_ref": [], "table_ref": []}, {"heading": "Related Work", "text": "Several software libraries target structured prediction.\nOptimization tools, such as SVM-struct (Joachims, 2008), focus on parameter estimation. Model libraries, such as CRFSuite (Okazaki, 2007), CRF++ (Kudo, 2005), or NCRF++ (Yang and Zhang, 2018), implement inference for a fixed set of popular models, usually linear-chain CRFs. General-purpose inference libraries, such as PyStruct (M\u00fcller and Behnke, 2014) or Tur-boParser (Martins et al., 2010), utilize external solvers for (primarily MAP) inference such as integer linear programming solvers and ADMM. Probabilistic programming languages, for example languages that integrate with deep learning such as Pyro (Bingham et al., 2019), allow for specification and inference over some discrete domains. Most ambitiously, inference libraries such as Dyna (Eisner et al., 2004) allow for declarative specifications of dynamic programming algorithms to support inference for generic algorithms. Torch-Struct takes a different approach and integrates a library of optimized structured distributions into a vectorized deep learning system. We begin by motivating this approach with a case study.", "publication_ref": ["b14", "b29", "b20", "b36", "b26", "b1", "b8"], "figure_ref": [], "table_ref": []}, {"heading": "Motivating Case Study", "text": "While structured prediction is traditionally presented at the output layer, recent applications have deployed structured models broadly within neural networks (Johnson et al., 2016;Kim et al., 2017;Yogatama et al., 2016, inter alia). Torch-Struct aims to encourage this general use case.\nTo illustrate, we consider a latent tree model. ListOps (Nangia and Bowman, 2018) is a dataset of mathematical functions. Each input/output pair consists of a prefix expression x and its result y, e.g.\nx = [ MAX 2 9 [ MIN 4 7 ] 0 ] y = 9 Models such as a flat RNN will fail to capture the hierarchical structure of this task. However, if a model can induce an explicit latent z, the parse tree of the expression, then the task is easy to learn by a tree-RNN model p(y|x, z) (Yogatama et al., 2016;Havrylov et al., 2019).\nLet us briefly summarize a latent-tree RL model for this task. The objective is to maximize the probability of the correct prediction under the expectation of a prior tree model, p(z|x; \u03c6),\nObj = E z\u223cp(z|x;\u03c6) [log p(y | z, x)]\nComputing the expectation is intractable so policy gradient is used. First a tree is sampledz \u223c p(z|x; \u03c6), then the gradient with respect to \u03c6 is approximated as, Even in this brief overview, we can see how complex a latent structured learning problem can be. To compute these terms, we need 5 different properties of the structured prior model p(z |x; \u03c6):\nSampling Policy gradient,z \u223c p(z | x; \u03c6) Density Score policy samples, p(z | x; \u03c6) Gradient Backpropagation, \u2202 \u2202\u03c6 p(z | x; \u03c6) Argmax Self-critical, arg max z p(z | x; \u03c6) Entropy Objective regularizer, H(p(z | x; \u03c6))\nFor structured models, each of these terms is nontrivial to compute. A goal of Torch-Struct is to make it seamless to deploy structured models for these complex settings. ", "publication_ref": ["b15", "b27", "b37", "b13"], "figure_ref": [], "table_ref": ["tab_2"]}, {"heading": "Library Design", "text": "The library design of Torch-Struct follows the distributions API used by both TensorFlow and Py-Torch (Dillon et al., 2017). For each structured model in the library, we define a conditional random field (CRF) distribution object. From a user's standpoint, this object provides all necessary distributional properties. Given log-potentials output from a deep network, the user can request samples z \u223c CRF( ), probabilities CRF(z; ), modes arg max z CRF( ), or other distributional properties such as H(CRF( )). The library is agnostic to how these are utilized, and when possible, they allow for backpropagation to update the input network. The same distributional object can be used for standard output prediction as for more complex operations like attention or reinforcement learning.\nFigure 2 demonstrates this API for a binary tree CRF over an ordered sequence, such as p(z | x; \u03c6) from the previous section. The distribution takes in log-potentials which score each possible span in the input. The distribution converts these to probabilities of a specific tree. This distribution can be queried for predicting over the set of trees, sampling a tree for model structure, or even computing entropy over all trees.\nTable 1 shows all of the structures and distributions implemented in Torch-Struct. While each is internally implemented using different specialized algorithms and optimizations, from the user's perspective they all utilize the same external distributional API, and pass a generic set of distributional tests. 1 This approach hides the internal complexity of the inference procedure, while giving the user full access to the model.", "publication_ref": ["b4"], "figure_ref": ["fig_1"], "table_ref": ["tab_1"]}, {"heading": "Technical Approach", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Conditional Random Fields", "text": "We now describe the technical approach underlying the library. To establish notation, first consider the implementation of a softmax categorical distribution, CAT( ), with one-hot categories z with z i = 1 from a set Z and probabilities given by the softmax over logits ,\nCAT(z; ) = exp(z \u2022 ) z \u2208Z exp(z \u2022 ) = exp i K j=1 exp j\nDefine the log-partition as A( ) = LSE( ), i.e. log of the denominator, where LSE is the log-sumexp operator. Computing probabilities or sampling from this distribution, requires enumerating Z to compute the log-partition A. A useful identity is that derivatives of A yield category probabilities,\np(z i = 1) = exp i n j=1 exp j = \u2202 \u2202 i A( )\nOther distributional properties can be similarly extracted from variants of the log-partition. For instance, define A * ( ) = log max K j=1 exp j then 2 : I(z * i = 1) = \u2202 \u2202 i A * ( ). Conditional random fields, CRF( ), extend the softmax to combinatorial spaces where Z is exponentially sized. Each z, is now represented as a binary vector over polynomial-sized set of parts, P, i.e. Z \u2282 {0, 1} |P| . Similarly log-potentials are now defined over parts \u2208 R |P| . For instance, in Figure 2 each span is a part and the vector is shown in the top-left figure. Define the probability of a structure z as,\nCRF(z; ) = exp z \u2022 z exp z \u2022 = exp p p z p z exp p p z p\nComputing probabilities or sampling from this distribution, requires computing the log-partition term A. In general, computing this term is now intractable, however for many core algorithms in NLP there are exist efficient combinatorial algorithms for this term (a list of examples is given in Table 1).\nstructures to ensure that properties hold. While this is intractable for large spaces, it can be done for small sets and was extremely useful for development.\n2 This is a subgradient identity, but that deep learning libraries like PyTorch generally default to this value.", "publication_ref": [], "figure_ref": ["fig_1"], "table_ref": ["tab_1"]}, {"heading": "Name", "text": "Ops ( , \u2297) Backprop Gradients\nLog LSE, + \u2206 p(zp = 1) Max max, + \u2206 arg maxz K-Max k max, + \u2206 K-Argmax Sample LSE, + \u223c z \u223c CRF( ) K-Sample LSE, + \u223c K-Samples Count , \u00d7 Entropy (H)\nSee (Li and Eisner, 2009) Exp.\nSee (Li and Eisner, 2009) Sparsemax See (Mensch and Blondel, 2018)  Derivatives of the log-partition again provide useful distributional properties. For instance, the marginal probabilities of parts are given by,\np(z p = 1) = exp z:zp=1 z \u2022 z \u2208 exp z \u2022 = \u2202 \u2202 p A( )\nSimilarly derivatives of A * correspond to whether a part appears in the argmax structure, I(z\n* p = 1) = \u2202 \u2202 p A * ( ).\nWhile these gradient identities are well-known (Eisner, 2016), they are not commonly deployed in practice. Computing CRF properties is typically done through two-step specialized algorithms, such as forward-backward, inside-outside, or similar variants such as viterbi-backpointers (Jurafsky and Martin, 2014). Common wisdom is that these approaches are more efficient implementations.\nHowever, we observe that recent engineering of faster gradient computation for deep learning has made gradient-based calculations competitive with hand-written calculations. In our experiments, we found that using these identities with autodiffer-entiation was often faster, and much simpler, than custom two-pass approaches. Torch-Struct is thus designed around using gradients for distributional computations.", "publication_ref": ["b22", "b22", "b25", "b7", "b16"], "figure_ref": [], "table_ref": []}, {"heading": "Dynamic Programming and Semirings", "text": "Torch-Struct is a collection of generic algorithms for CRF inference. Each CRF distribution object, CRF( ), is constructed by providing \u2208 R |P| where the parts P are specific to the type of distribution. Internally, each distribution is implemented through a single function for computing the logpartition function A( ). From this function, the library uses autodifferentiation and the identities from the previous section, to define a complete distribution object. The core models implemented by the library are shown in Table 1.\nTo make the approach concrete, we consider the example of the simplest structured model, a linear-\nchain CRF p(z 1 , z 2 , z 3 | x). z 1 z 2 z 3\nThe model has C labels per node with a length N utilizing a first-order linear-chain (Markov) model. This model has N \u2212 1 \u00d7 C \u00d7 C parts corresponding to edges in the chain, and thus \u2208 R N \u22121\u00d7C\u00d7C logpotentials. The log-partition function A( ) factors into two reduce computations,\nA( ) = log c 3 ,c 2 exp 2,c 2 ,c 3 c 1 exp 1,c 1 ,c 2 = LSE c 3 ,c 2 [ 2,c 2 ,c 3 + [LSE c 1 1,c 1 ,c 2 ]]\nComputing this function left-to-right using dynamic programming yields the standard forward algorithm for computing the log-partition of sequence models. As we have seen, the gradient with respect to produces marginals for each part, i.e. the probability of a specific labeled edge.\nWe can further extend the same function to support generic semiring dynamic programming (Goodman, 1999). A semiring is defined by a pair (\u2295, \u2297) with commutative \u2295, distribution, and appropriate identities.\nA( ) = c 3 ,c 2 [ 2,c 2 ,c 3 \u2297 [ c 1 1,c 1 ,c 2 ]]\nThe log-partition utilizes \u2295, \u2297 = (LSE, +), but we can substitute alternatives. For instance, utilizing the log-max semiring (max, +) in the forward algorithm yields the max score. As we have seen, its gradient with respect to is the argmax sequence, negating the need for a separate argmax (Viterbi) algorithm. Some distributional properties cannot be computed directly through gradient identities but still use a forward-backward style compute structure. For instance, sampling requires first computing the log-partition term and then sampling each part, (forward filtering / backward sampling). We can compute this value by overriding each backpropagation operation for the to instead compute a sample.\nTable 2 shows the set of semirings and backpropagation steps for computing different terms of interest. We note that many of the terms necessary in the case-study can be computed with variant semirings, negating the need for specialized algorithms.", "publication_ref": ["b12"], "figure_ref": [], "table_ref": ["tab_1", "tab_2"]}, {"heading": "Optimizations", "text": "Torch-Struct aims for computational and memory efficiency. Implemented naively, dynamic programming algorithms in Python are prohibitively slow. As such Torch-Struct provides key primitives to help batch and vectorize these algorithms to take advantage of GPU computation and to minimize the overhead of backpropagating through chart-based dynamic programmming. We discuss three optimizations: a) Parallel Scan, b) Vectorization, and c) Semiring Matrix Multiplications. Figure 3 shows the impact of these optimizations on the core algorithms.\nParallel Scan Inference The commutative properties of semiring algorithms allow flexibility in the order in which we compute A( ). Typical implementations of dynamic programming algorithms are serial in the length of the sequence. On parallel hardware, an appealing approach is a parallel scan ordering (S\u00e4rkk\u00e4 and Garc\u00eda-Fern\u00e1ndez, 2019), typically used for computing prefix sums. To compute, A( ) in this manner we first pad the sequence length N out to the nearest power of two, and then compute a balanced parallel tree over the parts, shown in Figure 4. Concretely each node layer would compute a semiring matrix multiplication, e.g.\nc n,\u2022,c \u2297 n+1,c,\u2022 . Under this approach, assuming enough parallel cores, we only need O(log N ) steps in Python and can use parallel operations for the rest. Similar parallel approach can also be used for computing sequence alignment and semi-Markov models. Vectorization Computational complexity is even more of an issue for algorithms that cannot easily be parallelized. For example, parsing algorithms the generalize CKY are common in NLP. The CKY algorithm has a bottleneck that it must compute each width from 1 through N in serial; however internally each one of these steps can be vectorized. Assuming we have computed all inside spans of width less than d, computing the inside span of width d requires computing for all i,\nC[i, i + d] = i+d\u22121 j=i C[i, j] \u2297 C[j + 1, i + d]\nIn order to vectorize this loop over i, j, we need to reindex the chart. Instead of using a single chart C, we split it into two parts: one rightfacing\nC r [i, d] = C[i, i + d] and one left facing, C l [i+d, N \u2212d] = C[i, i+d].\nAfter this reindexing, the update can be written.\nC r [i, d] = j\u22121 j=1 C r [i, j] \u2297 C l [i + d, N \u2212 d + j]\nUnlike the original, this formula can easily be computed as a vectorized semiring dot product. This allows use to compute C r [\u2022, d] in one operation. Variants of this same approach can be used for many more complex dynamic programs.", "publication_ref": ["b32"], "figure_ref": ["fig_2", "fig_3"], "table_ref": []}, {"heading": "Semiring Matrix Operations", "text": "The two previous optimizations reduce most of the cost to semiring matrix multiplication. In the specific case of the ( , \u00d7) semiring these can be computed very efficiently using matrix multiplication, which is highlytuned on GPU hardware. However, this semiring is not particularly useful and prone to underflow. For A( ) other semirings, such as log and max, these operations are either slow or very memory inefficient. For instance, for matrices T and U of sized N \u00d7 M and M \u00d7 O, we can broadcast with \u2297 to a tensor of size N \u00d7 M \u00d7 O and then reduce dim M by at a huge memory cost.\n\u2297 \u2297 I 7,\u2022,\u2022 \u2297 6,\u2022,\u2022 5,\u2022,\u2022 \u2297 \u2297 4,\u2022,\u2022 3,\u2022,\u2022 \u2297 2,\u2022,\u2022 1,\u2022,\u2022\nTo avoid this issue, we implement custom CUDA kernels targeting fast and memory efficient tensor operations. For log, this corresponds to computing,\nV m,o = log n exp(T m,n + U n,o \u2212 q) + q\nwhere q = max n T m,n + U n,o . To optimize this operation on GPU we utilize the TVM language (Chen et al., 2018) to layout the CUDA loops and tune it to hardware. This produces much faster operations, although still less efficient that matrix multiplication which is heavily customized to hardware.", "publication_ref": ["b2"], "figure_ref": [], "table_ref": []}, {"heading": "Conclusion and Future Work", "text": "We present Torch-Struct, a library for deep structured prediction. The library achieves modularity through its adoption of a generic distributional API, completeness by utilizing CRFs and semirings to make it easy to add new algorithms, and efficiency through core optimizations to vectorize important dynamic programming steps. In addition to the problems discussed so far, Torch-Struct also includes several other example implementations including supervised dependency parsing with BERT, unsupervised tagging, structured attention, and connectionist temporal classification (CTC) for speech. Code demonstrates that the model is able to replicate standard deep learning results, although we focus here on the fidelity and implementation approach of the core library. The full library is available at https: //github.com/harvardnlp/pytorch-struct.\nIn the future, we hope to support research and production applications employing structured models. We also believe the library provides a strong foundation for building generic tools for interpretablity, control, and visualization through its probabilistic API. Finally, we hope to explore further optimizations to make core algorithms competitive with highly-optimized neural network components. These approaches provide a benchmark for improving autodifferentiation systems and extending their functionality to higher-order properties.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgements", "text": "We thank Yoon Kim, Xiang Lisa Li, Sebastian Gehrmann, Yuntian Deng, and Justin Chiu for discussion and feedback on the project. The project was supported by NSF CAREER 1845664, NSF 1901030, and research awards by Sony and AWS.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Statistical inference for probabilistic functions of finite state markov chains. The annals of mathematical statistics", "journal": "", "year": "1966", "authors": "E Leonard; Ted Baum;  Petrie"}, {"ref_id": "b1", "title": "Pyro: Deep universal probabilistic programming", "journal": "The Journal of Machine Learning Research", "year": "2019", "authors": "Eli Bingham; Jonathan P Chen; Martin Jankowiak; Fritz Obermeyer; Neeraj Pradhan; Theofanis Karaletsos; Rohit Singh; Paul Szerlip; Paul Horsfall; Noah D Goodman"}, {"ref_id": "b2", "title": "Tvm: end-to-end optimization stack for deep learning", "journal": "", "year": "2018", "authors": "Tianqi Chen; Thierry Moreau; Ziheng Jiang; Haichen Shen; Eddie Yan; Leyuan Wang; Yuwei Hu; Luis Ceze; Carlos Guestrin; Arvind Krishnamurthy"}, {"ref_id": "b3", "title": "Natural language processing (almost) from scratch", "journal": "Journal of machine learning research", "year": "2011-08", "authors": "Ronan Collobert; Jason Weston; L\u00e9on Bottou; Michael Karlen; Koray Kavukcuoglu; Pavel Kuksa"}, {"ref_id": "b4", "title": "", "journal": "", "year": "2017", "authors": "Ian Joshua V Dillon; Dustin Langmore; Eugene Tran; Srinivas Brevdo; Dave Vasudevan;  Moore"}, {"ref_id": "b5", "title": "Neural crf parsing", "journal": "", "year": "2015", "authors": "Greg Durrett; Dan Klein"}, {"ref_id": "b6", "title": "Bilexical grammars and their cubic-time parsing algorithms", "journal": "Springer", "year": "2000", "authors": "Jason Eisner"}, {"ref_id": "b7", "title": "Inside-outside and forwardbackward algorithms are just backprop (tutorial paper)", "journal": "", "year": "2016", "authors": "Jason Eisner"}, {"ref_id": "b8", "title": "Dyna: A declarative language for implementing dynamic programs", "journal": "", "year": "2004", "authors": "Jason Eisner; Eric Goldlust; Noah A Smith"}, {"ref_id": "b9", "title": "Efficient, feature-based, conditional random field parsing", "journal": "", "year": "2008", "authors": "Jenny Rose Finkel; Alex Kleeman; Christopher D Manning"}, {"ref_id": "b10", "title": "Factorial hidden markov models", "journal": "", "year": "1996", "authors": "Zoubin Ghahramani; Michael I Jordan "}, {"ref_id": "b11", "title": "A fully bayesian approach to unsupervised part-of-speech tagging", "journal": "", "year": "2007", "authors": "Sharon Goldwater; Tom Griffiths"}, {"ref_id": "b12", "title": "Semiring parsing", "journal": "Computational Linguistics", "year": "1999", "authors": "Joshua Goodman"}, {"ref_id": "b13", "title": "Cooperative learning of disjoint syntax and semantics", "journal": "", "year": "2019", "authors": "Serhii Havrylov; Germ\u00e1n Kruszewski; Armand Joulin"}, {"ref_id": "b14", "title": "Svmstruct: Support vector machine for complex outputs", "journal": "", "year": "2008", "authors": "Thorsten Joachims"}, {"ref_id": "b15", "title": "Composing graphical models with neural networks for structured representations and fast inference", "journal": "", "year": "2016", "authors": "J Matthew; David K Johnson; Alex Duvenaud;  Wiltschko; P Ryan; Sandeep R Adams;  Datta"}, {"ref_id": "b16", "title": "Speech and language processing", "journal": "", "year": "2014", "authors": "Dan Jurafsky; H James;  Martin"}, {"ref_id": "b17", "title": "An efficient recognition and syntax-analysis algorithm for context-free languages", "journal": "Coordinated Science Laboratory Report", "year": "1966", "authors": "Tadao Kasami"}, {"ref_id": "b18", "title": "", "journal": "", "year": "", "authors": "Yoon Kim; Carl Denton; Luong Hoang; Alexander M "}, {"ref_id": "b19", "title": "Structured prediction models via the matrix-tree theorem", "journal": "", "year": "2007", "authors": "Terry Koo; Amir Globerson; Xavier Carreras P\u00e9rez; Michael Collins"}, {"ref_id": "b20", "title": "Crf++: Yet another crf toolkit", "journal": "", "year": "2005", "authors": "Taku Kudo"}, {"ref_id": "b21", "title": "Conditional random fields: Probabilistic models for segmenting and labeling sequence data", "journal": "", "year": "2001", "authors": "John Lafferty; Andrew Mccallum; Fernando Cn Pereira"}, {"ref_id": "b22", "title": "First-and secondorder expectation semirings with applications to minimum-risk training on translation forests", "journal": "", "year": "2009", "authors": "Zhifei Li; Jason Eisner"}, {"ref_id": "b23", "title": "Turbo parsers: Dependency parsing by approximate variational inference", "journal": "Association for Computational Linguistics", "year": "2010", "authors": "F T Andr\u00e9; Noah A Martins; Eric P Smith;  Xing; M Q Pedro;  Aguiar;  M\u00e1rio;  Figueiredo"}, {"ref_id": "b24", "title": "Non-projective dependency parsing using spanning tree algorithms", "journal": "", "year": "2005", "authors": "Ryan Mcdonald; Fernando Pereira; Kiril Ribarov"}, {"ref_id": "b25", "title": "Differentiable dynamic programming for structured prediction and attention", "journal": "", "year": "2018", "authors": "Arthur Mensch; Mathieu Blondel"}, {"ref_id": "b26", "title": "Pystruct: learning structured prediction in python", "journal": "The Journal of Machine Learning Research", "year": "2014", "authors": "C Andreas; Sven M\u00fcller;  Behnke"}, {"ref_id": "b27", "title": "Listops: A diagnostic dataset for latent tree learning", "journal": "", "year": "2018", "authors": "Nikita Nangia;  Samuel R Bowman"}, {"ref_id": "b28", "title": "A general method applicable to the search for similarities in the amino acid sequence of two proteins", "journal": "Journal of molecular biology", "year": "1970", "authors": "B Saul; Christian D Needleman;  Wunsch"}, {"ref_id": "b29", "title": "Crfsuite: a fast implementation of conditional random fields (crfs)", "journal": "", "year": "2007", "authors": "Naoaki Okazaki"}, {"ref_id": "b30", "title": "Self-critical sequence training for image captioning", "journal": "", "year": "2017", "authors": "J Steven; Etienne Rennie; Youssef Marcheret; Jerret Mroueh; Vaibhava Ross;  Goel"}, {"ref_id": "b31", "title": "Semimarkov conditional random fields for information extraction", "journal": "", "year": "2005", "authors": "Sunita Sarawagi;  William W Cohen"}, {"ref_id": "b32", "title": "Temporal parallelization of bayesian filters and smoothers", "journal": "", "year": "2019", "authors": "Simo S\u00e4rkk\u00e4;  Garc\u00eda-Fern\u00e1ndez"}, {"ref_id": "b33", "title": "Word reordering and a dynamic programming beam search algorithm for statistical machine translation", "journal": "Computational linguistics", "year": "2003", "authors": "Christoph Tillmann; Hermann Ney"}, {"ref_id": "b34", "title": "Hmm-based word alignment in statistical translation", "journal": "Association for Computational Linguistics", "year": "1996", "authors": "Stephan Vogel; Hermann Ney; Christoph Tillmann"}, {"ref_id": "b35", "title": "Learning neural templates for text generation", "journal": "", "year": "2018", "authors": "Sam Wiseman; M Stuart; Alexander M Shieber;  Rush"}, {"ref_id": "b36", "title": "Ncrf++: An opensource neural sequence labeling toolkit", "journal": "", "year": "2018", "authors": "Jie Yang; Yue Zhang"}, {"ref_id": "b37", "title": "Learning to compose words into sentences with reinforcement learning", "journal": "", "year": "2016", "authors": "Dani Yogatama; Phil Blunsom; Chris Dyer; Edward Grefenstette; Wang Ling"}], "figures": [{"figure_label": "", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "log p(y |z, x) \u2212 b)( \u2202 \u2202\u03c6 p(z|x; \u03c6)) where b is a variance reduction baseline. A common choice is the self-critical baseline (Rennie et al., 2017), b = log p(y | z * , x) with z * = arg max z p(z|x; \u03c6) Finally an entropy regularization term is added to the objective encourage exploration of different trees, Obj + \u03bbH(p(z | x; \u03c6)).", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 2 :2Figure 2: Latent Tree CRF example where each cell represents a span (i, j). Torch-Struct can be used to compute many different properties of a structured distribution. (a) Log-potentials for each part/span. (b) Marginals for CRF( ) computed by backpropagation. (c) A single argmax tree arg max z CRF(z; ). (d) A single sampled tree z \u223c CRF( ).", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Figure 3 :3Figure 3: Speed impact of optimizations. Time is given in seconds for 10 runs with batch 16. (a) Speed of a linearchain forward with 20 classes for lengths up to 500. Compares left-to-right ordering to parallel scan. (b) Speed of CKY inside with lengths up to 80. Compares inner loop versus vectorization. (c) Speed of linear-chain forward of length 20 with up to 100 classes. Compares broadcast-reduction versus CUDA semiring kernel. (Baseline memory is exhausted after 100 classes.)", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Figure 4 :4Figure 4: Parallel scan implementation of the linearchain CRF inference algorithm (parallel forward).Here \u2297 represents a semiring matrix operation and I is padding to produce a balanced tree.", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "", "figure_data": ""}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_2", "figure_caption": "", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "Obj = E z\u223cp(z|x;\u03c6) [log p(y | z, x)]", "formula_coordinates": [3.0, 107.12, 326.86, 148.04, 11.22]}, {"formula_id": "formula_1", "formula_text": "Sampling Policy gradient,z \u223c p(z | x; \u03c6) Density Score policy samples, p(z | x; \u03c6) Gradient Backpropagation, \u2202 \u2202\u03c6 p(z | x; \u03c6) Argmax Self-critical, arg max z p(z | x; \u03c6) Entropy Objective regularizer, H(p(z | x; \u03c6))", "formula_coordinates": [3.0, 72.0, 628.61, 199.01, 73.74]}, {"formula_id": "formula_2", "formula_text": "CAT(z; ) = exp(z \u2022 ) z \u2208Z exp(z \u2022 ) = exp i K j=1 exp j", "formula_coordinates": [4.0, 75.46, 229.59, 209.47, 28.88]}, {"formula_id": "formula_3", "formula_text": "p(z i = 1) = exp i n j=1 exp j = \u2202 \u2202 i A( )", "formula_coordinates": [4.0, 97.24, 356.77, 167.79, 27.09]}, {"formula_id": "formula_4", "formula_text": "CRF(z; ) = exp z \u2022 z exp z \u2022 = exp p p z p z exp p p z p", "formula_coordinates": [4.0, 72.69, 577.93, 215.2, 28.74]}, {"formula_id": "formula_5", "formula_text": "Log LSE, + \u2206 p(zp = 1) Max max, + \u2206 arg maxz K-Max k max, + \u2206 K-Argmax Sample LSE, + \u223c z \u223c CRF( ) K-Sample LSE, + \u223c K-Samples Count , \u00d7 Entropy (H)", "formula_coordinates": [4.0, 313.25, 83.02, 205.1, 73.31]}, {"formula_id": "formula_6", "formula_text": "p(z p = 1) = exp z:zp=1 z \u2022 z \u2208 exp z \u2022 = \u2202 \u2202 p A( )", "formula_coordinates": [4.0, 321.1, 511.28, 190.62, 29.34]}, {"formula_id": "formula_7", "formula_text": "* p = 1) = \u2202 \u2202 p A * ( ).", "formula_coordinates": [4.0, 308.47, 562.35, 217.08, 30.39]}, {"formula_id": "formula_8", "formula_text": "chain CRF p(z 1 , z 2 , z 3 | x). z 1 z 2 z 3", "formula_coordinates": [5.0, 72.0, 323.57, 161.86, 30.89]}, {"formula_id": "formula_9", "formula_text": "A( ) = log c 3 ,c 2 exp 2,c 2 ,c 3 c 1 exp 1,c 1 ,c 2 = LSE c 3 ,c 2 [ 2,c 2 ,c 3 + [LSE c 1 1,c 1 ,c 2 ]]", "formula_coordinates": [5.0, 80.27, 465.49, 201.73, 38.71]}, {"formula_id": "formula_10", "formula_text": "A( ) = c 3 ,c 2 [ 2,c 2 ,c 3 \u2297 [ c 1 1,c 1 ,c 2 ]]", "formula_coordinates": [5.0, 95.83, 679.26, 170.61, 22.26]}, {"formula_id": "formula_11", "formula_text": "C[i, i + d] = i+d\u22121 j=i C[i, j] \u2297 C[j + 1, i + d]", "formula_coordinates": [6.0, 76.76, 410.12, 208.75, 33.71]}, {"formula_id": "formula_12", "formula_text": "C r [i, d] = C[i, i + d] and one left facing, C l [i+d, N \u2212d] = C[i, i+d].", "formula_coordinates": [6.0, 72.0, 498.6, 219.63, 24.32]}, {"formula_id": "formula_13", "formula_text": "C r [i, d] = j\u22121 j=1 C r [i, j] \u2297 C l [i + d, N \u2212 d + j]", "formula_coordinates": [6.0, 79.62, 549.46, 203.03, 34.29]}, {"formula_id": "formula_14", "formula_text": "\u2297 \u2297 I 7,\u2022,\u2022 \u2297 6,\u2022,\u2022 5,\u2022,\u2022 \u2297 \u2297 4,\u2022,\u2022 3,\u2022,\u2022 \u2297 2,\u2022,\u2022 1,\u2022,\u2022", "formula_coordinates": [6.0, 320.3, 293.36, 195.91, 67.33]}, {"formula_id": "formula_15", "formula_text": "V m,o = log n exp(T m,n + U n,o \u2212 q) + q", "formula_coordinates": [6.0, 323.47, 573.97, 185.49, 21.54]}], "doi": ""}