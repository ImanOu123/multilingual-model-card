{"title": "Spectral Learning for Non-Deterministic Dependency Parsing", "authors": "Franco M Luque; Ariadna Quattoni; Borja Balle; Xavier Carreras", "pub_date": "", "abstract": "In this paper we study spectral learning methods for non-deterministic split headautomata grammars, a powerful hiddenstate formalism for dependency parsing. We present a learning algorithm that, like other spectral methods, is efficient and nonsusceptible to local minima. We show how this algorithm can be formulated as a technique for inducing hidden structure from distributions computed by forwardbackward recursions. Furthermore, we also present an inside-outside algorithm for the parsing model that runs in cubic time, hence maintaining the standard parsing costs for context-free grammars.", "sections": [{"heading": "Introduction", "text": "Dependency structures of natural language sentences exhibit a significant amount of non-local phenomena. Historically, there have been two main approaches to model non-locality: (1) increasing the order of the factors of a dependency model (e.g. with sibling and grandparent relations (Eisner, 2000;McDonald and Pereira, 2006;Carreras, 2007;Martins et al., 2009;Koo and Collins, 2010)), and (2) using hidden states to pass information across factors (Matsuzaki et al., 2005;Petrov et al., 2006;Musillo and Merlo, 2008).\nHigher-order models have the advantage that they are relatively easy to train, because estimating the parameters of the model can be expressed as a convex optimization. However, they have two main drawbacks. (1) The number of parameters grows significantly with the size of the factors, leading to potential data-sparsity problems. A solution to address the data-sparsity problem is to explicitly tell the model what properties of higher-order factors need to be remembered. This can be achieved by means of feature engineering, but compressing such information into a state of bounded size will typically be labor intensive, and will not generalize across languages. (2) Increasing the size of the factors generally results in polynomial increases in the parsing cost.\nIn principle, hidden variable models could solve some of the problems of feature engineering in higher-order factorizations, since they could automatically induce the information in a derivation history that should be passed across factors. Potentially, they would require less feature engineering since they can learn from an annotated corpus an optimal way to compress derivations into hidden states. For example, one line of work has added hidden annotations to the non-terminals of a phrase-structure grammar (Matsuzaki et al., 2005;Petrov et al., 2006;Musillo and Merlo, 2008), resulting in compact grammars that obtain parsing accuracies comparable to lexicalized grammars. A second line of work has modeled hidden sequential structure, like in our case, but using PDFA (Infante-Lopez and de Rijke, 2004). Finally, a third line of work has induced hidden structure from the history of actions of a parser (Titov and Henderson, 2007).\nHowever, the main drawback of the hidden variable approach to parsing is that, to the best of our knowledge, there has not been any convex formulation of the learning problem. As a result, training a hidden-variable model is both expensive and prone to local minima issues.\nIn this paper we present a learning algorithm for hidden-state split head-automata grammars (SHAG) (Eisner and Satta, 1999). In this for-malism, head-modifier sequences are generated by a collection of finite-state automata. In our case, the underlying machines are probabilistic non-deterministic finite state automata (PNFA), which we parameterize using the operator model representation. This representation allows the use of simple spectral algorithms for estimating the model parameters from data (Hsu et al., 2009;Bailly, 2011;Balle et al., 2012). In all previous work, the algorithms used to induce hidden structure require running repeated inference on training data-e.g. Expectation-Maximization (Dempster et al., 1977), or split-merge algorithms. In contrast, spectral methods are simple and very efficient -parameter estimation is reduced to computing some data statistics, performing SVD, and inverting matrices.\nThe main contributions of this paper are:\n\u2022 We present a spectral learning algorithm for inducing PNFA with applications to headautomata dependency grammars. Our formulation is based on thinking about the distribution generated by a PNFA in terms of the forward-backward recursions.\n\u2022 Spectral learning algorithms in previous work only use statistics of prefixes of sequences. In contrast, our algorithm is able to learn from substring statistics.\n\u2022 We derive an inside-outside algorithm for non-deterministic SHAG that runs in cubic time, keeping the costs of CFG parsing.\n\u2022 In experiments we show that adding nondeterminism improves the accuracy of several baselines. When we compare our algorithm to EM we observe a reduction of two orders of magnitude in training time.\nThe paper is organized as follows. Next section describes the necessary background on SHAG and operator models. Section 3 introduces Operator SHAG for parsing, and presents a spectral learning algorithm. Section 4 presents a parsing algorithm. Section 5 presents experiments and analysis of results, and section 6 concludes.", "publication_ref": ["b9", "b18", "b3", "b16", "b13", "b17", "b24", "b20", "b17", "b24", "b20", "b12", "b26", "b7", "b11", "b0", "b2"], "figure_ref": [], "table_ref": []}, {"heading": "Preliminaries", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Head-Automata Dependency Grammars", "text": "In this work we use split head-automata grammars (SHAG) (Eisner and Satta, 1999;Eis-ner, 2000), a context-free grammatical formalism whose derivations are projective dependency trees. We will use x i:j = x i x i+1 \u2022 \u2022 \u2022 x j to denote a sequence of symbols x t with i \u2264 t \u2264 j. A SHAG generates sentences s 0:N , where symbols s t \u2208 X with 1 \u2264 t \u2264 N are regular words and s 0 = \u2208 X is a special root symbol. Let X = X \u222a { }. A derivation y, i.e. a dependency tree, is a collection of head-modifier sequences h, d, x 1:T , where h \u2208X is a word, d \u2208 {LEFT, RIGHT} is a direction, and x 1:T is a sequence of T words, where each x t \u2208 X is a modifier of h in direction d. We say that h is the head of each x t . Modifier sequences x 1:T are ordered head-outwards, i.e. among x 1:T , x 1 is the word closest to h in the derived sentence, and x T is the furthest. A derivation y of a sentence s 0:N consists of a LEFT and a RIGHT head-modifier sequence for each s t . As special cases, the LEFT sequence of the root symbol is always empty, while the RIGHT one consists of a single word corresponding to the head of the sentence. We denote by Y the set of all valid derivations.\nAssume a derivation y contains h, LEFT, x 1:T and h, RIGHT, x 1:T . Let L(y, h) be the derived sentence headed by h, which can be expressed as\nL(y, x T ) \u2022 \u2022 \u2022 L(y, x 1 ) h L(y, x 1 ) \u2022 \u2022 \u2022 L(y, x T ). 1\nThe language generated by a SHAG are the strings L(y, ) for any y \u2208 Y.\nIn this paper we use probabilistic versions of SHAG where probabilities of head-modifier sequences in a derivation are independent of each other:\nP(y) = h,d,x 1:T \u2208y P(x 1:T |h, d) .(1)\nIn the literature, standard arc-factored models further assume that\nP(x 1:T |h, d) = T +1 t=1 P(x t |h, d, \u03c3 t ) , (2)\nwhere x T +1 is always a special STOP word, and \u03c3 t is the state of a deterministic automaton generating x 1:T +1 . For example, setting \u03c3 1 = FIRST and \u03c3 t>1 = REST corresponds to first-order models, while setting \u03c3 1 = NULL and \u03c3 t>1 = x t\u22121 corresponds to sibling models (Eisner, 2000;McDonald et al., 2005;McDonald and Pereira, 2006).", "publication_ref": ["b7", "b9", "b19", "b18"], "figure_ref": [], "table_ref": []}, {"heading": "Operator Models", "text": "An operator model A with n states is a tuple \u03b1 1 , \u03b1 \u221e , {A a } a\u2208X , where A a \u2208 R n\u00d7n is an operator matrix and \u03b1 1 , \u03b1 \u221e \u2208 R n are vectors. A computes a function f : X * \u2192 R as follows:\nf (x 1:T ) = \u03b1 \u221e A x T \u2022 \u2022 \u2022 A x 1 \u03b1 1 .(3)\nOne intuitive way of understanding operator models is to consider the case where f computes a probability distribution over strings. Such a distribution can be described in two equivalent ways: by making some independence assumptions and providing the corresponding parameters, or by explaining the process used to compute f . This is akin to describing the distribution defined by an HMM in terms of a factorization and its corresponding transition and emission parameters, or using the inductive equations of the forward algorithm. The operator model representation takes the latter approach.\nOperator models have had numerous applications. For example, they can be used as an alternative parameterization of the function computed by an HMM (Hsu et al., 2009). Consider an HMM with n hidden states and initial-state probabilities \u03c0 \u2208 R n , transition probabilities T \u2208 R n\u00d7n , and observation probabilities O a \u2208 R n\u00d7n for each a \u2208 X , with the following meaning:\n\u2022 \u03c0(i) is the probability of starting at state i,\n\u2022 T (i, j) is the probability of transitioning from state j to state i,\n\u2022 O a is a diagonal matrix, such that O a (i, i) is the probability of generating symbol a from state i.\nGiven an HMM, an equivalent operator model can be defined by setting \u03b1 1 = \u03c0, A a = T O a and \u03b1 \u221e = 1. To see this, let us show that the forward algorithm computes the expression in equation (3). Let \u03c3 t denote the state of the HMM at time t. Consider a state-distribution vector \u03b1 t \u2208 R n , where \u03b1 t (i) = P(x 1:t\u22121 , \u03c3 t = i). Initially \u03b1 1 = \u03c0. At each step in the chain of products (3), \u03b1 t+1 = A xt \u03b1 t updates the state distribution from positions t to t + 1 by applying the appropriate operator, i.e. by emitting symbol x t and transitioning to the new state distribution. The probability of x 1:T is given by i \u03b1 T +1 (i). Hence, A a (i, j) is the probability of generating symbol a and moving to state i given that we are at state j. HMM are only one example of distributions that can be parameterized by operator models. In general, operator models can parameterize any PNFA, where the parameters of the model correspond to probabilities of emitting a symbol from a state and moving to the next state.\nThe advantage of working with operator models is that, under certain mild assumptions on the operator parameters, there exist algorithms that can estimate the operators from observable statistics of the input sequences. These algorithms are extremely efficient and are not susceptible to local minima issues. See (Hsu et al., 2009) for theoretical proofs of the learnability of HMM under the operator model representation.\nIn the following, we write x = x i:j \u2208 X * to denote sequences of symbols, and use A x i:j as a shorthand for A x j \u2022 \u2022 \u2022 A x i . Also, for convenience we assume X = {1, . . . , l}, so that we can index vectors and matrices by symbols in X .", "publication_ref": ["b11", "b11"], "figure_ref": [], "table_ref": []}, {"heading": "Learning Operator SHAG", "text": "We will define a SHAG using a collection of operator models to compute probabilities. Assume that for each possible head h in the vocabularyX and each direction d \u2208 {LEFT, RIGHT} we have an operator model that computes probabilities of modifier sequences as follows:\nP(x 1:T |h, d) = (\u03b1 h,d \u221e ) A h,d x T \u2022 \u2022 \u2022 A h,d x 1 \u03b1 h,d 1 .\nThen, this collection of operator models defines an operator SHAG that assigns a probability to each y \u2208 Y according to (1). To learn the model parameters, namely\n\u03b1 h,d 1 , \u03b1 h,d \u221e , {A h,d a }\na\u2208X for h \u2208X and d \u2208 {LEFT, RIGHT}, we use spectral learning methods based on the works of Hsu et al. (2009), Bailly (2011) and Balle et al. (2012).\nThe main challenge of learning an operator model is to infer a hidden-state space from observable quantities, i.e. quantities that can be computed from the distribution of sequences that we observe. As it turns out, we cannot recover the actual hidden-state space used by the operators we wish to learn. The key insight of the spectral learning method is that we can recover a hiddenstate space that corresponds to a projection of the original hidden space. Such projected space is equivalent to the original one in the sense that we can find operators in the projected space that parameterize the same probability distribution over sequences.\nIn the rest of this section we describe an algorithm for learning an operator model. We will assume a fixed head word and direction, and drop h and d from all terms. Hence, our goal is to learn the following distribution, parameterized by operators \u03b1 1 , {A a } a\u2208X , and \u03b1 \u221e :\nP(x 1:T ) = \u03b1 \u221e A x T \u2022 \u2022 \u2022 A x 1 \u03b1 1 . (4\n)\nOur algorithm shares many features with the previous spectral algorithms of Hsu et al. (2009) and Bailly (2011), though the derivation given here is based upon the general formulation of Balle et al. (2012). The main difference is that our algorithm is able to learn operator models from substring statistics, while algorithms in previous works were restricted to statistics on prefixes. In principle, our algorithm should extract much more information from a sample.", "publication_ref": ["b11", "b2", "b11", "b2"], "figure_ref": [], "table_ref": []}, {"heading": "Preliminary Definitions", "text": "The spectral learning algorithm will use statistics estimated from samples of the target distribution. More specifically, consider the function that computes the expected number of occurrences of a substring x in a random string x drawn from P:\nf (x) = E(x x ) = x \u2208X * (x x )P(x ) = p,s\u2208X * P(pxs) ,(5)\nwhere x x denotes the number of times x appears in x . Here we assume that the true values of f (x) for bigrams are known, though in practice the algorithm will work with empirical estimates of these.\nThe information about f known by the algorithm is organized in matrix form as follows. Let P \u2208 R l\u00d7l be a matrix containing the value of f (x) for all strings of length two, i.e. bigrams. 2 . That is, each entry in P \u2208 R l\u00d7l contains the expected number of occurrences of a given bigram:\nP (b, a) = E(ab x) . (6\n)\n2 In fact, while we restrict ourselves to strings of length two, an analogous algorithm can be derived that considers longer strings to define P . See (Balle et al., 2012) for details. Furthermore, for each b \u2208 X let P b \u2208 R l\u00d7l denote the matrix whose entries are given by\nP b (c, a) = E(abc x) ,(7)\nthe expected number of occurrences of trigrams. Finally, we define vectors p 1 \u2208 R l and p \u221e \u2208 R l as follows: p 1 (a) = s\u2208X * P(as), the probability that a string begins with a particular symbol; and p \u221e (a) = p\u2208X * P(pa), the probability that a string ends with a particular symbol. Now we show a particularly useful way to express the quantities defined above in terms of the operators \u03b1 1 , \u03b1 \u221e , {A a } a\u2208X of P. First, note that each entry of P can be written in this form:\nP (b, a) = p,s\u2208X * P(pabs) (8) = p,s\u2208X * \u03b1 \u221e A s A b A a A p \u03b1 1 = (\u03b1 \u221e s\u2208X * A s ) A b A a ( p\u2208X * A p \u03b1 1 ) .\nIt is not hard to see that, since P is a probability distribution over X * , actually \u03b1 \u221e s\u2208X * A s = 1 . Furthermore, since 8) it is natural to define a forward matrix F \u2208 R n\u00d7l whose ath column contains the sum of all hiddenstate vectors obtained after generating all prefixes ended in a:\np\u2208X * A p = k\u22650 ( a\u2208X A a ) k = (I \u2212 a\u2208X A a ) \u22121 , we write\u03b1 1 = (I \u2212 a\u2208X A a ) \u22121 \u03b1 1 . From (\nF (:, a) = A a p\u2208X * A p \u03b1 1 = A a\u03b11 . (9)\nConversely, we also define a backward matrix B \u2208 R l\u00d7n whose ath row contains the probability of generating a from any possible state:\nB(a, :) = \u03b1 \u221e s\u2208X * A s A a = 1 A a . (10\n)\nBy plugging the forward and backward matrices into (8) one obtains the factorization P = BF . With similar arguments it is easy to see that one also has P b = BA b F , p 1 = B \u03b1 1 , and p \u221e = \u03b1 \u221e F . Hence, if B and F were known, one could in principle invert these expressions in order to recover the operators of the model from empirical estimations computed from a sample. In the next section we show that in fact one does not need to know B and F to learn an operator model for P, but rather that having a \"good\" factorization of P is enough.", "publication_ref": ["b2"], "figure_ref": [], "table_ref": []}, {"heading": "Inducing a Hidden-State Space", "text": "We have shown that an operator model A computing P induces a factorization of the matrix P , namely P = BF . More generally, it turns out that when the rank of P equals the minimal number of states of an operator model that computes P, then one can prove a duality relation between operators and factorizations of P . In particular, one can show that, for any rank factorization P = QR, the operators given by\u1fb1 1 = Q + p 1 ,\u1fb1 \u221e = p \u221e R + , and\u0100 a = Q + P a R + , yield an operator model for P. A key fact in proving this result is that the function P is invariant to the basis chosen to represent operator matrices. See (Balle et al., 2012) for further details.\nThus, we can recover an operator model for P from any rank factorization of P , provided a rank assumption on P holds (which hereafter we assume to be the case). Since we only have access to an approximation of P , it seems reasonable to choose a factorization which is robust to estimation errors. A natural such choice is the thin SVD decomposition of P (i.e. using top n singular vectors), given by: P = U (\u03a3V ) = U (U P ). Intuitively, we can think of U and U P as projected backward and forward matrices. Now that we have a factorization of P we can construct an operator model for P as follows: 3\n\u03b1 1 = U p 1 , (11\n) \u03b1 \u221e = p \u221e (U P ) + , (12\n) A a = U P a (U P ) + . (13\n)\nAlgorithm 1 presents pseudo-code for an algorithm learning operators of a SHAG from training head-modifier sequences using this spectral method. Note that each operator model in the 3 To see that equations (11-13) define a model for P, one must first see that the matrix M = F (\u03a3V ) + is invertible with inverse M \u22121 = U B. Using this and recalling that p1 = B\u03b11, Pa = BAaF , p \u221e = \u03b1 \u221e F , one obtains that:\n\u03b11 = U B\u03b11 = M \u22121 \u03b11 , \u03b1 \u221e = \u03b1 \u221e F (U BF ) + = \u03b1 \u221e M , Aa = U BAaF (U BF ) + = M \u22121 AaM .\nFinally:\nP(x1:T ) = \u03b1 \u221e Ax T \u2022 \u2022 \u2022 Ax 1 \u03b11 = \u03b1 \u221e M M \u22121 Ax T M \u2022 \u2022 \u2022 M \u22121 Ax 1 M M \u22121 \u03b11 =\u1fb1 \u221e\u0100xT \u2022 \u2022 \u2022\u0100x 1\u1fb1 1 Algorithm 1 Learn Operator SHAG inputs: \u2022 An alphabet X \u2022 A training set TRAIN = { h i , d i , x i 1:T } M i=1\n\u2022 The number of hidden states n 1: for each h \u2208X and d \u2208 {LEFT, RIGHT} do 2:\nCompute an empirical estimate from TRAIN of statistics matrices p 1 , p \u221e , P , and { P a } a\u2208X 3:\nCompute the SVD of P and let U be the matrix of top n left singular vectors of P 4:\nCompute the observable operators for h and d:\n5: \u03b1 h,d 1 = U p 1 6: ( \u03b1 h,d \u221e ) = p \u221e ( U P ) + 7:\nA h,d a = U P a ( U P ) + for each a \u2208 X 8: end for\n9: return Operators \u03b1 h,d 1 , \u03b1 h,d \u221e , A h,d a for each h \u2208X , d \u2208 {LEFT, RIGHT}, a \u2208 X\nSHAG is learned separately. The running time of the algorithm is dominated by two computations. First, a pass over the training sequences to compute statistics over unigrams, bigrams and trigrams. Second, SVD and matrix operations for computing the operators, which run in time cubic in the number of symbols l. However, note that when dealing with sparse matrices many of these operations can be performed more efficiently.", "publication_ref": ["b2"], "figure_ref": [], "table_ref": []}, {"heading": "Parsing Algorithms", "text": "Given a sentence s 0:N we would like to find its most likely derivation,\u0177 = argmax y\u2208Y(s 0:N ) P(y). This problem, known as MAP inference, is known to be intractable for hidden-state structure prediction models, as it involves finding the most likely tree structure while summing out over hidden states. We use a common approximation to MAP based on first computing posterior marginals of tree edges (i.e. dependencies) and then maximizing over the tree structure (see (Park and Darwiche, 2004) for complexity of general MAP inference and approximations). For parsing, this strategy is sometimes known as MBR decoding; previous work has shown that empirically it gives good performance (Goodman, 1996;Clark and Curran, 2004;Titov and Henderson, 2006;Petrov and Klein, 2007). In our case, we use the non-deterministic SHAG to compute posterior marginals of dependencies. We first explain the general strategy of MBR decoding, and then present an algorithm to compute marginals.\nLet (s i , s j ) denote a dependency between head word i and modifier word j. The posterior or marginal probability of a dependency (s i , s j ) given a sentence s 0:N is defined as \u00b5 i,j = P((s i , s j ) | s 0:N ) = y\u2208Y(s 0:N ) : (s i ,s j )\u2208y", "publication_ref": ["b21", "b10", "b4", "b25", "b23"], "figure_ref": [], "table_ref": []}, {"heading": "P(y) .", "text": "To compute marginals, the sum over derivations can be decomposed into a product of inside and outside quantities (Baker, 1979). Below we describe an inside-outside algorithm for our grammars. Given a sentence s 0:N and marginal scores \u00b5 i,j , we compute the parse tree for s 0:N a\u015d\ny = argmax y\u2208Y(s 0:N ) (s i ,s j )\u2208y log \u00b5 i,j(14)\nusing the standard projective parsing algorithm for arc-factored models (Eisner, 2000). Overall we use a two-pass parsing process, first to compute marginals and then to compute the best tree.", "publication_ref": ["b1", "b9"], "figure_ref": [], "table_ref": []}, {"heading": "An Inside-Outside Algorithm", "text": "In this section we sketch an algorithm to compute marginal probabilities of dependencies. Our algorithm is an adaptation of the parsing algorithm for SHAG by Eisner and Satta (1999) to the case of non-deterministic head-automata, and has a runtime cost of O(n 2 N 3 ), where n is the number of states of the model, and N is the length of the input sentence. Hence the algorithm maintains the standard cubic cost on the sentence length, while the quadratic cost on n is inherent to the computations defined by our model in Eq. (3). The main insight behind our extension is that, because the computations of our model involve state-distribution vectors, we need to extend the standard inside/outside quantities to be in the form of such state-distribution quantities. 4 Throughout this section we assume a fixed sentence s 0:N . Let Y(x i:j ) be the set of derivations that yield a subsequence x i:j . For a derivation y, we use root(y) to indicate the root word of it, and use (x i , x j ) \u2208 y to refer a dependency in y from head x i to modifier x j . Following Eisner and Satta (1999), we use decoding structures related to complete half-constituents (or \"triangles\", denoted C) and incomplete half-constituents (or \"trapezoids\", denoted I), each decorated with a direction (denoted L and R). We assume familiarity with their algorithm.\nWe define \u03b8 I,R i,j \u2208 R n as the inside score-vector of a right trapezoid dominated by dependency (s i , s j ), \u03b8 I,R i,j = y\u2208Y(s i:j ) : (s i ,s j )\u2208y , y={ s i ,R,x 1:t } \u222a y , xt=s j P(y )\u03b1 s i ,R (x 1:t ) . (15)\nThe term P(y ) is the probability of head-modifier sequences in the range s i:j that do not involve s i . The term \u03b1 s i ,R (x 1:t ) is a forward statedistribution vector -the qth coordinate of the vector is the probability that s i generates right modifiers x 1:t and remains at state q. Similarly, we define \u03c6 I,R i,j \u2208 R n as the outside score-vector of a right trapezoid, as\n\u03c6 I,R i,j = y\u2208Y(s 0:i s j:n ) : root(y)=s 0 , y={ s i ,R,x t:T } \u222a y , xt=s j P(y )\u03b2 s i ,R (x t+1:T ) , (16\n)\nwhere \u03b2 s i ,R (x t+1:T ) \u2208 R n is a backward statedistribution vector -the qth coordinate is the probability of being at state q of the right automaton of s i and generating x t+1:T . Analogous inside-outside expressions can be defined for the rest of structures (left/right triangles and trapezoids). With these quantities, we can compute marginals as\n\u00b5 i,j = (\u03c6 I,R i,j ) \u03b8 I,R i,j Z \u22121 if i < j , (\u03c6 I,L i,j ) \u03b8 I,L i,j Z \u22121 if j < i ,(17)\nwhere Z = y\u2208Y(s 0:N ) P(y) = (\u03b1 ,R \u221e ) \u03b8 C,R 0,N . Finally, we sketch the equations for computing inside scores in O(N 3 ) time. The outside equations can be derived analogously (see (Paskin, 2001)). For 0 \u2264 i < j \u2264 N :\n\u03b8 C,R i,i = \u03b1 s i ,R 1 (18) \u03b8 C,R i,j = j k=i+1 \u03b8 I,R i,k (\u03b1 s k ,R \u221e ) \u03b8 C,R k,j(19)\n\u03b8 I,R i,j = j k=i A s i ,R s j \u03b8 C,R i,k (\u03b1 s j ,L \u221e ) \u03b8 C,L k+1,j(20)", "publication_ref": ["b7", "b22"], "figure_ref": [], "table_ref": []}, {"heading": "Experiments", "text": "The goal of our experiments is to show that incorporating hidden states in a SHAG using operator models can consistently improve parsing accuracy. A second goal is to compare the spectral learning algorithm to EM, a standard learning method that also induces hidden states. The first set of experiments involve fully unlexicalized models, i.e. parsing part-of-speech tag sequences. While this setting falls behind the stateof-the-art, it is nonetheless valid to analyze empirically the effect of incorporating hidden states via operator models, which results in large improvements. In a second set of experiments, we combine the unlexicalized hidden-state models with simple lexicalized models. Finally, we present some analysis of the automaton learned by the spectral algorithm to see the information that is captured in the hidden state space.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Fully Unlexicalized Grammars", "text": "We trained fully unlexicalized dependency grammars from dependency treebanks, that is, X are PoS tags and we parse PoS tag sequences. In all cases, our modifier sequences include special START and STOP symbols at the boundaries. 5 6 We compare the following SHAG models:\n\u2022 DET: a baseline deterministic grammar with a single state. \u2022 DET+F: a deterministic grammar with two states, one emitting the first modifier of a sequence, and another emitting the rest (see (Eisner and Smith, 2010) for a similar deterministic baseline).\n\u2022 SPECTRAL: a non-deterministic grammar with n hidden states trained with the spectral algorithm. n is a parameter of the model. \u2022 EM: a non-deterministic grammar with n states trained with EM. Here, we estimate operators \u03b1 1 , \u03b1 \u221e , A h,d a using forwardbackward for the E step. To initialize, we mimicked an HMM initialization: (1) we set \u03b1 1 and \u03b1 \u221e randomly; (2) we created a random transition matrix T \u2208 R n\u00d7n ; (3) we STOP symbols can be packed into \u03b11 and \u03b1\u221e respectively. One just defines \u03b1 1 = ASTART \u03b11 and \u03b1 \u221e = \u03b1 \u221e ASTOP. We trained SHAG models using the standard WSJ sections of the English Penn Treebank (Marcus et al., 1994). Figure 1 shows the Unlabeled Attachment Score (UAS) curve on the development set, in terms of the number of hidden states for the spectral and EM models. We can see that DET+F largely outperforms DET 7 , while the hidden-state models obtain much larger improvements. For the EM model, we show the accuracy curve after 5, 10, 25 and 100 iterations. 8 In terms of peak accuracies, EM gives a slightly better result than the spectral method (80.51% for EM with 15 states versus 79.75% for the spectral method with 9 states). However, the spectral algorithm is much faster to train. With our Matlab implementation, it took about 30 seconds, while each iteration of EM took from 2 to 3 minutes, depending on the number of states. To give a concrete example, to reach an accuracy close to 80%, there is a factor of 150 between the training times of the spectral method and EM (where we compare the peak performance of the spectral method versus EM at 25 iterations with 13 states). 7 For parsing with deterministic SHAG we employ MBR inference, even though Viterbi inference can be performed exactly. In experiments on development data DET improved from 62.65% using Viterbi to 68.52% using MBR, and DET+F improved from 72.72% to 74.80%. 8 We ran EM 10 times under different initial conditions and selected the run that gave the best absolute accuracy after 100 iterations. We did not observe significant differences between the runs.  Table 1 shows results on WSJ test data, selecting the models that obtain peak performances in development. We observe the same behavior: hidden-states largely improve over deterministic baselines, and EM obtains a slight improvement over the spectral algorithm. Comparing to previous work on parsing WSJ PoS sequences, Eisner and Smith (2010) obtained an accuracy of 75.6% using a deterministic SHAG that uses information about dependency lengths. However, they used Viterbi inference, which we found to perform worse than MBR inference (see footnote 7).", "publication_ref": ["b8", "b15", "b8"], "figure_ref": ["fig_0"], "table_ref": ["tab_1"]}, {"heading": "Experiments with Lexicalized Grammars", "text": "We now turn to combining lexicalized deterministic grammars with the unlexicalized grammars obtained in the previous experiment using the spectral algorithm. The goal behind this experiment is to show that the information captured in hidden states is complimentary to head-modifier lexical preferences.\nIn this case X consists of lexical items, and we assume access to the PoS tag of each lexical item. We will denote as t a and w a the PoS tag and word of a symbol a \u2208X . We will estimate conditional distributions P(a | h, d, \u03c3), where a \u2208 X is a modifier, h \u2208X is a head, d is a direction, and \u03c3 is a deterministic state. Following Collins (1999), we use three configurations of deterministic states:\n\u2022 LEX: a single state.\n\u2022 LEX+F: two distinct states for first modifier and rest of modifiers. \u2022 LEX+FCP: four distinct states, encoding: first modifier, previous modifier was a coordination, previous modifier was punctuation, and previous modifier was some other word.\nTo estimate P we use a back-off strategy:  coarse level conditions on {t h , d, \u03c3}. For P B we use three levels, which from fine to coarse are {t a , w h , d, \u03c3}, {t a , t h , d, \u03c3} and {t a }. We follow Collins (1999) to estimate P A and P B from a treebank using a back-off strategy.\nP(a|h, d, \u03c3) = P A (t\nWe use a simple approach to combine lexical models with the unlexical hidden-state models we obtained in the previous experiment. Namely, we use a log-linear model that computes scores for head-modifier sequences as s( h, d, x 1:T ) = log P sp (x 1:T |h, d) (21) + log P det (x 1:T |h, d) ,\nwhere P sp and P det are respectively spectral and deterministic probabilistic models. We tested combinations of each deterministic model with the spectral unlexicalized model using different number of states. Figure 2 shows the accuracies of single deterministic models, together with combinations using different number of states. In all cases, the combinations largely improve over the purely deterministic lexical counterparts, suggesting that the information encoded in hidden states is complementary to lexical preferences.", "publication_ref": ["b5"], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "Results Analysis", "text": "We conclude the experiments by analyzing the state space learned by the spectral algorithm. Consider the space R n where the forward-state vectors lie. Generating a modifier sequence corresponds to a path through the n-dimensional state space. We clustered sets of forward-state vectors in order to create a DFA that we can use to visualize the phenomena captured by the state space.  To build a DFA, we computed the forward vectors corresponding to frequent prefixes of modifier sequences of the development set. Then, we clustered these vectors using a Group Average Agglomerative algorithm using the cosine similarity measure (Manning et al., 2008). This similarity measure is appropriate because it compares the angle between vectors, and is not affected by their magnitude (the magnitude of forward vectors decreases with the number of modifiers generated). Each cluster i defines a state in the DFA, and we say that a sequence x 1:t is in state i if its corresponding forward vector at time t is in cluster i. Then, transitions in the DFA are defined using a procedure that looks at how sequences traverse the states. If a sequence x 1:t is at state i at time t \u2212 1, and goes to state j at time t, then we define a transition from state i to state j with label x t . This procedure may require merging states to give a consistent DFA, because different sequences may define different transitions for the same states and modifiers. After doing a merge, new merges may be required, so the procedure must be repeated until a DFA is obtained.\nFor this analysis, we took the spectral model with 9 states, and built DFA from the nondeterministic automata corresponding to heads and directions where we saw largest improve-ments in accuracy with respect to the baselines.\nA DFA for the automaton (NN, LEFT) is shown in Figure 3. The vectors were originally divided in ten clusters, but the DFA construction required two state mergings, leading to a eight state automaton. The state named I is the initial state. Clearly, we can see that there are special states for punctuation (state 9) and coordination (states 1 and 5). States 0 and 2 are harder to interpret. To understand them better, we computed an estimation of the probabilities of the transitions, by counting the number of times each of them is used. We found that our estimation of generating STOP from state 0 is 0.67, and from state 2 it is 0.15. Interestingly, state 2 can transition to state 0 generating prp$, POS or DT, that are usual endings of modifier sequences for nouns (recall that modifiers are generated head-outwards, so for a left automaton the final modifier is the left-most modifier in the sentence).", "publication_ref": ["b14"], "figure_ref": ["fig_3"], "table_ref": []}, {"heading": "Conclusion", "text": "Our main contribution is a basic tool for inducing sequential hidden structure in dependency grammars. Most of the recent work in dependency parsing has explored explicit feature engineering. In part, this may be attributed to the high cost of using tools such as EM to induce representations. Our experiments have shown that adding hiddenstructure improves parsing accuracy, and that our spectral algorithm is highly scalable.\nOur methods may be used to enrich the representational power of more sophisticated dependency models. For example, future work should consider enhancing lexicalized dependency grammars with hidden states that summarize lexical dependencies. Another line for future research should extend the learning algorithm to be able to capture vertical hidden relations in the dependency tree, in addition to sequential relations.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Quadratic weighted automata: Spectral algorithm and likelihood maximization", "journal": "", "year": "2011", "authors": "Raphael Bailly"}, {"ref_id": "b1", "title": "Trainable grammars for speech recognition", "journal": "Acoustical Society of America", "year": "1979", "authors": "James K Baker"}, {"ref_id": "b2", "title": "Local loss optimization in operator models: A new insight into spectral learning", "journal": "", "year": "2012", "authors": "Borja Balle; Ariadna Quattoni; Xavier Carreras"}, {"ref_id": "b3", "title": "Experiments with a higherorder projective dependency parser", "journal": "", "year": "2007-06", "authors": "Xavier Carreras"}, {"ref_id": "b4", "title": "Parsing the wsj using ccg and log-linear models", "journal": "", "year": "2004-07", "authors": "Stephen Clark; James R Curran"}, {"ref_id": "b5", "title": "Head-Driven Statistical Models for Natural Language Parsing", "journal": "", "year": "1999", "authors": "Michael Collins"}, {"ref_id": "b6", "title": "Maximum likelihood from incomplete data via the em algorithm", "journal": "Journal of the royal statistical society, Series B", "year": "1977", "authors": "Arthur P Dempster; Nan M Laird; Donald B "}, {"ref_id": "b7", "title": "Efficient parsing for bilexical context-free grammars and headautomaton grammars", "journal": "", "year": "1999-06", "authors": "Jason Eisner; Giorgio Satta"}, {"ref_id": "b8", "title": "Favor short dependencies: Parsing with soft and hard constraints on dependency length", "journal": "Springer", "year": "2010", "authors": "Jason Eisner; Noah A Smith"}, {"ref_id": "b9", "title": "Bilexical grammars and their cubic-time parsing algorithms", "journal": "Kluwer Academic Publishers", "year": "2000-10", "authors": "Jason Eisner"}, {"ref_id": "b10", "title": "Parsing algorithms and metrics", "journal": "Association for Computational Linguistics", "year": "1996", "authors": "Joshua Goodman"}, {"ref_id": "b11", "title": "A spectral algorithm for learning hidden markov models", "journal": "", "year": "2009", "authors": "Daniel Hsu; M Sham; Tong Kakade;  Zhang"}, {"ref_id": "b12", "title": "Alternative approaches for generating bodies of grammar rules", "journal": "", "year": "2004-07", "authors": "Gabriel Infante; - Lopez; Maarten De Rijke"}, {"ref_id": "b13", "title": "Efficient thirdorder dependency parsers", "journal": "Association for Computational Linguistics", "year": "2010-07", "authors": "Terry Koo; Michael Collins"}, {"ref_id": "b14", "title": "Introduction to Information Retrieval", "journal": "Cambridge University Press", "year": "2008-07", "authors": "Christopher D Manning; Prabhakar Raghavan; Hinrich Sch\u00fctze"}, {"ref_id": "b15", "title": "Building a large annotated corpus of english: The penn treebank", "journal": "Computational Linguistics", "year": "1994", "authors": "Mitchell P Marcus; Beatrice Santorini; Mary A Marcinkiewicz"}, {"ref_id": "b16", "title": "Concise integer linear programming formulations for dependency parsing", "journal": "Association for Computational Linguistics", "year": "2009-08", "authors": "Andre Martins; Noah Smith; Eric Xing"}, {"ref_id": "b17", "title": "Probabilistic CFG with latent annotations", "journal": "", "year": "2005", "authors": "Takuya Matsuzaki; Yusuke Miyao; Jun'ichi Tsujii"}, {"ref_id": "b18", "title": "Online learning of approximate dependency parsing algorithms", "journal": "", "year": "2006", "authors": "Ryan Mcdonald; Fernando Pereira"}, {"ref_id": "b19", "title": "Non-projective dependency parsing using spanning tree algorithms", "journal": "Association for Computational Linguistics", "year": "2005-01", "authors": "Ryan Mcdonald; Fernando Pereira; Kiril Ribarov"}, {"ref_id": "b20", "title": "Unlexicalised hidden variable models of split dependency grammars", "journal": "Association for Computational Linguistics", "year": "2008-06", "authors": "Gabriele Antonio Musillo; Paola Merlo"}, {"ref_id": "b21", "title": "Complexity results and approximation strategies for map explanations", "journal": "Journal of Artificial Intelligence Research", "year": "2004", "authors": "James D Park; Adnan Darwiche"}, {"ref_id": "b22", "title": "Cubic-time parsing and learning algorithms for grammatical bigram models", "journal": "", "year": "2001", "authors": "Mark Paskin"}, {"ref_id": "b23", "title": "Improved inference for unlexicalized parsing", "journal": "Association for Computational Linguistics", "year": "2007-04", "authors": "Slav Petrov; Dan Klein"}, {"ref_id": "b24", "title": "Learning accurate, compact, and interpretable tree annotation", "journal": "", "year": "2006-07", "authors": "Slav Petrov; Leon Barrett; Romain Thibaux; Dan Klein"}, {"ref_id": "b25", "title": "Loss minimization in parse reranking", "journal": "", "year": "2006", "authors": "Ivan Titov; James Henderson"}, {"ref_id": "b26", "title": "A latent variable model for generative dependency parsing", "journal": "", "year": "2007-06", "authors": "Ivan Titov; James Henderson"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 1 :1Figure 1: Accuracy curve on English development set for fully unlexicalized models.", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 2 :2Figure 2: Accuracy curve on English development set for lexicalized models.", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Figure 3 :3Figure 3: DFA approximation for the generation of NN left modifier sequences.", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "Unlabeled Attachment Score of fully unlexicalized models on the WSJ test set.", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_2", "figure_caption": "To estimate P A we use two back-off levels, the fine level conditions on {w h , d, \u03c3} and the", "figure_data": "8684unlabeled attachment score76 78 80 82 74Lex Lex+F Lex+FCP Lex + SpectralLex+F + Spectral72Lex+FCP + Spectral2345678910number of states"}], "formulas": [{"formula_id": "formula_0", "formula_text": "L(y, x T ) \u2022 \u2022 \u2022 L(y, x 1 ) h L(y, x 1 ) \u2022 \u2022 \u2022 L(y, x T ). 1", "formula_coordinates": [2.0, 302.54, 422.69, 215.5, 14.07]}, {"formula_id": "formula_1", "formula_text": "P(y) = h,d,x 1:T \u2208y P(x 1:T |h, d) .(1)", "formula_coordinates": [2.0, 334.23, 526.64, 184.31, 23.75]}, {"formula_id": "formula_2", "formula_text": "P(x 1:T |h, d) = T +1 t=1 P(x t |h, d, \u03c3 t ) , (2)", "formula_coordinates": [2.0, 330.01, 590.01, 188.54, 33.58]}, {"formula_id": "formula_3", "formula_text": "f (x 1:T ) = \u03b1 \u221e A x T \u2022 \u2022 \u2022 A x 1 \u03b1 1 .(3)", "formula_coordinates": [3.0, 102.78, 153.65, 185.36, 11.69]}, {"formula_id": "formula_4", "formula_text": "P(x 1:T |h, d) = (\u03b1 h,d \u221e ) A h,d x T \u2022 \u2022 \u2022 A h,d x 1 \u03b1 h,d 1 .", "formula_coordinates": [3.0, 311.02, 493.22, 199.04, 15.95]}, {"formula_id": "formula_5", "formula_text": "\u03b1 h,d 1 , \u03b1 h,d \u221e , {A h,d a }", "formula_coordinates": [3.0, 399.78, 559.11, 79.09, 15.42]}, {"formula_id": "formula_6", "formula_text": "P(x 1:T ) = \u03b1 \u221e A x T \u2022 \u2022 \u2022 A x 1 \u03b1 1 . (4", "formula_coordinates": [4.0, 105.43, 203.92, 178.47, 11.69]}, {"formula_id": "formula_7", "formula_text": ")", "formula_coordinates": [4.0, 283.9, 204.27, 4.24, 9.46]}, {"formula_id": "formula_8", "formula_text": "f (x) = E(x x ) = x \u2208X * (x x )P(x ) = p,s\u2208X * P(pxs) ,(5)", "formula_coordinates": [4.0, 116.81, 466.59, 171.33, 72.21]}, {"formula_id": "formula_9", "formula_text": "P (b, a) = E(ab x) . (6", "formula_coordinates": [4.0, 127.09, 710.61, 156.81, 10.18]}, {"formula_id": "formula_10", "formula_text": ")", "formula_coordinates": [4.0, 283.9, 710.96, 4.24, 9.46]}, {"formula_id": "formula_11", "formula_text": "P b (c, a) = E(abc x) ,(7)", "formula_coordinates": [4.0, 353.81, 105.58, 164.74, 10.77]}, {"formula_id": "formula_12", "formula_text": "P (b, a) = p,s\u2208X * P(pabs) (8) = p,s\u2208X * \u03b1 \u221e A s A b A a A p \u03b1 1 = (\u03b1 \u221e s\u2208X * A s ) A b A a ( p\u2208X * A p \u03b1 1 ) .", "formula_coordinates": [4.0, 306.99, 268.65, 211.55, 84.95]}, {"formula_id": "formula_13", "formula_text": "p\u2208X * A p = k\u22650 ( a\u2208X A a ) k = (I \u2212 a\u2208X A a ) \u22121 , we write\u03b1 1 = (I \u2212 a\u2208X A a ) \u22121 \u03b1 1 . From (", "formula_coordinates": [4.0, 302.54, 390.54, 216.0, 42.15]}, {"formula_id": "formula_14", "formula_text": "F (:, a) = A a p\u2208X * A p \u03b1 1 = A a\u03b11 . (9)", "formula_coordinates": [4.0, 329.81, 494.59, 188.73, 22.26]}, {"formula_id": "formula_15", "formula_text": "B(a, :) = \u03b1 \u221e s\u2208X * A s A a = 1 A a . (10", "formula_coordinates": [4.0, 321.12, 573.63, 192.88, 22.26]}, {"formula_id": "formula_16", "formula_text": ")", "formula_coordinates": [4.0, 514.0, 573.98, 4.54, 9.46]}, {"formula_id": "formula_17", "formula_text": "\u03b1 1 = U p 1 , (11", "formula_coordinates": [5.0, 123.28, 467.5, 254.97, 10.63]}, {"formula_id": "formula_18", "formula_text": ") \u03b1 \u221e = p \u221e (U P ) + , (12", "formula_coordinates": [5.0, 119.05, 467.85, 295.3, 27.88]}, {"formula_id": "formula_19", "formula_text": ") A a = U P a (U P ) + . (13", "formula_coordinates": [5.0, 121.81, 484.39, 287.98, 26.82]}, {"formula_id": "formula_20", "formula_text": ")", "formula_coordinates": [5.0, 283.6, 500.92, 4.54, 9.46]}, {"formula_id": "formula_21", "formula_text": "\u03b11 = U B\u03b11 = M \u22121 \u03b11 , \u03b1 \u221e = \u03b1 \u221e F (U BF ) + = \u03b1 \u221e M , Aa = U BAaF (U BF ) + = M \u22121 AaM .", "formula_coordinates": [5.0, 88.34, 637.7, 255.91, 38.03]}, {"formula_id": "formula_22", "formula_text": "P(x1:T ) = \u03b1 \u221e Ax T \u2022 \u2022 \u2022 Ax 1 \u03b11 = \u03b1 \u221e M M \u22121 Ax T M \u2022 \u2022 \u2022 M \u22121 Ax 1 M M \u22121 \u03b11 =\u1fb1 \u221e\u0100xT \u2022 \u2022 \u2022\u0100x 1\u1fb1 1 Algorithm 1 Learn Operator SHAG inputs: \u2022 An alphabet X \u2022 A training set TRAIN = { h i , d i , x i 1:T } M i=1", "formula_coordinates": [5.0, 73.85, 71.38, 424.87, 672.23]}, {"formula_id": "formula_23", "formula_text": "5: \u03b1 h,d 1 = U p 1 6: ( \u03b1 h,d \u221e ) = p \u221e ( U P ) + 7:", "formula_coordinates": [5.0, 307.52, 210.45, 135.08, 38.05]}, {"formula_id": "formula_24", "formula_text": "9: return Operators \u03b1 h,d 1 , \u03b1 h,d \u221e , A h,d a for each h \u2208X , d \u2208 {LEFT, RIGHT}, a \u2208 X", "formula_coordinates": [5.0, 307.52, 260.93, 209.56, 25.65]}, {"formula_id": "formula_25", "formula_text": "y = argmax y\u2208Y(s 0:N ) (s i ,s j )\u2208y log \u00b5 i,j(14)", "formula_coordinates": [6.0, 115.36, 272.05, 172.78, 23.62]}, {"formula_id": "formula_26", "formula_text": "\u03c6 I,R i,j = y\u2208Y(s 0:i s j:n ) : root(y)=s 0 , y={ s i ,R,x t:T } \u222a y , xt=s j P(y )\u03b2 s i ,R (x t+1:T ) , (16", "formula_coordinates": [6.0, 313.4, 373.29, 200.59, 35.83]}, {"formula_id": "formula_27", "formula_text": ")", "formula_coordinates": [6.0, 514.0, 376.14, 4.54, 9.46]}, {"formula_id": "formula_28", "formula_text": "\u00b5 i,j = (\u03c6 I,R i,j ) \u03b8 I,R i,j Z \u22121 if i < j , (\u03c6 I,L i,j ) \u03b8 I,L i,j Z \u22121 if j < i ,(17)", "formula_coordinates": [6.0, 315.55, 540.05, 203.0, 31.88]}, {"formula_id": "formula_29", "formula_text": "\u03b8 C,R i,i = \u03b1 s i ,R 1 (18) \u03b8 C,R i,j = j k=i+1 \u03b8 I,R i,k (\u03b1 s k ,R \u221e ) \u03b8 C,R k,j(19)", "formula_coordinates": [6.0, 317.35, 665.4, 201.19, 55.02]}, {"formula_id": "formula_30", "formula_text": "\u03b8 I,R i,j = j k=i A s i ,R s j \u03b8 C,R i,k (\u03b1 s j ,L \u221e ) \u03b8 C,L k+1,j(20)", "formula_coordinates": [6.0, 319.48, 725.69, 199.06, 34.56]}, {"formula_id": "formula_31", "formula_text": "P(a|h, d, \u03c3) = P A (t", "formula_coordinates": [8.0, 76.15, 714.27, 88.47, 10.69]}], "doi": ""}