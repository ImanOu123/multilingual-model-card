{"title": "Reasonable Highly Expressive Query Languages", "authors": "Pierre Bourhis; Markus Kr\u00f6tzsch; Sebastian Rudolph", "pub_date": "", "abstract": "Expressive query languages are gaining relevance in knowledge representation (KR), and new reasoning problems come to the fore. Especially query containment is interesting in this context. The problem is known to be decidable for many expressive query languages, but exact complexities are often missing. We introduce a new query language, guarded queries (GQ), which generalizes most known languages where query containment is decidable. GQs can be nested (more expressive), or restricted to linear recursion (less expressive). Our comprehensive analysis of the computational properties and expressiveness of (linear/nested) GQs also yields insights on many previous languages.", "sections": [{"heading": "Introduction", "text": "The significance of query languages in KR is twofold. On the one hand, evaluating queries in the presence of a background ontology allows us to express more complex information needs, leading to the notion of ontology-based query answering. This topic has been studied for a wide range of ontology languages and many different query languages, including conjunctive queries [Calvanese et al., 2007b; and (many variants of) regular path queries [Calvanese et al., 2007a;Bienvenu et al., 2014]. On the other hand, recursive queries can be used to \"implement\" reasoning, such that the query plays the role of a logical calculus that computes subsumptions [Xiao et al., 2010;Kr\u00f6tzsch, 2011;Bischoff et al., 2014].\nIn both application areas, we can see a tendency towards more and more powerful recursive queries. Recent works introduced several highly expressive query languages related to applications in KR: Monadically Defined Queries (MQs) [Rudolph and Kr\u00f6tzsch, 2013] and Monadic Disjunctive SNP queries (coMMSNP) [Bienvenu et al., 2013]. Both can be viewed as fragments of (disjunctive) Datalog.\nThe proliferation of query languages and their uses in KR raises new questions. The complexity of ontology-based query answering has been studied from its inception, whereas the equally important question of relative expressiveness was studied only recently [Bienvenu et al., 2013]. Another important question is the problem of query containment, where we Figure 1: Query languages and complexities; languages higher up in the graph are more expressive consider two queries Q 1 and Q 2 , and ask if every answer to Q 1 is also an answer to Q 2 over all possible inputs. Deciding query containment is relevant for query rewriting algorithms, where it needs to be checked if new queries are contained in previous ones to ensure termination. Further relevant applications are query optimization (finding a simpler yet equivalent query), and verification (checking that a query contains specific test cases). In addition, query containment has a range of applications in databases, e.g., in information integration and database integrity checking.\nAlthough Datalog provides a useful framework for studying many recursive query languages, it does, unfortunately, not have a decidable query containment problem [Shmueli, 1987]. In contrast, the containment is known to be decidable for regular path queries, MQs, and coMMSNP queries. In the latter two cases, however, no upper complexity bound is known. Nevertheless, numerous results exist for various smaller query languages. For the following overview, recall that a predicate in a Datalog program is intensional (IDB) if it occurs in some rule head, and extentional (EDB) otherwise.", "publication_ref": ["b1", "b1", "b6", "b4", "b6"], "figure_ref": [], "table_ref": []}, {"heading": "Non-recursive Datalog and unions of conjunctive queries", "text": "A non-recursive Datalog program is equivalent to a (possibly exponential) union of conjunctive queries (UCQ), and thus expressible in first-order logic. Containment of Datalog (Dlog) [Chaudhuri and Vardi, 1997]. Some restrictions for decreasing these complexities have been considered. Deciding if a linear Datalog program (LinDlog, where rule bodies contain at most one recursive predicate) is contained in a UCQ is ExpSpace-complete; complexity further decreases to PSpace when the linear Datalog program is monadic (LinMDlog, see below) [Chaudhuri and Vardi, 1994;1997]. Monadic Datalog A monadic Datalog (MDlog) program is one with only unary IDB predicates. Containment between two MDlog programs is 2ExpTime-complete. The upper bound is well known since the 80's [Cosmadakis et al., 1988], while the lower bound has been established only recently [Benedikt et al., 2012]. Moreover, the containment of Dlog in MDlog is also decidable by a straightforward application of [Courcelle, 1991, Theorem 5.5]. 1 So far, however, tight bounds have not been known for this case. Guarded Datalog Guarded Datalog (GDlog) requires that, for each rule, the variables of the head should appear in a single EDB atom in the rule body. Such (frontier-)guarded rules have been known for a while [Cal\u00ec et al., 2008;Baget et al., 2011], but their first use as a query language is recent [B\u00e1r\u00e1ny et al., 2012]. GDlog is a proper extension of MDlog, since monadic rules can be rewritten into guarded rules [B\u00e1r\u00e1ny et al., 2012]. Query containment for GDlog is 2ExpTimecomplete, as it corresponds to a satisfiability problem for guarded negation fixed point logic [B\u00e1r\u00e1ny et al., 2011]. Navigational Queries Conjunctive two-way regular path queries (C2RPQs) generalize conjunctive queries (CQs) by regular expressions over binary predicates [Florescu et al., 1998;Calvanese et al., 2003]. Variants of this idea are used in the RDF query language SPARQL 1.1 and the XML query language XPath. Roughly, C2RPQ is a conjunction of atoms of the form xLy where L is a two-way regular expression. A pair of nodes n 1 , n 2 is a valuation of the pair x, y if and only if there exists a path between n 1 and n 2 matching L. Containment of such queries is ExpSpace-complete [Florescu et al., 1998;Calvanese et al., 2003;Abiteboul and Vianu, 1999;Deutsch and Tannen, 2002], while containment of Dlog in C2RPQ is 2ExpTime-complete [Calvanese et al., 2005]. Fragments of Monadic Second-Order Logic More recently, Monadically Defined Queries (MQs) and their nested version (MQ + s) have been introduced as a proper generalization of MDlog that also captures (unions of) C2RPQs [Rudolph and Kr\u00f6tzsch, 2013]. MQs are expressible in both Dlog and monadic second-order logic, but (in contrast to these languages) feature a decidable query containment problem. The most general recent query language for which containment is known to be decidable is coMMSNP [Bienvenu et al., 2013], a fragment of monadic second-order logic motivated by descriptive complexity. As opposed to the above languages, coMMSNP is a non-deterministic query language, closely related to disjunctive Datalog. A simple inspection of the definitions shows that the deterministic (disjunction-free) fragment, i.e., \"Horn-coMMSNP\", agrees with MQ.\nIn this paper, we further extend the known recursive query languages and at the same time settle all major questions re-lated to the complexity of their query containment problems. Figure 1 gives an overview of all languages we consider, together with their respective query-answering complexities.\nThe main new query language we consider is called guarded queries (GQ), and is based on the use of frontierguarded Datalog rules. GQ can be viewed as an extension of MQ, and is indeed inspired by a similar extension for coMMSNP [Bienvenu et al., 2013]. GQ thus also generalizes frontier-guarded Datalog. We further introduce the nested and linear variant of GQ, and establish complexity results for query answering in all cases.\nWe then turn towards query containment. We obtain tight complexity bounds for (nested) GQs and many other query languages, which are summarized in Table 1. To show the upper bounds, we extend known automata-based approaches by a number of new techniques. Lower bounds are obtained by simulating space-bounded alternating Turing machines in a way that allows for an exponential increase in space with each nesting level. Finally, we also sketch how our results transfer to the case of linear Datalog, where many complexities can be slightly reduced.\nIn summary, our results settle open problems for (nested) MQs, painting a comprehensive and detailed picture of the state of the art in Datalog query containment. Full proofs can be found in an accompanying report [Bourhis et al., 2015].", "publication_ref": ["b1", "b1", "b1", "b0", "b1", "b0", "b0", "b0", "b0", "b3", "b1", "b3", "b1", "b0", "b1", "b4", "b0"], "figure_ref": [], "table_ref": ["tab_3"]}, {"heading": "Preliminaries", "text": "We consider a standard language of first-order predicate logic, based on an infinite set C of constant symbols, an infinite set P of predicate symbols, and an infinite set V of firstorder variables. Each predicate p \u2208 P is associated with a natural number ar(p) called the arity of p. The list of predicates and constants forms the language's signature S = P, C . We generally assume S = P, C to be fixed, and only refer to it explicitly if needed. Formulae, Rules, and Queries A term is a variable x \u2208 V or a constant c \u2208 C. We use symbols s, t to denote terms, x, y, z, v, w to denote variables, a, b, c to denote constants. Expressions like t, x, c denote finite lists of such entities. We use the standard predicate logic definitions of atom and formula, using symbols \u03d5, \u03c8 for the latter.\nDatalog queries are defined over an extended signature with additional predicate symbols, called IDB predicates; all other predicates are called EDB predicates. A Datalog rule is a formula of the form \u2200x, y.\u03d5[x, y] \u2192 \u03c8[x] where \u03d5 and \u03c8 are conjunctions of atoms, called the body and head of the rule, respectively, and where \u03c8 only contains IDB predicates. We usually omit universal quantifiers when writing rules. Sets of Datalog rules are denoted P, R, S. A set of Datalog rules is:\n\u2022 monadic if all IDB predicates are of arity one;\n\u2022 frontier-guarded if the body of every rule contains an atom p(t) such that p is an EDB predicate and t contains all variables that occur in the rule's head; \u2022 linear if each rule body has at most one IDB predicate. A conjunctive query (CQ) is a formula Q[x] = \u2203y.\u03c8 [x, y] where \u03c8[x, y] is a conjunction of atoms; a union of conjunctive queries (UCQ) is a disjunction of such formulae. A Dat-alog query P, Q consists of a set of Datalog rules P and a conjunctive query Q over IDB or EDB predicates (Q could be expressed as a rule in Datalog, but not in all restrictions of Datalog we consider). We write Dlog for the language of Datalog queries. A monadic Datalog query is one where P is monadic, and similarly for other restrictions. We use the query languages MDlog (monadic), GDlog (frontier-guarded), LinDlog (linear), and LinMDlog (linear, monadic). Databases and Semantics We use the standard semantics of first-order logic (FOL). A database instance I over a signature S = P, C consists of a set \u2206 I called domain and a function \u2022 I that maps constants c \u2208 C to domain elements c I \u2208 \u2206 I and predicate symbols p \u2208 P to relations p I \u2286 (\u2206 I ) ar (p) , where p I is the extension of p.\nGiven a database instance I and a formula \u03d5[x] with free variables x = x 1 , . . . , x m , the extension of \u03d5[x] is the subset of (\u2206 I ) m containing all those tuples \u03b4 1 , . . . , \u03b4 m for which\nI, {x i \u2192 \u03b4 i | 1 \u2264 i \u2264 m} | = \u03d5[x].\nWe denote this by \u03b4 1 , . . . , \u03b4 m \u2208 \u03d5 I or by I | = \u03d5(\u03b4 1 , . . . , \u03b4 m ); a similar notation is used for all other types of query languages. Two formulae \u03d5[x] and \u03c8[x] are called equivalent if their extensions coincide for every database instance I.\nThe set of answers of a UCQ Q[x] over I is its extension. A Datalog program P is satisfied by database instance I over the extended signature of EDB and IDB predicates, if all rules of P are satisfied by I in the usual sense. The set of answers of a Datalog query P, Q over I is the intersection of the extensions of Q over all extended database instances I that satisfy P and agree with I on constants and EDB predicates. Datalog can also be defined as the least fixpoint of the inflationary evaluation of Q on I [Abiteboul et al., 1994].\nWe do not require database instances to have a finite domain, since all of our results are valid in either case. This is due to the fact that every entailment of a Datalog program has a finite witness, and that all of our query languages are positive, i.e., that their answers are preserved under homomorphisms of database instances.\nAn important reasoning task on queries is to determine if a query contains another. In particular, a Datalog query P, Q is contained in a Datalog query P , Q , denoted P, Q P , Q , iff for each database instance I over the signature of EDB predicates and constants, the set of answers of P, Q over I is included in the set of answers of P , Q over I.", "publication_ref": ["b0"], "figure_ref": [], "table_ref": []}, {"heading": "Guarded Queries", "text": "Rudolph and Kr\u00f6tzsch [2013] introduced monadically defined queries (MQs 2 ) as a generalization of conjunctive twoway regular path queries (C2RPQs) and monadic Datalog (MDlog) for which query containment is still decidable. The idea underlying this approach is that candidate query answers are checked by evaluating a monadic Datalog program, i.e., in contrast to the usual evaluation of Datalog queries, we start with a \"guessed\" answer that is the input to a Datalog program. To implement this, the candidate answer is represented by special constants \u03bb that the Datalog program can refer to. This mechanism was called flag & check, since the special constants act as flags to indicate the answer to be checked. 2 Here we shorten the original acronym MODEQ to MQ. Example 1. A query that computes the transitive closure over a relation p can be defined as follows.\np(\u03bb 1 , y) \u2192 U(y) U(y) \u2227 p(y, z) \u2192 U(z) U(\u03bb 2 ) \u2192 hit\nOne defines the answer of the query to contain all pairs \u03b4 1 , \u03b4 2 for which the rules entail hit when interpreting \u03bb 1 as \u03b4 1 and \u03bb 2 as \u03b4 2 .\nThe original approach used monadic Datalog for its close relationship to monadic second-order logic, which was the basis for showing decidability of query containment. In this work, however, we develop new techniques for showing the decidability (and exact complexity) of this problem directly. It is therefore suggestive to consider other types of Datalog programs for the \"check\" part. The next definition introduces the general approach for arbitrary Datalog programs, and defines interesting fragments by imposing further restrictions. Definition 1. Consider a signature S . An FCP (\"flag & check program\") of arity m is a set of Datalog rules P with k \u2265 0 IDB predicates U 1 , . . . , U k that may use the additional constant symbols \u03bb 1 , . . . , \u03bb m S and an additional nullary predicate symbol hit. An FCQ (\"flag & check query\") P is of the form \u2203y.P(z), where P is an FCP of arity |z| and all variables in y occur in z. The variables x that occur in z but not in y are the free variables of P.\nLet I be a database instance over S . The extension P I of P is the set of all tuples \u03b4 1 , . . . , \u03b4 m \u2208 (\u2206 I ) m such that every database instance I that extends I to the signature of P and that satisfies \u03bb I 1 , . . . , \u03bb I m = \u03b4 1 , . . . , \u03b4 m also entails hit. The semantics of FCQs is defined in the obvious way based on the extension of FCPs.\nA GQ is an FCQ \u2203y.P(z) such that P is frontier-guarded. Similarly, we define MQ (monadic), LinMQ (linear, monadic), and LinGQ (linear, frontier-guarded) queries.\nIn contrast to Rudolph and Kr\u00f6tzsch [2013], we do not define monadic queries as conjunctive queries of FCPs, but we merely allow existential quantification to project some of the FCP variables. Proposition 1 below shows that this does not reduce expressiveness.\nWe generally consider monadic Datalog as a special case of frontier-guarded Datalog. Monadic Datalog rules do not have to be frontier-guarded. A direct way to obtain a suitable guard is to assume that there is a unary domain predicate that contains all (relevant) elements of the domain of the database instance. However, it already suffices to require safety of Datalog rules, i.e., that the variable in the head of a rule must also occur in the body. Then every element that is inferred to belong to an IDB relation must also occur in some EDB relation. We can therefore add single EDB guard atoms to each rule in all possible ways without modifying the semantics. This is a polynomial operation, since all variables in the guards are fresh, other than the single head variable that we want to guard. We therefore find, in particular, that GQ captures the expressiveness of MQ. The converse is not true, as the following example illustrates.\nExample 2. The following 4-ary LinGQ generalizes Example 1 by checking for the existence of two parallel p-chains of arbitrary length, where each pair of elements along the chains is connected by a relation q, like the steps of a ladder.\nq(\u03bb 1 , \u03bb 2 ) \u2192 U q (\u03bb 1 , \u03bb 2 ) U q (x, y) \u2227 p(x, x ) \u2227 p(y, y ), q(x , y ) \u2192 U q (x , y ) U q (\u03bb 3 , \u03bb 4 ) \u2192 hit\nOne might assume that the following MQ is equivalent:\nq(\u03bb 1 , \u03bb 2 ) \u2192 U 1 (\u03bb 1 ) q(\u03bb 1 , \u03bb 2 ) \u2192 U 2 (\u03bb 2 ) U 1 (x) \u2227 U 2 (y) \u2227 p(x, x ) \u2227 p(y, y ), q(x , y ) \u2192 U 1 (x ) U 1 (x) \u2227 U 2 (y) \u2227 p(x, x ) \u2227 p(y, y ), q(x , y ) \u2192 U 2 (y ) U 1 (\u03bb 3 ) \u2227 U 2 (\u03bb 4 ) \u2192 hit\nHowever, the latter query also matches structures that are not ladders. For example, the following database yields the answer a, b, c, d , although there is no corresponding ladder structure: {q(a, b), p(a, c), p(b, e), q(c, e), p(a, e ), p(b, d), q(e , d)}. One can extend the MQ to avoid this case, but any such fix is \"local\" in the sense that a sufficiently large ladderlike structure can trick the query.\nRudolph and Kr\u00f6tzsch [2013] showed that monadically defined queries can be expressed both in Datalog and in monadic second-order logic. While we lose the connection to monadic second-order logic with GQs, the expressibility in Datalog remains. The encoding is based on the intuition that the choice of the candidate answers for \u03bb \"contextualizes\" the inferences of the Datalog program. To express this without special constants, we can store this context information in predicates of suitably increased arity.\nExample 3. The 4-ary LinGQ of Example 2 can be expressed with the following Datalog query. For brevity, let y be the variable list y 1 , y 2 , y 3 , y 4 , which provides the context for the IDB facts we derive.\nq(y 1 , y 2 ) \u2192 U + q (y 1 , y 2 , y) U q (x, y, y) \u2227 p(x, x ) \u2227 p(y, y ), q(x , y ) \u2192 U + q (x , y , y) U q (y 3 , y 4 , y) \u2192 goal(y)\nThis result is obtained by a straightforward extension of the translation algorithm for MQs [Rudolph and Kr\u00f6tzsch, 2013], which may not produce the most concise representation. Also note that the first rule in this program is not safe, since y 3 and y 4 occur in the head but not in the body. According to the semantics we defined, such variables can be bound to any element in the active domain of the given database instance (i.e., they behave as if bound by a unary domain predicate).\nThis observation justifies that we consider MQs, GQs, etc. as Datalog fragments. It is worth noting that the translation does not change the number of IDB predicates in the body of rules, and thus preserves linearity. The relation to (linear) Datalog also yields some complexity results for query answering; we will discuss these at the end of the next section, after introducing nested variants our query languages.", "publication_ref": ["b4"], "figure_ref": [], "table_ref": []}, {"heading": "Nested Queries", "text": "Every query language gives rise to a nested language, where we allow the use of nested queries as if they were predicates. Sometimes, this does not lead to a new query language (like for CQ and Dlog), but often it affects complexities and/or expressiveness. It has been shown that both are increased when moving from MQs to their nested variants [Rudolph and Kr\u00f6tzsch, 2013]. We will see that nesting also has strong effects on the complexity of query containment. Definition 2. We define k-nested FCPs inductively. A 1nested FCP is an FCP. A k+1-nested FCP is an FCP that may use k-nested FCPs of arity m instead of predicate symbols of arity m in rule bodies. The semantics of nested FCPs is immediate based on the extension of FCPs. A k-nested FCQ P is of the form \u2203y.P(z), where P is a k-nested FCP of arity |z| and all variables in y occur in z.\nA k-nested GQ query is a k-nested frontier-guarded FCQ. For the definition of frontier-guarded, we still require EDB predicates in guards: subqueries cannot be guards. The language of k-nested GQ queries is denoted GQ k ; the language of arbitrarily nested GQ queries is denoted GQ + .\nSimilarly, we define languages MQ k and MQ + (monadic), LinMQ k and LinMQ + (linear, monadic), and LinGQ k and LinGQ + (linear, frontier-guarded).\nNote that nested queries can use the same additional symbols (predicates and constants); this does not lead to any semantic interactions, however, as the interpretation of the special symbols is \"private\" to each query. To simplify notation, we assume that distinct (sub)queries always contain distinct special symbols. The relationships of the query languages we introduced here are summarized in Figure 1, where upwards links denote increased expressiveness. An interesting observation that is represented in this figure is that linear Datalog is closed under nesting: Theorem 3. LinDlog = LinDlog + .\nAnother kind of nesting that does not add expressiveness is the nesting of FCQs in UCQs. Indeed, it turns out that (nested) FCQs can internalize arbitrary conjunctions and disjunctions of FCQs (of the same nesting level). This even holds when restricting to linear rules. Proposition 1. Let P be a positive query, i.e., a Boolean expression of disjunctions and conjunctions, of LinMQ k queries with k \u2265 1. Then there is a LinMQ k query P of size polynomial in P that is equivalent to P. Analogous results hold when replacing LinMQ k by MQ k , GQ k , or LinMQ k queries.\nQuery answering for MQs has been shown to be NPcomplete (combined complexity) and P-complete (data complexity). For MQ + , the combined complexity increases to PSpace while the data complexity remains the same. These results can be extended to GQs. We also note the complexity for frontier-guarded Datalog, for which we are not aware of any published result. Theorem 4. The combined complexity of evaluating GQ queries over a database instance is NP-complete. The same holds for GDlog queries. The combined complexity of evaluating GQ + queries is PSpace-complete. The data complexity is P-complete for GDlog, GQ, and GQ + .\nThe lower bounds in the previous case follow from know results for MQs. Particularly, the hardness proof for nested MQs also shows that queries of a fixed nesting level can encode the validity problem for quantified boolean formulae with a certain number of quantifier alternations; this explains why we show the combined complexity of MQ k to be in the Polynomial Hierarchy in Figure 1. A modification of this hardness proof of Rudolph and Kr\u00f6tzsch [2013] yields the same results for the combined complexities in the linear cases; matching upper bounds follow from Theorem 4. Theorem 5. The combined complexity of evaluating LinMQ, LinGDlog, or LinGQ queries over a database instance is NPcomplete. The combined complexity of evaluating LinMQ + or LinGQ + queries is PSpace-complete. The data complexity is NLogSpace-complete for all of these query languages.", "publication_ref": ["b4", "b4"], "figure_ref": [], "table_ref": []}, {"heading": "Complexity of Query Containment", "text": "In this section, we first discuss an automata-based way to decide query containment, yielding upper complexity bounds.\nWe first recall a general technique of reducing query containment to the containment problem for (tree) automata [Chaudhuri and Vardi, 1997]. In spite of several extensions we need for \u03bb-terms and nesting, our proofs still follow the same basic approach. An introduction to tree automata is included in the report [Bourhis et al., 2015].\nA common way to describe the answers of a Dlog query P = P, p is to consider its expansion trees. Intuitively speaking, the goal atom p(x) can be rewritten by applying rules of P in a backward-chaining manner until all IDB predicates have been eliminated, resulting in a CQ. The answers of P coincide with the (infinite) union of answers to the CQs obtained in this fashion. The rewriting itself gives rise to a tree structure, where each node is labeled by the instance of the rule that was used in the rewriting, and the leaves are instances of rules that contain only EDB predicates in their body. The set of all expansion trees provides a regular description of P that we exploit to decide containment.\nTo formalize this approach, we describe the set of all expansion trees as a tree language, i.e., as a set of trees with node labels from a finite alphabet. The number of possible labels of nodes in expansion trees is unbounded, since rules are instantiated using fresh variables. To obtain a finite alphabet of labels, one limits the number of variables and thus the overall number of possible rule instantiations [Chaudhuri and Vardi, 1997]. The set of proof trees obtained in this way is a regular tree language that can be described by an automaton A P . In order to use A P to decide containment of P by another query P , we construct an automaton A P P that accepts all proof trees of P that are \"matched\" by P . Indeed, every proof tree induces a witness, i.e., a minimal matching database instance, and one can check whether or not P can produce the same query answer on this instance. If this is the case for all proof trees of P, then containment is shown.\nOur first result provides the upper bound for deciding containment of GQ queries. In fact, the result extends to arbitrary Dlog queries on the left-hand side. Theorem 6. Containment of Dlog queries in GQ queries can be decided in 3ExpTime.\nThe proof of this result requires a number of new techniques on top of the established methods. We are looking for an automaton A P P that accepts proof trees of P where the underlying witness is also accepted by P . As a first step, we construct an automaton A P,\u03c1 that verifies that a single rule \u03c1 of P can be applied in a specific way to derive one specific conclusion. Since proof trees reuse variables to obtain a finite alphabet, the conclusion of the rule is an atom p(v) referring to variables v that are ambiguous if we do not know exactly which place in the tree we are referring to. Therefore the input of A P,\u03c1 is a proof tree of P with two kinds of additional information added to the labels: (a) the interpretation of the \u03bb constants that is used, and (b) the expected conclusion of the rule. A P,\u03c1 is a top-down tree automaton of exponential size.\nWe want to combine many automata of the form A P,\u03c1 to verify complete derivations of P rather than single rule applications. In this case, we cannot add information about the expected conclusion p(v) to the tree, since there are unboundedly many conclusions during one run. Instead, we encode the conclusion by considering auomtata A + P,\u03c1,v that can start their run not just from the root, but from some node within the tree where all variables v occur with the same meaning as in the conclusion p(v) (this is a single node due to guardedness). Starting in the middle of the tree makes it necessary to consider both nodes below and above the current position, and A + P,\u03c1,v thus needs to be an alternating 2-way tree automaton. An automaton A + P P that verifies a complete derivation of P on a proof tree of P is obtained by \"concatenating\" automata of the form A + P,\u03c1,v . A + P P is an alternating 2-way automaton that is exponential in size. The trees accepted by A + P P still need to contain information about the interpretation of \u03bb-constants. Using a well-known construction, we obtain an exponentially larger (1-way) top-down tree automaton A P P that accepts the same trees. This automaton of double exponential size can finally be changed into the automaton A P P that does not require \u03bb-annotations-a polynomial transformation. We finish with a doubly-exponential automaton A P P . Checking containment in A P is an exponential process, leading to the claimed 3ExpTime result.\nWe can modify this proof to obtain another interesting result for the case of frontier-guarded Datalog. If P is a GDlog query, which does not use any special constants \u03bb, we can directly construct a complement tree automaton\u0100 P P that is only doubly exponential [Cosmadakis et al., 1988, Theorem A.1]. Containment can then be checked by checking the non-emptiness of A P \u2229\u0100 P P , which is possible in polynomial time, leading to a 2ExpTime algorithm. Theorem 7. Containment of Dlog queries in GDlog queries can be decided in 2ExpTime.\nThis generalizes an earlier result of Cosmadakis et al. [1988] for monadic Datalog, using another, direct proof.\nTo lift our results to nested queries, we further extend the ideas developed in the non-nested case. Nested queries are similar to IDB predicates whose validity we need to check using automata. To do this, we first construct alternating two-way tree automata A + P,Q,\u03b8 that verify a match of query Q on a tree that is annotated with the expected values of the \u03bb-constants. To remove the need for this annotation when ver- and Vardi, 1994] [Bourhis et al., 2015 (k + 1)ExpSpace-c Nonelementary Undecidable ExpSpace (k + 1)ExpSpace [Bourhis et al., 2015] [Bourhis et al., 2015] [Abiteboul et al., 1994] [Bourhis et al., 2015] [Bourhis et al., 2015 LinGDlog, LinMQ n (n \u2265 2), ExpSpace-c (k + 1)ExpSpace-c (k + 1)ExpSpace-c Nonelementary Undecidable LinMQ + , LinGQ + , [Bourhis et al., 2015] [Bourhis et al., 2015] [Bourhis et al., 2015] [Bourhis et al., 2015] [Abiteboul et al., 1994  ifying subqueries as part of a longer run, we can again transform A + P,Q,\u03b8 into a tree automaton (exponential), and project away the \u03bb-annotations (polynomial). The resulting automaton A P,Q is analogous to the above tree automaton A P,\u03c1 . The rest of the proof uses similar constructions as before. The exponential transformation from A + P,Q,\u03b8 to A P,Q is the reason for the exponential complexity increase in each nesting level. Theorem 8. Containment of Dlog queries in GQ k queries can be decided in (k + 2)ExpTime.\nUCQ,LinMDlog, MDlog, LinMQ k , MQ k , LinMQ + ,MQ + , LinGDlog, GDlog LinGQ k GQ k LinGQ + ,GQ + Dlog LinMQ PSpace-h kExpSpace-h [Chaudhuri\nTo obtain matching lower bounds, we provide direct encodings of Alternating Turing Machines (ATMs) with a fixed space bound. In the context of query containment, this is done by defining a pair of queries P 1 and P 2 such that P 1 matches all structures that encode a sequence (or tree) of (unrelated) Turing machine configurations, while P 2 matches all such structures that do not correctly encode a run of the given TM (i.e., P 2 detects encoding errors). Then any structure that is matched by P 1 but not by P 2 encodes a terminating ATM run, such that the ATM halts iff P 1 is not contained in P 2 .\nTo obtain hardness results for arbitrary towers of exponential functions, all of our constructions use existing queries to construct larger queries. For example, a query SameCell[x, y] is defined to match the cells in neighboring configurations that are located at the same position of the ATM tape. This query becomes more and more complex (and more and more nested) as we go to exponentially larger tapes, but the construction of the queries needed for the next level always follows the same pattern. In spite of this efficient presentation, the complete ATM encoding requires significant space, and we must refer to the technical report for the details. Theorem 9. Deciding containment of MDlog queries in MQ k queries is hard for (k + 2)ExpTime.\nNote that the statement includes the 3ExpTime-hardness for containment of MQs as a special case.\nA range of further results can be obtained by considering linear Datalog instead of Datalog in the role of the contained query. This tends to reduce complexity since one can focus on linear derivations, which can be described by word automata instead of tree automata. Accordingly, many ExpTime problems are reduced to PSpace, and all previous complexities for (k + 2)ExpTime translate into results for (k + 1)ExpSpace accordingly. Our ATM constructions are replaced by regular TM constructions, and we obtain tight bounds in most cases. The only exception is containment of LinMQ in LinMQ k , where our lower bounds are one exponential below the upper bounds. The exact complexity remains open.", "publication_ref": ["b1", "b0", "b1", "b1", "b0", "b0", "b0", "b0", "b0", "b0", "b0", "b0", "b0", "b0", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "Conclusions", "text": "We have studied the most expressive fragments of Datalog for which query containment is known to be decidable, and we provided exact complexities for query answering and containment in most cases. Our results are summarized in Table 1. While containment tends to be nonelementary for nested queries, we have identified tight exponential complexity hierarchies depending on nesting depth. Our results settle several open problems for known query languages: the complexity of query containment for MQ and MQ + , the complexity of query containment of Dlog in GDlog, and the expressivity of nested LinDlog.\nMoreover, we have introduced new query languages based on frontier-guarded Datalog, showing that most complexities are unaffected by this extension.\nA few small questions remain open. First, our results are not tight for linear MQs. This case is closely related to conjunctive regular path queries, and inspiration might be drawn from recent results in this field [Reutter, 2013]. Another question is about the role of constants, which we use heavily in some of our hardness proofs. For the case of (linear) monadic Datalog without constants, we conjecture that containment complexities are reduced by one exponential each.\nPromising directions for future research include the study of practical containment algorithms, since our automatabased techniques do not lend themselves to implementation yet. Another interesting topic is the search for suitable queries that contain a given query. A special case of this is the boundedness problem, where we try to find a UCQ that contains a given Datalog program. This can be addressed by similar automata-based constructions [Cosmadakis et al., 1988]. Besides boundedness, one can also ask more general questions of rewritability, e.g., whether some Datalog program can be expressed in monadic Datalog or in a regular path query.", "publication_ref": ["b4"], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Magdalena Ortiz, and Mantas Simkus. Nested regular path queries in description logics", "journal": "Springer", "year": "1994", "authors": "Vianu ; Serge Abiteboul; Victor Vianu; ; Abiteboul"}, {"ref_id": "b1", "title": "Diego Calvanese, Thomas Eiter, and Magdalena Ortiz. Regular path queries in expressive description logics with nominals", "journal": "ACM", "year": "1988", "authors": ""}, {"ref_id": "b2", "title": "Alin Deutsch and Val Tannen. Optimization properties for classes of conjunctive regular path queries", "journal": "Springer", "year": "1991", "authors": " Courcelle ; Bruno Courcelle"}, {"ref_id": "b3", "title": "Query containment for conjunctive queries with regular expressions", "journal": "AAAI Press/IJCAI", "year": "1998", "authors": ""}, {"ref_id": "b4", "title": "Containment of nested regular expressions. CoRR, abs/1304.2637", "journal": "", "year": "2013", "authors": "L Reutter ; Juan; Markus Reutter ; Sebastian Rudolph;  Kr\u00f6tzsch"}, {"ref_id": "b5", "title": "Principles of Database Systems (PODS'13)", "journal": "ACM", "year": "2013", "authors": " Symp"}, {"ref_id": "b6", "title": "DReW: a reasoner for Datalog-rewritable description logics and dl-programs", "journal": "ONTORULE Project", "year": "1987", "authors": "; O Shmueli;  Shmueli;  Xiao"}], "figures": [{"figure_label": "", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "in UCQ is 2ExpTime-complete, while containment of Dlog by non-recursive Datalog is 3ExpTime-complete Proceedings of the Twenty-Fourth International Joint Conference on Artificial Intelligence (IJCAI 2015) IJCAI-15 Distinguished Paper, Honorary Mention", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_3", "figure_caption": "Summary of the known complexities of query containment for several Datalog fragments; sources for each claim are shown in square brackets, using \\ to separate sources for lower and upper complexity bounds, respectively", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "I, {x i \u2192 \u03b4 i | 1 \u2264 i \u2264 m} | = \u03d5[x].", "formula_coordinates": [3.0, 54.0, 245.27, 158.02, 10.4]}, {"formula_id": "formula_1", "formula_text": "p(\u03bb 1 , y) \u2192 U(y) U(y) \u2227 p(y, z) \u2192 U(z) U(\u03bb 2 ) \u2192 hit", "formula_coordinates": [3.0, 394.76, 86.56, 83.47, 38.38]}, {"formula_id": "formula_2", "formula_text": "q(\u03bb 1 , \u03bb 2 ) \u2192 U q (\u03bb 1 , \u03bb 2 ) U q (x, y) \u2227 p(x, x ) \u2227 p(y, y ), q(x , y ) \u2192 U q (x , y ) U q (\u03bb 3 , \u03bb 4 ) \u2192 hit", "formula_coordinates": [4.0, 76.66, 108.31, 197.68, 38.38]}, {"formula_id": "formula_3", "formula_text": "q(\u03bb 1 , \u03bb 2 ) \u2192 U 1 (\u03bb 1 ) q(\u03bb 1 , \u03bb 2 ) \u2192 U 2 (\u03bb 2 ) U 1 (x) \u2227 U 2 (y) \u2227 p(x, x ) \u2227 p(y, y ), q(x , y ) \u2192 U 1 (x ) U 1 (x) \u2227 U 2 (y) \u2227 p(x, x ) \u2227 p(y, y ), q(x , y ) \u2192 U 2 (y ) U 1 (\u03bb 3 ) \u2227 U 2 (\u03bb 4 ) \u2192 hit", "formula_coordinates": [4.0, 72.05, 174.1, 206.91, 66.28]}, {"formula_id": "formula_4", "formula_text": "q(y 1 , y 2 ) \u2192 U + q (y 1 , y 2 , y) U q (x, y, y) \u2227 p(x, x ) \u2227 p(y, y ), q(x , y ) \u2192 U + q (x , y , y) U q (y 3 , y 4 , y) \u2192 goal(y)", "formula_coordinates": [4.0, 67.97, 484.13, 215.06, 43.52]}, {"formula_id": "formula_5", "formula_text": "UCQ,LinMDlog, MDlog, LinMQ k , MQ k , LinMQ + ,MQ + , LinGDlog, GDlog LinGQ k GQ k LinGQ + ,GQ + Dlog LinMQ PSpace-h kExpSpace-h [Chaudhuri", "formula_coordinates": [6.0, 63.78, 53.9, 450.14, 34.8]}], "doi": ""}