{"title": "", "authors": "Zihao Li; Jinyan Liu; Shengxin Liu; Xinhang Lu", "pub_date": "2021-01-27", "abstract": "We study the problem of fair division when the set of resources contains both divisible and indivisible goods. Classic fairness notions such as envy-freeness (EF) and envy-freeness up to one good (EF1) cannot be directly applied to this mixed goods setting. In this work, we propose a new fairness notion, envy-freeness for mixed goods (EFM), which is a direct generalization of both EF and EF1 to the mixed goods setting. We prove that an EFM allocation always exists for any number of agents with additive valuations. We also propose efficient algorithms to compute an EFM allocation for two agents with general additive valuations and for n agents with piecewise linear valuations over the divisible goods. Finally, we relax the envy-freeness requirement, instead asking for \u01eb-envy-freeness for mixed goods (\u01eb-EFM), and present an efficient algorithm that finds an \u01eb-EFM allocation. * A preliminary version appeared in Proceedings of the 34th AAAI Conference on Artificial Intelligence (AAAI) [Bei et al., 2020b]. Compared to the conference version, this journal version fixes a bug in the proof of Theorem 3.6 and includes a new section (Section 6) that discusses how to combine the newly proposed fairness notion together with economic efficiency considerations.", "sections": [{"heading": "Introduction", "text": "Fair division studies the allocation of scarce resources among interested agents, with the objective of finding an allocation that is fair to all participants involved. Initiated by Steinhaus [1948], the study of fair division has since been attracting interest from various disciplines for decades, including among others, mathematics, economics, and computer science [Brams and Taylor, 1996;Robertson and Webb, 1998;Moulin, 2003;Thomson, 2016;Moulin, 2019].\nThe literature of fair division can be divided into two classes, categorized by the type of the resources to be allocated. The first class assumes the resource to be heterogeneous and infinitely divisible. The corresponding problem is commonly known as cake cutting. One of the most prominent fairness notions in this setting is envy-freeness (EF). An allocation is said to be envy-free if each agent weakly prefers her own bundle to any other bundle in the allocation. An envy-free allocation with divisible resources always exists [Alon, 1987;Su, 1999] and can be found via a discrete and bounded protocol [Aziz and Mackenzie, 2016a].\nThe second class considers the fair allocation of indivisible goods. Note that an envy-free allocation may fail to exist in the indivisible goods setting. 1 To circumvent this problem, relaxations of envy-freeness have been studied. One of the commonly considered relaxations is envy-freeness up to one good (EF1) [Lipton et al., 2004;Budish, 2011]. An allocation is said to satisfy EF1 if it is possible to eliminate any envy one agent has towards another agent by removing some good from the latter's bundle. An EF1 allocation with indivisible goods always exists and can be found in polynomial time [Lipton et al., 2004;Caragiannis et al., 2019].\nThe vast majority of the fair division literature assumes that the resources either are completely divisible, or consist of only indivisible goods. However, this is not always the case in many realworld scenarios. In inheritance division, for example, the inheritances to be divided among the heirs may contain divisible goods such as land and money, as well as indivisible goods such as houses, cars, and artworks. What fairness notion should one adopt when dividing such mixed type of resources? While EF and EF1 both work well in their respective settings, neither of them can be directly applied to this more general scenario. On the one hand, an EF allocation may not exist, when, for example, all goods are indivisible. On the other hand, the EF1 notion in the mixed goods setting, when interpreted as that each agent does not envy another agent after removing at most one indivisible good from the latter agent's bundle, may also produce unfair allocations. Consider the example where there is an indivisible good and a cake that are both equally valued by two agents. The allocation that divides the cake in half and then gives the indivisible good to one of the agents is EF1 but is arguably unfair. Another tempting solution is to divide the divisible and indivisible resources using EF and EF1 protocols separately and independently, and then combine the two allocations together. This approach, however, also has problems. Consider a simple example where two agents need to divide a cake and an indivisible item. EF1 requires to allocate the indivisible item to one of the agent, say agent 1 for example. However, if we then divide the cake using an arbitrary EF allocation, the overall allocation might be unfair to agent 2 who does not receive the indivisible item. In fact, if the whole cake is valued less than the item, it would make more sense to allocate the cake entirely to agent 2. When the cake is valued more than the item, it is still a fairer solution to allocate more cake to agent 2 in order to compensate her disadvantage in the indivisible resource allocation. This demonstrates that it is not straightforward to generalize EF and EF1 to the mixed goods setting. Dividing mixed types of resources calls for a new fairness notion that could unify EF and EF1 together to the new setting in a natural and non-trivial way.", "publication_ref": ["b42", "b12", "b38", "b45", "b33", "b44", "b4", "b29", "b15", "b29", "b16"], "figure_ref": [], "table_ref": []}, {"heading": "Our Results", "text": "In this work, we initiate the study of fair division with mixed types of resources. More specifically, we propose a new fairness notion, denoted as envy-freeness for mixed goods (or EFM for short), that naturally combines EF and EF1 together and works for the setting where the set of resources may contain both divisible and indivisible goods. Intuitively, EFM requires that for each agent, if her allocation consists of only indivisible items, then other agents will compare their bundles to hers using the EF1 criterion; but if this agent's bundle contains any positive amount of divisible resources, other agents will compare their bundles to hers using the stricter EF condition. This definition generalizes both EF and EF1 to the mixed goods setting and strikes a natural balance between the two fairness notions.\nIn Section 3, we first show that with mixed types of goods, an EFM allocation always exists for any number of agents with additive valuations. Our proof is constructive and gives an algorithm for computing such an EFM allocation. The algorithm requires an oracle for computing a perfect allocation in cake cutting and can compute an EFM allocation in a polynomial number of steps. In addition, in Section 4, we present two algorithms that could compute an EFM allocation for two special cases without using the perfect allocation oracle: (1) two agents with general additive valuations in the Robertson-Webb model, and (2) any number of agents with piecewise linear valuation functions.\nWhile it is still unclear to us whether in general an EFM allocation can be computed in a finite number of steps in the Robertson-Webb model, in Section 5, we turn our attention to approximations and define the notion of \u01eb-EFM. We then give an algorithm to compute an \u01eb-EFM allocation in the Robertson-Webb model with running time polynomial in the number of agents n, the number of indivisible goods m, and 1/\u01eb, and query complexity polynomial in n and 1/\u01eb. We note that this algorithm does not require a perfect allocation oracle. This is an appealing result in particular due to its polynomial running time complexity. A bounded exact EFM protocol, even if exists, is likely to require a large number of queries and cuts. This is because in the special case when resources are all divisible, EFM reduces to EF in cake cutting, for which the best known protocol [Aziz and Mackenzie, 2016a] has a very high query complexity (a tower of exponents of n). This result shows that if one is willing to allow a small margin of errors, such an allocation could be found much more efficiently.\nFinally, in Section 6 we discuss EFM in conjunction with efficiency considerations. In particular, to one's surprise, we show that EFM and Pareto optimality (PO) are incompatible. We also propose a weaker version of EFM and discuss the possibilities and difficulties in combining it with PO.", "publication_ref": ["b4"], "figure_ref": [], "table_ref": []}, {"heading": "Related Work", "text": "As we mentioned, most previous works in fair division are from two categories based on whether the resources to be allocated are divisible or indivisible.\nWhen the resources are divisible, the existence of an envy-free allocation is guaranteed [Liapounoff, 1940;Dubins and Spanier, 1961], even with only n\u22121 cuts [Stromquist, 1980;Su, 1999]. Brams and Taylor [1995] gave the first finite (but unbounded) envy-free protocol for any number of agents. Recently, Aziz and Mackenzie [2016b] gave the first bounded protocol for computing an envy-free allocation with four agents and their follow-up work extended the result to any number of agents [Aziz and Mackenzie, 2016a]. Besides envy-freeness, other classic fairness notions include proportionality and equitability, both of which have been studied extensively [Dubins and Spanier, 1961;Even and Paz, 1984;Edmonds and Pruhs, 2006;Cechl\u00e1rov\u00e1 and Pill\u00e1rov\u00e1, 2012;Procaccia and Wang, 2017].\nWhen the resources are indivisible, none of the aforementioned fairness notions is guaranteed to exist, thus relaxations are considered. Among other notions, these include envy-freeness up to one good (EF1), envy-freeness up to any good (EFX), maximin share (MMS), etc. [Lipton et al., 2004;Budish, 2011;Caragiannis et al., 2019]. An EF1 allocation always exists and can be efficiently computed [Lipton et al., 2004;Caragiannis et al., 2019]. However, the existence of an EFX allocation is still open [Procaccia, 2020], except for several special cases [Plaut and Roughgarden, 2020;Chaudhury et al., 2020;Amanatidis et al., 2020]. As for MMS, an MMS allocation may not always exist; however, an approximation of MMS always exists and can be efficiently computed [Kurokawa et al., 2018;Amanatidis et al., 2017;Ghodsi et al., 2018;Garg and Taki, 2020]. A recent paper by Bei et al. [2020c] also studied the existence, approximation and computation of MMS allocations in the mixed goods setting.\nIn addition, several works studied fair division with the assumption that resources can be shared among agents. The adjusted-winner (AW) procedure proposed by Brams and Taylor [1996] ensures that at most one good must be split in a fair and (economically) efficient division between two agents. Sandomirskiy and Segal-Halevi [2019] focused on obtaining a fair and efficient division with minimum number of objects shared between two or more agents. Rubchinsky [2010] considered the fair division problem between two agents with both divisible and indivisible items, and introduced three fairness notions with computationally efficient algorithms for finding them. All of the works discussed above assumed that divisible items are homogeneous.\nSeveral other works studied the allocation of both indivisible goods and money, with the goal of finding envy-free allocations [Maskin, 1987;Alkan et al., 1991;Klijn, 2000;Meertens et al., 2002;Halpern and Shah, 2019;Brustle et al., 2020]. Money can be viewed as a homogeneous divisible good which is valued the same across all agents. In our work, we consider a more general setting with heterogeneous divisible goods. Moreover, these works focused on finding envy-free allocations with the help of a sufficient amount of money, which is again different from our goal in the sense that our method could also be used even in cases where the money is insufficient.", "publication_ref": ["b28", "b20", "b43", "b44", "b11", "b5", "b4", "b20", "b22", "b21", "b17", "b37", "b29", "b15", "b16", "b29", "b16", "b36", "b34", "b18", "b3", "b27", "b2", "b24", "b23", "b10", "b40", "b39", "b30", "b0", "b26", "b31", "b25", "b14"], "figure_ref": [], "table_ref": []}, {"heading": "Preliminaries", "text": "We consider a resource allocation setting with both divisible and indivisible goods (mixed goods for short). Denote by N = {1, 2, . . . , n} the set of agents, M = {1, 2, . . . , m} the set of indivisible goods, and D = {D 1 , D 2 , . . . , D \u2113 } the set of \u2113 heterogeneous divisible goods or cakes. Since the fairness notion we propose below does not distinguish pieces from different cakes, without loss of generality, we assume each cake D i is represented by the interval [ i\u22121 \u2113 , i \u2113 ], 2 and use a single cake C = [0, 1] to represent the union of all cakes. 3 Each agent i has a non-negative utility u i (g) for each indivisible good g \u2208 M . Agents' utilities for subsets of indivisible goods are additive, meaning that u i (M \u2032 ) = g\u2208M \u2032 u i (g) for each agent i and subset of goods M \u2032 \u2286 M . Each agent i also has a density function f i : [0, 1] \u2192 R + \u222a {0}, which captures how the agent values different parts of the cake. The value of agent i over a finite union of intervals S \u2286 [0, 1] is defined as u i (S) = S f i dx.\nDenote by M = (M 1 , M 2 , . . . , M n ) the partition of M into bundles such that agent i receives bundle M i . Denote by C = (C 1 , C 2 , . . . , C n ) the division of cake C such that C i \u2229 C j = \u2205 and agent i receives C i , a union of finitely many intervals. An allocation of the mixed goods is defined as A = (A 1 , A 2 , . . . , A n ) where A i = M i \u222a C i is the bundle allocated to agent i. Agent i's utility for the allocation is then defined as u i (A i ) = u i (M i ) + u i (C i ). We assume without loss of generality that agents' utilities are normalized to 1, i.e., u i (M \u222a C) = 1 for all i \u2208 N .\nNext, we define the fairness notions used in this paper.\nDefinition 2.1 (EF). An allocation A is said to satisfy envy-freeness (EF) if for any agents i, j \u2208 N , u i (A i ) \u2265 u i (A j ).\nDefinition 2.2 (EF1). With indivisible goods, an allocation A is said to satisfy envy-freeness up to one good (EF1) if for any agents i, j \u2208 N where A j = \u2205, there exists g \u2208 A j such that u i (A i ) \u2265 u i (A j \\ {g}).\nNeither EF nor EF1 alone is a suitable definition for mixed goods. In this paper we introduce the following new fairness notion.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Definition 2.3 (EFM).", "text": "An allocation A is said to satisfy envy-freeness for mixed goods (EFM) if for any agents i, j \u2208 N ,\n\u2022 if agent j's bundle consists of only indivisible goods, there exists g \u2208 A j such that u\ni (A i ) \u2265 u i (A j \\ {g}); \u2022 otherwise, u i (A i ) \u2265 u i (A j ).\nIt is easy to see that when the goods are all divisible, EFM reduces to EF; when goods are all indivisible, EFM reduces to EF1. Therefore EFM is a natural generalization of both EF and EF1 to the mixed goods setting.\nNext, we define \u01eb-EFM which is a relaxation of EFM. Note that this definition only relaxes the EF condition for the divisible goods; the EF1 condition is not relaxed. Definition 2.4 (\u01eb-EFM). An allocation A is said to satisfy \u01eb-envy-freeness for mixed goods (\u01eb-EFM) if for any agents i, j \u2208 N ,\n\u2022 if agent j's bundle consists of only indivisible goods, there exists g \u2208 A j such that u\ni (A i ) \u2265 u i (A j \\ {g}); \u2022 otherwise, u i (A i ) \u2265 u i (A j ) \u2212 \u01eb.\nFinally, we describe the Robertson-Webb (RW) query model [Robertson and Webb, 1998], which is a standard model in cake cutting. In this model, an algorithm is allowed to interact with the agents via two types of queries:\n\u2022 Evaluation: An evaluation query of agent i on [x, y] returns u i ([x, y]). \u2022 Cut: A cut query of \u03b2 for agent i from x returns a point y such that u i ([x, y]) = \u03b2.", "publication_ref": ["b38"], "figure_ref": [], "table_ref": []}, {"heading": "EFM: Existence", "text": "Although EFM is a natural generalization of both EF and EF1, it is not straightforward whether an EFM allocation would always exist with mixed goods. In this section, we prove through a constructive algorithm that with mixed goods and any number of agents, an EFM allocation always exists.\nWe first give some definitions which will be helpful for our algorithm and proofs.\nPerfect Allocation Our algorithm will utilize the concept of perfect allocation in cake cutting.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Definition 3.1 (Perfect allocation). A partition", "text": "C = (C 1 , C 2 , . . . , C k ) of cake C is said to be perfect if for all i \u2208 N, j \u2208 [k], u i (C j ) = u i (C)/k.\nIntuitively, a perfect allocation in cake cutting divides the cake into k pieces, such that every agent in N values these k pieces equally. It is known that a perfect allocation always exists for any number of agents and any k [Alon, 1987]. In the following, we will assume that our algorithm is equipped with an oracle PerfectAlloc(C, k, N ) that could return us a perfect allocation for any k and cake C among all agents in N .", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Envy Graph and Addable Set", "text": "We also make use of the envy graph to capture the envy relation among agents in an allocation. Definition 3.2 (Envy graph). Given an allocation A, its corresponding envy graph G = (N, E envy \u222a E eq ) is a directed graph, where each vertex represents an agent, and E envy and E eq consist of the following two types of edges, respectively:\n\u2022 Envy edge: i ENVY \u2212 \u2212\u2212\u2212 \u2192 j if u i (A i ) < u i (A j ); \u2022 Equality edge: i EQ \u2212 \u2212 \u2192 j if u i (A i ) = u i (A j ).\nMoreover, a cycle in an envy graph is called an envy cycle if it contains at least one envy edge. The concepts of envy edge and equality edge were also used in [Klijn, 2000;Lipton et al., 2004].\nGiven an envy graph, we then define another useful concept called addable set which corresponds to a specific set of agents. Definition 3.3 (Addable set). Given an envy graph, a non-empty set of agents S \u2286 N forms an addable set if,\n\u2022 there is no envy edge between any pair of agents in S;\n\u2022 there exists neither an envy edge nor an equality edge from any agent in N \\ S to any agent in S.\nMoreover, an addable set S \u2286 N is called a maximal addable set if there does not exist any other addable set S \u2032 \u2286 N such that S \u2282 S \u2032 . The following lemma shows the uniqueness of the maximal addable set in an envy graph.\nLemma 3.4. Given an envy graph, the maximal addable set, if exists, is unique. Moreover, we can find it or decide that none exists in O(n 3 ) time.\nProof. Suppose, to the contrary, that there exist two distinct maximal addable sets S 1 and S 2 in the given envy graph. We will show that S 1 \u222a S 2 is also an addable set which contradicts the maximality of S 1 and S 2 .\nFirst it is easy to see that there exists neither an envy edge nor an equality edge from any agent in N \\ (S 1 \u222a S 2 ) to agents in S 1 \u222a S 2 since, otherwise, either S 1 or S 2 is not an addable set.\nWe next argue that there is no envy edge between any pair of agents in S 1 \u222a S 2 . Clearly, according to Definition 3.3, there is no envy edge within each of S 1 and S 2 . The envy edges between S 1 and S 2 also cannot exist because there are no envy edges coming from outside of S 1 or S 2 into any of them. Thus, S 1 \u222a S 2 is also an addable set.\na A 1 b A 2 c A 3 d A 4 ENVY EQ ENVY EQ (a) Envy graph G. v ac v cd (b) The corresponding G \u2032 .\nFigure 1: Figure 1a shows an envy graph G with four vertices (agents) a, b, c, d. The bundle each agent gets is labelled with A 1 , A 2 , A 3 , A 4 beside. We show in Figure 1b its corresponding G \u2032 . In this example, G has an envy cycle (involving vertices a, b, c) but no addable set.\na A 3 b A 1 c A 2 d A 4 EQ ENVY EQ (a) Envy graph G. v cd (b) The corresponding G \u2032 .\nFigure 2: After rotating the bundles along the envy cycle in Figure 1a, we obtain the envy graph in Figure 2a. The corresponding G \u2032 is shown in Figure 2b. In this example, G has addable sets {b}, {b, c} and {a, b, c} but no envy cycle. Now, we show how to find the unique maximal addable set or decide its non-existence in O(n 3 ) time: for each j which has an incoming envy edge, let R j be the collection of vertices (including j) that are reachable by j via the union of envy edges and equality edges, and let S = N \\ j R j . We will show that an addable set does not exist in the envy graph if S = \u2205. Otherwise, S is the unique maximal addable set. First, S is an addable set because any agent in S does not have any incoming envy edge and is not reachable via the union of envy edges and equality edges from any other agent with an incoming envy edge. In addition, S is maximal because any agent in j R j cannot be in any addable set. Such S can be found in O(n 3 ) time because it takes O(n) time to check if an agent has an incoming edge, and for any agent j who has an incoming envy edge, it then takes O(n 2 ) time to construct R j via, for example, breadth-first search (BFS).\nIntuitively, agents in the addable set S can be allocated some cake without creating new envy, since each agent in N \\ S values her own bundle strictly more than the bundles of agents in S. Our next result characterizes the relation between the addable set and the envy cycle.\nLemma 3.5. Any envy graph G = (N, E envy \u222a E eq ) that does not have any envy cycle must have an addable set.\nProof. We assume without loss of generality that E envy = \u2205, since otherwise N itself is an addable set. Now, we construct graph\nG \u2032 = (N \u2032 , E \u2032 ) from G as follows. Each envy edge i ENVY \u2212 \u2212\u2212\u2212 \u2192 j in G corresponds to a vertex v ij in G \u2032 . For two envy edges i ENVY \u2212 \u2212\u2212\u2212 \u2192 j and i \u2032 ENVY \u2212 \u2212\u2212\u2212 \u2192 j \u2032 in G,\nif there exists a path from j to i \u2032 , we construct an edge v ij \u2192 v i \u2032 j \u2032 in G \u2032 . Note that, if there is an envy edge i ENVY \u2212 \u2212\u2212\u2212 \u2192 j and a path from j to i in G, there will be a self-loop v ij \u2192 v ij in G \u2032 . We illustrate this transformation using two examples in Figures 1 and 2.\nIt is easy to see that a cycle in G \u2032 implies an envy cycle in G. Thus, by the assumption that there is no envy cycle in G, G \u2032 must be acyclic. Then there must exist a vertex v ij \u2208 N \u2032 which is not reachable by any other vertices in G \u2032 . Because v ij corresponds to the envy edge i ENVY \u2212 \u2212\u2212\u2212 \u2192 j in G, since v ij cannot be reached by any vertices in G \u2032 , the vertex i is also not reachable by any j \u2032 which is pointed by an envy edge. We note that, however, this vertex i may be reachable by other vertices via only equality edges. Thus, we need to not only include agent i in the addable set but also those agents who are able to reach i via equality edges.\nLet S be the set containing agent i and all other agents who can reach i in the envy graph G via equality edges. In the following, we show that S is an addable set. First, S is non-empty because it at least contains agent i. Second, by our construction, there is no envy edge between any pair of agents in S. Third, recall that in envy graph G, agent i is not reachable by any j \u2032 which is pointed by an envy edge; thus, S is also not pointed by any envy edge. Last, S is also not pointed by any equality edge by our construction of S. Therefore, according to Definition 3.3, S must be an addable set.", "publication_ref": ["b26", "b29"], "figure_ref": ["fig_1", "fig_1", "fig_1", "fig_1"], "table_ref": []}, {"heading": "The Algorithm", "text": "The complete algorithm to compute an EFM allocation is shown in Algorithm 1. In general, our algorithm always maintains a partial allocation that is EFM. Then, we repeatedly and carefully add resources to the partial allocation, until all resources are allocated. We start with an EF1 allocation of only indivisible goods to all agents in Step 1, and construct the corresponding envy graph in Step 2. Then, our algorithm executes in rounds (Steps 3-30). In each round, we try to distribute some cake to the partial allocation while ensuring the partial allocation to be EFM. Such distribution needs to be done carefully because once an agent is allocated with a positive amount of cake, the fairness condition with regard to her bundle changes from EF1 to EF, which is more demanding. We repeat the process until the whole cake is allocated.\nIn each round of Algorithm 1, depending on whether there is an addable set that can be given some cake in Step 4, we execute either the cake-adding phase (Steps 4-23) or the envy-cycleelimination phase (Steps 24-29).\n\u2022 In the cake-adding phase, we have a maximal addable set S. By its definition, each agent in N \\ S values her own bundle strictly more than the bundles of agents in S. Thus there is room to allocate some cake C \u2032 to agents in S. We carefully select C \u2032 to be allocated to S such that it does not create any new envy among the agents. To achieve this, we choose a piece of cake C \u2032 \u2286 C to be perfectly allocated to S in Steps 12-19 so that no agent in N will envy agents in S after distributing C \u2032 in Steps 20-21. More specifically, for each agent i \u2208 N \\ S, we determine in Step 12 the largest value \u03b4 i to be added to any agent in S such that i would still not envy any agent in S. Then, the way we decide x i * in Steps 17-18 ensures that for all\nagents i \u2208 N \\ S, v i ([a, x i * ]) \u2264 |S| \u2022 \u03b4 i . Next, in Step 20, cake C \u2032 = [a, x i * ] is divided into |S|\npieces that are valued equally by all agents in N . This is to ensure that no agent i \u2208 N \\ S values any piece more than \u03b4 i .\n\u2022 In the envy-cycle-elimination phase, i.e., when there does not exist any addable set, we show that in this case there must exist an envy cycle T in the current envy graph. We can then apply the envy-cycle-elimination technique to reduce some existing envy from the allocation by rearranging the bundles along T . More specifically, for each agent j \u2208 T , we give agent j's bundle to agent i who points to her in T (shown in Step 27).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Algorithm 1 EFM Algorithm", "text": "Require: Agents N , indivisible goods M and cake C. 1: Find an arbitrary EF1 allocation (A 1 , A 2 , . . . , A n ) of M to n agents. 2: Construct an envy graph G = (N, E envy \u222a E eq ) accordingly.\n3: while C = \u2205 do 4:\nif there exists an addable set in G then 5:\n// cake-adding phase 6:\nLet S be the maximal addable set.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "7:", "text": "if S = N then 8:\nFind an EF allocation (C 1 , C 2 , . . . , C n ) of C.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "9:", "text": "C \u2190 \u2205 10:\nAdd C i to bundle A i for all i \u2208 N . \n\u03b4 i \u2190 min j\u2208S (u i (A i ) \u2212 u i (A j )) for each i \u2208 N \\ S.\n13:\nif u i (C) \u2264 |S| \u2022 \u03b4 i holds for each i \u2208 N \\ S then 14: C \u2032 \u2190 C, C \u2190 \u2205 15: else 16: Suppose w.l.o.g. that C = [a, b]. For each agent i \u2208 N \\ S, if u i ([a, b]) \u2265 |S| \u2022 \u03b4 i , let x i be a point such that u i ([a, x i ]) = |S| \u2022 \u03b4 i ; otherwise, let x i = b. 17: i * \u2190 arg min i\u2208N \\S x i 18: C \u2032 \u2190 [a, x i * ], C \u2190 C \\ C \u2032 19: end if 20: Let (C 1 , C 2 , . . . , C k ) = PerfectAlloc(C \u2032 , k, N ) where k = |S|.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "21:", "text": "Add C i to the bundle of the i-th agent in S.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "22:", "text": "Update envy graph G accordingly. Let T be an envy cycle in envy graph G.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "27:", "text": "For each agent j \u2208 T , give agent j's whole bundle to agent i who points to her in T .", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "28:", "text": "Update envy graph G accordingly.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "29:", "text": "end if 30: end while 31: return (A 1 , A 2 , . . . , A n )\nWe remark that when all goods are indivisible, our algorithm performs Steps 1-2 and terminates with an EF1 allocation (which is also EFM). When the whole good is a divisible cake, the algorithm goes directly to Step 8 and ends with an EF allocation of the cake, which is again EFM.\nIn the following we prove the correctness of this algorithm and analyze its running time.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Analysis", "text": "Our main result for the EFM allocation is as follows:\nTheorem 3.6. An EFM allocation always exists for any number of agents with additive valuations and can be found by Algorithm 1 in polynomial time with O(n 4 ) Robertson-Webb queries and O(n 3 ) calls to the PerfectAlloc oracle.\nTo prove Theorem 3.6, we first show that the following invariants are maintained by Algorithm 1 during its run.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Invariants", "text": "A1. In each round there is either an addable set for the cake-adding phase or an envy cycle for the envy-cycle-elimination phase.\nA2. The partial allocation is always EFM.\nLemma 3.7. Invariant A1 holds during the algorithm's run.\nProof. This invariant is implied directly by Lemma 3.5.\nLemma 3.8. Invariant A2 holds during the algorithm's run.\nProof. The partial allocation is clearly EFM after Step 1. Then the allocation is updated in three places in the algorithm: Steps 10 and 21 in the cake-adding phase and Step 27 in the envy-cycleelimination phase. Given a partial allocation that is EFM, we will show that each of these updates maintains the EFM condition.\nFirst, when we have S = N in Step 7, i.e., the addable set S consists of all n agents, the current envy graph does not contain any envy edge due to the definition of addable set (Definition 3.3). This implies that current partial allocation actually is envy-free. Because all valuation functions are additive, adding another envy-free allocation on top of it in Step 10 results in an envy-free and, hence, EFM allocation.\nWe next consider Step 21 in the cake-adding phase where a piece of cake is added to the addable set S. In order to maintain an EFM partial allocation, we need to ensure that this process does not introduce any new envy towards agents in S. Since we add a perfect allocation in Steps 20-21, envy will not emerge among agents in S. We also carefully choose the amount of cake to be allocated in Steps 13-19 such that each agent in N \\ S weakly prefers her bundle to any bundles that belong to agents in S. To achieve this, we choose a piece of cake C \u2032 \u2286 C to be perfectly allocated to S in Steps 12-19 so that no agent in N will envy agents in S after distributing C \u2032 in Steps 20-21. More specifically, for each agent i \u2208 N \\ S, we determine in Step 12 the largest value \u03b4 i to be added to any agent in S such that i would still not envy any agent in S. Then, the way we decide x i * in Steps 17-18 ensures that for all agents\ni \u2208 N \\ S, v i ([a, x i * ]) \u2264 |S| \u2022 \u03b4 i . Next, in Step 20, cake C \u2032 = [a, x i * ]\nis divided into |S| pieces that are valued equally by all agents in N . This is to ensure that for any piece of cake C j allocated to j \u2208 S, we have u i (C j ) \u2264 \u03b4 i for all i \u2208 N \\ S. Thus, agents in N \\ S continues to not envy agents in S in Step 21.\nFinally, in the envy-cycle-elimination phase, Step 27 eliminates envy edges by rearranging the partial allocation within the envy cycle T . Since each agent in T is weakly better off, the partial allocation remains EFM. For agents in N \\ T , rearranging the partial allocation that is EFM will not make EFM infeasible. The conclusion follows.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Correctness", "text": "Lemma 3.9. Algorithm 1 always returns an EFM allocation upon termination.\nProof. By Invariant A2, it suffices to prove that all goods are allocated when Algorithm 1 terminates. All indivisible goods are allocated in Step 1. Then the while loop (Steps 3-30) terminates only when the cake is also fully allocated, as desired.\nTermination and Time Complexity We use the number of envy edges in the envy graph and the size of the maximal addable set as a potential function to bound the running time of this algorithm.\nLemma 3.10. After the algorithm completes a cake-adding phase, the number of envy edges never increases. In addition, if the piece of cake to be allocated is not the whole remaining cake, either (a) the number of envy edges strictly decreases, or (b) the size of the maximal addable set strictly decreases or an addable set no longer exists. Proof. By Lemma 3.8, the partial allocation is always EFM after a cake-adding phase. In a cakeadding phase, some positive amount of cake is added to every agent in S. This means after this phase, there would never be any envy edge between agents in S or from N \\ S to S. The bundles of agents in N \\ S remains the same, hence the set of edges among agents in N \\ S remains unchanged. Lastly, since only agents in S are allocated new resources in the cake-adding phase, no new envy edge will be introduced from S to N \\ S. This proves the first part of Lemma 3.10.\nFor the second part, we only study the situation when the piece of cake to be allocated to agents in S is not the whole remaining cake . Note that the number of envy edges will never increase after a cake-adding phase as proved above. It suffices to show that if the number of envy edges remains unchanged and an addable set still exists, then the size of the maximal addable set must strictly decrease.\nNote that based on how we choose i * in Step 17, after the cake-adding phase, at least one equality edge will be generated in the envy graph from agent i * to some agent j \u2208 S. Let G and G \u2032 be the envy graphs before and after the cake-adding phase, and let S and S \u2032 be the maximal addable set of G and G \u2032 , respectively. In the following we will show that S \u2032 \u2282 S.\nWe first show S \u2032 \u2286 S. Suppose otherwise, we will show that S \u222a S \u2032 is also an addable set in G, which contradicts to the maximality of S. The reasons that S \u222a S \u2032 is an addable set in G are as follows.\n(i) We have already proved that compared to G, there is no new envy edge in G \u2032 . If G and G \u2032 has the same number of envy edges, they must share exactly the same set of envy edges. Hence, there will be no envy edge pointing to either S or S \u2032 in G.\n(ii) If there is an equality edge from N \\ (S \u222a S \u2032 ) to S \u222a S \u2032 in G, this equality edge cannot be from N \\ (S \u222a S \u2032 ) to S because S is an addable set in G. Hence, it must be from N \\ (S \u222a S \u2032 ) to S \u2032 \\ S. This equality edge remains in G \u2032 because neither the agents in N \\ (S \u222a S \u2032 ) nor the agents in S \u2032 \\ S receive any good. However, this is impossible because S \u2032 is an addable set in G \u2032 . In summary, there cannot be any equality edges from N \\ (S \u222a S \u2032 ) to S \u222a S \u2032 in G.\nTo further prove S \u2032 \u2282 S, we recall that according to our algorithm, at least one equality edge, from agent i * in N \\ S to some agent j \u2208 S, will be included in G \u2032 . It is then clear that j cannot be in S \u2032 . This concludes the proof.\nLemma 3.11. After the algorithm completes an envy-cycle-elimination phase, the number of envy edges strictly decreases.\nProof. The basic idea of this proof follows from Lipton et al. [2004], albeit only strict envy edges were considered in their context. In the envy-cycle-elimination phase, an envy cycle T is eliminated by giving agent j's bundle to agent i for each edge i ENVY \u2212 \u2212\u2212\u2212 \u2192 j or i EQ \u2212 \u2212 \u2192 j in the cycle. First, this process does not affect the bundles of agents in N \\ T , hence the set of envy edges among them remains the same. Next, since we only swap bundles in this phase, the number of envy edges from N \\ T to T remains the same. In addition, every agent i \u2208 T receives a weakly better bundle, meaning that the number of envy edges from T to N \\ T does not increase. Finally, because T contains at least one envy edge, some agent in T will receive a strictly better bundle. As a result, although some envy edges between agents in T may still exist, the total number of envy edges will decrease by at least one. Lemma 3.12. Algorithm 1 terminates in polynomial time with O(n 3 ) calls to the PerfectAlloc oracle and O(n 4 ) Robertson-Webb queries.\nProof. Calls to the PerfectAlloc oracle. By Invariant A1, each round in Algorithm 1 executes either a cake-adding phase or an envy-cycle-elimination phase. According to Lemmas 3.10 and 3.11, the number of envy edges never increases. Thus the number of rounds in which the number of envy edges strictly decreases is bounded by O(n 2 ).\nWe now upper bound the number of cake-adding phase rounds between any two consecutive rounds that decrease the number of envy edges. If the whole remaining cake is allocated (Step 8), PerfectAlloc(C, n, N ) is called once and then Algorithm 1 terminates. In the case that a piece of remaining cake is allocated, by Lemma 3.10, the size of the maximal addable set strictly decreases or an addable set no longer exists; in the latter case, the algorithm proceeds to an envycycle-elimination phase. Because the size of any addable set is O(n), it means that the number of cake-adding phase rounds between any two consecutive rounds that decrease the number of envy edges is O(n).\nFinally, it follows that Algorithm 1 executes at most O(n 2 ) \u2022 O(n) = O(n 3 ) cake-adding phase rounds. Every such round calls the PerfectAlloc oracle once. Algorithm 1 makes O(n 3 ) calls to the PerfectAlloc oracle.\nPolynomial running time and RW queries. Note that during the algorithm's run, we add resources to a bundle and rotate bundles among agents, but never split a bundle. For example, the partition of indivisible goods is computed in Step 1 and remains the same since then. To avoid redundant computations, we maintain an n by n array to keep track of u i (A j ) for all i, j \u2208 N and update them as necessary.\nIn\nStep 1, finding an EF1 allocation of indivisible goods can be done in O(mn log m) via the round-robin algorithm [Caragiannis et al., 2019]. The implementation details are as follows. We first compute the sorted order of goods according to each agent's valuation, which takes O(nm log m) time overall. Next, in each agent's turn, we keep looking for the next unallocated good in that agent's sorted list. This step takes O(mn) time in total. Therefore, the overall running time of the round-robin algorithm is dominated by O(mn log m).\nNext, in Step 2, the overall time to construct the corresponding envy graph is O(n 2 ). We now consider the while loop. According to Lemma 3.4, we can find the maximal addable set or decide its non-existence in time O(n 3 ). In the case that we need to perform an envy-cycleelimination, an envy cycle T can be found in the following way. Fix an agent i, we can first spend O(n) time scanning all outgoing edges and ignore those equality edges. Then, we apply depth-first search (DFS) starting from vertex i. If there is a back edge pointing to vertex i, then there must be an envy cycle with at least one envy edge, say, e.g., i ENVY \u2212 \u2212\u2212\u2212 \u2192 j, for some j \u2208 N . This takes O(n 2 ) time since DFS dominates the time complexity. Since there are O(n) agents, overall, this step can be implemented in O(n 3 ) time.\nIn the following, we discuss the steps in each phase at length.\nCake-adding phase When we have S = N satisfied in Step 7, we implement an EF allocation by calling PerfectAlloc(C, n, N ). It takes O(n) time to update the allocation. Algorithm 1 then terminates.\nIt takes O(n 2 ) time in Step 12 to compute \u03b4 i for all i \u2208 N \\ S. Steps 13 and 16 need O(n) evaluation and cut queries respectively. Once C \u2032 is determined in Step 18, we can make O(n) evaluation queries from all n agents over C \u2032 . Because we use a perfect allocation of C \u2032 , we can directly compute u i (C \u2032 )/|S| for all i \u2208 N to obtain the value increment of each agent in the addable set. It then takes O(n 2 ) time to update all agents' valuations of all bundles after\nStep 21. After this, updating an envy graph also takes O(n 2 ) time.\nSince we only make RW queries in this phase, we summarize here that Algorithm 1 makes O(n 4 ) Robertson-Webb queries, because there are O(n 3 ) cake-adding phases (stated earlier in this proof) and each such phase needs at most O(n) RW queries.\nEnvy-cycle-elimination phase Since we maintain an array as the reference for agents' valuations over the current bundles, we can rotate the bundles as well as update the array and the envy graph in time O(n 2 ).\nThe remaining steps can be implemented in time O(n). Overall, Algorithm 1 runs in time O(mn log m+ n 6 ), where the n 6 term comes from the O(n 3 ) total number of while loops and O(n 3 ) time to run each loop.\nFinally the correctness of Theorem 3.6 is directly implied by Lemma 3.9 and Lemma 3.12.\nBounded Protocol in the RW Model Even though we showed that Algorithm 1 can produce an EFM allocation, it is not a bounded protocol in the RW model. This is because our algorithm utilizes an oracle that can compute a perfect allocation of any piece of cake. However, while a perfect allocation always exists, it is known that such an allocation cannot be implemented with a finite number of queries in the RW model, even if there are only two agents [Robertson and Webb, 1998].\nWhether there exists a bounded protocol in the RW model to compute an EFM allocation remains a very interesting open question. Note that the perfect allocation oracle cannot be implemented even with a finite number of queries, therefore it is even an open question to find a finite EFM protocol.\nA natural and tempting approach to get a bounded EFM protocol would be to use an envy-free allocation, for which a bounded protocol in the RW model is known [Aziz and Mackenzie, 2016a], to replace the perfect allocation in Step 20. Note that doing so would not create any new envy edge within set S. Then, in order to not create any envy edge from N \\ S to S, we need to restrict the total value of the piece of cake allocated to S to not exceed \u03b4 i (Step 12) for every agent i \u2208 N \\ S. However, when doing so, we will not be able to quantify the progress of the algorithm like in Lemma 3.10. Specifically, we can no longer guarantee that either the number of envy edges strictly decreases or the size of the maximal addable set strictly decreases. This is because we are not guaranteed the equality edge from agent i * to some agent j \u2208 S as we rely on in the proof of Lemma 3.10. In other words, we cannot show the algorithm will always terminate in bounded steps. Interestingly, in sharp contrast, in Section 5 we will show that an approximate envy-free protocol, instead of an \u01eb-perfect protocol, is enough to give an efficient \u01eb-EFM algorithm. We will discuss this phenomenon in further detail in Section 5.\nIn the next two sections, we present two bounded protocols to compute an EFM allocation for two special cases, and another bounded (polynomial time) protocol to compute an \u01eb-EFM allocation in the general case.\nAlgorithm 2 EFM Allocation for Two Agents Require: Agents 1 and 2, indivisible goods M and cake C.\n1: Divide M into two parts, M 1 , M 2 , such that agent 1 is EF1 with respect to either bundle. Assume w.l.o.g. that u 1 (M 1 ) \u2265 u 1 (M 2 ) (otherwise we can swap M 1 and M 2 ).\n2: if u 1 (M 1 ) \u2264 u 1 (M 2 \u222a C) then 3:\nLet agent 1 partition the cake into two pieces (C 1 , C 2 ), such that u\n1 (M 1 \u222a C 1 ) = u 1 (M 2 \u222a C 2 ). 4: Let (A 1 , A 2 ) = (M 1 \u222a C 1 , M 2 \u222a C 2 ). 5: else 6: Let (A 1 , A 2 ) = (M 1 , M 2 \u222a C).\n7: end if 8: Give agent 2 her preferred bundle among A 1 , A 2 . Give agent 1 the remaining bundle.", "publication_ref": ["b29", "b16", "b38", "b4"], "figure_ref": [], "table_ref": []}, {"heading": "EFM Allocation in Special Case", "text": "In this section, we show two special cases where an EFM allocation can be computed in polynomial time without using the perfect allocation oracle. One is the 2-agent case with general valuations while the other deals with the n-agent case but each agent has a structured density function for the cake.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Two Agents", "text": "We first show that with only two agents, an EFM allocation can be found using a simple cutand-choose type of algorithm. We start with a partition (M 1 , M 2 ) of all indivisible goods such that agent 1 is EF1 with respect to either bundle. Without loss of generality, we assume that u 1 (M 1 ) \u2265 u 1 (M 2 ). Next agent 1 adds the cake into M 1 and M 2 so that the two bundles are as close to each other as possible. Note that if u 1 (M 1 ) > u 1 (M 2 \u222a C), agent 1 would add all cake to M 2 . If u 1 (M 1 ) \u2264 u 1 (M 2 \u222a C), agent 1 has a way to make the two bundles equal. We then give agent 2 her preferred bundle and leave to agent 1 the remaining bundle.\nTheorem 4.1. Algorithm 2 returns an EFM allocation in the case of two agents in polynomial time.\nProof. Correctness. It is obvious that all goods are allocated. We next show that the allocation returned is EFM. Agent 2 is guaranteed EF (thus EFM) since she gets her preferred bundle between A 1 and A 2 . In the following, we focus on agent 1. If u 1 (M 1 ) \u2264 u 1 (M 2 \u222a C) holds, agent 1 is indifferent between bundles A 1 and A 2 , so either A 1 or A 2 makes her EF (thus EFM). In the case that u 1 (M 1 ) > u 1 (M 2 \u222a C) holds, agent 1 is EF if she receives A 1 , and is EFM if she gets A 2 because A 1 consists of only indivisible goods and there exists some good\ng in A 1 such that u 1 (A 2 ) \u2265 u 1 (M 2 ) \u2265 u 1 (A 1 \\ {g}).\nPolynomial time. To obtain the initial partition (M 1 , M 2 ), we can let two copies of agent 1 run the round-robin algorithm on the indivisible items. This step can be done easily in polynomial time. The remaining steps only take constant running time and a constant number of RW queries.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "The conclusion follows.", "text": "A Stronger EFM Notion With two agents, an envy-freeness up to any good (EFX) allocation, in which no agent prefers the bundle of another agent following the removal of any single good, always exists [Plaut and Roughgarden, 2020]. This result can be carried over to show the existence of a stronger EFM notion in the mixed goods setting, in which an agent is EFX towards any agent with only indivisible goods, and EF towards the rest. Such an allocation can be obtained by using an EFX partition (with respect to agent 1) instead of an EF1 partition in Step 1 of Algorithm 2. Moreover, with any number of agents, whenever an EFX allocation exists among indivisible goods, 4 we can start with such an EFX allocation in Step 1 of Algorithm 1. The cakeadding phase maintains the EFM condition and does not introduce new envy. Thus Algorithm 1 will also produce an allocation with this stronger notion of EFM.", "publication_ref": ["b34"], "figure_ref": [], "table_ref": []}, {"heading": "Any Number of Agents with Piecewise Linear Functions", "text": "In the second case, we consider an arbitrary number of agents when agents' valuation functions over the cake are piecewise linear. Definition 4.2. A valuation density function f i is piecewise linear if the interval [0, 1] can be partitioned into a finite number of intervals such that f i is linear on each interval.\nPiecewise linear function is a generalization of both piecewise uniform function and piecewise constant function, each of which has been considered in several previous fair division works [Bei et al., 2012;Chen et al., 2013;Bei et al., 2020a]. In this case, we do not use the RW model, but rather assume that the valuation functions are provided to us in full information.\nThe only obstacle in converting Algorithm 1 to a bounded protocol is the implementation of the perfect allocation oracle for cake cutting. When agents have piecewise linear functions, Chen et al. [2013] showed that a perfect allocation can be computed efficiently in polynomial time. This fact, combined with Theorem 3.6, directly implies the following result.\nCorollary 4.3. For any number of agents with piecewise linear density functions over the cake, an EFM allocation can be computed in polynomial time.", "publication_ref": ["b7", "b19", "b8", "b19"], "figure_ref": [], "table_ref": []}, {"heading": "\u01eb-EFM: Algorithm", "text": "In this section, we focus on \u01eb-EFM, a relaxation of the EFM condition. Despite the computational issues with finding bounded exact EFM protocols, we will show that there is an efficient algorithm in the RW model that computes an \u01eb-EFM allocation for general density functions with running time polynomial in n, m and 1/\u01eb.\nSince the difficulty in finding a bounded EFM protocol in the RW model lies in computing perfect allocations of a cake (Section 3), one might be tempted to simply use a bounded \u01eb-Perfect Allocation protocol to replace the exact procedure. Here a partition\nC = (C 1 , C 2 , . . . , C k ) of cake C is said to be \u01eb-perfect if for all i \u2208 N , j \u2208 [k], |u i (C j ) \u2212 u i (C)/k| \u2264 \u01eb.\nHowever, although a bounded \u01eb-perfect protocol exists in the RW model [Robertson and Webb, 1998;Br\u00e2nzei and Nisan, 2017], all known protocols have running time exponential in 1/\u01eb. 5 It is still an open question to find an \u01eb-perfect allocation with both query and time complexity polynomial in 1/\u01eb. Therefore, to design an efficient \u01eb-EFM protocol, extra work needs to be done to circumvent this issue.\nWe next define the relaxed version of EF and envy graph.\nDefinition 5.1 (\u01eb-EF). An allocation A is said to satisfy \u01eb-envy-freeness (\u01eb-EF) if for all agents i, j \u2208 N , u i (A i ) \u2265 u i (A j ) \u2212 \u01eb.\nDefinition 5.2 (\u01eb-envy graph). Given an allocation A and a parameter \u01eb, the \u01eb-envy graph is defined as G(\u01eb) = (N, E \u01eb-envy \u222a E \u01eb-eq ), where every vertex represents an agent, and E \u01eb-envy and E \u01eb-eq consist of the following two types of edges, respectively:\n\u2022 \u01eb-envy edge: i \u01eb-ENVY \u2212 \u2212\u2212\u2212\u2212 \u2192 j if u i (A i ) < u i (A j ) \u2212 \u01eb; \u2022 \u01eb-equality edge: i \u01eb-EQ \u2212 \u2212\u2212 \u2192 j if u i (A j ) \u2212 \u01eb \u2264 u i (A i ) \u2264 u i (A j ).\nGiven an \u01eb-envy graph, a cycle is said to be an \u01eb-envy cycle if it contains at least one \u01eb-envy edge. We also note that when \u01eb = 0, the \u01eb-envy graph degenerates into the envy graph defined in Section 3.", "publication_ref": ["b38", "b13"], "figure_ref": [], "table_ref": []}, {"heading": "The Algorithm", "text": "The complete algorithm to compute an \u01eb-EFM allocation is shown in Algorithm 3. Similarly to Algorithm 1, our algorithm adds resources to the partial allocation iteratively. We always maintain the partial allocation to be\u01eb-EFM where\u01eb is updated increasingly and would never exceed \u01eb. This will ensure that the final allocation is \u01eb-EFM.\nLike Algorithm 1, starting with an EF1 allocation of indivisible goods to all agents in Step 2, Algorithm 3 then executes in rounds (Steps 4-31). Even though each round still executes either a cake-adding phase or an envy-cycle-elimination phase, the execution details are different from Algorithm 1.\n\u2022 In the cake-adding phase, instead of allocating some cake to an addable set S in a way that is perfect, we resort to a \u03b3-EF allocation, where \u03b3 will be fixed later in Algorithm 3. In the following, we will utilize an algorithm \u03b3-EFAlloc(C, S) that could return us a \u03b3-EF allocation for any set of agents S and cake C. Note that, for any\u01ed > 0, the algorithm \u01eb-EFAlloc can be implemented with both running time and query complexity polynomial in the number of agents involved and 1/\u01ed [Procaccia, 2016]. We also update\u01eb to a larger number, say\u01eb + \u03b3, in order to avoid generating\u01eb-envy edges due to cake-adding.\n\u2022 In the envy-cycle-elimination phase, we eliminate an\u01eb-envy cycle, instead of an envy cycle, by rearranging the current partial allocation.", "publication_ref": ["b35"], "figure_ref": [], "table_ref": []}, {"heading": "Analysis", "text": "Our main result for the \u01eb-EFM allocation is as follows:\nTheorem 5. To prove Theorem 5.3, we first show that each round (Steps 4-31 in Algorithm 3) maintains the following invariants during the run of the algorithm.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Invariants", "text": "B1. In each round there is either an addable set for the cake-adding phase or an\u01eb-envy cycle for the envy-cycle-elimination phase.\nB2. The partial allocation is always\u01eb-EFM with the current\u01eb. if there exists an addable set S then 6:\n// cake-adding phase 7:\nif S = N then 8:\nLet (C 1 , C 2 , . . . , C n ) = \u01eb 4 -EFAlloc(C, N ).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "9:", "text": "C \u2190 \u2205 10:\u01eb \u2190\u01eb + \u01eb/4 11:\nAdd C i to bundle A i for all i \u2208 N .\n12: else 13: if max i\u2208N \\S u i (C) \u2264\u01eb then 14:\nC \u2032 \u2190 C, C \u2190 \u2205 15: else 16: Suppose w.l.o.g. that C = [a, b]. For each agent i \u2208 N \\ S, if u i ([a, b]) \u2265\u01eb, let x i be a point such that u i ([a, x i ]) =\u01eb; otherwise, let x i = b. 17: i * \u2190 arg min i\u2208N \\S x i 18: C \u2032 \u2190 [a, x i * ], C \u2190 C \\ C \u2032 19: end if 20: Let (C 1 , C 2 , . . . , C k ) = \u03b3-EFAlloc(C \u2032 , S) where k = |S|. 21:\u01eb \u2190\u01eb + \u03b3 22:\nAdd C i to the bundle of the i-th agent in S.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "23:", "text": "Update\u01eb-envy graph G(\u01eb) accordingly. Let T be an\u01eb-envy cycle in the\u01eb-envy graph.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "28:", "text": "For each agent j \u2208 T , give agent j's whole bundle to agent i who points to her in T .", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "29:", "text": "Update\u01eb-envy graph G(\u01eb) accordingly.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "30:", "text": "end if 31: end while 32: return (A 1 , A 2 , . . . , A n )\nWe next prove these invariants in the following.\nLemma 5.4. Invariant B1 holds during the algorithm's run.\nProof. The proof is similar to the proof of Lemma 3.7, except that we consider the\u01eb-envy edge instead of the envy edge.\nLemma 5.5. Invariant B2 holds during the algorithm's run.\nProof. First, it is worth noting that at the beginning, when indivisible goods are allocated, the allocation is EF1 and therefore EFM. We then note that the partial allocation is only updated in Steps 11 and 22 in the cake-adding phase as well as in Step 28 in the envy-cycle-elimination phase.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Termination and Time Complexity", "text": "Lemma 5.8. In the envy-cycle-elimination phase, the social welfare i\u2208N u i (A i ), increases by at least\u01eb.\nProof. We eliminate an\u01eb-envy cycle T which contains at least one\u01eb-envy edge in the envy-cycleelimination phase (Steps 25-30).\nStep 28 eliminates the cycle by giving agent j's bundle to agent i for each edge i\u01eb -ENVY \u2212 \u2212\u2212\u2212\u2212 \u2192 j or i\u01eb -EQ \u2212 \u2212\u2212 \u2192 j in cycle T . None of the agents involved in T is worse off and at least one agent in T is better off by at least\u01eb by the definition of\u01eb-envy edge in Definition 5.2. Since agents outside cycle T do not change their bundles, we complete the proof. Proof. Since most parts of Algorithm 3 are similar to those in Algorithm 1, and we have discussed their time complexities in the proof of Lemma 3.12, we will focus on the steps that affect the time complexity for Algorithm 3 in this proof.\nSimilar to Algorithm 1, Algorithm 3 takes O(mn log m + n 2 ) time to perform Steps 2 and 3. Afterwards, by Invariant B1, Algorithm 3 executes either a cake-adding phase or an envy-cycleelimination phase in each round, and it takes O(n 3 ) time to check which phase to go into each time. Next, recall that agents' utilities are normalized to 1 and\u01eb is always no less than \u01eb/4. This means there are at most O(n/\u01eb) cake-adding rounds by Lemma 5.6 and at most O(n/\u01eb) envy-cycleelimination rounds by Lemma 5.8.\nIn the following, we discuss the steps in each phase in details.\nCake-adding phases When we have S = N in Step 7, we invoke \u01eb 4 -EFAlloc once, use O(n) time to update the allocation, and terminate the algorithm.\nTo determine the piece of cake C \u2032 to be allocated later, we need O(n) evaluation queries in\nStep 13, and O(n) cut queries in Step 16 if the condition check in Step 13 fails. In each cake-adding phase, we invoke the \u03b3-EFAlloc oracle with \u03b3 = \u01eb 2 8n once (Step 20). In order to update agents' valuations for each bundle, we invoke O(n 2 ) evaluation queries to obtain all agents' valuations of all pieces in (C 1 , C 2 , . . . , C k ), and then use O(n 2 ) time to update the envy graph.\nSummarizing everything, we conclude that Algorithm 3 makes O(n 3 /\u01eb) Robertson-Webb queries, and O(n/\u01eb) calls to the \u01eb 2 8n -EFAlloc oracle in total in all cake-adding phases. Envy-cycle-elimination phases Since we are keeping track of all agents' valuations for all bundles, it takes no Robertson-Webb queries and O(n 2 ) time to rearrange the bundles as well as update the\u01eb-envy graph. Overall all envy-cycle-elimination phases take O(n 3 /\u01eb) running time.\nThe remaining steps can be implemented in time O(n). Finally the correctness of Theorem 5.3 is directly implied by Lemmas 5.7 and 5.9. Note that at the end of Section 3, we explained why an exact envy-free oracle may not be helpful to obtain an EFM allocation. However, as we showed in this section, the approximate envy-free oracle does help to obtain an \u01eb-EFM allocation. Lemma 5.6 provides the key difference. In particular, the error allowed in the \u01eb-EFM condition ensures that agents' welfare for the remaining cake is reduced by at least an amount of\u01eb. This claim, however, makes no sense when discussing exact envy-freeness. Furthermore, Algorithm 3 introduces additional error into the EFM condition on top of the error that comes from the approximate envy-free oracle. As a result, even if Algorithm 3 was paired with an exact envy-free oracle, it would still not produce an exact EFM allocation.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "EFM and Efficiency", "text": "In this section, we discuss how to combine EFM with efficiency considerations. In particular, we focus on the well-studied efficiency notion of Pareto optimality. Definition 6.1 (PO). An allocation A is said to satisfy Pareto optimality (PO) if there is no allocation A \u2032 that Pareto-dominates A, i.e., satisfies u i (A \u2032 i ) \u2265 u i (A i ) for all i \u2208 N and at least one inequality is strict. Definition 6.2 (fPO [Barman et al., 2018]). An allocation A is said to satisfy fractional Pareto optimality (fPO) if it is not Pareto dominated by any fractional allocation. 6\nAs Barman et al. [2018] noted, an fPO allocation is also PO but not vice versa. It is known that with divisible resources, an allocation that is both envy-free and PO always exists [Weller, 1985]. With indivisible goods, an allocation satisfying both EF1 and fPO (and hence PO) also exists [Barman et al., 2018]. Perhaps to our surprise, in the following we show via a counterexample that with mixed types of goods, EFM and PO are no longer compatible. Example 6.3 (EFM is not compatible with PO). Consider an instance with two agents, one indivisible good, and one cake. Agents' valuation functions are listed below. It is obvious that in any EFM allocation, one agent will get the indivisible good and the entire cake has to be allocated to the other agent. However, such an allocation cannot be PO since the agent with the cake has no value for half of it, and giving that half to the other agent would make that agent better off without making the first agent worse off.\nThis counter-example relies on the fact that in the definition of EFM, if some agent i's bundle contains any positive amount of cake, another agent j will compare her bundle to i's bundle using the stricter EF condition, even if agent j has value zero over i's cake. This may seem counterintuitive, because when j has no value over i's cake, removing that cake from i's bundle will not help eliminate agent j's envy. To this end, one may consider the following weaker version of EFM. Definition 6.4 (Weak EFM). An allocation A is said to satisfy weak envy-freeness for mixed goods (weak EFM), if for any agents i, j \u2208 N ,\n\u2022 if agent j's bundle consists of indivisible goods, and either no divisible good, -or divisible goods that yield value 0 to agent i, i.e., u i (C j ) = 0, there exists an indivisible good g \u2208 A j such that u i (A i ) \u2265 u i (A j \\ {g});\n\u2022 otherwise, u i (A i ) \u2265 u i (A j ).\nFrom the definition, it is easy to see that EFM implies weak EFM, which means all existence results for EFM established in Section 3 can be carried over to weak EFM.\nThis weaker version of EFM precludes the incompatibility result in Example 6.3. Nevertheless, we show in the following example that weak EFM is incompatible with fPO. Example 6.5 ((Weak) EFM is incompatible with fPO). Consider an instance with two agents, one indivisible good and two homogeneous divisible goods. Agents' valuation functions are listed below.\nIndivisible good Divisible good 1 Divisible good 2 Agent 1 2 1 2 Agent 2 2 2 1\nBecause the valuations are symmetric, we can assume without loss of generality that in an EFM allocation, the indivisible good is given to agent 1. We also observe that in any EFM allocation, we cannot allocate all divisible goods to a single agent. This means that both agents' bundles must contain some divisible good, which then implies that both agents need to be envy-free towards the other agent's bundle. Next, via two simple linear programs one can compute the maximum utility of each agent in EFM allocations: giving the indivisible good and one half of divisible good 2 to agent 1 gives her a maximum utility 3; giving divisible good 1 and three quarters of divisible good 2 to agent 2 gives her a maximum utility 2.75. We note that the maximum utilities for the two agents are achieved under different allocations. However, even putting these two maximum utilities together, it is dominated by the utilities guaranteed by the fractional allocation in which agent 1 gets divisible good 2 and half of the indivisible good while agent 2 gets divisible good 1 and the other half of the indivisible good, which will give both agents a utility of 3. This means that any EFM allocation is not fPO in this problem instance.\nCould there always exist an allocation that satisfies both weak EFM and PO? We do not know the answer, and believe this is a very interesting open question. One tempting approach to answer this open question is to consider the maximum Nash welfare (MNW) allocation. This is the allocation that maximizes the Nash welfare i\u2208N u i (A i ) among all allocations. 7 It has been shown that an MNW allocation enjoys many desirable properties in various settings. In particular, an MNW allocation is always envy-free and PO in cake cutting Segal-Halevi and Sziklai [2019], and EF1 and PO for indivisible resource allocation Caragiannis et al. [2019]. It is therefore a natural idea to conjecture that it also satisfies EFM and PO for mixed goods. Unfortunately, this is not the case. Here we give such a counter-example. Example 6.6 (MNW does not imply (weak) EFM). Consider the following instance with two agents, two indivisible goods and one homogeneous cake. Agents' valuation functions are listed below.\nIndivisible good 1 Indivisible good 2 A homogeneous cake Agent 1 0.4 0.4 0.2 Agent 2 0.499 0.499 0.002\nWe discuss the following cases to find the MNW allocation.\n\u2022 When both indivisible goods are given to agent 1, giving the whole cake to agent 2 maximizes the Nash welfare, which is (0.4 + 0.4) \u00d7 0.002 = 0.0016.\n\u2022 When both indivisible goods are given to agent 2, giving the whole cake to agent 1 maximizes the Nash welfare, which is 0.2 \u00d7 (0.499 + 0.499) = 0.1996.\n\u2022 When each agent gets exactly one indivisible good, in the Nash welfare maximizing allocation, denoted by A, agent 1 receives an indivisible good and the entire cake, and agent 2 receives the other indivisible good. The Nash welfare of A is (0.4 + 0.2) \u00d7 0.499 = 0.2994. This is also the overall MNW allocation for this instance.\nHowever, allocation A is not weak EFM, because agent 1's bundle contains some cake that yields positive value to agent 2, and agent 2 is envious of agent 1. It is also worth noting that there is a simple envy-free and PO allocation for this instance: each agent gets one indivisible good and one half of the cake, with Nash welfare (0.4 + 0.1) \u00d7 (0.499 + 0.001) = 0.25.\nNote that the compatibility of weak EFM and PO remains an open question even for the special case with indivisible goods and a single homogeneous divisible good (e.g. money), even though this case is well-studied when there is enough money.", "publication_ref": ["b6", "b6", "b46", "b6", "b41", "b16"], "figure_ref": [], "table_ref": []}, {"heading": "Conclusion and Future Work", "text": "This work is concerned with fair division of a mixture of divisible and indivisible goods. To this end, we introduce the envy-freeness for mixed goods (EFM) fairness notion, which generalizes both EF and EF1 to the mixed goods setting. We show that an EFM allocation always exists for any number of agents. We also provide bounded protocols to compute an EFM allocation in special cases, and an \u01eb-EFM allocation in the general setting in time poly(n, m, 1/\u01eb).\nIt remains an important open question whether there exists a bounded, or even finite protocol in the RW model that computes an EFM allocation in the general setting for any number of players. With regard to \u01eb-EFM, although our algorithm runs in time poly(n, m, 1/\u01eb), it remains an open question to design an algorithm that runs in time poly(n, m, log(1/\u01eb)).\nBesides envy-freeness, one could also generalize other fairness notions to the mixed goods setting. How well would this notion behave with mixed goods in terms of its existence and approximation? Overall, we believe that fair division in the mixed goods setting encodes a rich structure and creates a new research direction that deserves to be pursued for future work.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgments", "text": "The authors acknowledge the helpful comments by the reviewers. We are in particular grateful to an anonymous reviewer for providing Example 6.5 to us.\nThis work is supported in part by an RGC grant (HKU 17203717E).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "", "text": "Given a partial allocation that is\u01eb-EFM, we will show that each of these updates maintains\u01eb-EFM with the updated\u01eb, which completes the proof of Lemma 5.5. We note that\u01eb is only updated in the cake-adding phase and is non-decreasing during the algorithm's run.\nFor analysis in the envy-cycle-elimination phase, the proof is identical to that of Lemma 3.8 in the case of envy-cycle-elimination phase.\nWe then discuss the cases in the cake-adding phase. For the updated partial allocation in Step 11, we allocate the remaining cake C in a way that is \u01eb 4 -EF which implies that u i (C i ) \u2265 u i (C j ) \u2212 \u01eb/4 holds for any pair of agents i, j \u2208 N . Given the partial allocation that is\u01eb-EFM, we have\nThus it is clear that no\u01eb-envy edge will be generated among agents in S if we update\u01eb to\u01eb + \u01eb/4 in Step 10.\nFor the updated partial allocation in Step 22, we allocate some cake C \u2032 to agents in S in a way that is \u03b3-EF. By a similar argument to the case above, we know that no\u01eb-envy edge will be generated among agents in S if we update\u01eb to\u01eb + \u03b3. Then, for any agent i \u2208 N \\ S, we have u i (A i ) > u i (A j ) where j \u2208 S. As u i (C \u2032 ) \u2264\u01eb, we have\nwhere C \u2032 j is the piece of cake allocated to agent j \u2208 S. It means that again no\u01eb-envy edge will be generated from N \\ S to S when we update\u01eb to\u01eb + \u03b3. Last, it is obvious that for any pair of agents in N \\ S, we do not generate any (\u01eb + \u03b3)-envy edge because the bundles of these agents remain the same. We note that\u01eb is updated to\u01eb + \u03b3 in Step 21 in order to make sure that there is no introduced\u01eb-envy edge in the updated\u01eb-envy graph.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Correctness", "text": "Lemma 5.6. In the cake-adding phase, if the piece of cake to be allocated is not the whole remaining cake, the sum of all agents' valuations on the remaining cake decreases by at least\u01eb. Proof. We consider the cake-adding phase in Steps 5-24. If the piece of cake C \u2032 to be allocated is not the whole remaining cake, there exists an agent i * in N \\ S such that u i * (C \u2032 ) =\u01eb according to Steps 16-18. Thus the lemma follows.\nWe are now ready to show the correctness of Algorithm 3.\nLemma 5.7. Algorithm 3 always returns an \u01eb-EFM allocation upon termination.\nProof. By Invariant B2, it suffices to prove that all goods are allocated and\u01eb is at most \u01eb when Algorithm 3 terminates. All indivisible goods are allocated in Step 2. Then the while loop (Steps 4-31) terminates only when the cake is also fully allocated, as desired.\nWe now turn our attention to\u01eb. First,\u01eb is initialized to be \u01eb/4 and never decreases during the algorithm's run. If the whole remaining cake is allocated, there is at most one execution of the cake-adding phase (Steps 7-11). Moreover,\u01eb is increased by \u01eb/4 in Step 10. We will show later in this proof that this increment would not let\u01eb exceed \u01eb. We then focus on the case where the remaining cake is not fully allocated. There are at most n/\u01eb \u2264 4n/\u01eb executions of the cake-adding phase (Steps 12-23) according to Lemma 5.6 and the fact that agents' utilities are normalized to 1. In addition,\u01eb is increased by \u03b3 in each cake-adding phase in Step 21. Thus,\u01eb is upper bounded by \u01eb/4 + 4n/\u01eb \u2022 \u03b3 + \u01eb/4 = \u01eb due to \u03b3 = \u01eb 2 8n . It follows that the final allocation is \u01eb-EFM.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Fair allocation of indivisible goods and criteria of justice", "journal": "Econometrica", "year": "1991", "authors": "Ahmet Alkan; Gabrielle Demange; David Gale"}, {"ref_id": "b1", "title": "", "journal": "Noga Alon. Splitting necklaces. Advances in Mathematics", "year": "1987", "authors": ""}, {"ref_id": "b2", "title": "Approximation algorithms for computing maximin share allocations", "journal": "ACM Transactions on Algorithms (TALG)", "year": "2017", "authors": "Georgios Amanatidis; Evangelos Markakis; Afshin Nikzad; Amin Saberi"}, {"ref_id": "b3", "title": "Aris Filos-Ratsikas, Alexandros Hollender, and Alexandros A. Voudouris. Maximum Nash welfare and other stories about EFX", "journal": "", "year": "2020", "authors": "Georgios Amanatidis; Georgios Birmpas"}, {"ref_id": "b4", "title": "A discrete and bounded envy-free cake cutting protocol for any number of agents", "journal": "", "year": "2016", "authors": "Haris Aziz; Simon Mackenzie"}, {"ref_id": "b5", "title": "A discrete and bounded envy-free cake cutting protocol for four agents", "journal": "", "year": "2016", "authors": "Haris Aziz; Simon Mackenzie"}, {"ref_id": "b6", "title": "Finding fair and efficient allocations", "journal": "", "year": "2018", "authors": "Siddharth Barman; Rohit Sanath Kumar Krishnamurthy;  Vaish"}, {"ref_id": "b7", "title": "Optimal proportional cake cutting with connected pieces", "journal": "", "year": "2012", "authors": "Xiaohui Bei; Ning Chen; Xia Hua; Biaoshuai Tao; Endong Yang"}, {"ref_id": "b8", "title": "Truthful fair division without free disposal", "journal": "Social Choice and Welfare", "year": "2020", "authors": "Xiaohui Bei; Guangda Huzhang; Warut Suksompong"}, {"ref_id": "b9", "title": "Fair division of mixed divisible and indivisible goods", "journal": "", "year": "2020", "authors": "Xiaohui Bei; Zihao Li; Jinyan Liu; Shengxin Liu; Xinhang Lu"}, {"ref_id": "b10", "title": "Maximin fairness with mixed divisible and indivisible goods. CoRR, abs", "journal": "", "year": "2002", "authors": "Xiaohui Bei; Shengxin Liu; Xinhang Lu; Hongao Wang"}, {"ref_id": "b11", "title": "An envy-free cake division protocol. The American Mathematical Monthly", "journal": "", "year": "1995", "authors": "J Steven; Alan D Brams;  Taylor"}, {"ref_id": "b12", "title": "Fair Division: From Cake-cutting to Dispute Resolution", "journal": "Cambridge University Press", "year": "1996", "authors": "J Steven; Alan D Brams;  Taylor"}, {"ref_id": "b13", "title": "The query complexity of cake cutting", "journal": "", "year": "2017", "authors": "Simina Br\u00e2nzei; Noam Nisan"}, {"ref_id": "b14", "title": "One dollar each eliminates envy", "journal": "", "year": "2020", "authors": "Johannes Brustle; Jack Dippel; V Vishnu; Mashbat Narayan; Adrian Suzuki;  Vetta"}, {"ref_id": "b15", "title": "The combinatorial assignment problem: Approximate competitive equilibrium from equal incomes", "journal": "Journal of Political Economy (JPE)", "year": "2011", "authors": "Eric Budish"}, {"ref_id": "b16", "title": "The unreasonable fairness of maximum Nash welfare", "journal": "ACM Transactions on Economics and Computation (TEAC)", "year": "2019", "authors": "Ioannis Caragiannis; David Kurokawa; Herv\u00e9 Moulin; Ariel D Procaccia; Nisarg Shah; Junxing Wang"}, {"ref_id": "b17", "title": "On the computability of equitable divisions", "journal": "Discrete Optimization", "year": "2012", "authors": "Katar\u00edna Cechl\u00e1rov\u00e1; Eva Pill\u00e1rov\u00e1"}, {"ref_id": "b18", "title": "EFX exists for three agents", "journal": "", "year": "2020", "authors": "Jugal Bhaskar Ray Chaudhury; Kurt Garg;  Mehlhorn"}, {"ref_id": "b19", "title": "Truth, justice, and cake cutting", "journal": "Games and Economic Behavior (GEB)", "year": "2013", "authors": "Yiling Chen; John K Lai; David C Parkes; Ariel D Procaccia"}, {"ref_id": "b20", "title": "How to cut a cake fairly", "journal": "The American Mathematical Monthly", "year": "1961", "authors": "E Lester; Edwin Henry Dubins;  Spanier"}, {"ref_id": "b21", "title": "Balanced allocations of cake", "journal": "", "year": "2006", "authors": "Jeff Edmonds; Kirk Pruhs"}, {"ref_id": "b22", "title": "A note on cake cutting", "journal": "Discrete Applied Mathematics", "year": "1984", "authors": "Shimon Even; Azaria Paz"}, {"ref_id": "b23", "title": "An improved approximation algorithm for maximin shares", "journal": "", "year": "2020", "authors": "Jugal Garg; Setareh Taki"}, {"ref_id": "b24", "title": "Fair allocation of indivisible goods: Improvements and generalizations", "journal": "", "year": "2018", "authors": "Mohammad Ghodsi; Mohammadtaghi Hajiaghayi; Masoud Seddighin; Saeed Seddighin; Hadi Yami"}, {"ref_id": "b25", "title": "Fair division with subsidy", "journal": "", "year": "2019", "authors": "Daniel Halpern; Nisarg Shah"}, {"ref_id": "b26", "title": "An algorithm for envy-free allocations in an economy with indivisible objects and money", "journal": "Social Choice and Welfare", "year": "2000", "authors": "Flip Klijn"}, {"ref_id": "b27", "title": "Fair enough: Guaranteeing approximate maximin shares", "journal": "Journal of the ACM (JACM)", "year": "2018", "authors": "David Kurokawa; Ariel D Procaccia; Junxing Wang"}, {"ref_id": "b28", "title": "Sur les fonctions-vecteurs compl\u00e8tement additives", "journal": "Izvestiya Akademii Nauk SSSR. Seriya Matematicheskaya", "year": "1940", "authors": "A A Liapounoff"}, {"ref_id": "b29", "title": "On approximately fair allocations of indivisible goods", "journal": "", "year": "2004", "authors": "Richard J Lipton; Evangelos Markakis; Elchanan Mossel; Amin Saberi"}, {"ref_id": "b30", "title": "Arrow and the Foundations of the Theory of Economic Policy", "journal": "Palgrave Macmillan UK", "year": "1987", "authors": "Eric S Maskin"}, {"ref_id": "b31", "title": "Envy-free and Pareto efficient allocations in economies with indivisible goods and money", "journal": "Mathematical Social Sciences", "year": "2002", "authors": "Marc Meertens; Jos Potters; Hans Reijnierse"}, {"ref_id": "b32", "title": "Herv\u00e9 Moulin. Fair Division and Collective Welfare", "journal": "MIT Press", "year": "2003", "authors": ""}, {"ref_id": "b33", "title": "Fair division in the internet age", "journal": "Annual Review of Economics", "year": "2019", "authors": "Herv\u00e9 Moulin"}, {"ref_id": "b34", "title": "Almost envy-freeness with general valuations", "journal": "SIAM Journal on Discrete Mathematics (SIDMA)", "year": "2020", "authors": "Benjamin Plaut; Tim Roughgarden"}, {"ref_id": "b35", "title": "Cake cutting algorithms", "journal": "Cambridge University Press", "year": "2016", "authors": "Ariel D Procaccia"}, {"ref_id": "b36", "title": "An answer to fair division's most enigmatic question: Technical perspective", "journal": "Communications of the ACM", "year": "2020", "authors": "Ariel D Procaccia"}, {"ref_id": "b37", "title": "A lower bound for equitable cake cutting", "journal": "", "year": "2017", "authors": "Ariel D Procaccia; Junxing Wang"}, {"ref_id": "b38", "title": "Cake-Cutting Algorithm: Be Fair If You Can. A K Peters", "journal": "CRC Press", "year": "1998", "authors": "Jack Robertson; William Webb"}, {"ref_id": "b39", "title": "Brams-Taylor model of fair division for divisible and indivisible items", "journal": "Mathematical Social Sciences", "year": "2010", "authors": "Alexander Rubchinsky"}, {"ref_id": "b40", "title": "Fair division with minimal sharing. CoRR, abs", "journal": "", "year": "1669", "authors": "Fedor Sandomirskiy; Erel Segal-Halevi"}, {"ref_id": "b41", "title": "Monotonicity and competitive equilibrium in cake-cutting", "journal": "Economic Theory", "year": "2019", "authors": "Erel Segal; - Halevi; Bal\u00e1zs R Sziklai"}, {"ref_id": "b42", "title": "The problem of fair division", "journal": "Econometrica", "year": "1948", "authors": "Hugo Steinhaus"}, {"ref_id": "b43", "title": "How to cut a cake fairly", "journal": "The American Mathematical Monthly", "year": "1980", "authors": "Walter Stromquist"}, {"ref_id": "b44", "title": "Rental harmony: Sperner's lemma in fair division", "journal": "The American Mathematical Monthly", "year": "1999", "authors": "Francis Edward Su"}, {"ref_id": "b45", "title": "Introduction to the theory of fair allocation", "journal": "Cambridge University Press", "year": "2016", "authors": "William Thomson"}, {"ref_id": "b46", "title": "Fair division of a measurable space", "journal": "Journal of Mathematical Economics", "year": "1985", "authors": "Dietrich Weller"}], "figures": [{"figure_label": "", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "3. An \u01eb-EFM allocation can be found by Algorithm 3 with running time O(n 4 /\u01eb + mn log m), O(n 3 /\u01eb) Robertson-Webb queries, and O(n/\u01eb) calls to the approximate EFAlloc oracle.", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "8n 2 :2Algorithm 3 \u01eb-EFM Algorithm Require: Agents N , indivisible goods M , cake C, and parameter \u01eb.1:\u01eb \u2190 \u01eb 4 , \u03b3 \u2190 \u01eb 2 Find an arbitrary EF1 allocation (A 1 , A 2 , . . . , A n ) of M to n agents. 3: Construct an\u01eb-envy graph G(\u01eb) = (N, E\u01eb -envy \u222a E\u01eb -eq ) accordingly. 4: while C = \u2205 do 5:", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Lemma 5.9. Algorithm 3 has running time O(n 4 /\u01eb + mn log m) and invokes O(n/\u01eb) calls to the approximate EFAlloc oracle and O(n 3 /\u01eb) Robertson-Webb queries.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "The overall time complexity of our algorithm is O(n/\u01eb\u2022 n 3 + n/\u01eb \u2022 n 2 + mn log m + n 2 ) = O(n 4 /\u01eb + mn log m).The overall Robertson-Webb query complexity is O(n 3 /\u01eb), and the number of calls to the \u03b3-EFAlloc oracle is O(n/\u01eb).", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "i (A i ) \u2265 u i (A j \\ {g}); \u2022 otherwise, u i (A i ) \u2265 u i (A j ).", "formula_coordinates": [5.0, 88.44, 281.98, 451.52, 47.73]}, {"formula_id": "formula_1", "formula_text": "i (A i ) \u2265 u i (A j \\ {g}); \u2022 otherwise, u i (A i ) \u2265 u i (A j ) \u2212 \u01eb.", "formula_coordinates": [5.0, 88.44, 453.34, 451.52, 47.73]}, {"formula_id": "formula_2", "formula_text": "\u2022 Evaluation: An evaluation query of agent i on [x, y] returns u i ([x, y]). \u2022 Cut: A cut query of \u03b2 for agent i from x returns a point y such that u i ([x, y]) = \u03b2.", "formula_coordinates": [5.0, 88.44, 561.7, 407.9, 34.05]}, {"formula_id": "formula_3", "formula_text": "C = (C 1 , C 2 , . . . , C k ) of cake C is said to be perfect if for all i \u2208 N, j \u2208 [k], u i (C j ) = u i (C)/k.", "formula_coordinates": [6.0, 72.0, 97.06, 467.9, 25.29]}, {"formula_id": "formula_4", "formula_text": "\u2022 Envy edge: i ENVY \u2212 \u2212\u2212\u2212 \u2192 j if u i (A i ) < u i (A j ); \u2022 Equality edge: i EQ \u2212 \u2212 \u2192 j if u i (A i ) = u i (A j ).", "formula_coordinates": [6.0, 88.44, 300.75, 209.42, 41.56]}, {"formula_id": "formula_5", "formula_text": "a A 1 b A 2 c A 3 d A 4 ENVY EQ ENVY EQ (a) Envy graph G. v ac v cd (b) The corresponding G \u2032 .", "formula_coordinates": [7.0, 141.47, 74.92, 332.53, 96.53]}, {"formula_id": "formula_6", "formula_text": "a A 3 b A 1 c A 2 d A 4 EQ ENVY EQ (a) Envy graph G. v cd (b) The corresponding G \u2032 .", "formula_coordinates": [7.0, 141.47, 238.01, 332.53, 88.12]}, {"formula_id": "formula_7", "formula_text": "G \u2032 = (N \u2032 , E \u2032 ) from G as follows. Each envy edge i ENVY \u2212 \u2212\u2212\u2212 \u2192 j in G corresponds to a vertex v ij in G \u2032 . For two envy edges i ENVY \u2212 \u2212\u2212\u2212 \u2192 j and i \u2032 ENVY \u2212 \u2212\u2212\u2212 \u2192 j \u2032 in G,", "formula_coordinates": [7.0, 72.0, 645.27, 468.05, 31.48]}, {"formula_id": "formula_8", "formula_text": "agents i \u2208 N \\ S, v i ([a, x i * ]) \u2264 |S| \u2022 \u03b4 i . Next, in Step 20, cake C \u2032 = [a, x i * ] is divided into |S|", "formula_coordinates": [8.0, 99.24, 585.26, 440.78, 13.24]}, {"formula_id": "formula_9", "formula_text": "\u03b4 i \u2190 min j\u2208S (u i (A i ) \u2212 u i (A j )) for each i \u2208 N \\ S.", "formula_coordinates": [9.0, 123.24, 252.82, 233.78, 11.73]}, {"formula_id": "formula_10", "formula_text": "if u i (C) \u2264 |S| \u2022 \u03b4 i holds for each i \u2208 N \\ S then 14: C \u2032 \u2190 C, C \u2190 \u2205 15: else 16: Suppose w.l.o.g. that C = [a, b]. For each agent i \u2208 N \\ S, if u i ([a, b]) \u2265 |S| \u2022 \u03b4 i , let x i be a point such that u i ([a, x i ]) = |S| \u2022 \u03b4 i ; otherwise, let x i = b. 17: i * \u2190 arg min i\u2208N \\S x i 18: C \u2032 \u2190 [a, x i * ], C \u2190 C \\ C \u2032 19: end if 20: Let (C 1 , C 2 , . . . , C k ) = PerfectAlloc(C \u2032 , k, N ) where k = |S|.", "formula_coordinates": [9.0, 73.32, 266.38, 466.2, 120.21]}, {"formula_id": "formula_11", "formula_text": "i \u2208 N \\ S, v i ([a, x i * ]) \u2264 |S| \u2022 \u03b4 i . Next, in Step 20, cake C \u2032 = [a, x i * ]", "formula_coordinates": [10.0, 72.0, 516.82, 467.8, 25.29]}, {"formula_id": "formula_12", "formula_text": "2: if u 1 (M 1 ) \u2264 u 1 (M 2 \u222a C) then 3:", "formula_coordinates": [14.0, 77.88, 130.9, 157.8, 24.22]}, {"formula_id": "formula_13", "formula_text": "1 (M 1 \u222a C 1 ) = u 1 (M 2 \u222a C 2 ). 4: Let (A 1 , A 2 ) = (M 1 \u222a C 1 , M 2 \u222a C 2 ). 5: else 6: Let (A 1 , A 2 ) = (M 1 , M 2 \u222a C).", "formula_coordinates": [14.0, 77.88, 144.46, 462.02, 65.85]}, {"formula_id": "formula_14", "formula_text": "g in A 1 such that u 1 (A 2 ) \u2265 u 1 (M 2 ) \u2265 u 1 (A 1 \\ {g}).", "formula_coordinates": [14.0, 72.0, 582.82, 467.91, 25.05]}, {"formula_id": "formula_15", "formula_text": "C = (C 1 , C 2 , . . . , C k ) of cake C is said to be \u01eb-perfect if for all i \u2208 N , j \u2208 [k], |u i (C j ) \u2212 u i (C)/k| \u2264 \u01eb.", "formula_coordinates": [15.0, 72.0, 545.14, 467.27, 25.29]}, {"formula_id": "formula_16", "formula_text": "\u2022 \u01eb-envy edge: i \u01eb-ENVY \u2212 \u2212\u2212\u2212\u2212 \u2192 j if u i (A i ) < u i (A j ) \u2212 \u01eb; \u2022 \u01eb-equality edge: i \u01eb-EQ \u2212 \u2212\u2212 \u2192 j if u i (A j ) \u2212 \u01eb \u2264 u i (A i ) \u2264 u i (A j ).", "formula_coordinates": [16.0, 88.44, 150.27, 284.06, 39.76]}, {"formula_id": "formula_17", "formula_text": "C \u2032 \u2190 C, C \u2190 \u2205 15: else 16: Suppose w.l.o.g. that C = [a, b]. For each agent i \u2208 N \\ S, if u i ([a, b]) \u2265\u01eb, let x i be a point such that u i ([a, x i ]) =\u01eb; otherwise, let x i = b. 17: i * \u2190 arg min i\u2208N \\S x i 18: C \u2032 \u2190 [a, x i * ], C \u2190 C \\ C \u2032 19: end if 20: Let (C 1 , C 2 , . . . , C k ) = \u03b3-EFAlloc(C \u2032 , S) where k = |S|. 21:\u01eb \u2190\u01eb + \u03b3 22:", "formula_coordinates": [17.0, 73.32, 278.42, 466.73, 134.1]}], "doi": ""}