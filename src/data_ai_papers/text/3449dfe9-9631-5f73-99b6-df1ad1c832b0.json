{"title": "String Re-writing Kernel", "authors": "Fan Bu; Hang Li; Xiaoyan Zhu", "pub_date": "", "abstract": "Learning for sentence re-writing is a fundamental task in natural language processing and information retrieval. In this paper, we propose a new class of kernel functions, referred to as string re-writing kernel, to address the problem. A string re-writing kernel measures the similarity between two pairs of strings, each pair representing re-writing of a string. It can capture the lexical and structural similarity between two pairs of sentences without the need of constructing syntactic trees. We further propose an instance of string rewriting kernel which can be computed efficiently. Experimental results on benchmark datasets show that our method can achieve better results than state-of-the-art methods on two sentence re-writing learning tasks: paraphrase identification and recognizing textual entailment.", "sections": [{"heading": "Introduction", "text": "Learning for sentence re-writing is a fundamental task in natural language processing and information retrieval, which includes paraphrasing, textual entailment and transformation between query and document title in search.\nThe key question here is how to represent the rewriting of sentences. In previous research on sentence re-writing learning such as paraphrase identification and recognizing textual entailment, most representations are based on the lexicons (Zhang and Patrick, 2005;Lintean and Rus, 2011;de Marneffe et al., 2006)   2009; Heilman and Smith, 2010) of the sentence pairs.\nIn (Lin and Pantel, 2001; Barzilay and Lee, 2003), re-writing rules serve as underlying representations for paraphrase generation/discovery. Motivated by the work, we represent re-writing of sentences by all possible re-writing rules that can be applied into it. For example, in Fig. 1, (A) is one re-writing rule that can be applied into the sentence re-writing (B). Specifically, we propose a new class of kernel functions (Sch\u00f6lkopf and Smola, 2002), called string rewriting kernel (SRK), which defines the similarity between two re-writings (pairs) of strings as the inner product between them in the feature space induced by all the re-writing rules. SRK is different from existing kernels in that it is for re-writing and defined on two pairs of strings. SRK can capture the lexical and structural similarity between re-writings of sentences and does not need to parse the sentences and create the syntactic trees of them.\nOne challenge for using SRK lies in the high computational cost of straightforwardly computing the kernel, because it involves two re-writings of strings (i.e., four strings) and a large number of re-writing rules. We are able to develop an instance of SRK, referred to as kb-SRK, which directly computes the number of common rewriting rules without explic-itly calculating the inner product between feature vectors, and thus drastically reduce the time complexity.\nExperimental results on benchmark datasets show that SRK achieves better results than the state-ofthe-art methods in paraphrase identification and recognizing textual entailment. Note that SRK is very flexible to the formulations of sentences. For example, informally written sentences such as long queries in search can also be effectively handled.", "publication_ref": ["b27", "b15", "b7", "b14", "b1", "b23"], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "Related Work", "text": "The string kernel function, first proposed by Lodhi et al. (2002), measures the similarity between two strings by their shared substrings. Leslie et al. (2002) proposed the k-spectrum kernel which represents strings by their contiguous substrings of length k. Leslie et al. (2004) further proposed a number of string kernels including the wildcard kernel to facilitate inexact matching between the strings. The string kernels defined on two pairs of objects (including strings) were also developed, which decompose the similarity into product of similarities between individual objects using tensor product (Basilico and Hofmann, 2004;Ben-Hur and Noble, 2005) or Cartesian product (Kashima et al., 2009). The task of paraphrasing usually consists of paraphrase pattern generation and paraphrase identification. Paraphrase pattern generation is to automatically extract semantically equivalent patterns (Lin and Pantel, 2001;Bhagat and Ravichandran, 2008) or sentences (Barzilay and Lee, 2003). Paraphrase identification is to identify whether two given sentences are a paraphrase of each other. The methods proposed so far formalized the problem as classification and used various types of features such as bag-of-words feature, edit distance (Zhang and Patrick, 2005), dissimilarity kernel (Lintean and Rus, 2011) predicate-argument structure (Qiu et al., 2006), and tree edit model (which is based on a tree kernel) (Heilman and Smith, 2010) in the classification task. Among the most successful methods, Wan et al. (2006) enriched the feature set by the BLEU metric and dependency relations. Das and Smith (2009) used the quasi-synchronous grammar formalism to incorporate features from WordNet, named entity recognizer, POS tagger, and dependency la-bels from aligned trees.\nThe task of recognizing textual entailment is to decide whether the hypothesis sentence can be entailed by the premise sentence (Giampiccolo et al., 2007). In recognizing textual entailment, de Marneffe et al. (2006) classified sentences pairs on the basis of word alignments. MacCartney and Manning ( 2008) used an inference procedure based on natural logic and combined it with the methods by de Marneffe et al. (2006). Harmeling (2007) and Heilman and Smith (2010) classified sequence pairs based on transformation on syntactic trees. Zanzotto et al. (2007) used a kernel method on syntactic tree pairs (Moschitti and Zanzotto, 2007).", "publication_ref": ["b18", "b16", "b17", "b2", "b3", "b12", "b14", "b4", "b1", "b27", "b15", "b21", "b11", "b25", "b6", "b9", "b7", "b7", "b10", "b11", "b26", "b20"], "figure_ref": [], "table_ref": []}, {"heading": "Kernel Approach to Sentence Re-Writing Learning", "text": "We formalize sentence re-writing learning as a kernel method. Following the literature of string kernel, we use the terms \"string\" and \"character\" instead of \"sentence\" and \"word\". Suppose that we are given training data consisting of re-writings of strings and their responses\n((s 1 ,t 1 ), y 1 ), ..., ((s n ,t n ), y n ) \u2208 (\u03a3 * \u00d7 \u03a3 * ) \u00d7 Y\nwhere \u03a3 denotes the character set, \u03a3 * = \u221e i=0 \u03a3 i denotes the string set, which is the Kleene closure of set \u03a3, Y denotes the set of responses, and n is the number of instances. (s i ,t i ) is a re-writing consisting of the source string s i and the target string t i . y i is the response which can be a category, ordinal number, or real number. In this paper, for simplicity we assume that Y = {\u00b11} (e.g. paraphrase/nonparaphrase). Given a new string re-writing (s,t) \u2208 \u03a3 * \u00d7 \u03a3 * , our goal is to predict its response y. That is, the training data consists of binary classes of string re-writings, and the prediction is made for the new re-writing based on learning from the training data.\nWe take the kernel approach to address the learning task. The kernel on re-writings of strings is defined as K :\n(\u03a3 * \u00d7 \u03a3 * ) \u00d7 (\u03a3 * \u00d7 \u03a3 * ) \u2192 R\nsatisfying for all (s i ,t i ), (s j ,t j ) \u2208 \u03a3 * \u00d7 \u03a3 * , K((s i ,t i ), (s j ,t j )) = \u03a6(s i ,t i ), \u03a6(s j ,t j )\nwhere \u03a6 maps each re-writing (pair) of strings into a high dimensional Hilbert space H , referred to as feature space. By the representer theorem (Kimeldorf and Wahba, 1971;Sch\u00f6lkopf and Smola, 2002), it can be shown that the response y of a new string re-writing (s,t) can always be represented as\ny = sign( n \u2211 i=1 \u03b1 i y i K((s i ,t i ), (s,t)))\nwhere\n\u03b1 i \u2265 0, (i = 1, \u2022 \u2022 \u2022 , n) are parameters.\nThat is, it is determined by a linear combination of the similarities between the new instance and the instances in training set. It is also known that by employing a learning model such as SVM (Vapnik, 2000), such a linear combination can be automatically learned by solving a quadratic optimization problem. The question then becomes how to design the kernel function for the task.", "publication_ref": ["b13", "b23", "b24"], "figure_ref": [], "table_ref": []}, {"heading": "String Re-writing Kernel", "text": "Let \u03a3 be the set of characters and \u03a3 * be the set of strings. Let wildcard domain D \u2286 \u03a3 * be the set of strings which can be replaced by wildcards. The string re-writing kernel measures the similarity between two string re-writings through the rewriting rules that can be applied into them. Formally, given re-writing rule set R and wildcard domain D, the string re-writing kernel (SRK) is defined as K((s 1 ,t 1 ), (s 2 ,t 2 )) = \u03a6(s 1 ,t 1 ), \u03a6(s 2 ,t 2 )\n(1)\nwhere \u03a6(s,t) = (\u03c6 r (s,t)) r\u2208R and\n\u03c6 r (s,t) = n\u03bb i (2)\nwhere n is the number of contiguous substring pairs of (s,t) that re-writing rule r matches, i is the number of wildcards in r, and \u03bb \u2208 (0, 1] is a factor punishing each occurrence of wildcard.\nA re-writing rule is defined as a triple r = (\u03b2 s , \u03b2 t , \u03c4) where \u03b2 s ,\u03b2 t \u2208 (\u03a3 \u222a { * }) * denote source and target string patterns and \u03c4 \u2286 ind * (\u03b2 s )\u00d7ind * (\u03b2 t ) denotes the alignments between the wildcards in the two string patterns. Here ind * (\u03b2 ) denotes the set of indexes of wildcards in \u03b2 .\nWe say that a re-writing rule (\u03b2 s , \u03b2 t , \u03c4) matches a string pair (s,t), if and only if string patterns \u03b2 s and \u03b2 t can be changed into s and t respectively by substituting each wildcard in the string patterns with an element in the strings, where the elements are defined in the wildcard domain D and the wildcards \u03b2 s [i] and \u03b2 t [ j] are substituted by the same elements, when there is an alignment (i, j) \u2208 \u03c4.\nFor example, the re-writing rule in Fig. 1 (A) can be formally written as r = (\u03b2 s, \u03b2t, \u03c4) where \u03b2 s = ( * , wrote, * ), \u03b2t = ( * , was, written, by, * ) and \u03c4 = {(1, 5), (3, 1)}. It matches with the string pair in Fig. 1 (B).\nString re-writing kernel is a class of kernels which depends on re-writing rule set R and wildcard domain D. Here we provide some examples. Obviously, the effectiveness and efficiency of SRK depend on the choice of R and D.\nExample 1. We define the pairwise k-spectrum kernel (ps-SRK) K ps k as the re-writing rule kernel un- Leslie et al. (2002).\nder R = {(\u03b2 s , \u03b2 t , \u03c4)|\u03b2 s , \u03b2 t \u2208 \u03a3 k , \u03c4 = / 0} and any D. It can be shown that K ps k ((s 1 ,t 1 ), (s 2 ,t 2 )) = K spec k (s 1 , s 2 )K spec k (t 1 ,t 2 ) where K spec k (x, y) is equiv- alent to the k-spectrum kernel proposed by\nExample 2. The pairwise k-wildcard kernel (pw-SRK) K pw k is defined as the re-writing rule kernel under\nR = {(\u03b2 s , \u03b2 t , \u03c4)|\u03b2 s , \u03b2 t \u2208 (\u03a3\u222a{ * }) k , \u03c4 = / 0} and D = \u03a3. It can be shown that K pw k ((s 1 ,t 1 ), (s 2 ,t 2 )) = K wc (k,k) (s 1 , s 2 )K wc (k,k) (t 1 ,t 2 )\nwhere K wc (k,k) (x, y) is a special case (m=k) of the (k,m)-wildcard kernel proposed by Leslie et al. (2004).\nBoth kernels shown above are represented as the product of two kernels defined separately on strings s 1 , s 2 and t 1 ,t 2 , and that is to say that they do not consider the alignment relations between the strings.", "publication_ref": ["b16", "b17"], "figure_ref": ["fig_1", "fig_1"], "table_ref": []}, {"heading": "K-gram Bijective String Re-writing Kernel", "text": "Next we propose another instance of string rewriting kernel, called the k-gram bijective string rewriting kernel (kb-SRK). As will be seen, kb-SRK can be computed efficiently, although it is defined on two pairs of strings and is not decomposed (note that ps-SRK and pw-SRK are decomposed).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Definition", "text": "The kb-SRK has the following properties: (1) A wildcard can only substitute a single character, denoted as \"?\". (2) The two string patterns in a rewriting rule are of length k.\n(3) The alignment relation in a re-writing rule is bijective, i.e., there is a one-to-one mapping between the wildcards in the string patterns. Formally, the k-gram bijective string re-writing kernel K k is defined as a string re-writing kernel under the re-writing rule set R = {(\u03b2 s , \u03b2 t , \u03c4)|\u03b2 s , \u03b2 t \u2208 (\u03a3 \u222a {?}) k , \u03c4 is bijective} and the wildcard domain D = \u03a3.\nSince each re-writing rule contains two string patterns of length k and each wildcard can only substitute one character, a re-writing rule can only match k-gram pairs in (s,t). We can rewrite Eq. (2) as\n\u03c6 r (s,t) = \u2211 \u03b1 s \u2208k-grams(s) \u2211 \u03b1 t \u2208k-grams(t)\u03c6 r (\u03b1 s , \u03b1 t ) (3) where\u03c6 r (\u03b1 s , \u03b1 t ) = \u03bb i if r (with i wildcards) matches (\u03b1 s , \u03b1 t ), otherwise\u03c6 r (\u03b1 s , \u03b1 t ) = 0.\nFor ease of computation, we re-write kb-SRK as\nK k ((s 1 ,t 1 ), (s 2 ,t 2 )) = \u2211 \u03b1s 1 \u2208 k-grams(s 1 ) \u03b1t 1 \u2208 k-grams(t 1 ) \u2211 \u03b1s 2 \u2208 k-grams(s 2 ) \u03b1t 2 \u2208 k-grams(t 2 )K k ((\u03b1 s 1 , \u03b1 t 1 ), (\u03b1 s 2 , \u03b1 t 2 ))(4)\nwhereK\nk = \u2211 r\u2208R\u03c6 r (\u03b1 s 1 , \u03b1 t 1 )\u03c6 r (\u03b1 s 2 , \u03b1 t 2 ) (5)", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Algorithm for Computing Kernel", "text": "A straightforward computation of kb-SRK would be intractable. The computation of K k in Eq. (4) needs computations ofK k conducted O((n \u2212 k + 1) 4 ) times, where n denotes the maximum length of strings. Furthermore, the computation ofK k in Eq. (5) needs to perform matching of all the rewriting rules with the two k-gram pairs (\u03b1 s 1 , \u03b1 t 1 ), (\u03b1 s 2 , \u03b1 t 2 ), which has time complexity O(k!).\nIn this section, we will introduce an efficient algorithm, which can computeK k and K k with the time complexities of O(k) and O(kn 2 ), respectively. The latter is verified empirically.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Transformation of Problem", "text": "For ease of manipulation, our method transforms the computation of kernel on k-grams into the computation on a new data structure called lists of doubles. We first explain how to make the transformation.\nSuppose that \u03b1 1 , \u03b1 2 \u2208 \u03a3 k are k-grams, we use \u03b1 1 [i] and \u03b1 2 [i] to represent the i-th characters of them. We call a pair of characters a double. Thus \u03a3 \u00d7 \u03a3 denotes the set of doubles and \u03b1 D s , \u03b1 D t \u2208 (\u03a3 \u00d7 \u03b1 1 = abbccbb ; \u03b1 2 = abcccdd; \u03b1 1 = cbcbbcb ; \u03b1 2 = cbccdcd; \u03a3) k denote lists of doubles. The following operation combines two k-grams into a list of doubles.\n\u03b1 1 \u2297 \u03b1 2 = ((\u03b1 1 [1], \u03b1 2 [1]), \u2022 \u2022 \u2022 , (\u03b1 1 [k], \u03b1 2 [k])).\nWe denotes \u03b1 1 \u2297 \u03b1 2 [i] as the i-th element of the list. \nR D = {r D = (\u03b2 D s , \u03b2 D t , \u03c4)|\u03b2 D s , \u03b2 D t \u2208 (I \u222a {?}) k\n, \u03c4 is a bijective alignment} where \u03b2 D s and \u03b2 D t are lists of identical doubles including wildcards and with length k. We say rule r D matches a pair of double lists (\u03b1\nD s , \u03b1 D t ) iff. \u03b2 D s , \u03b2 D t can be changed into \u03b1 D s\nand \u03b1 D t by substituting each wildcard pair to a double in \u03a3 \u00d7 \u03a3 , and the double substituting the wildcard pair \u03b2 D s [i] and \u03b2 D t [ j] must be an identical double when there is an alignment (i, j) \u2208 \u03c4. The rule set defined here and the rule set in Sec. 4 only differ on the elements where re-writing occurs. Fig. 4 (B) shows an example of re-writing rule for double lists. The pair of double lists in Fig. 3 can match with the re-writing rule.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "ComputingK k", "text": "We consider how to computeK k by extending the computation from k-grams to double lists.\nThe following lemma shows that computing the weighted sum of re-writing rules matching k-gram pairs (\u03b1 s 1 , \u03b1 t 1 ) and (\u03b1 s 2 , \u03b1 t 2 ) is equivalent to computing the weighted sum of re-writing rules for double lists matching (\u03b1 s 1 \u2297 \u03b1 s 2 , \u03b1 t 1 \u2297 \u03b1 t 2 ). Lemma 1. For any two k-gram pairs (\u03b1 s 1 , \u03b1 t 1 ) and (\u03b1 s 2 , \u03b1 t 2 ), there exists a one-to-one mapping from the set of re-writing rules matching them to the set of re-writing rules matching the corresponding double lists (\u03b1\ns 1 \u2297 \u03b1 s 2 , \u03b1 t 1 \u2297 \u03b1 t 2 ).\nThe re-writing rule in Fig. 4 (A) matches the kgram pairs in Fig. 2. Equivalently, the re-writing rule for double lists in Fig. 4 (B) matches the pair of double lists in Fig. 3. By lemma 1 and Eq. 5, we haveK\nk = \u2211 r D \u2208R D\u03c6 r D (\u03b1 s 1 \u2297 \u03b1 s 2 , \u03b1 t 1 \u2297 \u03b1 t 2 ) (6\n)\nwhere\u03c6 r D (\u03b1 D s , \u03b1 D t ) = \u03bb 2i\nif the rewriting rule for double lists r D with i wildcards matches (\u03b1 D s , \u03b1 D t ), otherwise\u03c6 r D (\u03b1 D s , \u03b1 D t ) = 0. To getK k , we just need to compute the weighted sum of re-writing rules for double lists matching (\u03b1 s 1 \u2297 \u03b1 s 2 , \u03b1 t 1 \u2297 \u03b1 t 2 ). Thus, we can work on the \"combined\" pair of double lists instead of two pairs of k-grams.\nInstead of enumerating all possible re-writing rules and checking whether they can match the given pair of double lists, we only calculate the number of possibilities of \"generating\" from the pair of double lists to the re-writing rules matching it, which can be carried out efficiently. We say that a re-writing rule of double lists can be generated from a pair of double lists (\u03b1 D s , \u03b1 D t ), if they match with each other. From the definition of R D , in each generation, the identical doubles in \u03b1 D s and \u03b1 D t can be either or not substituted by an aligned wildcard pair in the re-writing rule, and all the non-identical doubles in \u03b1 D s and \u03b1 D t must be substituted by aligned wildcard pairs. From this observation and Eq. 6,K k only depends on the number of times each double occurs in the double lists.\nAlgorithm 1: ComputingK k Input: k-gram pair (\u03b1 s 1 , \u03b1 t 1 ) and (\u03b1 s 2 , \u03b1 t 2 ) Output:K k ((\u03b1 s 1 , \u03b1 t 1 ), (\u03b1 s 2 , \u03b1 t 2 )) 1 Set (\u03b1 D s , \u03b1 D t ) = (\u03b1 s 1 \u2297 \u03b1 s 2 , \u03b1 t 1 \u2297 \u03b1 t 2 ) ; 2 Compute # \u03a3\u00d7\u03a3 (\u03b1 D s ) and # \u03a3\u00d7\u03a3 (\u03b1 D t ); 3 result=1; 4 for each e \u2208 \u03a3 \u00d7 \u03a3 satisfies # e (\u03b1 D s ) + # e (\u03b1 D t ) = 0 do 5 g e = 0, n e = min{# e (\u03b1 D s ), # e (\u03b1 D t )} ; 6 for 0 \u2264 i \u2264 n\nLet e be a double. We denote # e (\u03b1 D ) as the number of times e occurs in the list of doubles \u03b1 D . Also, for a set of doubles S \u2286 \u03a3 \u00d7 \u03a3, we denote # S (\u03b1 D ) as a vector in which each element represents # e (\u03b1 D ) of each double e \u2208 S. We can find a function g such thatK\nk = g(# \u03a3\u00d7\u03a3 (\u03b1 s 1 \u2297 \u03b1 s 2 ), # \u03a3\u00d7\u03a3 (\u03b1 t 1 \u2297 \u03b1 t 2 ))(7)\nAlg. 1 shows how to computeK k . # \u03a3\u00d7\u03a3 (.) is computed from the two pairs of k-grams in line 1-2. The final score is made through the iterative calculation on the two lists (lines 4-8).\nThe key of Alg. 1 is the calculation of g e based on a (e) i (line 7). Here we use a i can be computed as follows.\n(1) If e \u2208 N and # e (\u03b1 D s ) = # e (\u03b1 D t ), then a (e) i = 0 for any i.\n(2) If e \u2208 N and # e (\u03b1 D s ) = # e (\u03b1 D t ) = j, then a (e) j = j! and a (e) i = 0 for any i = j.\n(3) If e \u2208 I, then a\n(e) i = # e (\u03b1 D s ) i # e (\u03b1 D t ) i i!.\nWe next explain the rationale behind the above computations. In (1), since # e (\u03b1 D s ) = # e (\u03b1 D t ), it is impossible to generate a re-writing rule in which all the occurrences of non-identical double e are substituted by pairs of aligned wildcards. In (2), j pairs of aligned wildcards can be generated from all the occurrences of non-identical double e in both \u03b1 D s and \u03b1 D t . The number of combinations thus is j!. In (3), a pair of aligned wildcards can either be generated or not from a pair of identical doubles in \u03b1 D s and \u03b1 D t . We can select i occurrences of identical double e from \u03b1 D s , i occurrences from \u03b1 D t , and generate all possible aligned wildcards from them.\nIn the loop of lines 4-8, we only need to consider a\n(e) i for 0 \u2264 i \u2264 min{# e (\u03b1 D s ), # e (\u03b1 D t )}, because a (e) i = 0 for the rest of i.\nTo sum up, Eq. 7 can be computed as below, which is exactly the computation at lines 3-8.\ng(# \u03a3\u00d7\u03a3 (\u03b1 D s ), # \u03a3\u00d7\u03a3 (\u03b1 D t )) = \u220f e\u2208\u03a3\u00d7\u03a3 ( n e \u2211 i=0 a (e) i \u03bb 2i ) (8)\nFor the k-gram pairs in Fig. 2, we first create lists of doubles in Fig. 3 and compute # \u03a3\u00d7\u03a3 (\u2022) for them (lines 1-2 of Alg. 1), as shown in Fig. 5. We next compute K k from # \u03a3\u00d7\u03a3 (\u03b1 D s ) and # \u03a3\u00d7\u03a3 (\u03b1 D t ) in Fig. 5 (lines 3-8 of Alg. 1) and obtain K k = (1)(1 + \u03bb 2 )(\u03bb 2 )(2\u03bb 4 )(1 + 6\u03bb 2 + 6\u03bb 4 ) = 12\u03bb 12 + 24\u03bb 10 + 14\u03bb 8 + 2\u03bb 6 .", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Computing K k", "text": "Algorithm 2 shows how to compute K k . It prepares two maps m s and m t and two vectors of counters c s and c t . In m s and m t , each key # N (.) maps a set of values # \u03a3\u00d7\u03a3 (.). Counters c s and c t count the frequency of each # \u03a3\u00d7\u03a3 (.). Recall that # N (\u03b1 s 1 \u2297 \u03b1 s 2 ) denotes a vector whose element is # e (\u03b1 s 1 \u2297 \u03b1 s 2 ) for e \u2208 N. # \u03a3\u00d7\u03a3 (\u03b1 s 1 \u2297 \u03b1 s 2 ) denotes a vector whose element is # e (\u03b1 s 1 \u2297 \u03b1 s 2 ) where e is any possible double.\nOne can easily verify the output of the algorithm is exactly the value of K k .\nFirst,\nK k ((\u03b1 s 1 , \u03b1 t 1 ), (\u03b1 s 2 , \u03b1 t 2 )) = 0 if # N (\u03b1 s 1 \u2297 \u03b1 s 2 ) = # N (\u03b1 t 1 \u2297 \u03b1 t 2 )\n. Therefore, we only need to consider those \u03b1 s 1 \u2297 \u03b1 s 2 and \u03b1 t 1 \u2297 \u03b1 t 2 which have the same key (lines 10-13). We group the k-gram pairs by their key in lines 2-5 and lines 6-9.\nMoreover, the following relation holds\nK k ((\u03b1 s 1 , \u03b1 t 1 ), (\u03b1 s 2 , \u03b1 t 2 )) =K k ((\u03b1 s 1 , \u03b1 t 1 ), (\u03b1 s 2 , \u03b1 t 2 )) if # \u03a3\u00d7\u03a3 (\u03b1 s 1 \u2297\u03b1 s 2 ) = # \u03a3\u00d7\u03a3 (\u03b1 s 1 \u2297\u03b1 s 2 ) and # \u03a3\u00d7\u03a3 (\u03b1 t 1 \u2297 \u03b1 t 2 ) = # \u03a3\u00d7\u03a3 (\u03b1 t 1 \u2297 \u03b1 t 2 ), where \u03b1 s 1 , \u03b1 s 2 , \u03b1 t 1 , \u03b1 t 2 are\nAlgorithm 2: Computing K k Input: string pair (s 1 ,t 1 ) and (s 2 ,t 2 ), window size k Output: K k ((s 1 ,t 1 ), (s 2 ,t 2 )) 1 Initialize two maps m s and m t and two counters c s and c t ;\n2 for each k-gram \u03b1 s 1 in s 1 do 3 for each k-gram \u03b1 s 2 in s 2 do 4 Update m s with key-value pair (# N (\u03b1 s 1 \u2297 \u03b1 s 2 ), # \u03a3\u00d7\u03a3 (\u03b1 s 1 \u2297 \u03b1 s 2 )); 5 c s [# \u03a3\u00d7\u03a3 (\u03b1 s 1 \u2297 \u03b1 s 2 )] + + ; 6 for each k-gram \u03b1 t 1 in t 1 do 7 for each k-gram \u03b1 t 2 in t 2 do 8 Update m t with key-value pair (# N (\u03b1 t 1 \u2297 \u03b1 t 2 ), # \u03a3\u00d7\u03a3 (\u03b1 t 1 \u2297 \u03b1 t 2 )); 9 c t [# \u03a3\u00d7\u03a3 (\u03b1 t 1 \u2297 \u03b1 t 2 )] + + ; 10 for each key \u2208 m s .keys \u2229 m t .keys do 11 for each v s \u2208 m s [key] do 12 for each v t \u2208 m t [key] do 13 result+= c s [v s ]c t [v t ]g(v s , v t ) ;\n14 return result; other k-grams. Therefore, we only need to take # \u03a3\u00d7\u03a3 (\u03b1 s 1 \u2297 \u03b1 s 2 ) and # \u03a3\u00d7\u03a3 (\u03b1 t 1 \u2297 \u03b1 t 2 ) as the value under each key and count its frequency. That is to say, # \u03a3\u00d7\u03a3 provides sufficient statistics for computingK k .\nThe quantity g(v s , v t ) in line 13 is computed by Alg. 1 (lines 3-8).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Time Complexity", "text": "The time complexities of Alg. 1 and Alg. 2 are shown below.\nFor Alg. 1, lines 1-2 can be executed in O(k).\nThe time for executing line 7 is less  13 is quite difficult.\nthan # e (\u03b1 D s ) + # e (\u03b1 D t ) + 1 for each e satisfying # e (\u03b1 D s ) = 0 or # e (\u03b1 D t ) = 0 . Since \u2211 e\u2208\u03a3\u00d7\u03a3 # e (\u03b1 D s ) = \u2211 e\u2208\u03a3\u00d7\u03a3 # e (\u03b1 D t ) = k,\nLemma 2 and Theorem 1 provide an upper bound of the number of times computing g(v s , v t ) in line 13, denoted as C.\nLemma 2. For \u03b1 s 1 \u2208k-grams(s 1 ) and \u03b1 s 2 , \u03b1 s 2 \u2208kgrams(s 2 ), we have\n# \u03a3\u00d7\u03a3 (\u03b1 s 1 \u2297 \u03b1 s 2 ) = # \u03a3\u00d7\u03a3 (\u03b1 s 1 \u2297 \u03b1 s 2 ) if # N (\u03b1 s 1 \u2297 \u03b1 s 2 ) = # N (\u03b1 s 1 \u2297 \u03b1 s 2 ). Theorem 1. C is O(n 3 ).\nBy Lemma 2, each m s [key] contains at most n \u2212 k + 1 elements. Together with the fact that\n\u2211 key m s [key] = (n \u2212 k + 1) 2 , Theorem 1 is proved. It can be also proved that C is O(n 2 ) when k = 1.\nEmpirical study shows that O(n 3 ) is a loose upper bound for C. Let n avg denote the average length of s 1 , t 1 , s 2 and t 2 . Our experiment on all pairs of sentences on MSR Paraphrase (Fig. 6) shows that C is in the same order of n 2 avg in the worst case and C/n 2 avg decreases with increasing k in both average case and worst case, which indicates that C is O(n 2 ) and the overall time complexity of Alg. 2 is O(kn 2 ).", "publication_ref": [], "figure_ref": ["fig_8"], "table_ref": []}, {"heading": "Experiments", "text": "We evaluated the performances of the three types of string re-writing kernels on paraphrase identification and recognizing textual entailment: pairwise kspectrum kernel (ps-SRK), pairwise k-wildcard kernel (pw-SRK), and k-gram bijective string re-writing kernel (kb-SRK). We set \u03bb = 1 for all kernels. The performances were measured by accuracy (e.g. percentage of correct classifications).\nIn both experiments, we used LIBSVM with default parameters (Chang et al., 2011) as the classifier. All the sentences in the training and test sets were segmented into words by the tokenizer at OpenNLP (Baldrige et al., ). We further conducted stemming on the words with Iveonik English Stemmer (http://www.iveonik.com/ ). We normalized each kernel byK(x, y) = K(x,y) \u221a K(x,x)K(y,y) and then tried them under different window sizes k. We also tried to combine the kernels with two lexical features \"unigram precision and recall\" proposed in (Wan et al., 2006), referred to as PR. For each kernel K, we tested the window size settings of K 1 + ... + K k max (k max \u2208 {1, 2, 3, 4}) together with the combination with PR and we report the best accuracies of them in Tab 1 and Tab 2.", "publication_ref": ["b5", "b25"], "figure_ref": [], "table_ref": []}, {"heading": "Paraphrase Identification", "text": "The task of paraphrase identification is to examine whether two sentences have the same meaning. We trained and tested all the methods on the MSR Paraphrase Corpus (Dolan and Brockett, 2005;Quirk et al., 2004) (Zhang and Patrick, 2005) and kernel approach (Lintean and Rus, 2011). It also works better than the other approaches listed in the table, which use syntactic trees or dependency relations.\nFig. 7 gives detailed results of the kernels under different maximum k-gram lengths k max with and without PR. The results of ps-SRK and pw-SRK without combining PR under different k are all below 71%, therefore they are not shown for clar-", "publication_ref": ["b8", "b22", "b27", "b15"], "figure_ref": ["fig_9"], "table_ref": []}, {"heading": "Method", "text": "Acc. Zhang and Patrick (2005) 71.9 Lintean and Rus ( 2011  ity. By comparing the results of kb-SRK and pw-SRK we can see that the bijective property in kb-SRK is really helpful for improving the performance (note that both methods use wildcards). Furthermore, the performances of kb-SRK with and without combining PR increase dramatically with increasing k max and reach the peaks (better than state-of-the-art) when k max is four, which shows the power of the lexical and structural similarity captured by kb-SRK.", "publication_ref": ["b27"], "figure_ref": [], "table_ref": []}, {"heading": "Recognizing Textual Entailment", "text": "Recognizing textual entailment is to determine whether a sentence (sometimes a short paragraph) can entail the other sentence (Giampiccolo et al., 2007). RTE-3 is a widely used benchmark dataset. Following the common practice, we combined the development set of RTE-3 and the whole datasets of RTE-1 and RTE-2 as training data and took the test set of RTE-3 as test data. The train and test sets contain 3,767 and 800 sentence pairs. The results are shown in Table 2. Again, kb-SRK outperforms ps-SRK and pw-SRK. As indicated in (Heilman and Smith, 2010), the top-performing RTE systems are often built with significant engi-   neering efforts. Therefore, we only compare with the six systems which involves less engineering. kb-SRK still outperforms most of those state-of-the-art methods even if it does not exploit any other lexical semantic sources and syntactic analysis tools. Fig. 8 shows the results of the kernels under different parameter settings. Again, the results of ps-SRK and pw-SRK without combining PR are too low to be shown (all below 55%). We can see that PR is an effective method for this dataset and the overall performances are substantially improved after combining it with the kernels. The performance of kb-SRK reaches the peak when window size becomes two.", "publication_ref": ["b9", "b11"], "figure_ref": ["fig_10"], "table_ref": ["tab_3"]}, {"heading": "Conclusion", "text": "In this paper, we have proposed a novel class of kernel functions for sentence re-writing, called string re-writing kernel (SRK). SRK measures the lexical and structural similarity between two pairs of sentences without using syntactic trees. The approach is theoretically sound and is flexible to formulations of sentences. A specific instance of SRK, referred to as kb-SRK, has been developed which can balance the effectiveness and efficiency for sentence re-writing. Experimental results show that kb-SRK achieve better results than state-of-the-art methods on paraphrase identification and recognizing textual entailment.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgments", "text": "This work is supported by the National Basic Research Program (973 Program) No. 2012CB316301.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "", "journal": "", "year": "", "authors": "J Baldrige; T Morton; G Bierner;  Opennlp"}, {"ref_id": "b1", "title": "Learning to paraphrase: An unsupervised approach using multiple-sequence alignment", "journal": "", "year": "2003", "authors": "R Barzilay; L Lee"}, {"ref_id": "b2", "title": "Unifying collaborative and content-based filtering", "journal": "", "year": "2004", "authors": "J Basilico; T Hofmann"}, {"ref_id": "b3", "title": "Kernel methods for predicting protein-protein interactions", "journal": "Bioinformatics", "year": "2005", "authors": "A Ben-Hur; W S Noble"}, {"ref_id": "b4", "title": "Large scale acquisition of paraphrases for learning surface patterns", "journal": "", "year": "2008", "authors": "R Bhagat; D Ravichandran"}, {"ref_id": "b5", "title": "LIBSVM: A library for support vector machines", "journal": "", "year": "2011", "authors": "C Chang; C Lin"}, {"ref_id": "b6", "title": "Paraphrase identification as probabilistic quasi-synchronous recognition", "journal": "", "year": "2009", "authors": "D Das; N A Smith"}, {"ref_id": "b7", "title": "Learning to distinguish valid textual entailments", "journal": "", "year": "2006", "authors": "M De Marneffe; B Maccartney; T Grenager; D Cer; A Rafferty; C D Manning"}, {"ref_id": "b8", "title": "Automatically constructing a corpus of sentential paraphrases", "journal": "", "year": "2005", "authors": "W B Dolan; C Brockett"}, {"ref_id": "b9", "title": "The third pascal recognizing textual entailment challenge", "journal": "", "year": "2007", "authors": "D Giampiccolo; B Magnini; I Dagan; B Dolan"}, {"ref_id": "b10", "title": "An extensible probabilistic transformation-based approach to the third recognizing textual entailment challenge", "journal": "", "year": "2007", "authors": "S Harmeling"}, {"ref_id": "b11", "title": "Tree edit models for recognizing textual entailments, paraphrases, and answers to questions", "journal": "", "year": "2010", "authors": "M Heilman; N A Smith"}, {"ref_id": "b12", "title": "On pairwise kernels: An efficient alternative and generalization analysis. Advances in Knowledge Discovery and Data Mining", "journal": "Springer", "year": "2009", "authors": "H Kashima; S Oyama; Y Yamanishi; K Tsuda"}, {"ref_id": "b13", "title": "Some results on Tchebycheffian spline functions", "journal": "Journal of Mathematical Analysis and Applications", "year": "1971", "authors": "G Kimeldorf; G Wahba"}, {"ref_id": "b14", "title": "DIRT-discovery of inference rules from text", "journal": "", "year": "2001", "authors": "D Lin; P Pantel"}, {"ref_id": "b15", "title": "Dissimilarity Kernels for Paraphrase Identification. Twenty-Fourth International FLAIRS Conference", "journal": "", "year": "2011", "authors": "M Lintean; V Rus"}, {"ref_id": "b16", "title": "The spectrum kernel: a string kernel for SVM protein classification", "journal": "", "year": "2002", "authors": "C Leslie; E Eskin; W S Noble"}, {"ref_id": "b17", "title": "Fast string kernels using inexact matching for protein sequences", "journal": "The Journal of Machine Learning Research", "year": "2004", "authors": "C Leslie; R Kuang"}, {"ref_id": "b18", "title": "Text classification using string kernels", "journal": "The Journal of Machine Learning Research", "year": "2002", "authors": "H Lodhi; C Saunders; J Shawe-Taylor; N Cristianini; C Watkins"}, {"ref_id": "b19", "title": "Modeling semantic containment and exclusion in natural language inference", "journal": "", "year": "2008", "authors": "B Maccartney; C D Manning"}, {"ref_id": "b20", "title": "Fast and Effective Kernels for Relational Learning from Texts", "journal": "", "year": "2007", "authors": "A Moschitti; F M Zanzotto"}, {"ref_id": "b21", "title": "Paraphrase recognition via dissimilarity significance classification", "journal": "", "year": "2006", "authors": "L Qiu; M Y Kan; T S Chua"}, {"ref_id": "b22", "title": "Monolingual machine translation for paraphrase generation", "journal": "", "year": "2004", "authors": "C Quirk; C Brockett; W Dolan"}, {"ref_id": "b23", "title": "Learning with kernels: Support vector machines, regularization, optimization, and beyond", "journal": "The MIT Press", "year": "2002", "authors": "B Sch\u00f6lkopf; A J Smola"}, {"ref_id": "b24", "title": "The nature of statistical learning theory", "journal": "Springer Verlag", "year": "2000", "authors": "V N Vapnik"}, {"ref_id": "b25", "title": "Using dependency-based features to take the \"Para-farce\" out of paraphrase", "journal": "", "year": "2006", "authors": "S Wan; M Dras; R Dale; C Paris"}, {"ref_id": "b26", "title": "Shallow semantics in fast textual entailment rule learners", "journal": "", "year": "2007", "authors": "F M Zanzotto; M Pennacchiotti; A Moschitti"}, {"ref_id": "b27", "title": "Paraphrase identification by text canonicalization", "journal": "", "year": "2005", "authors": "Y Zhang; J Patrick"}], "figures": [{"figure_label": "", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "or the syntactic trees(Das and Smith,    ", "figure_data": ""}, {"figure_label": "1", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 1 :1Figure 1: Example of re-writing. (A) is a re-writing rule and (B) is a re-writing of sentence.", "figure_data": ""}, {"figure_label": "23", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Figure 2 :Figure 3 :23Figure 2: Example of two k-gram pairs. \u03b1 D = (a, a), (b, b), ( , ), (c, c), (c, c), ( , ), ( , ) \u03b1 D = (c, c), (b, b), (c, c), ( , ), ( , ), (c, c), ( , )", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Fig. 3 shows example lists of doubles combined from k-grams. We introduce the set of identical doubles I = {(c, c)|c \u2208 \u03a3} and the set of non-identical doubles N = {(c, c )|c, c \u2208 \u03a3 and c = c }. Obviously, I N = \u03a3 \u00d7 \u03a3 and I N = / 0. We define the set of re-writing rules for double lists", "figure_data": ""}, {"figure_label": "45", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "Figure 4 :Figure 5 :45Figure 4: For re-writing rule (A) matching both k-gram pairs shown in Fig. 2, there is a corresponding re-writing rule for double lists (B) matching the pair of double lists shown in Fig. 3. # \u03a3\u00d7\u03a3 (\u03b1 D ) = {(a, a): 1, (b, b): 1, ( , ): 1, ( , ): 2, (c, c): 2} # \u03a3\u00d7\u03a3 (\u03b1 D ) = {(a, a): 0, (b, b): 1, ( , ): 1, ( , ): 2, (c, c): 3}", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_6", "figure_caption": "ito denote the number of possibilities for which i pairs of aligned wildcards can be generated from e in both \u03b1 D s and \u03b1 D t . a(e)", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_7", "figure_caption": "the time for executing lines 3-8 is less than 4k, which results in the O(k) time complexity of Alg. 1.For Alg. 2, we denote n = max{|s 1 |, |s 2 |, |t 1 |, |t 2 |}. It is easy to see that if the maps and counters in the algorithm are implemented by hash maps, the time complexities of lines 2-5 and lines 6-9 are O(kn 2 ). However, analyzing the time complexity of lines 10-", "figure_data": ""}, {"figure_label": "6", "figure_type": "figure", "figure_id": "fig_8", "figure_caption": "Figure 6 :6Figure 6: Relation between ratio C/n 2 avg and window size k when running Alg. 2 on MSR Paraphrases Corpus.", "figure_data": ""}, {"figure_label": "7", "figure_type": "figure", "figure_id": "fig_9", "figure_caption": "Figure 7 :7Figure 7: Performances of different kernels under different maximum window size k max on MSRP.", "figure_data": ""}, {"figure_label": "8", "figure_type": "figure", "figure_id": "fig_10", "figure_caption": "Figure 8 :8Figure 8: Performances of different kernels under different maximum window size k max on RTE-3.", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "consisting of 4,076 sentence pairs for training and 1,725 sentence pairs for testing. The experimental results on different SRKs are shown in Table 1. It can be seen that kb-SRK outperforms ps-SRK and pw-SRK. The results by the state-of-the-art methods reported in previous work are also included in Table 1. kb-SRK outperforms the existing lexical approach", "figure_data": ""}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_3", "figure_caption": "Comparison with state-of-the-arts on RTE-3.", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "((s 1 ,t 1 ), y 1 ), ..., ((s n ,t n ), y n ) \u2208 (\u03a3 * \u00d7 \u03a3 * ) \u00d7 Y", "formula_coordinates": [2.0, 330.22, 384.01, 190.35, 13.17]}, {"formula_id": "formula_1", "formula_text": "(\u03a3 * \u00d7 \u03a3 * ) \u00d7 (\u03a3 * \u00d7 \u03a3 * ) \u2192 R", "formula_coordinates": [2.0, 374.36, 619.85, 117.66, 12.55]}, {"formula_id": "formula_2", "formula_text": "y = sign( n \u2211 i=1 \u03b1 i y i K((s i ,t i ), (s,t)))", "formula_coordinates": [3.0, 116.45, 119.85, 140.32, 29.4]}, {"formula_id": "formula_3", "formula_text": "\u03b1 i \u2265 0, (i = 1, \u2022 \u2022 \u2022 , n) are parameters.", "formula_coordinates": [3.0, 103.56, 159.46, 159.04, 10.52]}, {"formula_id": "formula_4", "formula_text": "\u03c6 r (s,t) = n\u03bb i (2)", "formula_coordinates": [3.0, 157.53, 472.22, 141.34, 12.88]}, {"formula_id": "formula_5", "formula_text": "der R = {(\u03b2 s , \u03b2 t , \u03c4)|\u03b2 s , \u03b2 t \u2208 \u03a3 k , \u03c4 = / 0} and any D. It can be shown that K ps k ((s 1 ,t 1 ), (s 2 ,t 2 )) = K spec k (s 1 , s 2 )K spec k (t 1 ,t 2 ) where K spec k (x, y) is equiv- alent to the k-spectrum kernel proposed by", "formula_coordinates": [3.0, 313.13, 256.89, 224.54, 51.52]}, {"formula_id": "formula_6", "formula_text": "R = {(\u03b2 s , \u03b2 t , \u03c4)|\u03b2 s , \u03b2 t \u2208 (\u03a3\u222a{ * }) k , \u03c4 = / 0} and D = \u03a3. It can be shown that K pw k ((s 1 ,t 1 ), (s 2 ,t 2 )) = K wc (k,k) (s 1 , s 2 )K wc (k,k) (t 1 ,t 2 )", "formula_coordinates": [3.0, 313.13, 354.33, 224.54, 41.42]}, {"formula_id": "formula_7", "formula_text": "\u03c6 r (s,t) = \u2211 \u03b1 s \u2208k-grams(s) \u2211 \u03b1 t \u2208k-grams(t)\u03c6 r (\u03b1 s , \u03b1 t ) (3) where\u03c6 r (\u03b1 s , \u03b1 t ) = \u03bb i if r (with i wildcards) matches (\u03b1 s , \u03b1 t ), otherwise\u03c6 r (\u03b1 s , \u03b1 t ) = 0.", "formula_coordinates": [4.0, 74.34, 199.22, 224.53, 59.76]}, {"formula_id": "formula_8", "formula_text": "K k ((s 1 ,t 1 ), (s 2 ,t 2 )) = \u2211 \u03b1s 1 \u2208 k-grams(s 1 ) \u03b1t 1 \u2208 k-grams(t 1 ) \u2211 \u03b1s 2 \u2208 k-grams(s 2 ) \u03b1t 2 \u2208 k-grams(t 2 )K k ((\u03b1 s 1 , \u03b1 t 1 ), (\u03b1 s 2 , \u03b1 t 2 ))(4)", "formula_coordinates": [4.0, 74.42, 279.5, 224.45, 55.94]}, {"formula_id": "formula_9", "formula_text": "k = \u2211 r\u2208R\u03c6 r (\u03b1 s 1 , \u03b1 t 1 )\u03c6 r (\u03b1 s 2 , \u03b1 t 2 ) (5)", "formula_coordinates": [4.0, 126.05, 356.87, 172.82, 19.8]}, {"formula_id": "formula_10", "formula_text": "\u03b1 1 \u2297 \u03b1 2 = ((\u03b1 1 [1], \u03b1 2 [1]), \u2022 \u2022 \u2022 , (\u03b1 1 [k], \u03b1 2 [k])).", "formula_coordinates": [4.0, 327.66, 274.62, 195.47, 10.7]}, {"formula_id": "formula_11", "formula_text": "R D = {r D = (\u03b2 D s , \u03b2 D t , \u03c4)|\u03b2 D s , \u03b2 D t \u2208 (I \u222a {?}) k", "formula_coordinates": [4.0, 333.54, 404.56, 193.67, 13.39]}, {"formula_id": "formula_12", "formula_text": "D s , \u03b1 D t ) iff. \u03b2 D s , \u03b2 D t can be changed into \u03b1 D s", "formula_coordinates": [4.0, 345.13, 458.36, 192.03, 13.25]}, {"formula_id": "formula_13", "formula_text": "s 1 \u2297 \u03b1 s 2 , \u03b1 t 1 \u2297 \u03b1 t 2 ).", "formula_coordinates": [5.0, 105.45, 346.62, 80.22, 11.52]}, {"formula_id": "formula_14", "formula_text": "k = \u2211 r D \u2208R D\u03c6 r D (\u03b1 s 1 \u2297 \u03b1 s 2 , \u03b1 t 1 \u2297 \u03b1 t 2 ) (6", "formula_coordinates": [5.0, 118.48, 437.76, 176.19, 20.81]}, {"formula_id": "formula_15", "formula_text": ")", "formula_coordinates": [5.0, 294.67, 438.1, 4.2, 9.36]}, {"formula_id": "formula_16", "formula_text": "where\u03c6 r D (\u03b1 D s , \u03b1 D t ) = \u03bb 2i", "formula_coordinates": [5.0, 74.34, 468.19, 113.7, 13.39]}, {"formula_id": "formula_17", "formula_text": "Algorithm 1: ComputingK k Input: k-gram pair (\u03b1 s 1 , \u03b1 t 1 ) and (\u03b1 s 2 , \u03b1 t 2 ) Output:K k ((\u03b1 s 1 , \u03b1 t 1 ), (\u03b1 s 2 , \u03b1 t 2 )) 1 Set (\u03b1 D s , \u03b1 D t ) = (\u03b1 s 1 \u2297 \u03b1 s 2 , \u03b1 t 1 \u2297 \u03b1 t 2 ) ; 2 Compute # \u03a3\u00d7\u03a3 (\u03b1 D s ) and # \u03a3\u00d7\u03a3 (\u03b1 D t ); 3 result=1; 4 for each e \u2208 \u03a3 \u00d7 \u03a3 satisfies # e (\u03b1 D s ) + # e (\u03b1 D t ) = 0 do 5 g e = 0, n e = min{# e (\u03b1 D s ), # e (\u03b1 D t )} ; 6 for 0 \u2264 i \u2264 n", "formula_coordinates": [5.0, 314.58, 71.02, 193.79, 132.27]}, {"formula_id": "formula_18", "formula_text": "k = g(# \u03a3\u00d7\u03a3 (\u03b1 s 1 \u2297 \u03b1 s 2 ), # \u03a3\u00d7\u03a3 (\u03b1 t 1 \u2297 \u03b1 t 2 ))(7)", "formula_coordinates": [5.0, 337.63, 443.84, 200.03, 11.52]}, {"formula_id": "formula_19", "formula_text": "(e) i = # e (\u03b1 D s ) i # e (\u03b1 D t ) i i!.", "formula_coordinates": [5.0, 401.59, 653.35, 99.57, 16.76]}, {"formula_id": "formula_20", "formula_text": "(e) i for 0 \u2264 i \u2264 min{# e (\u03b1 D s ), # e (\u03b1 D t )}, because a (e) i = 0 for the rest of i.", "formula_coordinates": [6.0, 74.34, 212.74, 224.53, 31.55]}, {"formula_id": "formula_21", "formula_text": "g(# \u03a3\u00d7\u03a3 (\u03b1 D s ), # \u03a3\u00d7\u03a3 (\u03b1 D t )) = \u220f e\u2208\u03a3\u00d7\u03a3 ( n e \u2211 i=0 a (e) i \u03bb 2i ) (8)", "formula_coordinates": [6.0, 82.73, 277.68, 216.14, 29.69]}, {"formula_id": "formula_22", "formula_text": "K k ((\u03b1 s 1 , \u03b1 t 1 ), (\u03b1 s 2 , \u03b1 t 2 )) = 0 if # N (\u03b1 s 1 \u2297 \u03b1 s 2 ) = # N (\u03b1 t 1 \u2297 \u03b1 t 2 )", "formula_coordinates": [6.0, 74.34, 568.86, 224.54, 24.93]}, {"formula_id": "formula_23", "formula_text": "K k ((\u03b1 s 1 , \u03b1 t 1 ), (\u03b1 s 2 , \u03b1 t 2 )) =K k ((\u03b1 s 1 , \u03b1 t 1 ), (\u03b1 s 2 , \u03b1 t 2 )) if # \u03a3\u00d7\u03a3 (\u03b1 s 1 \u2297\u03b1 s 2 ) = # \u03a3\u00d7\u03a3 (\u03b1 s 1 \u2297\u03b1 s 2 ) and # \u03a3\u00d7\u03a3 (\u03b1 t 1 \u2297 \u03b1 t 2 ) = # \u03a3\u00d7\u03a3 (\u03b1 t 1 \u2297 \u03b1 t 2 ), where \u03b1 s 1 , \u03b1 s 2 , \u03b1 t 1 , \u03b1 t 2 are", "formula_coordinates": [6.0, 74.34, 658.78, 224.54, 51.84]}, {"formula_id": "formula_24", "formula_text": "2 for each k-gram \u03b1 s 1 in s 1 do 3 for each k-gram \u03b1 s 2 in s 2 do 4 Update m s with key-value pair (# N (\u03b1 s 1 \u2297 \u03b1 s 2 ), # \u03a3\u00d7\u03a3 (\u03b1 s 1 \u2297 \u03b1 s 2 )); 5 c s [# \u03a3\u00d7\u03a3 (\u03b1 s 1 \u2297 \u03b1 s 2 )] + + ; 6 for each k-gram \u03b1 t 1 in t 1 do 7 for each k-gram \u03b1 t 2 in t 2 do 8 Update m t with key-value pair (# N (\u03b1 t 1 \u2297 \u03b1 t 2 ), # \u03a3\u00d7\u03a3 (\u03b1 t 1 \u2297 \u03b1 t 2 )); 9 c t [# \u03a3\u00d7\u03a3 (\u03b1 t 1 \u2297 \u03b1 t 2 )] + + ; 10 for each key \u2208 m s .keys \u2229 m t .keys do 11 for each v s \u2208 m s [key] do 12 for each v t \u2208 m t [key] do 13 result+= c s [v s ]c t [v t ]g(v s , v t ) ;", "formula_coordinates": [6.0, 310.64, 151.85, 189.87, 201.43]}, {"formula_id": "formula_25", "formula_text": "than # e (\u03b1 D s ) + # e (\u03b1 D t ) + 1 for each e satisfying # e (\u03b1 D s ) = 0 or # e (\u03b1 D t ) = 0 . Since \u2211 e\u2208\u03a3\u00d7\u03a3 # e (\u03b1 D s ) = \u2211 e\u2208\u03a3\u00d7\u03a3 # e (\u03b1 D t ) = k,", "formula_coordinates": [6.0, 313.13, 574.85, 224.54, 40.07]}, {"formula_id": "formula_26", "formula_text": "# \u03a3\u00d7\u03a3 (\u03b1 s 1 \u2297 \u03b1 s 2 ) = # \u03a3\u00d7\u03a3 (\u03b1 s 1 \u2297 \u03b1 s 2 ) if # N (\u03b1 s 1 \u2297 \u03b1 s 2 ) = # N (\u03b1 s 1 \u2297 \u03b1 s 2 ). Theorem 1. C is O(n 3 ).", "formula_coordinates": [7.0, 74.34, 271.01, 224.54, 40.18]}, {"formula_id": "formula_27", "formula_text": "\u2211 key m s [key] = (n \u2212 k + 1) 2 , Theorem 1 is proved. It can be also proved that C is O(n 2 ) when k = 1.", "formula_coordinates": [7.0, 74.34, 343.84, 224.54, 24.8]}], "doi": ""}