{"title": "Breaking Out of Local Optima with Count Transforms and Model Recombination: A Study in Grammar Induction", "authors": "Valentin I Spitkovsky; Hiyan Alshawi; Daniel Jurafsky", "pub_date": "", "abstract": "Many statistical learning problems in NLP call for local model search methods. But accuracy tends to suffer with current techniques, which often explore either too narrowly or too broadly: hill-climbers can get stuck in local optima, whereas samplers may be inefficient. We propose to arrange individual local optimizers into organized networks. Our building blocks are operators of two types: (i) transform, which suggests new places to search, via non-random restarts from already-found local optima; and (ii) join, which merges candidate solutions to find better optima. Experiments on grammar induction show that pursuing different transforms (e.g., discarding parts of a learned model or ignoring portions of training data) results in improvements. Groups of locally-optimal solutions can be further perturbed jointly, by constructing mixtures. Using these tools, we designed several modular dependency grammar induction networks of increasing complexity. Our complete system achieves 48.6% accuracy (directed dependency macro-average over all 19 languages in the 2006/7 CoNLL data) -more than 5% higher than the previous state-of-the-art.", "sections": [{"heading": "Introduction", "text": "Statistical methods for grammar induction often boil down to solving non-convex optimization problems. Early work attempted to locally maximize the likelihood of a corpus, using EM to estimate probabilities of dependency arcs between word bigrams (Paskin 2001a;2001b). That parsing model has since been extended to make unsupervised learning more feasible (Klein and Manning, 2004;Headden et al., 2009;Spitkovsky et al., 2012b). But even the latest techniques can be quite error-prone and sensitive to initialization, because of approximate, local search.\nIn theory, global optima can be found by enumerating all parse forests that derive a corpus, though this is usually prohibitively expensive in practice. A preferable brute force approach is sampling, as in Markov-chain Monte Carlo (MCMC) and random restarts (Hu et al., 1994), which hit exact solutions eventually. Restarts can be giant steps in a parameter space that undo all previous work. At the other extreme, MCMC may cling to a neighborhood, rejecting most proposed moves that would escape a local attractor. Sampling methods thus take unbounded time to solve a problem (and can't certify optimality) but are useful for finding approximate solutions to grammar induction (Cohn et al., 2011;Mare\u010dek and\u017dabokrtsk\u00fd, 2011;Naseem and Barzilay, 2011).\nWe propose an alternative (deterministic) search heuristic that combines local optimization via EM with non-random restarts. Its new starting places are informed by previously found solutions, unlike conventional restarts, but may not resemble their predecessors, unlike typical MCMC moves. We show that one good way to construct such steps in a parameter space is by forgetting some aspects of a learned model. Another is by merging promising solutions, since even simple interpolation (Jelinek and Mercer, 1980) of local optima may be superior to all of the originals. Informed restarts can make it possible to explore a combinatorial search space more rapidly and thoroughly than with traditional methods alone.", "publication_ref": ["b53", "b54", "b35", "b18", "b71", "b24", "b50", "b26"], "figure_ref": [], "table_ref": []}, {"heading": "Abstract Operators", "text": "Let C be a collection of counts -the sufficient statistics from which a candidate solution to an optimization problem could be computed, e.g., by smoothing and normalizing to yield probabilities. The counts may be fractional and solutions could take the form of multinomial distributions. A local optimizer L will convert C into C * = L D (C) -an updated collection of counts, resulting in a probabilistic model that is no less (and hopefully more) consistent with a data set D than the original C:\n(1)\nL D C C *\nUnless C * is a global optimum, we should be able to make further improvements. But if L is idempotent (and ran to convergence) then L(L(C)) = L (C).\nGiven only C and L D , the single-node optimization network above would be the minimal search pattern worth considering. However, if we had another optimizer L \u2032 -or a fresh starting point C \u2032 -then more complicated networks could become useful.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Transforms (Unary)", "text": "New starts could be chosen by perturbing an existing solution, as in MCMC, or independently of previous results, as in random restarts. We focus on intermediate changes to C, without injecting randomness. All of our transforms involve selective forgetting or filtering. For example, if the probabilistic model that is being estimated decomposes into independent constituents (e.g., several multinomials) then a subset of them can be reset to uniform distributions, by discarding associated counts from C. In text classification, this could correspond to eliminating frequent or rare tokens from bags-of-words. We use circular shapes to represent such model ablation operators:\n(2)", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "C", "text": "An orthogonal approach might separate out various counts in C by their provenance. For instance, if D consisted of several heterogeneous data sources, then the counts from some of them could be ignored: a classifier might be estimated from just news text. We will use squares to represent data-set filtering:\n(3)", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "C", "text": "Finally, if C represents a mixture of possible interpretations over D -e.g., because it captures the output of a \"soft\" EM algorithm -contributions from less likely, noisier completions could also be suppressed (and their weights redistributed to the more likely ones), as in \"hard\" EM. Diamonds will represent plain (single) steps of Viterbi training:\n(4) C", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Joins (Binary)", "text": "Starting from different initializers, say C 1 and C 2 , it may be possible for L to arrive at distinct local optima,\nC * 1 = C * 2 .\nThe better of the two solutions, according to likelihood L D of D, could then be selected -as is standard practice when sampling.\nOur joining technique could do better than either\nC * 1 or C *\n2 , by entertaining also a third possibility, which combines the two candidates. We construct a mixture model by adding together all counts from\nC * 1 and C * 2 into C + = C * 1 + C * 2 .\nOriginal initializers C 1 , C 2 will, this way, have equal pull on the merged model, 1 regardless of nominal size (because C * 1 , C * 2 will have converged using a shared training set, D). We return the best of C * 1 , C * 2 and C * + = L(C + ). This approach may uncover more (and never returns less) likely solutions than choosing among C * 1 , C * 2 alone:\n(5)\nL D L D L D + arg MAX L D C 1 C * 1 = L(C 1 ) C 2 C * 2 = L(C 2 ) C * 1 + C * 2 = C +\nWe will use a short-hand notation to represent the combiner network diagrammed above, less clutter:\nL D C 2 C 1(6)", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "The Task and Methodology", "text": "We apply transform and join paradigms to grammar induction, an important problem of computational linguistics that involves notoriously difficult objectives (Pereira and Schabes, 1992;de Marcken, 1995;Gimpel and Smith, 2012, inter alia). The goal is to induce grammars capable of parsing unseen text. Input, in both training and testing, is a sequence of tokens labeled as: (i) a lexical item and its category, (w, c w ); (ii) a punctuation mark; or (iii) a sentence boundary. Output is unlabeled dependency trees.", "publication_ref": ["b55", "b3"], "figure_ref": [], "table_ref": []}, {"heading": "Models and Data", "text": "We constrain all parse structures to be projective, via dependency-and-boundary grammars (Spitkovsky et al., 2012a;2012b): DBMs 0-3 are head-outward generative parsing models (Alshawi, 1996) that distinguish complete sentences from incomplete fragments in a corpus D: D comp comprises inputs ending with punctuation; D frag = D \u2212 D comp is everything else. The \"complete\" subset is further partitioned into simple sentences, D simp \u2286 D comp , with no internal punctuation, and others, which may be complex.\nAs an example, consider the beginning of an article from (simple) Wikipedia: (i) Linguistics (ii) Linguistics (sometimes called philology) is the science that studies language. (iii) Scientists who study language are called linguists. Since the title does not end with punctuation, it would be relegated to D frag . But two complete sentences would be in D comp , with the last also filed under D simp , as it has only a trailing punctuation mark. Spitkovsky et al. suggested two curriculum learning strategies: (i) one in which induction begins with clean, simple data, D simp , and a basic model, DBM-1 (2012b); and (ii) an alternative bootstrapping approach: starting with still more, simpler data -namely, short inter-punctuation fragments up to length l = 15, D l split \u2287 D l simp -and a bare-bones model, DBM-0 (2012a). In our example, D split would hold five text snippets: (i) Linguistics; (ii) Linguistics; (iii) sometimes called philology; (iv) is the science that studies language; and (v) Scientists who study language are called linguists. Only the last piece of text would still be considered complete, isolating its contribution to sentence root and boundary word distributions from those of incomplete fragments. The sparse model, DBM-0, assumes a uniform distribution for roots of incomplete inputs and reduces conditioning contexts of stopping probabilities, which works well with split data. We will exploit both DBM-0 and the full DBM, 2 drawing also on split, simple and raw views of input text.\nAll experiments prior to final multi-lingual evaluation will use the Penn English Treebank's Wall Street Journal (WSJ) portion (Marcus et al., 1993) as the underlying tokenized and sentence-broken corpus D. Instead of gold parts-of-speech, we plugged in 200 context-sensitive unsupervised tags, from Spitkovsky et al. (2011c), 3 for the word categories.", "publication_ref": ["b70", "b71", "b41", "b69"], "figure_ref": [], "table_ref": []}, {"heading": "Smoothing and Lexicalization", "text": "All unlexicalized instances of DBMs will be estimated with \"add one\" (a.k.a. Laplace) smoothing, using only the word category c w to represent a token. Fully-lexicalized grammars (L-DBM) are left unsmoothed, and represent each token as both a word and its category, i.e., the whole pair (w, c w ). To evaluate a lexicalized parsing model, we will always obtain a delexicalized-and-smoothed instance first.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Optimization and Viterbi Decoding", "text": "We use \"early-switching lateen\" EM (Spitkovsky et al., 2011a, \u00a72.4) to train unlexicalized models, alternating between the objectives of ordinary (soft) and hard EM algorithms, until neither can improve its own objective without harming the other's. This approach does not require tuning termination thresholds, allowing optimizers to run to numerical convergence if necessary, and handles only our shorter inputs (l \u2264 15), starting with soft EM (L = SL, for \"soft lateen\"). Lexicalized models will cover full data (l \u2264 45) and employ \"early-stopping lateen\" EM (2011a, \u00a72.3), re-estimating via hard EM until soft EM's objective suffers. Alternating EMs would be expensive here, since updates take (at least) O(l 3 ) time, and hard EM's objective (L = H) is the one better suited to long inputs (Spitkovsky et al., 2010).\nOur decoders always force an inter-punctuation fragment to derive itself (Spitkovsky et al., 2011b, \u00a72.2). 4 In evaluation, such (loose) constraints may help attach sometimes and philology to called (and the science... to is). In training, stronger (strict) constraints also disallow attachment of fragments' heads by non-heads, to connect Linguistics, called and is (assuming each piece got parsed correctly).", "publication_ref": ["b66"], "figure_ref": [], "table_ref": []}, {"heading": "Final Evaluation and Metrics", "text": "Evaluation is against held-out CoNLL shared task data (Buchholz and Marsi, 2006;Nivre et al., 2007), spanning 19 languages. We compute performance as directed dependency accuracies (DDA), fractions of correct unlabeled arcs in parsed output (an extrinsic metric). 5 For most WSJ experiments we include also sentence and parse tree cross-entropies (soft and hard EMs' intrinsic metrics), in bits per token (bpt).\n4 But these constraints do not impact training with shorter inputs, since there is no internal punctuation in D split or D simp . 5 We converted gold labeled constituents in WSJ to unlabeled reference dependencies using deterministic \"head-percolation\" rules (Collins, 1999); sentence root symbols, though not punctuation arcs, contribute to scores, as is standard (Paskin, 2001b).", "publication_ref": ["b52", "b0", "b54"], "figure_ref": [], "table_ref": []}, {"heading": "Concrete Operators", "text": "We will now instantiate the operators sketched out in \u00a72 specifically for the grammar induction task.\nThroughout, we repeatedly employ single steps of Viterbi training to transfer information between subnetworks in a model-independent way: when a module's output is a set of (Viterbi) parse trees, it necessarily contains sufficient information required to estimate an arbitrarily-factored model down-stream. 6", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Transform #1: A Simple Filter", "text": "Given a model that was estimated from (and therefore parses) a data set D, the simple filter (F ) attempts to extract a cleaner model, based on the simpler complete sentences of D simp . It is implemented as a single (unlexicalized) step of Viterbi training:\n(7) C F\nThe idea here is to focus on sentences that are not too complicated yet grammatical. This punctuationsensitive heuristic may steer a learner towards easy but representative training text and, we showed, aids grammar induction (Spitkovsky et al., 2012b, \u00a77.1).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Transform #2: A Symmetrizer", "text": "The symmetrizer (S) reduces input models to sets of word association scores. It blurs all details of induced parses in a data set D, except the number of times each (ordered) word pair participates in a dependency relation. We implemented symmetrization also as a single unlexicalized Viterbi training step, but now with proposed parse trees' scores, for a sentence in D, proportional to a product over non-root dependency arcs of one plus how often the left and right tokens (are expected to) appear connected:\n(8) C S\nThe idea behind the symmetrizer is to glean information from skeleton parses. Grammar inducers can sometimes make good progress in resolving undirected parse structures despite being wrong about the polarities of most arcs (Spitkovsky et al., 2009, Figure 3: Uninformed). Symmetrization offers an extra chance to make heads or tails of syntactic relations, after learning which words tend to go together.\nAt each instance where a word a attaches z on (say) the right, our implementation attributes half its weight to the intended construction, a z , reserving the other half for the symmetric structure, z attaching a to its left: a z . For the desired effect, these aggregated counts are left unnormalized, while all other counts (of word fertilities and sentence roots) get discarded. To see why we don't turn word attachment scores into probabilities, consider sentences a z and c z . The fact that z co-occurs with a introduces an asymmetry into z 's relation with c : P( z | c ) = 1 differs from P( c | z ) = 1/2. Normalizing might force the interpretation c z (and also a z ), not because there is evidence in the data, but as a side-effect of a model's head-driven nature (i.e., factored with dependents conditioned on heads). Always branching right would be a mistake, however, for example if z is a noun, since either of a or c could be a determiner, with the other a verb.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Join: A Combiner", "text": "The combiner must admit arbitrary inputs, including models not estimated from D, unlike the transforms. Consequently, as a preliminary step, we convert each input C i into parse trees of D, with counts C \u2032 i , via Viterbi-decoding with a smoothed, unlexicalized version of the corresponding incoming model. Actual combination is then performed in a more precise (unsmoothed) fashion: C * i are the (lexicalized) solutions starting from C \u2032 i ; and C * + is initialized with their sum, i C * i . Counts of the lexicalized model with lowest cross-entropy on D become the output:\n7 (9) L D C 2 C 1", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Basic Networks", "text": "We are ready to propose a non-trivial subnetwork for grammar induction, based on the transform and join operators, which we will reuse in larger networks.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Fork/Join (FJ)", "text": "Given a model that parses a base data set D 0 , the fork/join subnetwork will output an adaptation of that model for D. It could facilitate a grammar induction process, e.g., by advancing it from smaller to larger -or possibly more complex -data sets.\nWe first fork off two variations of the incoming model based on D 0 : (i) a filtered view, which focuses on cleaner, simpler data (transform #1); and (ii) a symmetrized view that backs off to word associations (transform #2). Next is grammar induction over D. We optimize a full DBM instance starting from the first fork, and bootstrap a reduced DBM 0 from the second. Finally, the two new induced sets of parse trees, for D, are merged (lexicalized join):\n(10)\nH L\u2022DBM D SL DBM D SL DBM0 D C F S D0 C 1 C 2 C \u2032 1 C \u2032 2\nThe idea here is to prepare for two scenarios: an incoming grammar that is either good or bad for D. If the model is good, DBM should be able to hang on to it and make improvements. But if it is bad, DBM could get stuck fitting noise, whereas DBM 0 might be more likely to ramp up to a good alternative. Since we can't know ahead of time which is the true case, we pursue both optimization paths simultaneously and let a combiner later decide for us.\nNote that the forks start (and end) optimizing with soft EM. This is because soft EM integrates previously unseen tokens into new grammars better than hard EM, as evidenced by our failed attempt to reproduce the \"baby steps\" strategy with Viterbi training (Spitkovsky et al., 2010, Figure 4). A combiner then executes hard EM, and since outputs of transforms are trees, the end-to-end process is a chain of lateen alternations that starts and ends with hard EM.\nWe will use a \"grammar inductor\" to represent subnetworks that transition from D l split to D l+1 split , by taking transformed parse trees of inter-punctuation fragments up to length l (base data set, D 0 ) to initialize training over fragments up to length l + 1:\n(11) C l+1\nThe FJ network instantiates a grammar inductor with l = 14, thus training on inter-punctuation fragments up to length 15, as in previous work, starting from an empty set of counts, C = \u2205. Smoothing causes initial parse trees to be chosen uniformly at random, as suggested by Cohen and Smith (2010):\n(12) \u2205 15", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Iterated Fork/Join (IFJ)", "text": "Our second network daisy-chains grammar inductors, starting from the single-word inter-punctuation fragments in D 1 split , then retraining on D 2 split , and so forth, until finally stopping at D 15 split , as before:\n(13) 1 2 14 15\nWe diagrammed this system as not taking an input, since the first inductor's output is fully determined by unique parse trees of single-token strings. This iterative approach to optimization is akin to deterministic annealing (Rose, 1998), and is patterned after \"baby steps\" (Spitkovsky et al., 2009, \u00a74.2).\nUnlike the basic FJ, where symmetrization was a no-op (since there were no counts in C = \u2205), IFJ makes use of symmetrizers -e.g., in the third inductor, whose input is based on strings with up to two tokens. Although it should be easy to learn words that go together from very short fragments, extracting correct polarities of their relations could be a challenge: to a large extent, outputs of early inductors may be artifacts of how our generative models factor (see \u00a74.2) or how ties are broken in optimization (Spitkovsky et al., 2012a, Appendix B). We therefore expect symmetrization to be crucial in earlier stages but to weaken any high quality grammars, nearer the end; it will be up to combiners to handle such phase transitions correctly (or gracefully).", "publication_ref": ["b60"], "figure_ref": [], "table_ref": []}, {"heading": "Grounded Iterated Fork/Join (GIFJ)", "text": "So far, our networks have been either purely iterative (IFJ) or static (FJ). These two approaches can also be combined, by injecting FJ's solutions into IFJ's more dynamic stream. Our new transition subnetwork will join outputs of grammar inductors that either (i) continue a previous solution (as in IFJ); or (ii) start over from scratch (\"grounding\" to an FJ):\n(14) H L\u2022DBM D l+1 split \u2205 C l C l+1 l+1 l+1\nThe full GIFJ network can then be obtained by unrolling the above template from l = 14 back to one.  ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Performance of Basic Networks", "text": "We compared our three networks' performance on their final training sets, WSJ 15 split (see Table 1, which also tabulates results for a cleaner subset, WSJ 15 simp ). The first network starts from C = \u2205, helping us establish several straw-man baselines. Its empty initializer corresponds to guessing (projective) parse trees uniformly at random, which has 21.4% accuracy and sentence string cross-entropy of 8.76bpt.", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_1"]}, {"heading": "Fork/Join (FJ)", "text": "FJ's symmetrizer yields random parses of WSJ 14 split , which initialize training of DBM 0 . This baseline (B) lowers cross-entropy to 6.18bpt and scores 57.0%. FJ's filter starts from parse trees of WSJ 14 simp only, and trains up a full DBM. This choice makes a stronger baseline (A), with 5.89bpt cross-entropy, at 62.2%.\nThe join operator uses counts from A and B, C 1 and C 2 , to obtain parse trees whose own counts C \u2032 1 and C \u2032 2 initialize lexicalized training. From each C \u2032 i , an optimizer arrives at C * i . Grammars corresponding to these counts have higher cross-entropies, because of vastly larger vocabularies, but also better accuracies: 59.2 and 62.3%. Their mixture C + is a simple sum of counts in C * 1 and C * 2 : it is not expected to be an improvement but happens to be a good move, resulting in a grammar with higher accuracy (64.0%), though not better Viterbi cross-entropy (7.27 falls between 7.08 and 7.30bpt) than both sources. The combiner's third alternative, a locally optimal C * + , is then obtained by re-optimizing from C + . This solution performs slightly better (64.2%) and will be the local optimum returned by FJ's join operator, because it attains the lowest cross-entropy (7.04bpt).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Iterated Fork/Join (IFJ)", "text": "IFJ's iterative approach results in an improvement: 70.5% accuracy and 6.96bpt cross-entropy. To test how much of this performance could be obtained by a simpler iterated network, we experimented with ablated systems that don't fork or join, i.e., our classic \"baby steps\" schema (chaining together 15 optimizers), using both DBM and DBM 0 , with and without a transform in-between. However, all such \"linear\" networks scored well below 50%. We conclude from these results that an ability to branch out into different promising regions of a solution space, and to merge solutions of varying quality into better models, are important properties of FJ subnetworks.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Grounded Iterated Fork/Join (GIFJ)", "text": "Grounding improves GIFJ's performance further, to 71.4% accuracy and 6.92bpt cross-entropy. This result shows that fresh perspectives from optimizers that start over can make search efforts more fruitful.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Enhanced Subnetworks", "text": "Modularity and abstraction allow for compact representations of complex systems. Another key benefit is that individual components can be understood and improved in isolation, as we will demonstrate next.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "An Iterative Combiner (IC)", "text": "Our basic combiner introduced a third option, C * + , into a pool of candidate solutions, {C * 1 , C * 2 }. This new entry may not be a simple mixture of the originals, because of non-linear effects from applying L to C * 1 + C * 2 , but could most likely still be improved. Rather than stop at C * + , when it is better than both originals, we could recombine it with a next best solution, continuing until no further improvement is made. Iterating can't harm a given combiner's crossentropy (e.g., it lowers FJ's from 7.04 to 7.00bpt), and its advantages can be realized more fully in the larger networks (albeit without any end-to-end guarantees): upgrading all 15 combiners in IFJ would improve performance (slightly) more than grounding (71.5 vs. 71.4%), and lower cross-entropy (from 6.96 to 6.93bpt). But this approach is still a bit timid.\nA more greedy way is to proceed so long as C * + is not worse than both predecessors. We shall now state our most general iterative combiner (IC) algorithm: Start with a solution pool\np = {C * i } n i=1 . Next, construct p \u2032 by adding C * + = L( n i=1 C * i )\nto p and removing the worst of n + 1 candidates in the new set. Finally, if p = p \u2032 , return the best of the solutions in p; otherwise, repeat from p := p \u2032 . At n = 2, one could think of taking L(C * 1 + C * 2 ) as performing a kind of bisection search in some (strange) space. With these new and improved combiners, the IFJ network performs better: 71.9% (up from 70.5 -see Table 1), lowering cross-entropy (down from 6.96 to 6.93bpt). We propose a distinguished notation for the ICs:\n(15) * C 2 C 1", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_1"]}, {"heading": "A Grammar Transformer (GT)", "text": "The levels of our systems' performance at grammar induction thus far suggest that the space of possible networks (say, with up to k components) may itself be worth exploring more thoroughly. We leave this exercise to future work, ending with two relatively straight-forward extensions for grounded systems.\nOur static bootstrapping mechanism (\"ground\" of GIFJ) can be improved by pretraining with simple sentences first -as in the curriculum for learning DBM-1 (Spitkovsky et al., 2012b, \u00a77.1), but now with a variable length cut-off l (much lower than the original 45) -instead of starting from \u2205 directly:\n(16) S DBM D l simp \u2205 l+1 \uf8fc \uf8fd \uf8fe l\nThe output of this subnetwork can then be refined, by reconciling it with a previous dynamic solution. We perform a mini-join of a new ground's counts with C l , using the filter transform (single steps of lexicalized Viterbi training on clean, simple data), ahead of the main join (over more training data):\n(17) H L\u2022DBM D l+1 split C l C l+1 l+1 F l\nThis template can be unrolled, as before, to obtain our last network (GT), which achieves 72.9% accuracy and 6.83bpt cross-entropy (slightly less accurate with basic combiners, at 72.3% -see Table 1).", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_1"]}, {"heading": "Full Training and System Combination", "text": "All systems that we described so far stop training at\nD 15\nsplit . We will use a two-stage adaptor network to transition their grammars to a full data set, D 45 :\n(18) H L\u2022DBM D 45 split H L\u2022DBM D 45 C\nThe first stage exposes grammar inducers to longer inputs (inter-punctuation fragments with up to 45 tokens); the second stage, at last, reassembles text snippets into actual sentences (also up to l = 45). 8 After full training, our IFJ and GT systems parse Section 23 of WSJ at 62.7 and 63.4% accuracy, better than the previous state-of-the-art (61.2% -see Table 2). To test the generalized IC algorithm, we merged our implementations of these three strong grammar induction pipelines into a combined system (CS). It scored highest: 64.4%.\n(19) H L\u2022DBM D 45 (GT) #1 (IFJ) #2 #3", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_3"]}, {"heading": "CS", "text": "The quality of bracketings corresponding to (nontrivial) spans derived by heads of our dependency structures is competitive with the state-of-the-art in unsupervised constituent parsing. On the WSJ sentences up to length 40 in Section 23, CS attains similar F 1 -measure (54.2 vs. 54.6, with higher recall) to System DDA (@10) (Gimpel and Smith, 2012) 53.1 (64.3) (Gillenwater et al., 2010) 53.3 (64.3) (Bisk and Hockenmaier, 2012) 53.3 (71.5) (Blunsom and Cohn, 2010) 55.7 (67.7) (Tu and Honavar, 2012) 57.0 (71.4) (Spitkovsky et al., 2011b) 58.4 (71.4) (Spitkovsky et al., 2011c) 59.1 (71.4)  PRLG (Ponvert et al., 2011), which is the strongest system of which we are aware (see Table 3). 9", "publication_ref": ["b12", "b11", "b76", "b68", "b69", "b57"], "figure_ref": [], "table_ref": ["tab_5"]}, {"heading": "Multi-Lingual Evaluation", "text": "Last, we checked how our algorithms generalize outside English WSJ, by testing in 23 more set-ups: all 2006/7 CoNLL test sets (Buchholz and Marsi, 2006;Nivre et al., 2007), spanning 19 languages. Most recent work evaluates against this multi-lingual data, with the unrealistic assumption of part-of-speech tags. But since inducing high quality word clusters for many languages would be beyond the scope of our paper, here we too plugged in gold tags for word categories (instead of unsupervised tags, as in \u00a73-8).\nWe compared to the two strongest systems we knew: 10 MZ (Mare\u010dek and\u017dabokrtsk\u00fd, 2012) and SAJ (Spitkovsky et al., 2012b), which report average accuracies of 40.0 and 42.9% for CoNLL data (see Table 4). Our fully-trained IFJ and GT systems score 40.0 and 47.6%. As before, combining these networks with our own implementation of the best previous state-of-the-art system (SAJ) yields a further improvement, increasing final accuracy to 48.6%. 9 These numbers differ from Ponvert et al.'s (2011, Table 6) for the full Section 23 because we restricted their eval-ps.py script to a maximum length of 40 words, in our evaluation, to match other previous work: Golland et al.'s (2012, Figure 1) for CCM and LLCCM; Huang et al.'s (2012, Table 2) for the rest.\n10 During review, another strong system (Mare\u010dek and Straka, 2013, scoring 48.7%) of possible interest to the reader came out, exploiting prior knowledge of stopping probabilities (estimated from large POS-tagged corpora, via reducibility principles).", "publication_ref": ["b52", "b71"], "figure_ref": [], "table_ref": ["tab_7"]}, {"heading": "System", "text": "F1 Binary-Branching Upper Bound 85.7 Left-Branching Baseline 12.0 CCM (Klein and Manning, 2002) 33.7 Right-Branching Baseline 40.7 F-CCM (Huang et al., 2012) 45.1 HMM (Ponvert et al., 2011) 46.3 LLCCM (Golland et al., 2012) ", "publication_ref": ["b34", "b25", "b57", "b16"], "figure_ref": [], "table_ref": []}, {"heading": "Discussion", "text": "CoNLL training sets were intended for comparing supervised systems, and aren't all suitable for unsupervised learning: 12 languages have under 10,000 sentences (with Arabic, Basque, Danish, Greek, Italian, Slovenian, Spanish and Turkish particularly small), compared to WSJ's nearly 50,000. In some treebanks sentences are very short (e.g., Chinese and Japanese, which appear to have been split on punctuation), and in others extremely long (e.g., Arabic). Even gold tags aren't always helpful, as their number is rarely ideal for grammar induction (e.g., 42 vs. 200 for English). These factors contribute to high variances of our (and previous) results (see Table 4). Nevertheless, if we look at the more stable average accuracies, we see a positive trend as we move from a simpler fully-trained system (IFJ, 40.0%), to a more complex system (GT, 47.6%), to system combination (CS, 48.6%). Grounding seems to be more important for the CoNLL sets, possibly because of data sparsity or availability of gold tags.", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_7"]}, {"heading": "Related Work", "text": "The surest way to avoid local optima is to craft an objective that doesn't have them. For example, Wang et al. (2008) demonstrated a convex training method for semi-supervised dependency parsing; Lashkari and Golland (2008) introduced a convex reformulation of likelihood functions for clustering tasks; and Corlett and Penn (2010)   a search algorithm for encoding decipherment problems that guarantees to quickly converge on optimal solutions. Convexity can be ideal for comparative analyses, by eliminating dependence on initial conditions. But for many NLP tasks, including grammar induction, the most relevant known objective functions are still riddled with local optima. Renewed efforts to find exact solutions (Eisner, 2012;Gormley and Eisner, 2013) may be a good fit for the smaller and simpler, earlier stages of our iterative networks. Multi-start methods (Solis and Wets, 1981) can recover certain global extrema almost surely (i.e., with probability approaching one). Moreover, random restarts via uniform probability measures can be optimal, in a worst-case-analysis sense, with parallel processing sometimes leading to exponential speed-ups (Hu et al., 1994). This approach is rarely emphasized in NLP literature. For instance, Moore and Quirk (2008) demonstrated consistent, substantial gains from random restarts in statistical machine translation (but also suggested better and faster replacements -see below); Ravi and Knight (2009, \u00a75, Figure 8) found random restarts for EM to be crucial in parts-of-speech disambiguation. However, other reviews are few and generally negative (Kim and Mooney, 2010;Martin-Brualla et al., 2010). Iterated local search methods (Hoos and St\u00fctzle, 2004;Johnson et al., 1988, inter alia) escape local basins of attraction by perturbing candidate solutions, without undoing all previous work. \"Largestep\" moves can come from jittering (Hinton and Roweis, 2003), dithering (Price et al., 2005, Ch. 2) or smoothing (Bhargava and Kondrak, 2009). Nonimproving \"sideways\" moves offer substantial help with hard satisfiability problems (Selman et al., 1992); and injecting non-random noise (Selman et al., 1994), by introducing \"uphill\" moves via mixtures of random walks and greedy search strategies, does better than random noise alone or simulated annealing (Kirkpatrick et al., 1983). In NLP, Moore and Quirk's (2008) random walks from previous local optima were faster than uniform sampling and also increased BLEU scores; Elsner and Schudy (2009) showed that local search can outperform greedy solutions for document clustering and chat disentanglement tasks; and Mei et al. (2001) incorporated tabu search (Glover, 1989;Glover and Laguna, 1993, Ch. 3) into HMM training for ASR.\nGenetic algorithms are a fusion of what's best in local search and multi-start methods (Houck et al., 1996), exploiting a problem's structure to combine valid parts of any partial solutions (Holland, 1975;Goldberg, 1989). Evolutionary heuristics proved useful in the induction of phonotactics (Belz, 1998), text planning (Mellish et al., 1998), factored modeling of morphologically-rich languages (Duh and Kirchhoff, 2004) and plot induction for story generation (McIntyre and Lapata, 2010). Multi-objective genetic algorithms (Fonseca and Fleming, 1993) can handle problems with equally important but conflicting criteria (Stadler, 1988), using Pareto-optimal ensembles. They are especially well-suited to language, which evolves under pressures from competing (e.g., speaker, listener and learner) constraints, and have been used to model configurations of vowels and tone systems (Ke et al., 2003). Our transform and join mechanisms also exhibit some features of genetic search, and make use of competing objec-tives: good sets of parse trees must make sense both lexicalized and with word categories, to rich and impoverished models of grammar, and for both long, complex sentences and short, simple text fragments.\nThis selection of text filters is a specialized case of more general \"data perturbation\" techniqueseven cycling over randomly chosen mini-batches that partition a data set helps avoid some local optima (Liang and Klein, 2009). Elidan et al. (2002) suggested how example-reweighing could cause \"informed\" changes, rather than arbitrary damage, to a hypothesis. Their (adversarial) training scheme guided learning toward improved generalizations, robust against input fluctuations. Language learning has a rich history of reweighing data via (cooperative) \"starting small\" strategies (Elman, 1993), beginning from simpler or more certain cases. This family of techniques has met with success in semisupervised named entity classification (Collins and Singer, 1999;Yarowsky, 1995), 11 parts-of-speech induction (Clark, 2000;, and language modeling (Krueger and Dayan, 2009;Bengio et al., 2009), in addition to unsupervised parsing (Spitkovsky et al., 2009;Tu and Honavar, 2011;Cohn et al., 2011).", "publication_ref": ["b79", "b38", "b1", "b5", "b17", "b64", "b24", "b49", "b59", "b32", "b45", "b22", "b27", "b19", "b62", "b63", "b33", "b49", "b8", "b47", "b14", "b23", "b21", "b15", "b48", "b4", "b46", "b9", "b72", "b31", "b39", "b6", "b7", "b81", "b37", "b65", "b75"], "figure_ref": [], "table_ref": []}, {"heading": "Conclusion", "text": "We proposed several simple algorithms for combining grammars and showed their usefulness in merging the outputs of iterative and static grammar induction systems. Unlike conventional system combination methods, e.g., in machine translation (Xiao et al., 2010), ours do not require incoming models to be of similar quality to make improvements. We exploited these properties of the combiners to reconcile grammars induced by different views of data (Blum and Mitchell, 1998). One such view retains just the simple sentences, making it easier to recognize root words. Another splits text into many inter-punctuation fragments, helping learn word associations. The induced dependency trees can themselves also be viewed not only as directed structures but also as skeleton parses, facilitating the recovery of correct polarities for unlabeled dependency arcs.\nBy reusing templates, as in dynamic Bayesian network (DBN) frameworks (Koller and Friedman,11 The so-called Yarowsky-cautious modification of the original algorithm for unsupervised word-sense disambiguation.\n2009, \u00a76.2.2), we managed to specify relatively \"deep\" learning architectures without sacrificing (too much) clarity or simplicity. On a still more speculative note, we see two (admittedly, tenuous) connections to human cognition. First, the benefits of not normalizing probabilities, when symmetrizing, might be related to human language processing through the base-rate fallacy (Bar-Hillel, 1980;Kahneman and Tversky, 1982) and the availability heuristic (Chapman, 1967;, since people are notoriously bad at probability (Attneave, 1953;Kahneman and Tversky, 1972;. And second, intermittent \"unlearning\" -though perhaps not of the kind that takes place inside of our transformsis an adaptation that can be essential to cognitive development in general, as evidenced by neuronal pruning in mammals (Craik and Bialystok, 2006;Low and Cheng, 2006). \"Forgetful EM\" strategies that reset subsets of parameters may thus, possibly, be no less relevant to unsupervised learning than is \"partial EM,\" which only suppresses updates, other EM variants (Neal and Hinton, 1999), or \"dropout training\" (Hinton et al., 2012;Wang and Manning, 2013), which is important in supervised settings.\nFuture parsing models, in grammar induction, may benefit by modeling head-dependent relations separately from direction. As frequently employed in tasks like semantic role labeling (Carreras and M\u00e0rquez, 2005) and relation extraction (Sun et al., 2011), it may be easier to first establish existence, before trying to understand its nature. Other key next steps may include exploring more intelligent ways of combining systems (Surdeanu and Manning, 2010;Petrov, 2010) and automating the operator discovery process. Furthermore, we are optimistic that both count transforms and model recombination could be usefully incorporated into sampling methods: although symmetrized models may have higher cross-entropies, hence prone to rejection in vanilla MCMC, they could work well as seeds in multi-chain designs; existing algorithms, such as MCMCMC (Geyer, 1991), which switch contents of adjacent chains running at different temperatures, may also benefit from introducing the option to combine solutions, in addition to just swapping them.", "publication_ref": ["b80", "b30", "b28", "b2", "b40", "b51", "b20", "b78", "b73", "b74", "b56", "b10"], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgments", "text": "We thank Yun-Hsuan Sung, for early-stage discussions on ways of extending \"baby steps,\" Elias Ponvert, for sharing all of the relevant experimental results and evaluation scripts from his work with Jason Baldridge and Katrin Erk, and the anonymous reviewers, for their helpful comments on the draft version of this paper. Funded, in part, by Defense Advanced Research Projects Agency (DARPA) Deep Exploration and Filtering of Text (DEFT) Program, under Air Force Research Laboratory (AFRL) prime contract no. FA8750-13-2-0040. Any opinions, findings, and conclusion or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of the DARPA, AFRL, or the US government. Once again, the first author thanks Moofus.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Head-Driven Statistical Models for Natural Language Parsing", "journal": "", "year": "1999", "authors": "M Collins"}, {"ref_id": "b1", "title": "An exact A * method for deciphering letter-substitution ciphers", "journal": "", "year": "2010", "authors": "E Corlett; G Penn"}, {"ref_id": "b2", "title": "Cognition through the lifespan: mechanisms of change", "journal": "TRENDS in Cognitive Sciences", "year": "2006", "authors": "F I M Craik; E Bialystok"}, {"ref_id": "b3", "title": "Lexical heads, phrase structure and the induction of grammar", "journal": "", "year": "1995", "authors": "C De Marcken"}, {"ref_id": "b4", "title": "Automatic learning of language model structure", "journal": "", "year": "2004", "authors": "K Duh; K Kirchhoff"}, {"ref_id": "b5", "title": "Grammar induction: Beyond local search", "journal": "", "year": "2012", "authors": "J Eisner"}, {"ref_id": "b6", "title": "Data perturbation for escaping local maxima in learning", "journal": "", "year": "2002", "authors": "G Elidan; M Ninio; N Friedman; D Schuurmans"}, {"ref_id": "b7", "title": "Learning and development in neural networks: The importance of starting small", "journal": "Cognition", "year": "1993", "authors": "J L Elman"}, {"ref_id": "b8", "title": "Bounding and comparing methods for correlation clustering beyond ILP", "journal": "", "year": "2009", "authors": "M Elsner; W Schudy"}, {"ref_id": "b9", "title": "Genetic algorithms for multiobjective optimization: Formulation, discussion and generalization", "journal": "", "year": "1993", "authors": "M Fonseca; P J Fleming"}, {"ref_id": "b10", "title": "Markov chain Monte Carlo maximum likelihood", "journal": "", "year": "1991", "authors": "C J Geyer"}, {"ref_id": "b11", "title": "Posterior sparsity in unsupervised dependency parsing", "journal": "", "year": "2010", "authors": "J Gillenwater; K Ganchev; J Gra\u00e7a; F Pereira; B Taskar"}, {"ref_id": "b12", "title": "Concavity and initialization for unsupervised dependency parsing", "journal": "", "year": "2012", "authors": "K Gimpel; N A Smith"}, {"ref_id": "b13", "title": "Tabu search", "journal": "Blackwell Scientific Publications", "year": "1993", "authors": "F Glover; M Laguna"}, {"ref_id": "b14", "title": "Tabu search -Part I", "journal": "ORSA Journal on Computing", "year": "1989", "authors": "F Glover"}, {"ref_id": "b15", "title": "Genetic Algorithms in Search, Optimization & Machine Learning", "journal": "Addison-Wesley", "year": "1989", "authors": "D E Goldberg"}, {"ref_id": "b16", "title": "A featurerich constituent context model for grammar induction", "journal": "", "year": "2012", "authors": "D Golland; J Denero; J Uszkoreit"}, {"ref_id": "b17", "title": "Nonconvex global optimization for latent-variable models", "journal": "", "year": "2013", "authors": "M R Gormley; J Eisner"}, {"ref_id": "b18", "title": "Improving unsupervised dependency parsing with richer contexts and smoothing", "journal": "", "year": "2009", "authors": "W P Headden; M Iii; D Johnson;  Mcclosky"}, {"ref_id": "b19", "title": "Stochastic neighbor embedding", "journal": "", "year": "2003", "authors": "G Hinton; S Roweis"}, {"ref_id": "b20", "title": "Improving neural networks by preventing co-adaptation of feature detectors", "journal": "", "year": "2012", "authors": "G E Hinton; N Srivastava; A Krizhevsky; I Sutskever; R R Salakhutdinov"}, {"ref_id": "b21", "title": "Adaptation in Natural and Artificial Systems: An Introductory Analysis with Applications to Biology, Control, and Artificial Intelligence", "journal": "University of Michigan Press", "year": "1975", "authors": "J H Holland"}, {"ref_id": "b22", "title": "Stochastic Local Search: Foundations and Applications", "journal": "Morgan Kaufmann", "year": "2004", "authors": "H H Hoos; T St\u00fctzle"}, {"ref_id": "b23", "title": "Comparison of genetic algorithms, random restart, and two-opt switching for solving large location-allocation problems", "journal": "Computers & Operations Research", "year": "1996", "authors": "C R Houck; J A Joines; M G Kay"}, {"ref_id": "b24", "title": "Random restarts in global optimization", "journal": "", "year": "1994", "authors": "R Hu; M C Shonkwiler;  Spruill"}, {"ref_id": "b25", "title": "Improved constituent context model with features", "journal": "", "year": "2012", "authors": "M Huang; C L Zhang;  Tan"}, {"ref_id": "b26", "title": "Interpolated estimation of Markov source parameters from sparse data", "journal": "", "year": "1980", "authors": "F Jelinek; R L Mercer"}, {"ref_id": "b27", "title": "How easy is local search?", "journal": "Journal of Computer and System Sciences", "year": "1988", "authors": "D S Johnson; C H Papadimitriou; M Yannakakis"}, {"ref_id": "b28", "title": "Subjective probability: A judgment of representativeness", "journal": "Cognitive Psychology", "year": "1972", "authors": "D Kahneman; A Tversky"}, {"ref_id": "b29", "title": "On the psychology of prediction", "journal": "Psychological Review", "year": "1973", "authors": "D Kahneman; A Tversky"}, {"ref_id": "b30", "title": "Evidential impact of base rates", "journal": "Cambridge University Press", "year": "1982", "authors": "D Kahneman; A Tversky"}, {"ref_id": "b31", "title": "Optimization models of sound systems using genetic algorithms", "journal": "Computational Linguistics", "year": "2003", "authors": "J Ke; M Ogura; W S ; -Y. Wang"}, {"ref_id": "b32", "title": "Generative alignment and semantic parsing for learning from ambiguous supervision", "journal": "", "year": "2010", "authors": "J Kim; R J Mooney"}, {"ref_id": "b33", "title": "Optimization by simulated annealing", "journal": "Science", "year": "1983", "authors": "S Kirkpatrick; C D Gelatt; Jr ; M P Vecchi"}, {"ref_id": "b34", "title": "A generative constituentcontext model for improved grammar induction", "journal": "", "year": "2002", "authors": "D Klein; C D Manning"}, {"ref_id": "b35", "title": "Corpus-based induction of syntactic structure: Models of dependency and constituency", "journal": "", "year": "2004", "authors": "D Klein; C D Manning"}, {"ref_id": "b36", "title": "Probabilistic Graphical Models: Principles and Techniques", "journal": "MIT Press", "year": "2009", "authors": "D Koller; N Friedman"}, {"ref_id": "b37", "title": "Flexible shaping: How learning in small steps helps", "journal": "Cognition", "year": "2009", "authors": "K A Krueger; P Dayan"}, {"ref_id": "b38", "title": "Convex clustering with exemplar-based models", "journal": "", "year": "2008", "authors": "D Lashkari; P Golland"}, {"ref_id": "b39", "title": "Online EM for unsupervised models", "journal": "", "year": "2009", "authors": "P Liang; D Klein"}, {"ref_id": "b40", "title": "Axon pruning: an essential step underlying the developmental plasticity of neuronal connections", "journal": "Royal Society of London Philosophical Transactions Series B", "year": "2006", "authors": "L K Low; H.-J Cheng"}, {"ref_id": "b41", "title": "Building a large annotated corpus of English: The Penn Treebank", "journal": "Computational Linguistics", "year": "1993", "authors": "M P Marcus; B Santorini; M A Marcinkiewicz"}, {"ref_id": "b42", "title": "Stop-probability estimates computed on a large corpus improve unsupervised dependency parsing", "journal": "", "year": "2013", "authors": "D Mare\u010dek; M Straka"}, {"ref_id": "b43", "title": "Gibbs sampling with treeness constraint in unsupervised dependency parsing", "journal": "", "year": "2011", "authors": "D Mare\u010dek; Z \u017dabokrtsk\u00fd"}, {"ref_id": "b44", "title": "Exploiting reducibility in unsupervised dependency parsing", "journal": "", "year": "2012", "authors": "D Mare\u010dek; Z \u017dabokrtsk\u00fd"}, {"ref_id": "b45", "title": "Instance sense induction from attribute sets", "journal": "", "year": "2010", "authors": "R Martin-Brualla; E Alfonseca; M Pasca; K Hall; E Robledo-Arnuncio; M Ciaramita"}, {"ref_id": "b46", "title": "Plot induction and evolutionary search for story generation", "journal": "", "year": "2010", "authors": "N Mcintyre; M Lapata"}, {"ref_id": "b47", "title": "Optimization of HMM by the tabu search algorithm", "journal": "", "year": "2001", "authors": "X Mei; S Sun; J Pan; T.-Y. Chen"}, {"ref_id": "b48", "title": "Experiments using stochastic search for text planning", "journal": "", "year": "1998", "authors": "C Mellish; A Knott; J Oberlander; M O'donnell"}, {"ref_id": "b49", "title": "Random restarts in minimum error rate training for statistical machine translation", "journal": "", "year": "2008", "authors": "R C Moore; C Quirk"}, {"ref_id": "b50", "title": "Using semantic cues to learn syntax", "journal": "", "year": "2011", "authors": "T Naseem; R Barzilay"}, {"ref_id": "b51", "title": "A view of the EM algorithm that justifies incremental, sparse, and other variants", "journal": "MIT Press", "year": "1999", "authors": "M Neal; G E Hinton"}, {"ref_id": "b52", "title": "The CoNLL 2007 shared task on dependency parsing", "journal": "", "year": "2007", "authors": "J Nivre; J Hall; S K\u00fcbler; R Mcdonald; J Nilsson; S Riedel; D Yuret"}, {"ref_id": "b53", "title": "Cubic-time parsing and learning algorithms for grammatical bigram models", "journal": "", "year": "2001", "authors": "M A Paskin"}, {"ref_id": "b54", "title": "Grammatical bigrams", "journal": "", "year": "2001", "authors": "M A Paskin"}, {"ref_id": "b55", "title": "Inside-outside reestimation from partially bracketed corpora", "journal": "", "year": "1992", "authors": "F Pereira; Y Schabes"}, {"ref_id": "b56", "title": "Products of random latent variable grammars", "journal": "", "year": "2010", "authors": "S Petrov"}, {"ref_id": "b57", "title": "Simple unsupervised grammar induction from raw text with cascaded finite state models", "journal": "", "year": "2011", "authors": "E Ponvert; J Baldridge; K Erk"}, {"ref_id": "b58", "title": "Differential Evolution: A Practical Approach to Global Optimization", "journal": "Springer", "year": "2005", "authors": "K V Price; R M Storn; J A Lampinen"}, {"ref_id": "b59", "title": "Minimized models for unsupervised part-of-speech tagging", "journal": "", "year": "2009", "authors": "S Ravi; K Knight"}, {"ref_id": "b60", "title": "Deterministic annealing for clustering, compression, classification, regression and related optmization problems", "journal": "", "year": "1998", "authors": "K Rose"}, {"ref_id": "b61", "title": "Fast unsupervised incremental parsing", "journal": "", "year": "2007", "authors": "Y Seginer"}, {"ref_id": "b62", "title": "A new method for solving hard satisfiability problems", "journal": "", "year": "1992", "authors": "B Selman; H Levesque; D Mitchell"}, {"ref_id": "b63", "title": "Noise strategies for improving local search", "journal": "", "year": "1994", "authors": "B Selman; H A Kautz; B Cohen"}, {"ref_id": "b64", "title": "Minimization by random search techniques. Mathematics of Operations Research", "journal": "", "year": "1981", "authors": "F J Solis; R ; J.-B Wets"}, {"ref_id": "b65", "title": "Baby Steps: How \"Less is More\" in unsupervised dependency parsing", "journal": "", "year": "2009", "authors": "V I Spitkovsky; H Alshawi; D Jurafsky"}, {"ref_id": "b66", "title": "Viterbi training improves unsupervised dependency parsing", "journal": "", "year": "2010", "authors": "V I Spitkovsky; H Alshawi; D Jurafsky; C D Manning"}, {"ref_id": "b67", "title": "Lateen EM: Unsupervised training with multiple objectives, applied to dependency grammar induction", "journal": "", "year": "2011", "authors": "V I Spitkovsky; H Alshawi; D Jurafsky"}, {"ref_id": "b68", "title": "Punctuation: Making a point in unsupervised dependency parsing", "journal": "", "year": "2011", "authors": "V I Spitkovsky; H Alshawi; D Jurafsky"}, {"ref_id": "b69", "title": "Unsupervised dependency parsing without gold partof-speech tags", "journal": "", "year": "2011", "authors": "V I Spitkovsky; A X Chang; H Alshawi; D Jurafsky"}, {"ref_id": "b70", "title": "Bootstrapping dependency grammar inducers from incomplete sentence fragments via austere models", "journal": "", "year": "2012", "authors": "V I Spitkovsky; H Alshawi; D Jurafsky"}, {"ref_id": "b71", "title": "Three dependency-and-boundary models for grammar induction", "journal": "", "year": "2012", "authors": "V I Spitkovsky; H Alshawi; D Jurafsky"}, {"ref_id": "b72", "title": "Multicriteria Optimization in Engineering and in the Sciences", "journal": "Plenum Press", "year": "1988", "authors": "W Stadler"}, {"ref_id": "b73", "title": "Semi-supervised relation extraction with large-scale word clustering", "journal": "", "year": "2011", "authors": "A Sun; R Grishman; S Sekine"}, {"ref_id": "b74", "title": "Ensemble models for dependency parsing: Cheap and good", "journal": "", "year": "2010", "authors": "M Surdeanu; C D Manning"}, {"ref_id": "b75", "title": "On the utility of curricula in unsupervised learning of probabilistic grammars", "journal": "", "year": "2011", "authors": "K Tu; V Honavar"}, {"ref_id": "b76", "title": "Unambiguity regularization for unsupervised learning of probabilistic grammars", "journal": "", "year": "2012", "authors": "K Tu; V Honavar"}, {"ref_id": "b77", "title": "Availability: A heuristic for judging frequency and probability", "journal": "Cognitive Psychology", "year": "1973", "authors": "A Tversky; D Kahneman"}, {"ref_id": "b78", "title": "Fast dropout training", "journal": "", "year": "2013", "authors": "S I Wang; C D Manning"}, {"ref_id": "b79", "title": "Semisupervised convex training for dependency parsing", "journal": "", "year": "2008", "authors": "Q I Wang; D Schuurmans; D Lin"}, {"ref_id": "b80", "title": "Boosting-based system combination for machine translation", "journal": "", "year": "2010", "authors": "T Xiao; J Zhu; M Zhu; H Wang"}, {"ref_id": "b81", "title": "Unsupervised word sense disambiguation rivaling supervised methods", "journal": "", "year": "1995", "authors": "D Yarowsky"}], "figures": [{"figure_label": "1", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "", "figure_data": ": Sentence string and parse tree cross-entropies (in bpt), and accuracies (DDA), on inter-punctuation fragmentsup to length 15 (WSJ 15 split ) and its subset of simple, complete sentences (WSJ 15 simp , with exact tree accuracies -TA)."}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_3", "figure_caption": "", "figure_data": ": Directed dependency accuracies (DDA) on Sec-tion 23 of WSJ (all sentences and up to length ten) forrecent systems, our full networks (IFJ and GT), and three-way combination (CS) with the previous state-of-the-art."}, {"figure_label": "3", "figure_type": "table", "figure_id": "tab_5", "figure_caption": "", "figure_data": ": Harmonic mean (F 1 ) of precision (P) and re-call (R) for unlabeled constituent bracketings on Section23 of WSJ (sentences up to length 40) for our combinedsystem (CS), recent state-of-the-art and the baselines."}, {"figure_label": "4", "figure_type": "table", "figure_id": "tab_7", "figure_caption": "", "figure_data": ": Blind evaluation on 2006/7 CoNLL test sets (allsentences) for our full networks (IFJ and GT), previousstate-of-the-art systems of Spitkovsky et al. (2012b) andMare\u010dek and\u017dabokrtsk\u00fd (2012), and three-way combi-nation with SAJ (CS, including results up to length ten)."}], "formulas": [{"formula_id": "formula_0", "formula_text": "L D C C *", "formula_coordinates": [1.0, 369.12, 686.18, 117.6, 10.85]}, {"formula_id": "formula_1", "formula_text": "(4) C", "formula_coordinates": [2.0, 162.0, 602.66, 136.72, 11.21]}, {"formula_id": "formula_2", "formula_text": "C * 1 = C * 2 .", "formula_coordinates": [2.0, 108.84, 670.34, 43.65, 12.31]}, {"formula_id": "formula_3", "formula_text": "C * 1 or C *", "formula_coordinates": [2.0, 313.2, 73.94, 42.48, 12.31]}, {"formula_id": "formula_4", "formula_text": "C * 1 and C * 2 into C + = C * 1 + C * 2 .", "formula_coordinates": [2.0, 313.2, 114.62, 137.37, 12.31]}, {"formula_id": "formula_5", "formula_text": "L D L D L D + arg MAX L D C 1 C * 1 = L(C 1 ) C 2 C * 2 = L(C 2 ) C * 1 + C * 2 = C +", "formula_coordinates": [2.0, 317.16, 220.22, 193.33, 88.75]}, {"formula_id": "formula_6", "formula_text": "L D C 2 C 1(6)", "formula_coordinates": [2.0, 365.4, 354.14, 174.52, 24.43]}, {"formula_id": "formula_7", "formula_text": "(7) C F", "formula_coordinates": [4.0, 152.04, 292.94, 146.68, 11.21]}, {"formula_id": "formula_8", "formula_text": "(8) C S", "formula_coordinates": [4.0, 152.04, 550.46, 146.68, 11.22]}, {"formula_id": "formula_9", "formula_text": "7 (9) L D C 2 C 1", "formula_coordinates": [4.0, 365.4, 480.66, 174.52, 44.43]}, {"formula_id": "formula_10", "formula_text": "H L\u2022DBM D SL DBM D SL DBM0 D C F S D0 C 1 C 2 C \u2032 1 C \u2032 2", "formula_coordinates": [5.0, 82.56, 213.52, 189.92, 81.41]}, {"formula_id": "formula_11", "formula_text": "(11) C l+1", "formula_coordinates": [5.0, 152.04, 632.7, 146.68, 13.09]}, {"formula_id": "formula_12", "formula_text": "(14) H L\u2022DBM D l+1 split \u2205 C l C l+1 l+1 l+1", "formula_coordinates": [5.0, 343.44, 649.34, 196.48, 22.3]}, {"formula_id": "formula_13", "formula_text": "p = {C * i } n i=1 . Next, construct p \u2032 by adding C * + = L( n i=1 C * i )", "formula_coordinates": [7.0, 72.0, 335.22, 226.77, 25.95]}, {"formula_id": "formula_14", "formula_text": "(15) * C 2 C 1", "formula_coordinates": [7.0, 124.2, 489.62, 174.52, 24.55]}, {"formula_id": "formula_15", "formula_text": "(16) S DBM D l simp \u2205 l+1 \uf8fc \uf8fd \uf8fe l", "formula_coordinates": [7.0, 338.04, 60.69, 201.88, 26.86]}, {"formula_id": "formula_16", "formula_text": "(17) H L\u2022DBM D l+1 split C l C l+1 l+1 F l", "formula_coordinates": [7.0, 333.48, 183.74, 206.44, 27.63]}, {"formula_id": "formula_17", "formula_text": "D 15", "formula_coordinates": [7.0, 313.2, 315.98, 15.85, 10.85]}, {"formula_id": "formula_18", "formula_text": "(18) H L\u2022DBM D 45 split H L\u2022DBM D 45 C", "formula_coordinates": [7.0, 334.44, 348.38, 205.48, 21.69]}, {"formula_id": "formula_19", "formula_text": "(19) H L\u2022DBM D 45 (GT) #1 (IFJ) #2 #3", "formula_coordinates": [7.0, 361.2, 540.14, 178.72, 26.63]}], "doi": ""}