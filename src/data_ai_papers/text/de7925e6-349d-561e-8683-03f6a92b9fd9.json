{"title": "On Computing all Abductive Explanations", "authors": "Thomas Eiter; Kazuhisa Makino", "pub_date": "", "abstract": "We consider the computation of all respectively a polynomial subset of the explanations of an abductive query from a Horn theory, and pay particular attention to whether the query is a positive or negative letter, the explanation is based on literals from an assumption set, and the Horn theory is represented in terms of formulas or characteristic models. We derive tractability results, one of which refutes a conjecture by Selman and Levesque, as well as intractability results, and furthermore also semi-tractability results in terms of solvability in quasi-polynomial time. Our results complement previous results in the literature, and elucidate the computational complexity of generating the set of explanations.", "sections": [{"heading": "Introduction", "text": "Abduction is a fundamental mode of reasoning, which has been recognized as an important principle of common-sense reasoning (see e.g. (Brewka, Dix, & Konolige 1997)). It has applications in many areas of AI including diagnosis, planning, learning, natural language understanding and many others (see e.g. references in (Eiter & Gottlob 1995)). In a logic-based setting, abduction can be defined as the task, given a set of formulas \u03a3 (the background theory) and a formula \u03c7 (the query), to find a smallest set of formulas E (an explanation) from a set of hypotheses such that \u03a3 plus E is satisfiable and logically entails \u03c7. For use in practice, the computation of abductive explanations is an important problem, for which well-known early systems such as Theorist (Poole 1989) or ATMS solvers have been devised. Since then, there has been a vastly growing literature on this subject, indicating the need for efficient abductive procedures. Main problems considered. In this paper, we consider computing a set of explanations for queries from Horn theories. More precisely, we address the following problems:\n\u2022 Computing all explanations of a query \u03c7 given by a letter q, with and without a set of assumption literals A from which explanations E must be formed, similar as in (Poole 1989;Selman & Levesque 1996). Note that the logical disjunction of all explanations is a weakest disjunctive form over the hypotheses explaining \u03c7. It is easy to see that in general, there might be exponentially many explanations, and computing all explanations is inevitably exponential. However, it is in this case of interest whether the computation is possible in polynomial total time (or output-polynomial time), i.e., in time polynomial in the combined size of the input and the output. Furthermore, if exponential space is prohibitive, it is of interest to know whether a few explanations (e.g., polynomially many) can be generated in polynomial time, as studied by Selman and Levesque (1996).\n\u2022 We contrast formula-based (syntactic) with model-based (semantic) representation of Horn theories. The latter form of representation, where a Horn theory is represented by the characteristic models, was advocated by Kautz et al. (1993). As they showed, important inference problems are tractable in the model-based setting. Namely, whether a Horn theory \u03a3 implies a CNF \u03d5, and whether a query q has an explanation w.r.t. an assumption set A; the latter is intractable under formula-based representation. Similar results were shown for other theories by Khardon and Roth (1996).\n\u2022 We investigate the role of syntax for computing abductive queries. In the framework of (Selman & Levesque 1996;Kautz, Kearns, & Selman 1993), the query is a positive letter q. However, it is of equal interest to consider negative queries as well, i.e., to explain the complement q of an atom q. Since the Horn property imposes semantic restrictions on theories, it is not straightforward to express such negative queries in terms of positive queries.\n\u2022 Finally, we consider as a meaningful generalization the computation of joint explanations. That is, given a background theory \u03a3 and observations o 1 , o 2 ,. . . , o l , where l \u2265 2, compute a single explanation E which is good for each o i . Joint explanations are relevant, e.g., in diagnostic reasoning. We may want to know whether different observations allow to come up with the same diagnosis, given by an abductive explanation, about a system malfunctioning. Such a diagnosis is particularly strong, as it is backed up by several cases.\nMain results. Our main results are summarized as follows.\n\u2022 We refute Selman and Leveque's belief (1996, p. 266), that given a Horn theory \u03a3 and a query letter q, it is hard to list all explanations of q from \u03a3 even if we are guaranteed that there are only few explanations. More precisely, we disprove their conjecture that generating O(n) many explanations of q is NP-hard, where n is the number of propositional letters in the language. This is a consequence of our result that generating all nontrivial explanations of q is possible in total polynomial time (Theorem 1).\n\u2022 We give a detailed characterization of computing all explanations of a query from Horn theory in the formula-vs model-based setting, for both general explanations and explanations w.r.t. a set of assumption literals. In a nutshell, we obtain three kinds of results:\n(1) A procedure which enumerates all nontrivial explanations of a query letter q from a Horn theory \u03a3 with incremental polynomial delay. This is a positive result and trivially implies that all explanations can be found in polynomial total time. Moreover, it means that any polynomial number of explanations can be generated in polynomial time in the size of the input (Corollary 1).\n(2) Intractability results for generating all explanations for a negative query q from a Horn theory \u03a3 contained in a set of assumption literals A; this complements a similar result for positive queries in (Selman & Levesque 1996). Both results emerge from the fact that the associated problems of recognizing the correct output are co-NP-complete. Since some hard instances have only small (polynomial-size) output, they also imply that computing few (polynomially many) explanations is intractable.\n(3) Under model-based representation, generating all explanations is polynomial-time equivalent to the well-known problem of dualizing a positive CNF (DUALIZATION), i.e., given a CNF \u03d5 in which no negative literal occurs, compute the (unique) prime DNF of \u03d5. DUALIZATION is a well-known open problem in NP-completeness, cf. (Bioch & Ibaraki 1995;Fredman & Khachiyan 1996); it is known to be solvable in quasi-polynomial total time, i.e., in time N o (log N ) where N denotes the combined size of the input and output (Fredman & Khachiyan 1996); furthermore, polynomial total time algorithms are known for many special cases, and as recently shown, the decisional variant of recognizing the prime DNF of \u03d5 is solvable with limited nondeterminism, i.e., in polynomial time with O(log 2 N ) many guesses (Eiter, Gottlob, & Makino 2002). Since DU-ALIZATION is strongly believed not to be co-NP-hard, our result thus provides strong evidence that under model-based representation, computing all explanations is not co-NPhard. Interestingly, the equivalence result holds for both positive and negative queries, and whether arbitrary or explanations over a set of assumption literals A are admitted. This means that, in a sense, model-based representation, in contrast to formula-based representation, is not sensitive to these aspects. Furthermore, by resorting to respective algorithms for dualization, the result provides us with algorithms for enumerating all or polynomially many explanations with quasi-polynomial time delay between outputs.\n\u2022 We show that deciding the existence of a joint explanation is intractable, for both formula-and model-based representation. Thus, the positive results for ordinary explanations do not extend to joint explanations.\nProofs of all results are given in (Eiter & Makino 2002).", "publication_ref": ["b2", "b5", "b14", "b14", "b16", "b16", "b9", "b10", "b16", "b9", "b16", "b0", "b7", "b7", "b6", "b6"], "figure_ref": [], "table_ref": []}, {"heading": "Preliminaries", "text": "We assume a standard propositional language with letters x 1 , x 2 , . . . , x n from a set P , where each x i takes either value 1 (true) or 0 (false). Negated atoms are denoted by x i , and the opposite of a literal by . Furthermore, we use A = { | \u2208 A} for any set of literals A and set Lit = P \u222a P .\nA clause is a disjunction c = p\u2208P (c) p \u2228 p\u2208N (c) p of literals, where P (c) and N (c) are the sets of atoms occurring positive and negated in c and P (c) \u2229 N (c) = \u2205. Dually, a term is conjunction t = p\u2208P (t) p \u2227 p\u2208N (t) p of literals, where P (t) and N (t) are similarly defined. We also view clauses and terms as sets of literals P (c) \u222a N (c) and P (t) \u222a N (t), respectively. A clause c is Horn, if |P (c)| \u2264 1, and a CNF is Horn, if it contains only Horn clauses. A theory \u03a3 is any set of formulas; it is Horn, if it is a set of Horn clauses. As usual, we identify \u03a3 with \u03d5 = c\u2208\u03a3 c, and write c \u2208 \u03d5 etc. Definition 1 Given a (Horn) theory \u03a3, called the background theory, a letter q (called query), and a set of literals A \u2286 Lit, an explanation of q w.r.t. A is a minimal set of literals E over A such that (i) \u03a3 \u222a E |= q, and (ii) \u03a3 \u222a E is satisfiable. If A = Lit, then we call E simply an explanation of q.\nObserve that the above definition is slightly more general than the assumption-based explanations of (Selman & Levesque 1996), which emerge as A = P \u222a P where P \u2286 P (i.e., A contains all literals over a subset P of the letters). Furthermore, in some texts explanations must be sets of positive literals. As for Horn theories, the following is known, cf. (Khardon & Roth 1996): Proposition 1 Let E be any explanation of q w.r.t. A \u2286 Lit. Then E \u2286 P , i.e., E contains only positive literals.\nExample 1 Consider a theory \u03a3 = {x 1 \u2228 x 4 , x 4 \u2228 x 3 , x 1 \u2228 x 2 , x 4 \u2228 x 5 \u2228 x 1 }.\nSuppose we want to explain q = x 2 from A = {x 1 , x 4 }. Then, we find that E = {x 1 } is an explanation. Indeed, \u03a3 \u222a {x 1 } |= x 2 , and \u03a3 \u222a {x 1 } is satisfiable; moreover, E is minimal. On the other hand, E = {x 1 , x 4 } satisfies (i) and (ii) for q = x 2 , but is not minimal. 2\nHorn theories have a well-known semantic characterization. A model is a vector v \u2208{0, 1} n , whose i-th component is denoted by\nv i . For B \u2286 {1, . . . , n}, we let x B be the model v such that v i = 1, if i \u2208 B and v i = 0, if i / \u2208 B, for i \u2208{1, . . . , n}.\nThe set of models of formula \u03d5 (resp. theory \u03a3), denoted by mod(\u03d5) (resp. mod(\u03a3)), is defined as usual.\nFor models v, w, we denote by v \u2264 w the usual componentwise ordering, i.e., v i \u2264 w i for all i = 1, 2, . . . , n, where 0 \u2264 1; v < w means v = w and v \u2264 w. For any set of models M, we denote by max(M), (resp., min(M)) the set of all maximal (resp., minimal) models in M . Denote by v \u2227 w componentwise AND of vectors v, w \u2208 {0, 1} n , and by Cl \u2227 (S) the closure of S \u2286 {0, 1} n under \u2227. Then, a theory \u03a3 is Horn representable, iff mod(\u03a3) = Cl \u2227 (mod(\u03a3)). Example 2 Consider M 1 = {(0101), (1001), (1000)} and M 2 = {(0101), (1001), ( 1000), ( 0001), (0000)}. Then, for v = (0101), w = (1000), we have w, v \u2208 M 1 , while v \u2227w = (0000) / \u2208 M 1 ; hence M 1 is not the set of models of a Horn theory. On the other hand, Cl \u2227 (M 2 ) = M 2 , thus M 2 = mod(\u03a3) for some Horn theory \u03a3.\nAs discussed by Kautz et al. (1993), a Horn theory \u03a3 is semantically represented by its characteristic models, where v \u2208 mod(\u03a3) is called characteristic (or extreme (Dechter & Pearl 1992)), if v \u2208 Cl \u2227 (mod(\u03a3) \\ {v}). The set of all such models, the characteristic set of \u03a3, is denoted by char(\u03a3). Note that char(\u03a3) is unique. E.g., (0101) \u2208 char(\u03a3 2 ), while (0000) / \u2208 char(\u03a3 2 ); we have char(\u03a3 2 ) = M 1 .", "publication_ref": ["b16", "b10", "b9", "b3"], "figure_ref": [], "table_ref": []}, {"heading": "Generating Explanations", "text": "In this section, we consider the generation of all explanations for an atom q. We exclude in our considerations the trivial explanation E = {q}, which always exists if q belongs to the assumption literals A, \u03a3 \u222a {q} is satisfiable and \u03a3 |= q. These conditions can be efficiently checked under both formula-and model-based representations.\nRecall that a prime implicate (res., prime implicant) of a theory \u03a3 is a smallest (w.r.t. inclusion) clause c (resp., term t) such that \u03a3 |= c (resp., t |= \u03a3). As well-known, explanations can be characterized by prime implicates as follows. Proposition 2 For a theory \u03a3, E is a nontrivial explanation of q w.r.t. A \u2286 Lit if and only if the clause c = p\u2208E p \u2228 q is a prime implicate of \u03a3 such that E \u2286 A.\nWe start with the generation of all nontrivial explanations under formula-based representation. For this problem, we present the following algorithm. \nO := O \\ {(c1, c2)}; if (1) q / \u2208 N (c1), (2) P (c1) = {r} \u2286 N (c2) and (3) \u03d5 \u222a N (c1) \u222a N (c2) \\ P (c1) is satisfiable then begin c := resolvent of c1 and c2; compute any prime implicate c \u2286 c of \u03d5; if N (c ) / \u2208 S then begin output N (c ); S := S \u222a {N (c )}; O := O \u222a {(c, c ) | c \u2208 \u03d5 } end end end. 2\nExample 3 We consider algorithm EXPLANATION on input of \u03d5 = (x 1 \u2228x 4 )(x 4 \u2228x 3 )(x 1 \u2228x 2 )(x 3 \u2228x 5 \u2228x 1 ), and q = x 2 . As easily seen, each clause in \u03d5 is a prime implicate, and thus after Step 2, \u03d5 = \u03d5 and S = {{x 1 }}. Furthermore, the explanation\nE 1 = {x 1 } was output. In Step 3, (c 1 , c 2 ), where c 1 = x 3 \u2228 x 5 \u2228 x 1 and c 2 = x 1 \u2228 x 2 , is the only pair in O satisfying (2) P (c 2 ) = {x 1 } \u2286 N (c 2 )(= {x 1 }); moreover, (1) q /\n\u2208 N (c 1 )(= {x 3 , x 5 }) holds and (3) \u03d5 \u222a {x 3 , x 5 } is satisfiable. Thus, in the body of the while-loop, its resolvent c = x 3 \u2228x 5 \u2228x 2 is computed.\nClause c is a prime implicate of \u03d5, and thus E 2 = {x 3 , x 5 } is output and added to S. Furthermore, O is updated.\nIn the next iterations, no pair (c 1 , c 2 ) \u2208 O is found which satisfies condition (2), and thus the algorithm halts. Note that E 1 and E 2 are the nontrivial explanations of q = x 2 . 2\nThe following result states that our algorithm works as desired. For any formula \u03d5, denote by \u03d5 its length, i.e., the number of literal occurrences in it.\nTheorem 1 Algorithm EXPLANATIONS incrementally outputs, without duplicates, all nontrivial explanations of q from \u03d5. Moreover, the next output resp. termination occurs To show that it outputs all nontrivial explanations E for q, assume that such an E is not output, i.e., E = E i , i = 1, . . . , k. Let \u03d5 N be the CNF of all negative prime implicates of \u03d5, and let \u03d5 = \u03d5 N \u222a{ p\u2208Ei p\u2228q | i \u2208{1, . . . , k}}. Since c = p\u2208E p \u2228 q is a prime implicate of \u03d5 and c / \u2208 \u03d5 , there exists a model v \u2208 mod(\u03d5 ) such that c(v) = 0. Let w be a maximal such model, i.e., no model u (> w) exists such that u \u2208 mod(\u03d5 ) and c(u\nwithin O(e \u2022 m \u2022 n \u2022 \u03d5 ) time,\n) = 0. Since c(w) = 0 implies w \u2208 mod(\u03d5), there exists a prime implicate c 1 in \u03d5 (when Step 2 is finished) such that c 1 (w) = 0. Clearly c 1 \u2208 \u03d5 , i.e., c 1 is of form c 1 = p\u2208N (c1) p \u2228 x i such that x i = q.\nMoreover, we have q \u2208 N (c 1 ) by c(w) = c 1 (w) = 0. Consider now the model w defined by w i = 1 and w j = w j , for all j = i. Note that c(w ) = 0, and by the maximality of w, there is a prime implicate c 2 \u2208 \u03d5 such that c 2 (w ) = 0. Since c 2 (w) = 1 and c 2 (w ) = 0, we have x i \u2208 N (c 2 ). Since q \u2208 N (c 1 ), a resolvent c of c 1 and c 2 thus exists. It can be shown (Eiter & Makino 2002)  From this result, we obtain the following corollary.\nCorollary 1 Given a Horn CNF \u03d5 and a query q, computing O(n k ) many explanations of q, where k is a constant, is possible in polynomial time.\nThis corollary implies that Selman and Leveque's conjecture (1996, p. 266) that generating O(n) many explanations of q is NP-hard, where n is the number of propositional letters in the language, is not true (unless P=NP). Note, however, that by the results of (Selman & Levesque 1996), computing O(n) many or all assumption-based explanations from a Horn \u03a3 is not possible in total polynomial time unless P = NP.\nLet us now consider computing all explanations in the model-based setting.\nTheorem 2 Given the characteristic set M = char(\u03a3) \u2286 {0, 1} n of a Horn theory \u03a3, a query q, and A \u2286 Lit, computing the set of all explanations for q from \u03a3 w.r.t. A is polynomial-time equivalent to dualizing a positive CNF.\nHere, polynomial-time equivalence means mutual polynomial-time transformability between deterministic functions, i.e., A reduces to B, if there a polynomial functions f, g s.t. for any input I of A, f (I) is an input of B, and if O is the output for f (I), then g(O) is the output of I, cf. (Papadimitriou 1994); we also request that O has size polynomial in the size of the output for I (if not, trivial reductions may exist). In our reduction, explanations correspond to clauses of the dual prime CNF and vice versa. We describe how the problem can be transformed to dualization of polynomially many positive CNFs \u03d5 1 ,. . . ,\u03d5 k , such that the clauses of the dual prime CNFs \u03c8 i for \u03d5 i correspond to the explanations of q w.r.t. A \u2229 P (equivalently, w.r.t. A). Thus, the problem is polynomially reducible to dualizing (in parallel) several positive CNFs \u03d5 i . By simple methods, we can combine \u03d5 1 ,. . . ,\u03d5 k into a single CNF \u03d5 (using further variables) such that the clauses of the dual prime CNF for \u03d5 correspond to the explanations of q w.r.t. A. (This step is of less interest in practice, since dualization of the individual \u03d5 i is at the core of the computation.)\nTo construct the \u03d5 i , we proceed as follows. Let q = x j .\n(\n) Define M i = {v \u2208 M | v j = i}, i \u2208 {0, 1}.1\n(2) For every model v \u2208 max(M 1 ), let\nF v = max({v \u2227 x A \u2227 w | w \u2208 max(M 0 )}).\nWe associate with F v a monotone Boolean function f v on the variables\nP v = A \u2229 {x i | v i = 1} such that f v (w) = 0 \u21d4 w \u2264 s for some vector s in the projection of F v on P v .\nThat is, F v describes the maximal false points of f v .\n(3) Finally, define for every v \u2208 max(M 1 )\n\u03d5 v = {c | N (c) = \u2205, P (c) = P v \\ S, x S \u2208 F v }.\nNote that \u03d5 v is a prime CNF for f v . It can be shown (Eiter & Makino 2002) that the nontrivial explanations of q w.r.t. A are given by the clauses in all dual prime CNFs \u03c8 v for \u03d5 v where v \u2208 max(M 1 ) (equivalently, by all prime implicants t, i.e., a prime DNF representation of f v , v \u2208 max(M 1 )). This proves one direction of the result.\nFor the converse, we show that, given a positive CNF \u03d5 on atoms P , computing an equivalent prime DNF \u03c8 is reducible to computing all explanations as follows. Let q be a fresh letter (for component n + 1), and define 11011), (11010), ( 10101), ( 01010), (00001)}, and suppose we want all explanations of q = x 1 w.r.t. A = {x 3 , x 4 , x 5 }. According to above, we obtain:\nM = {(v, 0) | v \u2208 max({w | \u03d5(w) = 0})} \u222a {(11 \u2022 \u2022 \u2022 1)} and A = P ; note that max({w | \u03d5(w) = 0}) is easily computed from \u03d5. 2 Example 4 Let M = {(\n(1) M 0 = {(01010), (00001)} and M 1 = {(11011), (11010), ( 10101)}, thus max(M 1 ) = {(11011), (10101)}.\n(2) We have two vectors v (1) = (11011) and v (2) = ( 10101): 00111)\u2227( 01010), ( 11011)\u2227( 00111)\u2227( 00001)\nF v (1) = max (11011)\u2227(\n= {( 00010), (00001)}, 00111)\u2227( 01010), ( 10101)\u2227( 00111)\u2227( 00001)\nF v (2) = max (10101)\u2227(\n= {(00001)}. 10), (01), (00)}, and P v (2) = {x 3 , x 5 } and f v (2) (w) = 0 iff w \u2208{( 01), (00)}.\nThus, P v (1) = {x 4 , x 5 } and f v (1) (w) = 0 iff w \u2208 {(\n(3) We obtain \u03d5 (1) = x 4 \u2227 x 5 and \u03d5 (2) = x 3 . The respective prime dual CNFs are \u03c8 (1) = x 4 \u2228 x 5 and \u03c8 (2) = x 3 .\nThus, the explanations of q w.r.t. A are E 1 = {x 4 , x 5 } and E 2 = {x 3 }. It can be seen that this is the correct result.", "publication_ref": ["b6", "b16", "b13", "b6"], "figure_ref": [], "table_ref": []}, {"heading": "Negative Queries", "text": "So far, we considered Horn theories \u03a3 and queries given by a letter q. In a general setting, we might allow that the formulas in \u03a3 and the query are any propositional formulas. As for computation, we can introduce for a query, given by any formula \u03c7, a fresh letter q, add implications q \u2192 \u03c7, \u03c7 \u2192 q in \u03a3, and then ask for a nontrivial explanation of q. Thus, positive letter queries do not constrain the expressivity of the framework. However, this technique does not work for Horn theories, if one of the implications q \u2192 \u03c7, \u03c7 \u2192 q is not Horn. In the simplest case, \u03c7 is a negative literal q.\nThe next result tells us that already in this case, abduction from a Horn CNF is intractable. Recall that a Horn CNF \u03d5 is acyclic, if the graph on P with arcs from x i \u2208 N (c) to\nx i \u2208 P (c), c \u2208 \u03d5, has no directed cycle.\nTheorem 3 Given a Horn CNF \u03d5, a general query \u03c7 in CNF, and A \u2286 Lit, deciding if \u03c7 has a nontrivial explanation w.r.t. A is NP-complete. Hardness holds even if \u03c7 = q, \u03d5 is acyclic, and either (i) A = P or (ii) A = P \u222a P for some P \u2286 P .\nProof. (Sketch) The problem is in NP, since clearly an explanation E exists if some set E \u2286 A exists such that \u03a3 \u222a E is satisfiable and \u03a3 \u222a E |= \u03c7; such an E can be guessed and the conditions can be checked in polynomial time.\nHardness is shown by a reduction from 3SAT. Let \u03b3 = c 1 \u2227 \u2022 \u2022 \u2022 \u2227 c m be a 3CNF over atoms x 1 , . . . , x n , where c i = i,1 \u2228 i,2 \u2228 i,3 . We introduce for each clause c i a new atom y i , for each x j a new atom x j , and a special atom z. The Horn CNF \u03d5 contains the following clauses:\nAAAI-02 65\n\u2022 x i \u2228 x i , for all i = 1, . . . , n; \u2022 z \u2228 y 1 \u2022 y i \u2228 i,j \u2228 y i+1 if i,j is positive and y i \u2228 i,j \u2228 y i+1 if i,j\nis negative, for all i = 1, . . . , m \u2212 1 and j = 1, 2, 3;\n\u2022 y m \u2228 m,j if m,j is positive and y m \u2228 m,j if i,j is negative, for j = 1, 2, 3. As easily seen, \u03d5 is acyclic Horn. It can be shown (Eiter & Makino 2002) that the query q = \u00acz has a nontrivial explanation E consisting of positive literals iff \u03b3 is satisfiable, which proves NP-hardness under restriction (i). For (ii), we use a similar construction.\n2\nNote that this result contrasts the tractability result that a nontrivial explanation E \u2286 P for a positive query q can be computed in polynomial time (Selman & Levesque 1996). Thus, the framework of Horn abduction is sensitive with respect to query representation. We also remark that we can find an arbitrary explanation E for a query q (which may contain negative literals), in polynomial time.\nIn the model-based setting, we obtain for computing all explanations for a negative query a similar result as for a positive query.\nTheorem 4 Given the characteristic set M = char(\u03a3) \u2286 {0, 1} n of a Horn theory \u03a3, a negative query q, and A \u2286 Lit, computing all explanations for q from \u03a3 w.r.t. A is polynomial-time equivalent to dualizing a positive CNF.\nProof. (Sketch) Observe that since the query is not positive, explanations of q may involve negative literals.\nProposition 2 implies that the nontrivial explanations for q w.r. Similarly as in the proof of Theorem 2, we construct dualization problems for functions f v , but for v \u2208 max(M 0 ):\n(1.1) For every v \u2208 max(M 0 ), let F v = max({v \u2227 x A+ \u2227 w | w \u2208 max(M 1 )}).\nThe associated monotone Boolean function\nf v on P v = A \u2229 {x i | v i = 1}\nis defined by f v (w) = 0 \u21d4 w \u2264 s holds for some vector s in the projection of\nF v on P v . (1.2) We define, for v \u2208 max(M 0 ), \u03d5 v = {c | N (c) = \u2205, P (c) = P v \\ S, x S \u2208 F v }.\nSimilarly as in Theorem 2, we can show that the clauses in the dual prime CNFs for all \u03d5 v , v \u2208 max(M 0 ), correspond to the positive explanations of q (Eiter & Makino 2002).\n(2) Non-positive explanations for q. These are all prime implicates c of \u03a3 s.t. {q} \u2286 N (c) \u2286 A + \u222a {q} and P (c) = {r}, where r \u2208 A \u2212 .\nFor each r = x j (where j = j), we proceed as follows.\n(2.1) For every v \u2208 max(M 0 ) and i \u2208 {0, 1}, define\nM r i = {v \u2208 M i | v r = i}.\n(2.2) For each v (0) \u2208 max(M r 0 ) and v (1) \u2208 max(M r 1 ), let\nF v (0) ,v (1) = max({v (0) \u2227v (1) \u2227x A+ \u2227w | w \u2208 max({u \u2208 M 1 | u j = 0)}).\nWe associate with it a monotone Boolean function f v (0) ,v (1)\non P v (0) ,v (1) = A \u2229 {x i | v (0) i = v\n(1) i = 1} such that f v (0) ,v (1) (w) = 0 \u21d4 w \u2264 s for some s in the projection of\nF v (0) ,v (1) on P v (0) ,v (1) .\n(2.3) We define the CNFs\n\u03d5 v (0) ,v (1) = {c | N (c) = \u2205, P (c) = Pv \\ S, x S \u2208 F v (0) ,v (1) }.\nThen, it can be shown (Eiter & Makino 2002) that the clauses in the dual prime CNFs \u03c8 v (0) ,v (1) for all \u03d5 v (0) ,v (1) , where v (0) \u2208 max(M r 0 ) and v (1) \u2208 max(M r 1 ) and r \u2208 A \u2212 , correspond to the non-positive explanations of q.\nIn total, computing all explanations of q is polynomialtime reducible to dualizing (in parallel) polynomially many positive CNFs. As mentioned in the proof of Theorem 2, this is polynomially reducible to dualizing a single CNF.\nThe converse is shown by a reduction similar to the one in the proof of Theorem 2; we just invert the polarity of q. 2", "publication_ref": ["b6", "b16", "b6", "b6"], "figure_ref": [], "table_ref": []}, {"heading": "Joint Explanations", "text": "We call any set of E \u2286 A of literals a joint explanation of observations o 1 , o 2 , . . . , o l from a background theory \u03a3 w.r.t. a set of assumptions A \u2286 Lit, if E is an explanation of each o i from \u03a3 w.r.t. A. The observations o i may be letters, or in a generalized setting propositional formulas.\nNote that any such E is also an explanation for the conjunction\n\u03b1 = o 1 \u2227 o 2 \u2227 \u2022 \u2022 \u2022 \u2227 o l\nof all observations, while the converse is not true in general: an explanation E of \u03b1 may not satisfy minimality for o 1 , say, i.e., some E \u2282 E may explain o 1 . Thus, joint explanations are stronger than ordinary explanations. In case of multiple explanations, this may be used to single out those which match with each of the (possibly independently made) observations. For example, the malfunctioning of a car may be explained by two car mechanics, based on observations o 1 and o 2 , respectively. A match of their (individual) diagnoses E 1 and E 2 (i.e., E 1 = E 2 ) may be taken in favor of believing in their correctness. In fact, the diagnoses are robust in the sense that adding the other observation does not require a change; from another perspective, the same diagnosis is good for explaning different observations. If E 1 and E 2 are different, then we might want to know whether alternative diagnoses E 1 and E 2 do exist which coincide, i.e., whether a joint explanation is possible.\nAs it turns out, recognizing joint explanations for CNFs, i.e., deciding whether E is a joint explanation for observations o 1 , . . . , o l described by CNFs, from \u03a3 w.r.t. assumptions A is tractable, for both formula-and model based representation. However, deciding existence is harder.\nTheorem 5 Given a Horn CNF \u03d5, query CNFs \u03c7 1 , \u03c7 2 , . . . , \u03c7 l , where l \u2265 2, andA \u2286 Lit, deciding if a joint explanation exists from \u03a3 w.r.t. A is NP-complete. Hardness holds even if l = 2, each \u03c7 i is a letter, \u03d5 is acyclic, and A = Lit.\nTheorem 6 Given the characteristic set M = char(\u03a3) of a Horn theory \u03a3, query CNFs \u03c7 1 , \u03c7 2 , . . . , \u03c7 l , l \u2265 2, and A \u2286 Lit, deciding if a joint explanation exists from \u03a3 w.r.t. A is NP-complete. Hardness holds even if l = 2, each \u03c7 i is a letter, and A = Lit.\nThus, the tractability results in (Selman & Levesque 1996;Kautz, Kearns, & Selman 1993) do not generalize to joint explanations for positive queries. Similar intractability results hold for negative queries and combined positive and negative queries. Selman and Levesque (1990; were among the first to study the complexity of computing general and assumptionbased explanations; Corollary 1 closes an open problem of them. The underlying algorithm EXPLANATIONS is a relative of a similar procedure by Boros et al. (1990) for computing all prime implicates of a Horn CNF in output-polynomial time. In fact, Theorem 1 can be seen as a strengthening of their result. For negative queries, a similar algorithm is not evident. del Val (2000) presented generation of implicates and prime implicates of certain clausal theories in a target language, which is formed on a subset of the atoms, using a procedure based on kernel resolution and derived exponential bounds on its running time. Furthermore, del Val described the use of this procedure for generating jointly all explanations of all literals not on a set of atoms V . However, neither is this method incremental in nature, nor is it clear whether it is total polynomial time. Moreover, it considers a letter q and its negation q at once. Inoue (1992) considered, in the propositional and the firstorder context, generating explanations and prime implicates using SOL-resolution. He proposed a strategy which processes, starting from the empty set, clauses from a theory incrementally. However, due to possible large intermediate results, this method is not total polynomial time in general. Khardon et al. (1999) show how computing all keys of a relational database schema, which is constrained by a Boolean formula \u03d5, can be polynomially transformed into computing all explanations of a query q from \u03d5 \u2227 \u03c8, where \u03c8 is Horn. Thus, our algorithm EXPLANATIONS can be used for efficiently generating all keys of a database scheme where \u03d5 is a Horn CNF. This generalizes the result for \u03d5 consisting of non-negative Horn clauses, i.e., a set of functional dependencies (Lucchesi & Osborn 1978). 1 Note that Khardon et al. also show how to compute a single explanation of a query q from a theory \u03d5 polynomially, using repeatedly an oracle for computing a key of a database schema constrained by \u03d5 \u2227 \u03c8, where \u03c8 is Horn; however, this method is not usable for generating explanations from general Horn theories (cf. Footnote 1). Less related to our work is (Eiter & Gottlob 1995), which considered abduction from Horn and general propositional theories, but focused on existence of explanations and reasoning tasks about explanations.", "publication_ref": ["b16", "b9", "b15", "b1", "b4", "b8", "b11", "b12", "b5"], "figure_ref": [], "table_ref": []}, {"heading": "Related Works", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Conclusion", "text": "We have presented a number of positive and negative results about generating all and some abductive explanations, re-spectively, which complement previous work in the literature. In particular, we analyzed the role of positive vs negative abductive queries, under both formula-and model-based representation, and we considered the novel notion of joint explanation. Our positive results may be readily applied for efficiently computing (a subset of) all explanations. The results draw a complete picture for the model-based setting, and almost so for the formula-based setting; the complexity of generating all explanations for a negative query in it is currently open.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgments", "text": "We thank the reviewers for helpful comments. This work was partly supported by the Austrian Science Fund (FWF) project Z29-INF, by TU Wien through a scientific collaboration grant, and by the Scientific Grant in Aid of the Ministry of Education, Science, Sports and Culture of Japan.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Complexity of identification and dualization of positive Boolean functions", "journal": "Information and Computation", "year": "1995", "authors": "C Bioch; T Ibaraki"}, {"ref_id": "b1", "title": "Polynomial-time inference of all valid implications for Horn and related formulae", "journal": "Annals of Mathematics & Artificial Intelligence", "year": "1990", "authors": "E Boros; Y Crama; P L Hammer"}, {"ref_id": "b2", "title": "Nonmonotonic Reasoning -An Overview. Number 73 in CSLI Lecture Notes", "journal": "CSLI Publications", "year": "1997", "authors": "G Brewka; J Dix; K Konolige"}, {"ref_id": "b3", "title": "Structure identification in relational data", "journal": "Artificial Intelligence", "year": "1992", "authors": "R Dechter; J Pearl"}, {"ref_id": "b4", "title": "The complexity of restricted consequence finding and abduction", "journal": "", "year": "2000", "authors": "A Del Val"}, {"ref_id": "b5", "title": "The complexity of logic-based abduction", "journal": "J. ACM", "year": "1995", "authors": "T Eiter; G Gottlob"}, {"ref_id": "b6", "title": "New results on monotone dualization and generating hypergraph transversals", "journal": "", "year": "2002", "authors": "T Eiter; K Makino; Austria Tu Wien; T Eiter; G Gottlob; K Makino"}, {"ref_id": "b7", "title": "On the complexity of dualization of monotone disjunctive normal forms", "journal": "Journal of Algorithms", "year": "1996", "authors": "M Fredman; L Khachiyan"}, {"ref_id": "b8", "title": "Linear resolution for consequence finding", "journal": "Artificial Intelligence", "year": "1992", "authors": "K Inoue"}, {"ref_id": "b9", "title": "Reasoning with characteristic models", "journal": "", "year": "1993", "authors": "H Kautz; M Kearns; B Selman"}, {"ref_id": "b10", "title": "Reasoning with models", "journal": "Artificial Intelligence", "year": "1996", "authors": "R Khardon; Roth ; D "}, {"ref_id": "b11", "title": "Reasoning with examples: Propositional formulae and database dependencies", "journal": "Acta Informatica", "year": "1999", "authors": "R Khardon; H Mannila; D Roth"}, {"ref_id": "b12", "title": "Candidate keys for relations", "journal": "J. Computer and System Sciences", "year": "1978", "authors": "C L Lucchesi; S Osborn"}, {"ref_id": "b13", "title": "", "journal": "Computational Complexity", "year": "1994", "authors": "C H Papadimitriou"}, {"ref_id": "b14", "title": "Explanation and prediction: An architecture for default and abductive reasoning", "journal": "Comp. Intelligence", "year": "1989", "authors": "D Poole"}, {"ref_id": "b15", "title": "Abductive and default reasoning: A computational core", "journal": "", "year": "1990", "authors": "B Selman; H J Levesque"}, {"ref_id": "b16", "title": "Support set selection for abductive and default reasoning", "journal": "Artif. Intell", "year": "1996", "authors": "B Selman; H J Levesque"}], "figures": [{"figure_label": "", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Algorithm EXPLANATIONSInput: A Horn CNF \u03d5 and a positive letter q. Output: All nontrivial explanations of q from \u03d5. Step 1. \u03d5 := \u2205, S := \u2205, and O := \u2205; Step 2. for each c \u2208 \u03d5 do add any prime implicate c \u2286 c of \u03d5 to \u03d5 ; for each c \u2208 \u03d5 with P (c ) = {q} and N (c ) / \u2208 S do begin output N (c ); S := S \u222a {N (c )}; O := O \u222a {(c, c ) | c \u2208 \u03d5 } end; Step 3. while some (c1, c2) \u2208 O exists do begin", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "where m is the number of clauses in \u03d5, n the number of atoms, and e the number of explanations output so far. Proof. (Sketch) Only pairs (c, c ) are added to O such that c is a prime implicate of \u03d5. Furthermore, by condition (3) in Step 3, each such c must have P (c ) = {q}. Thus, by Props. 1 and 2, algorithm EXPLANATIONS outputs only nontrivial (clearly different) explanations E 1 , E 2 , . . . , E k for q.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "that c creates a new prime implicate c = p\u2208N (c ) p\u2228q \u2286 c of \u03d5 in Step 3, i.e., N (c ) = E i , i = 1, . . . , k. This contradicts our assumption. Thus, EXPLANATION is correct, and it remains to verify the time bound. Computing a prime implicate c \u2286 c of \u03d5 in Steps 2 and 3 is feasible in time O(n \u2022 \u03d5 ), and thus the outputs in Step 2 occur with O(m \u2022 n \u2022 \u03d5 ) delay. As for Step 3, note the O contains only pairs (c 1 , c 2 ) where c 1 \u2208 \u03d5 and c 2 = N (c 2 ) \u222a {q} such that N (c 2 ) was output, and each such pairs is added to O only once. Thus, the next output or termination follows within e \u2022 m runs of the whileloop, where e is the number of solutions output so far. The body of the loop can be done, using proper data structures, in O(n \u2022 \u03d5 ) time (for checking N (c 1 ) / \u2208 S efficiently, we may store S in a prefix tree). Thus, the time until the next output resp. termination is bounded by O(e \u2022 m \u2022 n \u2022 \u03d5 ). 2", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Proof. (Sketch) By Props. 1 and 2, we need only compute all nontrivial explanations E \u2286 A corresponding to prime implicates c of \u03a3 s.t. P (c) = {q} and N (c) = E \u2286 A \u2229 P .", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "t. A correspond to the prime implicates c of \u03a3 such that q \u2208 N (c) and P (c) \u222a N (c) \u2286 A \u222a {q}. Let q = x j , and define sets M 0 and M 1 for M as in the proof of Theorem 2. Denote by A + (resp., A \u2212 ) the set of positive (resp., negative) literals in A. We consider the following two cases: (1) Positive explanations for q. I.e., all prime implicates c of \u03a3 s.t. {q} \u2286 N (c) \u2286 A + \u222a {q} and P (c) = \u2205.", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "Example 1 Consider a theory \u03a3 = {x 1 \u2228 x 4 , x 4 \u2228 x 3 , x 1 \u2228 x 2 , x 4 \u2228 x 5 \u2228 x 1 }.", "formula_coordinates": [2.0, 319.5, 417.32, 238.5, 20.87]}, {"formula_id": "formula_1", "formula_text": "v i . For B \u2286 {1, . . . , n}, we let x B be the model v such that v i = 1, if i \u2208 B and v i = 0, if i / \u2208 B, for i \u2208{1, . . . , n}.", "formula_coordinates": [2.0, 319.5, 506.29, 238.5, 32.81]}, {"formula_id": "formula_2", "formula_text": "O := O \\ {(c1, c2)}; if (1) q / \u2208 N (c1), (2) P (c1) = {r} \u2286 N (c2) and (3) \u03d5 \u222a N (c1) \u222a N (c2) \\ P (c1) is satisfiable then begin c := resolvent of c1 and c2; compute any prime implicate c \u2286 c of \u03d5; if N (c ) / \u2208 S then begin output N (c ); S := S \u222a {N (c )}; O := O \u222a {(c, c ) | c \u2208 \u03d5 } end end end. 2", "formula_coordinates": [3.0, 87.23, 477.1, 205.27, 108.32]}, {"formula_id": "formula_3", "formula_text": "E 1 = {x 1 } was output. In Step 3, (c 1 , c 2 ), where c 1 = x 3 \u2228 x 5 \u2228 x 1 and c 2 = x 1 \u2228 x 2 , is the only pair in O satisfying (2) P (c 2 ) = {x 1 } \u2286 N (c 2 )(= {x 1 }); moreover, (1) q /", "formula_coordinates": [3.0, 54.0, 640.03, 238.5, 42.79]}, {"formula_id": "formula_4", "formula_text": "within O(e \u2022 m \u2022 n \u2022 \u03d5 ) time,", "formula_coordinates": [3.0, 319.5, 190.13, 125.24, 9.66]}, {"formula_id": "formula_5", "formula_text": ") = 0. Since c(w) = 0 implies w \u2208 mod(\u03d5), there exists a prime implicate c 1 in \u03d5 (when Step 2 is finished) such that c 1 (w) = 0. Clearly c 1 \u2208 \u03d5 , i.e., c 1 is of form c 1 = p\u2208N (c1) p \u2228 x i such that x i = q.", "formula_coordinates": [3.0, 319.5, 362.86, 238.5, 43.94]}, {"formula_id": "formula_6", "formula_text": ") Define M i = {v \u2208 M | v j = i}, i \u2208 {0, 1}.1", "formula_coordinates": [4.0, 67.84, 490.88, 188.62, 9.91]}, {"formula_id": "formula_7", "formula_text": "F v = max({v \u2227 x A \u2227 w | w \u2208 max(M 0 )}).", "formula_coordinates": [4.0, 82.77, 518.97, 180.96, 11.13]}, {"formula_id": "formula_8", "formula_text": "P v = A \u2229 {x i | v i = 1} such that f v (w) = 0 \u21d4 w \u2264 s for some vector s in the projection of F v on P v .", "formula_coordinates": [4.0, 58.98, 547.37, 233.52, 31.83]}, {"formula_id": "formula_9", "formula_text": "\u03d5 v = {c | N (c) = \u2205, P (c) = P v \\ S, x S \u2208 F v }.", "formula_coordinates": [4.0, 75.23, 597.38, 196.04, 11.13]}, {"formula_id": "formula_10", "formula_text": "M = {(v, 0) | v \u2208 max({w | \u03d5(w) = 0})} \u222a {(11 \u2022 \u2022 \u2022 1)} and A = P ; note that max({w | \u03d5(w) = 0}) is easily computed from \u03d5. 2 Example 4 Let M = {(", "formula_coordinates": [4.0, 319.5, 67.75, 238.5, 49.41]}, {"formula_id": "formula_11", "formula_text": "F v (1) = max (11011)\u2227(", "formula_coordinates": [4.0, 330.85, 189.55, 126.69, 16.15]}, {"formula_id": "formula_12", "formula_text": "F v (2) = max (10101)\u2227(", "formula_coordinates": [4.0, 330.85, 231.4, 126.69, 16.15]}, {"formula_id": "formula_13", "formula_text": "Thus, P v (1) = {x 4 , x 5 } and f v (1) (w) = 0 iff w \u2208 {(", "formula_coordinates": [4.0, 319.5, 275.35, 221.53, 10.71]}, {"formula_id": "formula_14", "formula_text": "x i \u2208 P (c), c \u2208 \u03d5, has no directed cycle.", "formula_coordinates": [4.0, 319.5, 529.48, 160.16, 9.91]}, {"formula_id": "formula_15", "formula_text": "\u2022 x i \u2228 x i , for all i = 1, . . . , n; \u2022 z \u2228 y 1 \u2022 y i \u2228 i,j \u2228 y i+1 if i,j is positive and y i \u2228 i,j \u2228 y i+1 if i,j", "formula_coordinates": [5.0, 54.0, 56.79, 237.6, 42.32]}, {"formula_id": "formula_16", "formula_text": "(1.1) For every v \u2208 max(M 0 ), let F v = max({v \u2227 x A+ \u2227 w | w \u2208 max(M 1 )}).", "formula_coordinates": [5.0, 63.96, 499.97, 202.57, 23.84]}, {"formula_id": "formula_17", "formula_text": "f v on P v = A \u2229 {x i | v i = 1}", "formula_coordinates": [5.0, 58.98, 530.16, 233.52, 20.53]}, {"formula_id": "formula_18", "formula_text": "F v on P v . (1.2) We define, for v \u2208 max(M 0 ), \u03d5 v = {c | N (c) = \u2205, P (c) = P v \\ S, x S \u2208 F v }.", "formula_coordinates": [5.0, 63.96, 552.08, 207.31, 38.43]}, {"formula_id": "formula_19", "formula_text": "M r i = {v \u2208 M i | v r = i}.", "formula_coordinates": [5.0, 118.6, 691.32, 109.29, 12.23]}, {"formula_id": "formula_20", "formula_text": "F v (0) ,v (1) = max({v (0) \u2227v (1) \u2227x A+ \u2227w | w \u2208 max({u \u2208 M 1 | u j = 0)}).", "formula_coordinates": [5.0, 324.48, 72.91, 233.52, 22.46]}, {"formula_id": "formula_21", "formula_text": "on P v (0) ,v (1) = A \u2229 {x i | v (0) i = v", "formula_coordinates": [5.0, 324.48, 114.71, 153.89, 13.98]}, {"formula_id": "formula_22", "formula_text": "F v (0) ,v (1) on P v (0) ,v (1) .", "formula_coordinates": [5.0, 324.48, 140.92, 90.05, 10.38]}, {"formula_id": "formula_23", "formula_text": "\u03d5 v (0) ,v (1) = {c | N (c) = \u2205, P (c) = Pv \\ S, x S \u2208 F v (0) ,v (1) }.", "formula_coordinates": [5.0, 323.32, 168.8, 230.85, 11.51]}, {"formula_id": "formula_24", "formula_text": "\u03b1 = o 1 \u2227 o 2 \u2227 \u2022 \u2022 \u2022 \u2227 o l", "formula_coordinates": [5.0, 355.35, 402.75, 96.17, 9.91]}], "doi": ""}