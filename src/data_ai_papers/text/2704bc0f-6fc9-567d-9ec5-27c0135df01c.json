{"title": "Trident: Efficient 4PC Framework for Privacy Preserving Machine Learning", "authors": "Harsh Chaudhari; Rahul Rachuri; Ajith Suresh", "pub_date": "2021-06-08", "abstract": "Machine learning has started to be deployed in fields such as healthcare and finance, which involves dealing with a lot of sensitive data. This propelled the need for and growth of privacy-preserving machine learning (PPML). We propose an actively secure four-party protocol (4PC), and a framework for PPML, showcasing its applications on four of the most widely-known machine learning algorithms -Linear Regression, Logistic Regression, Neural Networks, and Convolutional Neural Networks.", "sections": [{"heading": "", "text": "Our 4PC protocol tolerating at most one malicious corruption is practically more efficient than Gordon et al. (ASIACRYPT 2018) as the 4th party in our protocol is not active in the online phase, except input sharing and output reconstruction stages. Concretely, we reduce the online communication as compared to them by 1 ring element. We use the protocol to build an efficient mixed-world framework (Trident) to switch between the Arithmetic, Boolean, and Garbled worlds. Our framework operates in the offline-online paradigm over rings and is instantiated in an outsourced setting for machine learning, where the data is secretly shared among the servers. Also, we propose conversions especially relevant to privacy-preserving machine learning. With the privilege of having an extra honest party, we outperform the current state-of-the-art ABY3 (for three parties), in terms of both rounds as well as communication complexity.\nThe highlights of our framework include using minimal number of expensive circuits overall as compared to ABY3. This can be seen in our technique for truncation, which does not affect the online cost of multiplication and removes the need for any circuits in the offline phase. Our B2A conversion has an improvement of 7\u00d7 in rounds and 18\u00d7 in the communication complexity.\nThe practicality of our framework is argued through improvements in the benchmarking of the aforementioned algorithms when compared with ABY3. All the protocols are implemented over a 64-bit ring in both LAN and WAN settings. Our improvements go up to 187\u00d7 for the training phase and 158\u00d7 for the prediction phase when observed over LAN and WAN.\nUpdate: An improved version of this framework appears at [1] https://arxiv.org/abs/2106.02850", "publication_ref": ["b0"], "figure_ref": [], "table_ref": []}, {"heading": "I. INTRODUCTION", "text": "Machine learning is one of the fastest-growing research domains today. Applications for machine learning range from smarter keyboard predictions to better object detection in selfdriving cars to avoid collisions. This is in part due to more data being made available with the rise of internet companies such as Google and Amazon, as well as due to the machine learning This work was done when Rahul Rachuri was at IIIT-B, India. \u00a7 Corresponding Author. algorithms themselves getting more robust and accurate. In fact, machine learning algorithms have now started to beat humans at some complicated tasks such as classifying echocardiograms [2], and they are only getting better. Techniques such as deep learning and reinforcement learning are at the forefront making such breakthroughs possible.\nThe level of accuracy and robustness required is very high to operate in mission-critical fields such as healthcare, where the functioning of the model is vital to the working of the system. Accuracy and robustness are governed by two factors, one of them is the high amount of computing power demanded to train deep learning models. The other factor influencing the accuracy of the model is the variance in the dataset. Variance in datasets comes from collecting data from multiple diverse sources, which is typically infeasible for a single company to achieve.\nTowards this, companies such as Microsoft (Azure), Amazon (AWS), Google (Google Cloud), etc. have entered into space by offering \"Machine Learning as a Service (MLaaS)\". MLaaS works in two different ways, depending on the enduser. The first scenario is companies offering their trained machine learning models that a customer can query to obtain the prediction result. The second scenario is when multiple customers/companies want to come together and train a common model using their datasets, but none of them wish to share the data in the clear. While promising, both models require the end-user to make compromises. In the case of an individual customer, privacy of his/her query is not maintained and in the case of companies, policies like the European Union General Data Protection Regulation (GDPR) or the EFF's call for information fiduciary rules for businesses have made it hard and often illegal for companies to share datasets with each other without prior consent of the customers, security, and other criteria met. Even with all these criteria met, data is proprietary information of a company which they would not want to share due to concerns such as competitive advantage.\nDue to the huge interest in using machine learning, the field of privacy-preserving machine learning (PPML) has become a fast-growing area of research that addresses the aforementioned problems through techniques for privacy-preserving training and prediction. These techniques when deployed ensure that no information about the query or the datasets is leaked beyond what is permissible by the algorithm, which in some cases might be only the prediction output. Recently there have been a slew of works that have used the techniques of Secure Multiparty Computation (MPC) to perform efficient PPML, works such as [3]- [7] making huge contributions.\nSecure multiparty computation is an area of extensive re-search that allows for n mutually distrusting parties to perform computations together on their private inputs, such that no coalition of t parties, controlled by an adversary, can learn any information beyond what is already known and permissible by the algorithm. While MPC has been shown to be practical [8]- [10], MPC for a small number of parties in the honest majority setting [11]- [16], [16]- [20] has become popular over the last few years due to applications such as financial data analysis [21], email spam filtering [22], distributed credential encryption [17], privacy-preserving statistical studies [23] that involve only a few parties. This is also evident from popular MPC frameworks such as Sharemind [24] and VIFF [25].\nOur Setting: In this work we deal with the specific case of MPC with 4 parties (4PC), tolerating at most 1 malicious corruption. The state-of-the-art three-party (3PC) PPML frameworks in the honest majority setting such as ABY3 [6], SecureNN [7], and ASTRA [26] (prediction only) have fast and efficient protocols for the semi-honest case but are significantly slower when it comes to the malicious setting. This is primarily due to the underlying operations such as Dot Product, Secure Comparison, and Truncation being more expensive in the malicious setting. For instance, the Dot Product protocol of ABY3 incurs communication cost that is linearly dependent on the size of the underlying vector. Since these operations are performed many times, especially during the training phase, more efficient protocols for these operations are crucial in building a better PPML framework.\nThe motivation behind our 4PC setting is to investigate the performance improvement, both theoretical and practical, over the existing solutions in the 3PC setting, when given the privilege of an additional honest party. We show later in this work that having an extra honest party helps us achieve simpler and much more efficient protocols as compared to 3PC. For instance, operating in 4PC eliminates the need for expensive multiplication triples and allows us to perform a dot product at a cost that is independent of the size of the two vectors.\nOur ML constructions are built on a new 4PC scheme, instead of the one proposed by Gordon et al. [27], primarily due to the following reasons:\n1) Our protocol requires only three out of the four parties to be active during most of the online phase. On the contrary, [27] demands all the four parties to be active during the online phase. Thus, our protocol is more efficient in the setting where the computation is outsourced to a set of servers.\n2) Using the new secret sharing scheme, our protocol shifts 25% (1 ring element) of the online communication to the offline phase, thus improving the online efficiency.\nWhile our setting is more communication efficient, we assume the presence of an extra honest party which demands an additional 3 pairwise authentic channels when compared to that of 3PC. However, monetary cost [28] is an important parameter to look at since the servers need to be running for a long time for complex ML models. The time servers run for and the compute power of the servers dictate the cost of operation. As the fourth party in our framework does not have to be online throughout the online phase, we can shut the server down for most of the online phase. Aided by this fact, the total monetary cost, which would be the total cost of hiring 4 servers to run our framework for either the training or the prediction phase of an algorithm, we come out ahead of ABY3, primarily because the total running time of the servers in our framework is much lower. More details about monetary cost are presented in Appendix E.", "publication_ref": ["b1", "b2", "b6", "b7", "b9", "b10", "b15", "b15", "b19", "b20", "b21", "b16", "b22", "b23", "b24", "b5", "b6", "b25", "b26", "b26", "b27"], "figure_ref": [], "table_ref": []}, {"heading": "Offline-online paradigm:", "text": "To improve efficiency, a class of MPC protocols operates in the offline-online paradigm [29]. Data-independent computations are carried out in the offline phase, doing so paves way for a fast and efficient online phase of the protocol. Moreover, since the computations performed in the offline phase are data-independent, not all the parties need to be active throughout this phase, placing less reliance on each party. This paradigm has proved its ability to improve the efficiency of protocols in both theoretical [29]- [34] and practical [5], [35]- [42] domains. It is especially useful in a scenario like MLaaS, where the same functions need to be performed many times and the function descriptions are known beforehand. Furthermore, we operate in the outsourced setting of MPC, which allows for an arbitrary number of parties to come together and perform their joint computation via a set of servers. Each server can be thought of as a representative for a subset of data owners, or as an independent party. The advantage of this setting is that it allows the framework to easily scale for a large number of parties and the security notions reduce to that of a standard 4PC between the servers.", "publication_ref": ["b28", "b28", "b33", "b4", "b34", "b41"], "figure_ref": [], "table_ref": []}, {"heading": "Rings vs Fields:", "text": "In the pursuit of practical efficiency, protocols in MPC that operate over rings are preferred to ones that work over finite fields. This is because of the way computations are carried out in standard 32/64-bit CPUs. Since these architectures have been around for a while, many algorithms are optimized for them. Moreover, operating over rings means that we do not have to override basic operations such as addition and multiplication, unlike with finite fields.\nAlthough MPC techniques have been making a lot of progress towards being practically efficient, we cannot directly use the current best MPC protocols to perform PPML. This is mainly due to two reasons, which are:\n1) MPC techniques operate in three different worlds -Arithmetic, Boolean, and Garbled. Each of these worlds is naturally better suited to carry out certain types of computations. For example, the Arithmetic domain (over a ring Z 2 \u2113 ) is more suited to perform addition whereas the Garbled world is more suited to perform division. Activation functions used in machine learning, such as Rectified Linear Unit (ReLU), have operations that alternate between multiplications and comparisons. Operating in only one of the worlds, as most of the current MPC techniques do, does not give us the maximum possible efficiency. The mixed protocol framework for MPC was first shown to be practical by TASTY [43], which combined Garbled circuits and homomorphic encryption. The idea was later applied to the ML domain by SecureML [3], ABY3 [6] etc., where protocols to switch between the three worlds were proposed. These mixed world frameworks have proven to be orders of magnitude more efficient than operating in a single world.\n2) Since most of the computations and intermediate values in machine learning are decimal numbers, we embed them over a ring by allocating the least significant bits to the fractional part. But several multiplications performed may lead to an overflow. A naive solution to avoid this is to use a large ring to accommodate a fixed number of multiplications, but the number of multiplications for machine learning varies based on the algorithm, making this infeasible. SecureML tackled this problem through truncation, which approximates the value by sacrificing the accuracy by an infinitesimal amount, performed after every multiplication. This technique, however, does not extend into the 3PC or 4PC setting, due to the attack described in ABY3, requiring us to come up with new techniques.\nFrameworks such as SecureML and ABY3 have tackled both these issues in the honest majority setting by proposing ways to switch between the three worlds efficiently, as well as efficient ways to do truncation. ABY3 is a lot more efficient than SecureML, in large part due to the 3PC primitives it uses. But ABY3 cannot avoid some expensive operations such as evaluation of a Ripple Carry Adder (RCA) in its truncation and activation functions. Truncation and activation functions -ReLU and Sigmoid, need rounds proportional to the underlying ring size in ABY3. This gives a lot of scope for improvement in the efficiency, which we achieve through our 4PC framework.", "publication_ref": ["b42", "b2", "b5"], "figure_ref": [], "table_ref": []}, {"heading": "A. Our Contribution", "text": "We propose an efficient framework for mixed world computations in the four-party honest majority setting with active security over the ring Z 2 \u2113 . Our protocols are optimized for PPML and follow the offline-online paradigm. Our improvements come from having an additional honest party in the protocol. Our contributions can be summed up as follows:\n1) Efficient 4PC Protocol: We propose an efficient four-party protocol with active security which proceeds through a masked evaluation inspired by Gordon et al. [27]. Our protocol requires 3 ring elements in the online phase per multiplication as opposed to 4 of [27], achieving a 25% improvement. This improvement is achieved by not compromising on the total cost (6 ring elements). Another significant advantage of our protocol is that the fourth party is not required for evaluation in the online phase. This is not the case with [27], where all the parties need to be online throughout the protocol execution. In addition to the stated contributions, our framework also achieves fairness without affecting the complexity of a multiplication gate.", "publication_ref": ["b26", "b26", "b26"], "figure_ref": [], "table_ref": []}, {"heading": "Conversion", "text": "Ref.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Rounds Communication", "text": "G2B ABY3 1 \u03ba This 1 3 G2A ABY3 1 2\u2113\u03ba This 1 3\u2113 B2G ABY3 1 2\u03ba This 1 \u03ba A2G ABY3 1 2\u2113\u03ba This 1 \u2113\u03ba A2B ABY3 1 + log \u2113 9\u2113 log \u2113 + 9\u2113 This 1 + log \u2113 3\u2113 log \u2113 + \u2113 B2A ABY3 1 + log \u2113 9\u2113 log \u2113 + 9\u2113 This 1 3\u2113\nTable I: Online cost of share conversions of ABY3 [6] and This work. \u2113 denotes the size of underlying ring in bits and \u03ba denotes the computational security parameter.\n2) Fast Mixed World Computation: We propose a framework -Trident, that is geared towards a high throughput online phase as compared to the existing alternatives. This throughput is achieved by making use of an additional honest party. Every one of the conversions we propose to switch between the worlds is more efficient in terms of online communication complexity as compared to ABY3, with our improvements ranging from 2\u00d7 to 2\u03ba/3\u00d7, where \u03ba denotes the computational security parameter. More concretely, if we aim for 128-bit computational security, our framework gives a maximum improvement of \u2248 85\u00d7. For instance, the technique we propose to perform bit composition (B2A) requires only 1 round, as opposed to 1+log \u2113 rounds in ABY3, which translates to a 7\u00d7 gain for a 64-bit ring. The table below provides the concrete cost of our online phase in comparison to ABY3. The overall cost comparison can be found in Table IX.\n3) Efficient Truncation: The highlight of the protocol we propose for truncation is that it can be combined with our multiplication protocol with no additional cost in the online phase. In contrast, the online cost for multiplication in ABY3 increases from 9 to 12 ring elements, which gives us a 4\u00d7 improvement in online communication. Moreover, we forgo the need for (2\u2113 \u2212 2)-round Ripple Carry Adders (RCA), as opposed to ABY3, in the offline phase resulting in an improvement of 63\u00d7 in rounds for a 64-bit ring.", "publication_ref": ["b5"], "figure_ref": [], "table_ref": ["tab_20"]}, {"heading": "Conversion", "text": "Ref.   We also provide results for the prediction phase and give throughput (no. of predictions per second) comparison details for the aforementioned algorithms, using real-world datasets. The gain in online throughput for prediction ranges from 3\u00d7 to 145.18\u00d7 for Linear Regression and 3\u00d7 to 158.40\u00d7 for Logistic Regression over LAN and WAN combined. Similarly, the online throughput gain ranges from 335.44\u00d7 to 421.72\u00d7 for NN and 598.44\u00d7 to 759.65\u00d7 for CNN.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Rounds Communication", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Multiplication with Truncation", "text": "ABY3 1 12\u2113 This 1 3\u2113 Secure Comparison ABY3 log \u2113 18\u2113 log \u2113 This 3 5\u2113 + 2 Bit2A b B \u2192 b ABY3 2 18\u2113 This 1 3\u2113 BitInj b B v \u2192 bv ABY3 3", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "II. PRELIMINARIES AND DEFINITIONS", "text": "We consider a set of four parties P = {P 0 , P 1 , P 2 , P 3 } that are connected by pair-wise private and authentic channels in a synchronous network. The function f to be evaluated is expressed as a circuit ckt, whose topology is publicly known and is evaluated over either an arithmetic ring Z 2 \u2113 or a Boolean ring Z 2 1 , consisting of 2-input addition and multiplication gates. The term D denotes the multiplicative depth of the circuit, while I, O, A, M denote the number of input wires, output wires, addition gates and multiplication gates respectively in ckt.\nWe use the notation w v to denote a wire w with value v flowing through it. We use g = (w x , w y , w z , op) to denote a gate in the ckt with left input wire w x , right input wire w y , output wire w z and operation op, which is either addition (+) or multiplication (\u00d7).\nFor a vector x, x i denotes the i th element in the vector. For two vectors x and y of length d, the dot product is given by,\nx \u2299 y = d i=1 x i y i .\nGiven two matrices X, Y, the operation X \u2022 Y denotes the matrix multiplication. a) Shared Key Setup: In order to facilitate noninteractive communication, parties use functionality F setup that establishes pre-shared random keys for a pseudo-random function (PRF) among them. Similar setup for the three-party case can be found in [5], [6], [12], [13], [26].\nIn our protocols, we make use of a collision-resistant hash function, denoted by H(), to save communication. We defer the formal details of key setup and hash function to Appendix A.", "publication_ref": ["b4", "b5", "b11", "b12", "b25"], "figure_ref": [], "table_ref": []}, {"heading": "III. OUR 4PC PROTOCOL", "text": "In this section, we provide details for our 4PC protocol. We begin with the sharing semantics in Section III-A followed by explaining the relevant building blocks in Section III-B.\nWe elaborate on the stages of our protocol in Section III-C. Lastly, in Section III-D, we show how to improve the security to achieve fairness.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "A. Sharing Semantics", "text": "In this section, we explain three variants of secret sharing that are used in this work. The sharings work over both arithmetic (Z 2 \u2113 ) and boolean (Z 2 1 ) rings.\na) [\u2022]-sharing: A value v is said to be [\u2022]-shared among parties P 1 , P 2 , P 3 , if the parties P 1 , P 2 and P 3 respectively hold the values v 1 , v 2 and v 3 such that\nv = v 1 + v 2 + v 3 . We use [\u2022] Pi to denote the [\u2022]-share of party P i for i \u2208 {1, 2, 3}. b) \u2022 -sharing: A value v\nis said to be \u2022 -shared among parties P 1 , P 2 , P 3 , if the parties P 1 , P 2 and P 3 respectively holds values\n(v 2 , v 3 ), (v 3 , v 1 ) and (v 1 , v 2 ) such that v = v 1 + v 2 + v 3 .\nWe denote \u2022 -shares of the parties as follows:\nv P1 = (v 2 , v 3 ), v P2 = (v 3 , v 1 ), v P3 = (v 1 , v 2 ) c) \u2022 -sharing: A value v is said to be \u2022 -shared among parties P 0 , P 1 , P 2 , P 3 , if -there exist values \u03bb v , m v \u2208 Z 2 \u2113 such that m v = v + \u03bb v .\n-parties P 1 , P 2 , P 3 know the value m v in clear, while the value \u03bb v is \u2022 -shared among them.\n-party P 0 knows \u03bb v,1 , \u03bb v,2 and \u03bb v,3 in clear.\nWe denote the \u2022 -shares of the parties as follows:\nv P 0 = (\u03bbv,1, \u03bbv,2, \u03bbv,3) v P 1 = (mv, \u03bbv,2, \u03bbv,3) v P 2 = (mv, \u03bbv,3, \u03bbv,1) v P 3 = (mv, \u03bbv,1, \u03bbv,2)\nWe use v = (m v , \u03bb v ) to denote the \u2022 -share of v. [c\n1 x + c 2 y] = (c 1 x 1 + c 2 y 1 , c 1 x 2 + c 2 y 2 , c 1 x 3 + c 2 y 3 ) = c 1 [x] + c 2 [y]\nIt is easy to see that the linearity trivially extends to \u2022 -sharing as well. That is c 1 x + c 2 y = c 1 x + c 2 y . Similarly, given the \u2022 -sharing of x, y and public constants c 1 , c 2 , parties can locally compute c 1 x + c 2 y . Note that the linearity property enables parties to non-interactively evaluate an addition gate as well as perform the multiplication of their shares with a public constant.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "B. Building Blocks", "text": "a) Sharing Protocol: Protocol \u03a0 Sh (Fig. 1) enables party P i to generate \u2022 -share of value v. The offline phase is done using the pre-shared keys in such a way that P i will get the entire mask \u03bb. During the online phase, P i computes m v and sends to P 1 , P 2 , P 3 who exchange the hash values to check for consistency.", "publication_ref": [], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "Offline:", "text": "-If Pi = P0, parties in P \\ {Pj } together sample \u03bbv,j for j \u2208 {1, 2, 3}.\nProtocol \u03a0 Sh (Pi, v)\n-If Pi = P k for k \u2208 {1, 2, 3}, parties in P together sample \u03bb v,k . In addition, parties in P \\ {Pj } together sample \u03bbv,j for j \u2208 {1, 2, 3} \\ {k}.\nOnline:\n-Pi computes mv = v + \u03bbv and sends to P1, P2, P3.\n-P1, P2, P3 mutually exchange H(mv) and abort if the received values are inconsistent. Looking ahead, we also encounter scenarios where party P 0 has to generate \u2022 -sharing of a value v in the offline phase.\nWe call the resultant protocol as \u03a0 aSh and the formal details appear in Fig. 2.\nOffline:\n-Parties in P \\ {P1} sample random v1 \u2208 Z 2 \u2113 , while parties in P \\ {P2} sample random v2.\n-P0 computes v3 = \u2212(v + v1 + v2) and sends it to both P1 and P2, who exchange H(v3) and abort if there is a mismatch.\nProtocol \u03a0 aSh (P0, v) b) Reconstruction Protocol: Protocol \u03a0 Rec (P, v) (Fig. 3) enables parties in P to compute v, given its \u2022 -share. Towards this, each party receives the missing share from one other party and hash of the missing share from one of the other two parties. If the received shares are consistent, he/she will proceed with the reconstruction. Reconstruction towards a single party can be viewed as a special case of this protocol.", "publication_ref": [], "figure_ref": ["fig_2", "fig_3"], "table_ref": []}, {"heading": "Online:", "text": "-P1 receives \u03bbv,1 and H(\u03bbv,1) from P2 and P0 respectively. -P2 receives \u03bbv,2 and H(\u03bbv,2) from P3 and P0 respectively. -P3 receives \u03bbv,3 and H(\u03bbv,3) from P1 and P0 respectively. -P0 receives mv and H(mv) from P1 and P2 respectively. \nPi for i \u2208 {0, 1, 2, 3} abort if the received values are inconsistent. Else computes v = mv \u2212 \u03bbv,1 \u2212 \u03bbv,2 \u2212 \u03bbv,3. Protocol \u03a0 Rec (P, v )", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "C. Stages of our 4PC protocol", "text": "Our protocol \u03a0 4PC consists of three stages, namely -Input Sharing, Evaluation and Output Reconstruction. We elaborate on each of these stages below. a) Input Sharing: For each wire w v holding the value v, of which P i \u2208 P is the owner, he/she generates \u2022 -share of v by executing the \u03a0 Sh (P i , v) protocol.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "b) Evaluation:", "text": "In this stage, parties evaluate the circuit in a topological order, where the following invariant is maintained for every gate g: given the inputs of g in \u2022 -shared fashion, the output is generated in the \u2022 -shared fashion. For the case of an addition gate g = (w x , w y , w z , +), the linearity of our sharing scheme maintains this invariant.\nFor a multiplication gate g = (w x , w y , w z , \u00d7), the protocol proceeds as follows: during the offline phase, parties P 1 , P 2 , P 3 locally compute [\u2022]-shares of \u03b3 xy = \u03bb x \u03bb y , followed by exchanging them to form a \u2022 -sharing of \u03b3 xy . Before exchanging the shares of \u03b3 xy , the parties randomize the shares by adding a share of 0 to the share of \u03b3 xy to prevent leakage. In addition, P 0 helps the parties in verifying the correctness of shares received in the aforementioned step. During the online phase, the goal is to compute m z . Note that,\nm z = z + \u03bb z = xy + \u03bb z = (m x \u2212 \u03bb x )(m y \u2212 \u03bb y ) + \u03bb z = m x m y \u2212 \u03bb x m y \u2212 \u03bb y m x + \u03bb x \u03bb y + \u03bb z\nParties P 1 , P 2 , P 3 locally compute [\u2022]-share of m z \u2212 m x m y followed by an exchange to reconstruct m z \u2212 m x m y . By the nature of our secret-sharing scheme, every missing share can be computed by two parties. This facilitates the parties to verifiably reconstruct m z \u2212 m x m y by having one party send the missing share and the other send a hash of the same.\nEach of P 1 , P 2 , P 3 locally add m x m y to the result to obtain m z . We call the resultant protocol \u03a0 Mult (Fig. 4).", "publication_ref": [], "figure_ref": ["fig_4"], "table_ref": []}, {"heading": "Offline:", "text": "-Parties in P \\ {Pj } together sample \u03bbz,j for j \u2208 {1, 2, 3}.\n-Parties invoke protocol \u03a0 Zero (Fig. 21) to generate A, B, \u0393 such that A + B + \u0393 = 0. Parties locally compute the following: -P0, P1 compute \u03b3xy,2 = \u03bbx,2\u03bby,2 + \u03bbx,2\u03bby,3 + \u03bbx,3\u03bby,2 + A.\n-P0, P2 compute \u03b3xy,3 = \u03bbx,3\u03bby,3 + \u03bbx,3\u03bby,1 + \u03bbx,1\u03bby,3 + B.\n-P0, P3 compute \u03b3xy,1 = \u03bbx,1\u03bby,1 + \u03bbx,1\u03bby,2 + \u03bbx,2\u03bby,1 + \u0393.\n-Parties exchange the following: -P1 receives \u03b3xy,3 and H(\u03b3xy,3) from P2 and P0 respectively.\n-P2 receives \u03b3xy,1 and H(\u03b3xy,1) from P3 and P0 respectively.\n-P3 receives \u03b3xy,2 and H(\u03b3xy,2) from P1 and P0 respectively.\n-Pi for i \u2208 {1, 2, 3} abort if received values are inconsistent. \nOnline: Let m \u2032 z = mz \u2212 mxmy. -Parties locally compute the following: -P1, P3 compute m \u2032 z,2 = \u2212\u03bbx,2my \u2212 \u03bby,2mx + \u03b3xy,2 + \u03bbz,2. -P2, P1 compute m \u2032 z,3 = \u2212\u03bbx,3my \u2212 \u03bby,3mx + \u03b3xy,3 + \u03bbz,3. -P3, P2 compute m \u2032 z,1 = \u2212\u03bbx,\n= (m \u2032 z,1 + m \u2032 z,2 + m \u2032 z,3 ) + mxmy = m \u2032 z + mxmy.\nProtocol \u03a0 Mult (wx, wy, wz) As a very important optimization, note that the exchange of hash values for every multiplication gate can be delayed until the output reconstruction stage. Moreover, all the corresponding values can be appended and hashed, resulting in an overall communication of only 3 ring elements. c) Output Reconstruction: For each of the output wire w y with value y, parties execute protocol \u03a0 Rec (P, y ) to reconstruct the output.\nCorrectness and Security: We prove the correctness of \u03a0 4PC below and defer the security details to Appendix F. Theorem III.1 (Correctness). Protocol \u03a0 4PC is correct.\nProof: We claim that for every wire in ckt, the parties hold a \u2022 -sharing of the wire value in \u03a0 4PC . The correctness for the input and output wires follows from \u03a0 Sh and \u03a0 Rec respectively. The claim for addition gates follows from the linearity of \u2022sharing. For a multiplication gate g = (w x , w y , w z , \u00d7), when evaluated using \u03a0 Mult , the parties receive xy + \u03bb z in the online phase, resulting in obtaining z . The correctness of xy + \u03bb z is ensured through the verified reconstruction as shown in \u03a0 Mult .\nTheorem III.2 (Communication Efficiency). \u03a0 4PC requires one round with an amortized communication of 3M ring elements during the offline phase. In the online phase, \u03a0 4PC requires one round with an amortized communication of at most 3I ring elements in the Input-sharing stage, D rounds with an amortized communication of 3M ring elements for evaluation stage and one round with an amortized communication of 3O elements for the output-reconstruction stage.", "publication_ref": [], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "D. Achieving Fairness", "text": "For fairness, we need to ensure that all the parties are alive in the protocol during the output reconstruction stage. On top of this, we also need to prevent the adversary from mounting a selective abort attack, where he can make some of the honest parties abort the protocol. To achieve this, parties P 1 , P 2 , P 3 set a bit b to continue, if the verification of the multiplication gates was successful, else set it to abort, and send it to P 0 . P 0 then sends abort back to all the parties if one of the parties sends abort, thus ensuring aliveness. Remaining parties then exchange their reply from P 0 and follow the honest-majority in deciding whether to proceed or abort. Since there can be only 1 corruption, all the parties will now be on the same page, preventing a selective abort. If the parties decide to proceed, they exchange the missing shares. Using the fact that there is at most 1 corruption and the structure of our secret-sharing scheme, the most commonly received missing share will be consistent among the honest parties. Protocol \u03a0 fRec (P, v )\n-Pi for i \u2208 {0, 1, 2, 3} chooses the missing share that forms the majority and computes v = mv \u2212 \u03bbv,1 \u2212 \u03bbv,2 \u2212 \u03bbv,3. ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "IV. MIXED PROTOCOL FRAMEWORK", "text": "In this section, we present our mixed protocol framework, Trident. Before we go into the details of it, we discuss another world of MPC, called The Garbled World. To evaluate circuits over a ring Z 2 \u2113 , we operate in the arithmetic world and to evaluate boolean circuits (Z 2 \u2113 ) we use either the boolean world or the Garbled world, depending on the operation being performed. Superscripts {A, B, G} are used to indicate the respective worlds. If there is no superscript, the values are assumed to operate in the arithmetic world.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "A. The Garbled World", "text": "For the Garbled world, we use the MRZ [17] scheme in the 4PC setting. In 4PC, parties P 1 , P 2 , P 3 act as the garblers and the party P 0 acts as the sole evaluator. As an optimisation, P 0 can share his inputs with only P 1 , P 2 instead of all three parties. For cross-verification, P 1 sends the garbled circuit to P 0 while P 2 sends a hash of the it to P 0 . We incorporate the recent optimisations including free XOR [45], [46], half-gates [47], [48], fixed-key AES garbling [49]. As opposed to the dishonest majority setting, this scheme removes the need for expensive public key primitives (in terms of communication) such as Oblivious Transfers altogether. We present the protocols for a single bit, and each operation can be performed \u2113 times in parallel to support \u2113-bit values.", "publication_ref": ["b16", "b44", "b45", "b46", "b47", "b48"], "figure_ref": [], "table_ref": []}, {"heading": "a) Sharing Semantics", "text": ": For a bit v, v G is defined as v G Pi = K 0 v \u2208 {0, 1} \u03ba for i \u2208 {1, 2, 3} and v G P0 = K v v = K 0 v \u2295 vR,\nwhere \u03ba is the computational security parameter. Here R is a global offset with the least significant bit as one, and is known only to P 1 , P 2 , P 3 (generated by shared randomness), and R is common across all the \u2022 G -sharing. It is easy to see that XOR of the least significant bit of\nv G P1 (resp. v G P2 , v G P3 ) and v G P0 is v. For a value v \u2208 Z 2 \u2113 , we abuse the notation v G to denote the set of \u2022 G -shares of each bit of v. Offline: -P1, P2, P3 samples a random K 0 v \u2208 {0, 1} \u03ba , computes K 1 v = K 0 v \u2295 R and set v G P 1 = v G P 2 = v G P 3 = K 0 v . -P1, P2, P3 compute commitment of K 0 v , K 1 v .\nP1, P2 send the commitments to P0 in a random permuted order, who abort if the received commitments mismatch.\nOnline:\n-Pi sends K 0 v \u2295 vR to P0, who sets it as v G P 0 . -Pi decommits the right key K v v to P0, who abort if the decommitment is incorrect. Protocol \u03a0 G Sh (Pi, v) Figure 6: \u2022 G -sharing of v by Pi for i \u2208 {1, 2, 3}. b) Input Sharing: Protocol \u03a0 G Sh (P i , v\n) enables P i to generate \u2022 G -sharing of value v. During the protocol, P 0 needs to ensure that it obtains the correct K v v . To tackle this, we make the garblers commit both keys to P 0 , who can then verify the correctness by cross-checking the commitments received. The formal details for the case when P i is one of the garblers appear in Fig. 6.\nIf P i = P 0 , then \u03a0 G Sh (P i , v\n) proceeds as follows: P 0 samples random bit v 1 , computes v 2 = v \u2295 v 1 and sends v 1 and v 2 to P 1 and P 2 respectively. Parties execute\n\u03a0 G Sh (P 1 , v 1 ) and \u03a0 G Sh (P 2 , v 2 ) to generate v 1 G and v 2 G respectively. Parties then locally compute v G = v 1 G \u2295 v 2 G\n, using the XOR gate evaluation method via the free-XOR technique.\nHere, the commitments of the keys need not be permuted, as P 0 already knows the actual v 1 and v 2 . As an optimization, the computation of v 1 G can be offloaded to the offline phase. c) Reconstruction: If P i = P 0 , then P 1 , P 2 send the least significant bit of their shares and P i verifies if it received the same bit from both P 1 and P 2 . If P i is one of the garblers, then P 0 sends its share to P i . Due to the authenticity of the underlying garbling scheme [50], a corrupt P 0 cannot send an incorrect share to P i . If there are multiple reconstructions towards P i \u2208 {P 1 , P 2 , P 3 }, P 0 can send the least significant bit of its shares along with a hash of all the corresponding shares.\nd) Operations: Let u, v \u2208 {0, 1} be \u2022 G -shared with P 1 , P 2 , P 3 holding the shares (K 0 u , K 0 v ), and P 0 holding the shares (K 0 u \u2295 uR, K 0 v \u2295 vR). Let c denote the output. -XOR: The parties locally compute c G = u G \u2295 v G .\n-AND: P 1 , P 2 , P 3 sample random K 0 c \u2208 {0, 1} \u03ba , compute K 1 u = K 0 u \u2295 R and construct a garbled table for AND using the garbling scheme described in [47], [49]. P 1 sends the garbled table to P 0 , while P 2 sends a hash of the table to P 0 . P 0 evaluates the table 1 \nto obtain c G P0 = K c c . P i for i \u2208 {1, 2, 3} sets c G Pi = K 0 c .", "publication_ref": ["b49", "b46", "b48", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "B. Building Blocks", "text": "a) Verifiable Arithmetic/Boolean Sharing: Protocol \u03a0 vSh (Fig. 7) allows two parties P i , P j to generate \u2022 -sharing of value v in a verifiable manner. On a high level, P i executes \u03a0 Sh on v, while P j helps in verification by sending H(m v ) to parties P 1 , P 2 , P 3 .\nOffline: Parties execute offline steps of \u03a0 Sh (Pi, v).", "publication_ref": [], "figure_ref": ["fig_7"], "table_ref": []}, {"heading": "Online:", "text": "-Pi computes mv = v + \u03bbv and sends to P1, P2, P3.\n-Pj computes H(mv) and sends to P1, P2, P3, who abort if the received values are inconsistent. We observe that the parties can non-interactively generate \u2022 -sharing of a value v when all of the parties P 1 , P 2 , P 3 know v. Parties set \u03bb v,1 = \u03bb v,2 = \u03bb v,3 = 0 and m v = v. We abuse the notation and use \u03a0 vSh (P 1 , P 2 , P 3 , v) to denote this protocol. b) Verifiable Garbled Sharing: Protocol \u03a0 G vSh (Fig. 8) is adapted from ABY3 [6] and allows two parties P i , P j to generate \u2022 G -sharing of value v in a verifiable manner. When P i , P j are both garblers, one of them can send the key while the other can send just the hash to check for inconsistency. If P 0 = P j , the other parties (P 1 , P 2 ) send commitments of the keys in order, to P 0 . In addition, P i sends the decommitment of the actual key to P 0 .\nProtocol \u03a0 vSh (Pi, Pj, v)\nOffline: P1, P2, P3 locally sample random K 0 v \u2208 {0, 1} \u03ba , compute K 1 v = K 0 v \u2295 R and set v G P 1 = v G P 2 = v G P 3 = K 0 v .\nOnline:\n-If (Pi, Pj ) = (P1, P0): -P1, P2 compute commitments Com(K 0 v ), Com(K 1 v\n) and send it to P0. In addition, P1 sends decommitment of Com(K v v ) to P0.\n-P0 abort if either the received commitments are inconsistent or the decommitment is incorrect. Else he/she sets v\nG P 0 = K v v . -If (Pi, Pj) = (P k , P0) for k \u2208 {2, 3}:\nThe steps are similar as above.\n-If (Pi, Pj ) = (P1, P2): P1 and P2 sends K v v and H(K v v ) respectively to P0, who abort if the received values are inconsistent. Else he/she sets v G c) Dot Product: Given two vectors x and y, each of size d, \u03a0 DotP (Fig. 9) computes the dot product z = x \u2299 y. ABY3 [6] and ASTRA [26] have proposed efficient dot product protocols for the semi-honest and malicious settings. In the semi-honest case, their dot product cost is the same as a single multiplication, but for the malicious case it scales with the vector size. In comparison, the cost of our dot product is independent of the vector size. On a high level, instead of performing reconstruction for each multiplication x j \u2022 y j for j \u2208 {1, . . . , d}, parties locally add their shares corresponding to all the multiplications and perform a single exchange.\nP 0 = K v v . -If (Pi, Pj) = (P1, P3) or (P2,\nLet z = x \u2299 y.", "publication_ref": ["b5", "b5", "b25"], "figure_ref": ["fig_8", "fig_9"], "table_ref": []}, {"heading": "Offline:", "text": "-Parties in P \\ {Pj } together sample \u03bbz,j for j \u2208 {1, 2, 3}.\n-Parties invoke protocol \u03a0 Zero (Fig. 21) to generate A, B, \u0393 such that A + B + \u0393 = 0. Parties locally compute the following: -P0, P1 compute \u03b3xy,2 = d j=1 \u03b3x j y j ,2 = d j=1 (\u03bbx j ,2\u03bby j ,2 + \u03bbx j ,2\u03bby j ,3 + \u03bbx j ,3\u03bby j ,2) + A.\n-P0, P2 compute \u03b3xy,3 = d j=1 \u03b3x j y j ,3 = d j=1 (\u03bbx j ,3\u03bby j ,3 + \u03bbx j ,3\u03bby j ,1 + \u03bbx j ,1\u03bby j ,3) + B.\n-P0, P3 compute \u03b3xy,1 = d j=1 \u03b3x j y j ,1 = d j=1 (\u03bbx j ,1\u03bby j ,1 + \u03bbx j ,1\u03bby j ,2 + \u03bbx j ,2\u03bby j ,1) + \u0393.\n-Parties exchange the following:\nProtocol \u03a0 DotP ( x, y)\n-P1 receives \u03b3xy,3 and H(\u03b3xy,3) from P2 and P0 respectively. -P2 receives \u03b3xy,1 and H(\u03b3xy,1) from P3 and P0 respectively. -P3 receives \u03b3xy,2 and H(\u03b3xy,2) from P1 and P0 respectively.\n-Pi for i \u2208 {1, 2, 3} abort if the received values are inconsistent.\nOnline: Let m \u2032 z = mz \u2212 d j=1 mx j my j . -Parties locally compute the following: -P1, P3:  \nm \u2032 z,2 = d j=1 (\u2212\u03bbx j ,2my j \u2212 \u03bby j ,2mx j ) + \u03b3xy,2 + \u03bbz,2. -P2, P1: m \u2032 z,3 = d j=1 (\u2212\u03bbx j ,3my j \u2212 \u03bby j ,3mx j ) + \u03b3xy,3 + \u03bbz,3. -P3, P2: m \u2032 z,1 = d j=1 (\u2212\u03bbx j ,1my j \u2212 \u03bby j ,1mx j ) + \u03b3xy,1 + \u03bbz,1. -Parties\n= (m \u2032 z,1 + m \u2032 z,2 + m \u2032 z,3 ) + + d j=1 (mx j my j ) = m \u2032 z + d j=1 (mx j my j ).", "publication_ref": [], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "C. Sharing Conversions", "text": "We now discuss the inter-sharing conversions among Arithmetic, Boolean, and Garbled sharing.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "a) Garbled to Boolean Sharing (G2B):", "text": "To convert a garbled share into the boolean world, P 1 , P 2 first generate the garbled and boolean shares of a random value (r) using their shared randomness in the offline phase. In addition, they communicate the garbled circuit which performs the XOR of two bits along with the decoding information (Note that the garbled circuit does not have to be communicated due to the free XOR technique). In the online phase, P 0 evaluates and obtains v \u2295 r and sends it to P 3 along with the hash of the corresponding key. Authenticity of the underlying garbling scheme ensures that a corrupt P 0 cannot send the wrong bit, as he will not be able to guess the right key for it.\nOffline:\n-P1, P2 locally sample random r \u2208 Z 2 \u2113 . Parties execute \u03a0 G\nvSh (P1, P2, r) and \u03a0 B vSh (P1, P2, r) to generate r G and r B respectively.\n-P1, P2, P3 garble a boolean adder circuit Add(x, y) that computes x \u2295 y. P1 sends the garbled circuit along with the decoding information to P0, while P2 sends a combined hash to P0.\nOnline:\n-P0 evaluates the circuit Add on v and r to obtain v \u2295 r. P0 sends v \u2295 r along with a hash of the actual key corresponding to v \u2295 r to P3. P3 abort if the received values are inconsistent.\n-Else, parties execute b) Garbled to Arithmetic Sharing (G2A): This conversion proceeds in a similar way as \u03a0 G2B . The major difference is that instead of the garbled circuit for XOR, the parties communicate a circuit for subtraction of two \u2113-bit values. Note that P 0 needs to communicate only a single hash combining all the keys corresponding to the \u2113-bits of v\u2212r.\n\u03a0 B vSh (P3, P0, v \u2295 r) to generate v \u2295 r B . -Parties locally compute v B = v \u2295 r B \u2295 r B .", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Protocol \u03a0 G2B", "text": "Offline:\n-P1, P2 locally sample random r \u2208 Z 2 \u2113 . Parties execute \u03a0 G vSh (P1, P2, r) and \u03a0 A vSh (P1, P2, r) to generate r G and r A respectively.\n-P1, P2, P3 garble a subtractor circuit Sub(x, y) that computes\nx \u2212 y. P1 sends the garbled circuit along with the decoding information to P0, while P2 sends a combined hash to P0, who abort if the received values are inconsistent.\nOnline:\n-P0 evaluates the circuit Sub on v and r to obtain v \u2212 r. P0 sends v \u2212 r along with a combined hash of all the actual keys corresponding to v \u2212 r to P3. P3 abort if the received values are inconsistent.\n-Else, parties execute \n\u03a0 A vSh (P3, P0, v \u2212 r) to generate v \u2212 r A . -Parties locally compute v A = v \u2212 r A + r A . Protocol \u03a0 G2A", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "c) Boolean to Garbled Sharing (B2G): Since the bit", "text": "v = (m v \u2295 \u03bb v,1 ) \u2295 (\u03bb v,2 \u2295 \u03bb v,3\n) in the boolean world, if we can get the garbled shares of x = (m v \u2295\u03bb v,1 ) and y = (\u03bb v,2 \u2295\u03bb v,3 ), parties can use the free XOR technique to compute the garbled shares of v locally. Each of x, y is possessed by two parties, enabling them to verifiably generate the garbled shares using the protocol \u03a0 G vSh .\nOffline: P0, P1 execute \u03a0 G vSh (P1, P0, y) to generate y G where y = \u03bbv,2 \u2295 \u03bbv,3.\nOnline: \n-P2, P3 execute \u03a0 G vSh (P2, P3, x) to generate x G where x = mv \u2295 \u03bbv,1. -Parties locally compute v G = x G \u2295 y G . Protocol \u03a0 B2G", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "d) Arithmetic to Garbled Sharing (A2G):", "text": "Similar to \u03a0 B2G , v = (m v \u2212 \u03bb v,1 ) \u2212 (\u03bb v,2 + \u03bb v,3\n) and the parties can verifiably generate the garbled shares of x = (m v \u2212 \u03bb v,1 ) and y = (\u03bb v,2 + \u03bb v,3 ) using \u03a0 G vSh . In the online phase, the parties evaluate a garbled subtractor circuit to obtain the shares of v = x \u2212 y.\nOffline:\n-P0, P1 execute \u03a0 G vSh (P1, P0, y) to generate y G where y = \u03bbv,2 + \u03bbv,3.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Protocol \u03a0 A2G", "text": "-P1, P2, P3 garble a subtractor circuit Sub(x, y) that computes\nx \u2212 y. P1 sends the garbled circuit to P0, while P2 sends a hash of the same to P0, who abort if the received values are inconsistent.\nOnline:\n-P2, P3 execute \u03a0 G vSh (P2, P3, x) to generate x G where x = mv \u2212 \u03bbv,1.\n-Parties compute v G = x G \u2212 y G by evaluating circuit Sub.  \n) \u2032 = u + r \u2032 b \u2212 2ur \u2032\nb where the superscript ( \u2032 ) denotes the corresponding bits over ring Z 2 \u2113 . After the verification, parties locally convert u to u . In the online phase, parties multiply u , v to generate uv followed by locally computing b = v + u \u2212 2 uv . Note that since \u03bb v is set to 0 while executing \u03a0 Sh (P 1 , P 2 , P 3 , v) protocol, \u03b3 uv -sharing is not needed during multiplication.\nOffline: Let u and \u03bbu,i denote the bits \u03bb b and \u03bb b,i respectively over the ring Z 2 \u2113 . Here i \u2208 {1, 2, 3}.\n-P0 executes \u03a0 aSh (P0, u) (Fig. 2) to generate u . Let the shares be u P 1 = (u2, u3), u P 2 = (u3, u1), and u P 3 = (u1, u2).\n-P1, P2, P3 performs the following check: -P1, P2 sample a random ring element r and a random bit r b .  g) Boolean to Arithmetic Sharing (B2A): We use the fact that a value v can be expressed as\nLet r \u2032 b denotes the bit r b over ring Z 2 \u2113 . -P1 computes x1 = \u03bb b,3 \u2295 r b , y1 = (u2 + u3)(1 \u2212 2r \u2032 b ) + r \u2032 b + r and sends (x1, y1) to P3. -P2 computes y2 = u1(1 \u2212 2r \u2032 b ) \u2212 r and sends H(y2) to P3. -P3 computes x = \u03bb b \u2295 r b = x1 \u2295 \u03bb b,1 \u2295 \u03bb b,2 and abort if H(x \u2032 \u2212 y1) = H(\n\u2113\u22121 i=0 2 i \u2022 v i , where v i denotes the ith bit of v over a ring Z 2 \u2113 . Note that v = \u2113\u22121 i=0 2 i \u2022 v i = \u2113\u22121 i=0 2 i \u2022 (m \u2032 vi + \u03bb \u2032 ui \u2212 2m \u2032 vi \u2022 \u03bb \u2032 ui )\nwhere m \u2032 vi and \u03bb \u2032 ui denote the bits m vi and \u03bb ui respectively over the ring Z 2 \u2113 .\nThe offline phase of \u03a0 B2A proceeds similar to \u03a0 Bit2A , where each bit \u03bb vi for i \u2208 {0, . . . , \u2113 \u2212 1} is converted to \u2022 -share. During the online phase, parties locally compute [\u2022]-shares of v followed by generating \u2022 -shares of it by executing \u03a0 vSh protocol. Parties then locally add their shares to obtain v .\nOffline: Let vi denotes the ith bit of value v. Let pi and \u03bbp i ,j denote the bits \u03bbv i and \u03bbv i ,j respectively over the ring Z 2 \u2113 , where i \u2208 {0, . . . , \u2113 \u2212 1} and j \u2208 {1, 2, 3}.\n-Parties execute offline steps of \u03a0 Bit2A on each pi for i \u2208 {0, . . . , \u2113 \u2212 1}, to generate pi . Let the shares be pi P 1 = (pi,2, pi,3), pi P 2 = (pi,3, pi,1), and pi P 3 = (pi,1, pi,2).\nOnline: Let qi for i \u2208 {0, . . . , \u2113\u22121} denotes bit mv i over Z 2 \u2113 .\n-Parties compute the following:  \n-P1, P3 compute x = \u2113\u22121 i=0 2 i (qi + pi,2 \u2212 2qi \u2022 pi,2). -P2, P1 compute y = \u2113\u22121 i=0 2 i (pi,3 \u2212 2qi \u2022 pi,3). -P3, P2 compute z = \u2113\u22121 i=0 2 i (pi,1 \u2212 2qi \u2022 pi,1). -Parties generate x , y and z by executing \u03a0 vSh (P1, P3, x), \u03a0 vSh (P2, P1, y) and \u03a0 vSh (P3, P2, z) respectively. -Parties locally compute v = x + y + z . Protocol \u03a0 B2A\nb \u2022 v = (m b \u2295 \u03bb b )(m v \u2212 \u03bb v ) = x 0 \u2212 x 1 y 1 + x 2 y 2 + x 3 y 3\nOffline: Let y1 and y2 denote the values \u03bb b and \u03bb b \u03bbv respectively over Z 2 \u2113 . -P0 executes \u03a0 aSh (P0, yj ) to generate yj for j \u2208 {1, 2}. Let the shares be yj P 1 = (yj,2, yj,3), yj P 2 = (yj,3, yj,1), and Protocol \u03a0 BitInj yj P 3 = (yj,1, yj,2).\n-Parties verify the correctness of y1 using the steps similar to protocol \u03a0 Bit2A (Fig. 15). To verify the correctness of y2 , parties proceed as follows:\n-Parties execute \u03a0 Zero (Fig. 21) to generate A, B, \u0393 such that    [6], [26], where the most significant bit (msb) represents the sign and the last d bits represent the fractional part.\nA + B + \u0393 = 0. -P1 computes u2 = \u03bby 1 ,2\u03bbv,2 + \u03bby 1 ,2\u03bbv,3 + \u03bby 1 ,3\u03bbv,2 + A. -P2 computes u3 = \u03bby 1 ,3\u03bbv,3 + \u03bby 1 ,3\u03bbv,1 + \u03bby 1 ,1\u03bbv,3 + B. -P3 computes u1 = \u03bby 1 ,1\u03bbv,1 + \u03bby 1 ,1\u03bbv,2 + \u03bby 1 ,2\u03bbv,1 + \u0393. -P1\n-P1, P3 compute c2 = x0 \u2212 x1\u03bbv,2 + x2y1,2 + x3y2,2. -P2, P1 compute c3 = \u2212x1\u03bbv,3 + x2y1,3 + x3y2,3. -P3, P2 compute c1 = \u2212x1\u03bbv,1 + x2y1,1 + x3y2,1. -Parties execute \u03a0 vSh (P1, P3, c2), \u03a0 vSh (P2, P1,\nIn order to perform privacy-preserving machine learning, we need efficient instantiations of three components -Share Truncation, Secure Comparison, and Non-linear Activation Functions. This section covers our protocols for performing the aforementioned components.", "publication_ref": ["b5", "b25"], "figure_ref": ["fig_2", "fig_1", "fig_1"], "table_ref": []}, {"heading": "A. Share Truncation", "text": "We take inspiration for truncation from ABY3 [6], where they perform it on shares after evaluating a multiplication gate, preserving the underlying value with very high probability. Our approach improves upon ABY3 by not using any boolean circuits, thus improving the offline round complexity to constant.", "publication_ref": ["b5"], "figure_ref": [], "table_ref": []}, {"heading": "Offline:", "text": "-Parties execute the offline steps of protocol \u03a0 Mult (wx, wy, wz) apart from \u03bbz not being generated.\n-Parties locally sample the following random values:\nP \\ {P2} : r2, P \\ {P1} : r1, P \\ {P3} : r3\nProtocol \u03a0 MultTr (wx, wy, wz)\n-P0 locally compute r = r1 +r2+r3, locally truncates it to obtain r t and executes \u03a0 aSh (P0, r t ) to generate r t . Let the shares be r t P 1 = (r t 2 , r t 3 ), r t P 2 = (r t 3 , r t 1 ), and r t P 3 = (r t 1 , r t 2 ). -Let r d and r d,i denote the last d bits of r and ri respectively for i \u2208 {1, 2, 3}. Parties verify the correctness of r t as follows:\n-P1 samples a random element c and computes\nm1 = r2 \u2212 2 d r t 2 \u2212 r d,2 + c. P1 sends (m1, H(c)) to P2. -P2 computes m2 = (r1 + r3) \u2212 2 d (r t 1 + r t 3 ) \u2212 (r d,1 + r d,3\n) and abort if H(m1 + m2) = H(c).\n-Parties locally convert r t to r t by setting m r t = 0 and \u03bb r t = r t .\nOnline: Let z \u2032 = (z \u2212 r) \u2212 mxmy.\n-Parties locally compute the following:\n-P1, P3 compute [z \u2032 ] 2 = \u2212\u03bbx,2my \u2212 \u03bby,2mx + \u03b3xy,2 \u2212 r2. -P2, P1 compute [z \u2032 ] 3 = \u2212\u03bbx,3my \u2212 \u03bby,3mx + \u03b3xy,3 \u2212 r3. -P3, P2 compute [z \u2032 ] 1 = \u2212\u03bbx,1my \u2212 \u03bby,1mx + \u03b3xy,1 \u2212 r1.\n-Parties exchange the following: \n-P1 receives [z \u2032 ]\n(z \u2212 r) = [z \u2032 ] 1 + [z \u2032 ] 2 + [z \u2032 ] 3 + mxmy.\n-P1, P2, P3 locally truncates (z \u2212 r) to obtain (z \u2212 r) t , followed by executing \u03a0 vSh (P1, P2, P3, (z \u2212 r) t ) to generate (z \u2212 r) t .\n-Parties locally compute z t = (z \u2212 r) t + r t . We start by generating a random (r, r t ) in the offline phase, where r t is the truncated value of r. The truncated value of z can be obtained by first opening and truncating z \u2212 r, and then adding it to r t . Parties non-interactively generate r , such that P 0 obtains r. This is followed by P 0 generating r t , but since we cannot rely on P 0 , parties P 1 , P 2 , P 3 perform a check to ensure the correctness of the share. On a high level, parties check the relation r = 2 d r t + r d , where r d denotes the last d bits of r The formal details of the check are provided in the protocol above and the correctness appears in Lemma D.1.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "B. Secure Comparison", "text": "The secure comparison technique allows parties to check whether x < y, given arithmetic shares of x, y. In fixed point arithmetic, a simple way to achieve this is by computing x \u2212 y, and checking its sign, stored in the msb position. This protocol, inspired from [6], is called Bit Extraction (\u03a0 BitExt ), since it extracts a bit from the given arithmetic shares and outputs the boolean shares of the bit. Towards this, P 0 , P 3 generate the boolean sharing of y = \u03bb v,1 + \u03bb v,2 in the offline, while p 1 , P 2 generate the boolean sharing of x = m v \u2212 \u03bb v,3 in the online. Parties then evaluate the optimized Parallel Prefix Adder of [6] to obtain the MSB bit in boolean shared format. b) Sigmoid: In our protocols, we use the approximation of sigmoid function [3], [6], [26], defined as:", "publication_ref": ["b5", "b5", "b2", "b5", "b25"], "figure_ref": [], "table_ref": []}, {"heading": "C. Activation", "text": "sig(v) = \uf8f1 \uf8f2 \uf8f3 0 v < \u2212 1 2 v + 1 2 \u2212 1 2 \u2264 v \u2264 1 2 1 v > 1 2\nThis can be viewed as, sig(v) = (1\u2295b\n1 )b 2 (v+1/2)+(1\u2295b 2 ), where b 1 = 1 if v + 1/2 < 0 and b 2 = 1 if v \u2212 1/2 < 0.\nThe protocol is similar to that of relu apart from an additional bit extraction, bit multiplication and a bit injection is required.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "VI. IMPLEMENTATION AND BENCHMARKING", "text": "The improvements of our framework over the current stateof-the-art (ABY3) are showcased through our implementation, comparing the two. The training and prediction phases of Linear Regression, Logistic Regression, Neural Networks (NN), and Convolutional Neural Networks (CNN) are used for benchmarking. While we compare our construction with the malicious ABY3 in this section, the comparison of ours with the semi-honest version of ABY3 and with the 4PC protocol of Gordon et al. [27] are deferred to Appendix E. a) Environment Details: We provide results for both LAN (1Gbps bandwidth) and WAN (40Mbps bandwidth) settings. In the LAN setting, we have machines with 3.6 GHz Intel Core i7-7700 CPU and 32 GB RAM. In the WAN setting, we use Google Cloud Platform 2 with machines located in West Europe (P 0 ), East Australia (P 1 ), South Asia (P 2 ) and South East Asia (P 3 ). We use n1-standard-8 instances, where machines are equipped with 2.3 GHz Intel Xeon E5 v3 (Haswell) processors supporting hyper-threading, with 8 vCPUs, and 30 GB RAM. We measured the average roundtrip time (rtt) for communicating 1 KB of data between every pair of parties. Over the LAN setting, the rtt turned out to be 0.296ms. In the WAN setting, the rtt values were We implement our protocols using the ENCRYPTO library [51] in C++17 over a 64 bit ring. Since the codes for ABY3 and MRZ [17] are not publicly available, we implement their protocols in our environment. The hash function is instantiated using SHA-256. We use multi-threading, wherever possible, to facilitate efficient computation and communication among the parties. To even out the results, each experiment is run 20 times and the average values are reported.\nP 0 -P 1 P 0 -P 2 P 0 -P 3 P 1 -P 2 P 1 -P 3 P 2 -P", "publication_ref": ["b26", "b50", "b16"], "figure_ref": [], "table_ref": []}, {"heading": "b) Datasets:", "text": "To benchmark the training phase of machine learning algorithms, it is common practice to use synthetic datasets so that we have freedom to choose the parameters of the datasets. However, testing the accuracy of a trained model must be carried out with a real dataset, which is the MNIST [44] [54] 31 \u2248119000 CalCOFI (CI) -Oceanographic Data [55] 74 \u2248876000 Epileptic (EP) Seizures [56] 179 \u224811500 Food Recipes (RE) [57] 680 \u224820000 MNIST [44] 784 70000\nWe choose Boston, Weather and CalCOFI for linear regression, since they are best suited for it, while Candy, Epileptic and Recipes were chosen for logistic regression. For NN and CNN, we used the MNIST dataset.", "publication_ref": ["b43", "b53", "b54", "b43"], "figure_ref": [], "table_ref": []}, {"heading": "A. Secure Training", "text": "The training phase in most of the machine learning algorithms consists of two stages-i) forward propagation, where the model computes the output, and ii) backward propagation, where the model parameters are adjusted according to the computed output and the actual output. We define one iteration in the training phase as one forward propagation followed by a backward propagation.\nThis section covers the improvements in the training phase of our protocol as compared to ABY3. We report the performance in terms of the number of iterations over varying feature (d) and batch sizes (B), where d \u2208 {10, 100, 1000} and B \u2208 {128, 256, 512}. In LAN, we use iterations per second (#it/sec) as the metric, but since rtt is much higher for WAN, we instead use iterations per minute (#it/min). a) Linear Regression: For linear regression, one iteration can be viewed as updating the weight vector w using the Gradient Descent algorithm (GD). The update function for w is given by\nw = w \u2212 \u03b1 B X T i \u2022 (X i \u2022 w \u2212 Y i )\nwhere \u03b1 denotes the learning rate and X i denotes a subset of batch size B, randomly selected from the entire dataset in the ith iteration. Here the forward propagation consists of computing X i \u2022 w, while the weight vector is updated in the backward propagation. The update function consists of a series of matrix multiplications, which in turn can be achieved using dot product protocols. The operations of subtraction as well as multiplication by a public constant can be performed locally. We observe that the aforementioned update function can be computed entirely in the arithmetic domain and can be viewed in form of \u2022 -shares as\nw = w \u2212 \u03b1 B X T j \u2022 ( X j \u2022 w \u2212 Y j )\nTable IV provides concrete values for Linear Regression. Our improvement over LAN ranges from 4.88\u00d7 to 251.84\u00d7 and 2\u00d7 to 2.83\u00d7 over WAN. The gain comes due to two factors: One being the amount we save through our featureindependent communication of the dot product protocol (3 ring elements as opposed to 9d). The other factor is our efficient truncation protocol, which reduces the online communication from 12 elements to 3 elements -by 75%. The reason for the discrepancy in gains in LAN and WAN is because in LAN, the rtt is in the order of microseconds, and scales with the communication size. In contrast, the rtt in WAN is in the order of milliseconds and does not scale with communication up to a threshold, within which all our protocols operate.  b) Logistic Regression: The iteration for the case of logistic regression is similar to that of linear regression, apart from an activation function being applied on X i \u2022 w in the forward propagation. We instantiate the activation function using sigmoid (Section V-C). The update function for w is given by\nw = w \u2212 \u03b1 B X T i \u2022 (sig(X i \u2022 w) \u2212 Y i )\nOne iteration of logistic regression incurs an additional cost for computing sig(X j \u2022 w) as compared with that for linear regression.  Table V provides concrete values for Logistic Regression. Logistic Regression can be thought of as an execution of Linear Regression followed by a Sigmoid function on the output, due to which our improvements for Linear Regression carry over to Logistic. Our improvement ranges from 5.95\u00d7 to 67.88\u00d7 over LAN and 2.71\u00d7 to 2.96\u00d7 over WAN. Our efficient Sigmoid protocol takes this result further by improving upon the round and communication complexity. The round complexity is brought down to constant from 4 + log \u2113 to 5. Instantiated over ring Z 2 64 , this amounts to an improvement of 50%. The communication is also improved by \u2248 80% (from 81 elements to roughly 16). c) Neural Networks: For the case of NN, we follow steps similar to that of ABY3, where each node across all the layers, except the last layer, uses ReLU (relu) as the activation function. At the output layer, we use the MPC friendly variant of the softmax activation function, smx(u i ) = relu(ui) n f j=1 relu(uj) , proposed by SecureML [3]. In order to perform the division, we switch from arithmetic to garbled world and then use a division garbled circuit.\nThe network is trained using the Gradient Descent, where the forward propagation comprises of computing activation matrices for all the layers in the network. Here, the activation matrix for all the layers except the output, is defined as\nA i = relu(U i ), where U i = A i\u22121 \u2022 W i . A 0 is initialized to X j ,\nwhere X j is a subset of batch size B, randomly selected from the entire dataset for the j th iteration. The activation matrix for the output layer is defined as A m = smx(U m ).\nDuring the backward propagation, error matrices are computed first. The error matrix for the output layer is defined as E m = (A m \u2212 T), while for the remaining layers it is defined as\nE i = (E i+1 \u2022 W T i ) \u2297 drelu(U i ).\nHere the operation \u2297 denotes element wise multiplication and drelu denotes the derivative of ReLU. This is followed by updating the weights as  We consider a NN with two hidden layers, each having 128 nodes followed by an output layer of 10 nodes. After each layer, the activation function ReLU is applied. NN training involves one forward pass followed by one back-propagation. In LAN, the number of iterations is maximum with a batch of 128, at 22.99 #it/sec, and comes down to 7.70 with a batch size of 512. Similarly, over WAN it is maximum at 13.94 and comes down to 13.79. As expected, the #it/sec has not decreased with increase in features due to our dot product protocol being feature-independent in terms of communication. ABY3 on the other hand, has reported 2.5 #it/sec with a batch size of 128, in the computationally lighter semi-honest setting. Table VI above provides more details.\nW i = W i \u2212 \u03b1 B A T i\u22121 \u2022 E i .\nWe also considered a CNN discussed in [5] with 2 hidden layers, consisting of 100 and 10 nodes. Similar to ABY3, we overestimate the running time by replacing the convolutional kernel with a fully connected layer. In LAN, the number of iterations is maximum with a batch of 128, at 10.46 #it/sec, and comes down to 2.99 with a batch size of 512. Similarly, over WAN it is maximum at 13.86 and comes down to 13.16.", "publication_ref": ["b2", "b4"], "figure_ref": [], "table_ref": ["tab_9"]}, {"heading": "B. Secure Prediction", "text": "For Secure Prediction, we use online latency of the protocol as a metric to compare both works. The units are milliseconds in LAN and seconds in WAN. We use the MNIST dataset, which has 784 features, with a batch size of 1 and 100 for benchmarking. Our truncation protocol causes a bit-error at the least significant bit position, which is the same as that of ABY3 and SecureML [3] due to similarity in the techniques. We refer the readers to SecureML for a detailed analysis of the bit-error. The accuracy of the prediction itself however, ranges from 93% for linear regression to 98.3% for CNN.  For Linear Regression, our improvement ranges from 3\u00d7 to 126\u00d7, considering LAN and WAN together. For Logistic Regression, our improvement ranges from 3\u00d7 to 19.48\u00d7, considering LAN and WAN together. In NN, we achieve an improvement ranging from 3.05\u00d7 to 74.85\u00d7. Similarly for CNN, the improvement ranges from 2.71\u00d7 to 68.82\u00d7.\nThough not stated explicitly, our offline cost for linear regression is orders of magnitude more efficient as compared to ABY3. This improvement carries over for logistic regression, NN, and CNN networks as well. A large part of this improvement comes from the difference in the approaches to truncation. ABY3's approach entails using Ripple Carry Adder (RCA) circuits, which consume 128 rounds. ABY3 has pointed out that this was the reason SecureML performed better in total time for a single prediction. Our approach on the other hand, does not use any such circuit, resulting in an improvement of \u2248 15\u00d7 in communication and 64\u00d7 in rounds.", "publication_ref": ["b2"], "figure_ref": [], "table_ref": []}, {"heading": "Throughput Comparison:", "text": "We use a different metric to better illustrate the impact of our efficiency in the case of secure prediction, which is online throughput. Online throughput over LAN is the number of predictions that can be made in a second, and over WAN it is the number of predictions per minute. We have a total of 32 threads over 4 CPU cores, wherein each thread can perform 100 queries simultaneously without reduction in performance.  Regression. This is due to the limitation of being able to run only 32 CPU threads in parallel, which amounts to a lot of bandwidth not being utilized. This gap can be closed by introducing more CPU threads into our infrastructure. However, since we could not do this, in order to showcase the efficiency better, we limit the bandwidth and compute the gain in online throughput. As evident from the plot in Fig. 19, the gain increases as we limit the bandwidth. We observe that our protocols for Linear Regression and Logistic Regression achieve maximum bandwidth utilization at around 1.5 Mbps.\nOn the other hand, NN and CNN utilize the entire bandwidth, even at 40 Mbps. So decreasing the bandwidth does have an effect on the throughput for NN and CNN. ", "publication_ref": [], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "VII. CONCLUSION", "text": "In this work, we presented an efficient privacy-preserving machine learning framework for the four-party setting, tolerating at most one malicious corruption. The theoretical improvements over the state-of-the-art 3PC framework of ABY3 were backed up by an extensive benchmarking. The improvements show that the availability of an additional honest party can improve the performance of ML protocols while at the same time, decreasing the total monetary cost of hiring the servers.\nAn interesting open problem is extending this framework to the n party setting. Improving the security to guaranteed output delivery with a minimal trade-off in the concrete performance is another challenging problem. Another direction would be to try to integrate the protocols proposed in this paper into a compiler such as HyCC [58], which already has support for the two-party framework of ABY. APPENDIX A BUILDING BLOCKS a) Collision Resistant Hash: Consider a hash function family H = K \u00d7 L \u2192 Y. The hash function H is said to be collision resistant if for all probabilistic polynomial-time adversaries A, given the description of H k where k \u2208 R K, there exists a negligible function negl() such that Pr\n[(x 1 , x 2 ) \u2190 A(k) : (x 1 = x 2 ) \u2227 H k (x 1 ) = H k (x 2 )] \u2264 negl(\u03ba), where m = poly(\u03ba) and x 1 , x 2 \u2208 R {0, 1} m . b) Shared Key Setup: Let F : 0, 1 \u03ba \u00d7 0, 1 \u03ba \u2192 X be a secure PRF, with co-domain X being Z 2 \u2113 .\nThe set of keys are: -One key shared between every pair of parties -k ij for (P i , P j ) where i, j \u2208 {0, 1, 2, 3}.\n-One key shared between every group of three parties -k ijk for (P i , P j , P k ) where i, j, k \u2208 {0, 1, 2, 3}.\n-One key shared amongst all -k P .\nWe present the ideal world functionality F setup below.\nFsetup interacts with the parties in P and the adversary S. Fsetup picks random keys kij and k ijk for i, j, k \u2208 {0, 1, 2, 3} and kP . Let yi denote the keys corresponding to party Pi. Then yi = (k01, k02, k03, k012, k013, k023 and kP ) when Pi = P0.\nyi = (k01, k12, k13, k012, k013, k123 and kP ) when Pi = P1.\nyi = (k02, k12, k23, k012, k023, k123 and kP ) when Pi = P2.\nyi = (k03, k13, k23, k013, k023, k123 and kP ) when Pi = P3.\nOutput to adversary: If S sends abort, then send (Output, \u22a5) to all the parties. Otherwise, send (Output, yi) to the adversary S, where yi denotes the keys corresponding to the corrupt party.\nOutput to selected honest parties: Receive (select, {I}) from adversary S, where {I} denotes a subset of the honest parties. If an honest party Pi belongs to I, send (Output, \u22a5), else send (Output, yi).  c) Generating Zero Share, \u03a0 Zero : Protocol \u03a0 Zero (Fig. 21) enables parties in P to generate a \u2022 -sharing of zero among P 1 , P 2 , P 3 . In detail, parties P 1 , P 2 and P 3 obtain values A, B and \u0393 respectively such that A + B + \u0393 = 0. In addition, P 0 obtains all the values A, B and \u0393. The protocol is adapted to the 4PC setting from the 3PC protocol of [11], and we use F Zero to denote the ideal-world functionality for the same. We omit the proof for \u03a0 Zero and refer readers to [11] since the protocols are almost similar.", "publication_ref": ["b10", "b10"], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "Functionality Fsetup", "text": "-Parties use the Fsetup functionality to establish the following set of keys among them:\nP \\ {P3} : k2, P \\ {P1} : k3, P \\ {P2} : k1 -Using the above set of keys and the PRF F , parties compute the following: -P0, P1 : A = F (k2) \u2212 F (k1).\n-P0, P2 : B = F (k3) \u2212 F (k2).\n-P0, P3 : \u0393 = F (k1) \u2212 F (k3). Proof: During the offline phase, parties sample the \u03bbshares non-interactively using the shared key setup. During the online phase, P i sends m-value to P 1 , P 2 , P 3 resulting in 1 round and a communication of at most 3\u2113 bits (for the case when P i = P 0 ). Parties P 1 , P 2 , P 3 then mutually exchange the hash of m-value received from P 0 . Parties can combine m-values for several instances into a single hash and hence the cost gets amortized over multiple instances.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Protocol \u03a0 Zero", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Lemma B.2 (Communication)", "text": ". Protocol \u03a0 aSh (Fig. 2) requires 1 round and an amortized communication of 2\u2113 bits in the offline phase.\nProof: Protocol \u03a0 aSh is performed entirely in the offline phase. During the protocol, P 0 computes and sends v 3 to both P 1 and P 2 resulting in 1 round and a communication of 2\u2113 bits. Parties P 1 , P 2 mutually exchange hash of the value received from P 0 to ensure consistency. Similar to \u03a0 Sh , hash for multiple instances can be combined and hence this cost gets amortized over multiple instances.", "publication_ref": [], "figure_ref": ["fig_2"], "table_ref": []}, {"heading": "Lemma B.3 (Communication)", "text": ". Protocol \u03a0 Rec (Fig. 3) requires 1 round and an amortized communication of 4\u2113 bits in the online phase.\nProof: During the protocol, each party receives his/her missing share from another party, resulting in 1 round and a communication of 4\u2113 bits. In addition, each party receives a hash of the missing share from another party for verification. The hash for multiple instances can be combined to a single hash and thus this cost gets amortized over multiple instances.", "publication_ref": [], "figure_ref": ["fig_3"], "table_ref": []}, {"heading": "Lemma B.4 (Communication)", "text": ". Protocol \u03a0 Mult (Fig. 4) requires 1 round and an amortized communication of 3\u2113 bits in the offline phase and requires 1 round and an amortized communication of 3\u2113 bits in the online phase.\nProof: During the offline phase, each P 1 , P 2 , P 3 receives one share of \u03b3 xy from another party resulting in 1 round and communication of 3\u2113 bits. Also, each party receives a hash value from P 0 in the same round. The values corresponding to all the multiplication gates can be combined into a single hash resulting in an overall communication of just three hash values, which gets amortized. During the online phase, each of P 1 , P 2 , P 3 receives one [\u2022]-share of m z \u2212 m x m y from another party resulting in 1 round and a communication of 3\u2113 bits. Also, each party receives a hash value of the same from the third party. The values corresponding to all the multiplication gates can be combined into a single hash resulting in amortization of this cost. Proof: In the first round, P 0 receives a single bit from parties P 1 , P 2 , P 3 . In the next round, P 0 sends back a single bit to P 1 , P 2 , P 3 . In the third round, P 1 , P 2 , P 3 mutually exchanges the bit received from P 0 . In the last round, each party receives the missing share from two other parties resulting in the communication of 8\u2113 bits. In parallel, each party receives a hash of the missing share from the third party. Note that the first three rounds can be performed only once, for all the output wires together, amortizing the corresponding cost. In the last round, parties can compute a single hash corresponding to all the output wires resulting in getting this cost amortized over all the instances.", "publication_ref": [], "figure_ref": ["fig_4"], "table_ref": []}, {"heading": "APPENDIX C ANALYSIS OF CONVERSIONS", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "A. Building Blocks", "text": "Lemma C.1 (Communication). Protocol \u03a0 vSh (Fig. 7) is noninteractive in the offline phase and requires 1 round and an amortized communication of at most 2\u2113 bits in the online phase.\nProof: The cost for the offline phase follows from Lemma B.1. In the online phase, parties P i , P j sends the masked value to P 1 , P 2 , P 3 . For the case when P 0 \u2208 {P i , P j }, this requires 1 round and a communication of 2\u2113 bits. In other cases, communication of just \u2113 bits is required. Note that the values corresponding to multiple instances of \u03a0 vSh can be combined into a single hash, resulting in amortization of this cost.\nLemma C.2 (Communication). Protocol \u03a0 G vSh (Fig. 8) is noninteractive in the offline phase, while it requires 1 round and an amortised communication of \u03ba bits in the online phase.\nProof: For the case when P 0 along with one of the garblers P 1 , P 2 , P 3 owns v, the protocol requires two commitments and one decommitment. ABY3 [6] has shown that the number of commitments can be limited to 2s, when the number of values to be shared is larger than the statistical security parameter s. Consequently, the amortized cost per instance of \u03a0 G vSh becomes \u03ba bits (where the garbler sends the key K v v to P 0 ). For the case when two of the garblers need to share multiple values, one garbler can combine all the actual keys to a single hash and send it to P 0 , resulting in an amortized cost of \u03ba bits.", "publication_ref": ["b5"], "figure_ref": ["fig_7", "fig_8"], "table_ref": []}, {"heading": "Lemma C.3 (Communication)", "text": ". Protocol \u03a0 DotP (Fig. 9) requires 1 round and an amortized communication of 3\u2113 bits in the offline phase and requires 1 round and an amortized communication of 3\u2113 bits in the online phase.\nProof: The proof follows from Lemma B.4 since the protocol is similar to \u03a0 Mult .", "publication_ref": [], "figure_ref": ["fig_9"], "table_ref": []}, {"heading": "B. Sharing Conversions", "text": "We use |Add| and |Sub| to denote the size of garbled circuits corresponding to two \u2113-bit input adder and subtractor circuit respectively. We abuse the notation |Decode| to denote the size of decoding information for the corresponding garbled circuit. The lemmas in this section provide the amortized cost and omit the cost of hash values.\nLemma C.4 (Communication). Protocol \u03a0 G2B (Fig. 10) requires 1 round and a communication of \u03ba + 1 + |Decode| bits in the offline phase, while it requires 1 round and a communication of 3 bits in the online phase.\nProof: During the offline phase, parties execute one instance of \u03a0 G vSh and \u03a0 B vSh resulting in 1 round and a communication of \u03ba + 1 bits (Lemmas C.1 and C.2). Also, the decoding information for performing an XOR in the garbled world needs to be communicated to P 0 . During the online phase, P 0 communicates a single bit to P 3 . Also, P 0 performs the boolean sharing of the same bit resulting in a total communication of 3 bits. The verification by P 3 can be pushed to the next round as long as the values are not revealed in the next round. Thus parties can proceed with the evaluation after the first round.\nLemma C.5 (Communication). Protocol \u03a0 G2A (Fig. 11) requires 1 round and a communication of \u2113\u03ba + \u2113 + |Sub| + |Decode| bits in the offline phase, while it requires 1 round and a communication of 3\u2113 bits in the online phase.\nProof: The protocol is similar to that of \u03a0 G2B (Lemma C.4) with the main difference being a garbled subtractor circuit Sub is used for evaluating the final output.\nLemma C.6 (Communication). Protocol \u03a0 B2G (Fig. 12) requires 1 round and a communication of \u03ba bits in the offline phase, while it requires 1 round and a communication of \u03ba bits in the online phase.\nProof: The protocol \u03a0 B2G involves the execution of an instance of protocol \u03a0 G vSh in both the offline and online phases. The cost follows directly from Lemma C.2.\nLemma C.7 (Communication). Protocol \u03a0 A2G (Fig. 13) requires \u2212 rounds and a communication of \u2113\u03ba+ |Sub| bits in the offline phase, while it requires 1 round and a communication of \u2113\u03ba bits in the online phase.\nProof: The protocol can be viewed as \u2113 instances of \u03a0 B2G (Lemma C.6), where each bit of v is converted to its garbled sharing. Moreover, a garbled subtractor circuit Sub is used to evaluate the output.\nLemma C.8 (Communication). Protocol \u03a0 A2B (Fig. 14) requires 1 round and a communication of 3\u2113 log \u2113 + 2\u2113 bits in the offline phase, while it requires 1 + log \u2113 rounds and a communication of 3\u2113 log \u2113 + \u2113 bits in the online phase.\nProof: The protocol proceeds similarly to that of \u03a0 A2G apart from the garbled world being replaced with the boolean world. Parties execute a single instance of \u03a0 B vSh in both the offline and online phases. This results in one round and a communication of 2\u2113 bits in the offline phase, while it results in one round and communication of \u2113 bits in the online phases (Lemma C.1). Moreover, parties evaluate a boolean subtractor circuit Sub (Parallel Prefix Adder version mentioned in ABY3 [6]) of log \u2113 multiplicative depth and contain \u2113 log \u2113 AND gates. This results in an additional communication of 3\u2113 log \u2113 bits in the offline and online phases (Lemma B.4). Moreover, the online rounds increases from 1 to 1 + log \u2113.\nLemma C.9 (Communication). Protocol \u03a0 Bit2A (Fig. 15) requires 2 rounds and a communication of 3\u2113 + 1 bits in the offline phase, while it requires 1 round and a communication of 3\u2113 bits in the online phase.\nProof: During the offline phase, P 0 executes \u03a0 aSh on u resulting in one round and a communication of 2\u2113 bits (Lemma B.2). This is followed by parties P 1 , P 2 , P 3 performing the check to ensure the correctness of sharing done by P 0 . During the check, P 1 sends one ring element and a bit to P 3 , while P 2 sends a hash value. This results in an additional round and an amortized communication of \u2113 + 1 bits.\nDuring the online phase, parties non-interactively generate the \u2022 -shares of v. This is followed by one arithmetic multiplication, resulting in one round and communication of 3\u2113 bits in the online phase (Lemma B.4). Here, note that the offline phase for the multiplication is not required, since \u03bb v is set to 0 while executing the protocol \u03a0 Sh (P 1 , P 2 , P 3 , v), resulting in \u03b3 uv to be set to 0.\nLemma C.10 (Communication). Protocol \u03a0 B2A (Fig. 16) requires 2 rounds and a communication of 3\u2113 2 + \u2113 bits in the offline phase, while it requires 1 round and a communication of 3\u2113 bits in the online phase.\nProof: The offline cost follows from that of protocol \u03a0 Bit2A since the offline phase can be viewed as \u2113 instances of that of \u03a0 Bit2A (Lemma C.9). During the online phase, every pair from P 1 , P 2 , P 3 executes an instance of \u03a0 vSh resulting in one round and communication of 3\u2113 bits (Lemma C.1).\nLemma C.11 (Communication). Protocol \u03a0 BitInj (Fig. 17) requires 2 rounds and a communication of 6\u2113 + 1 bits in the offline phase, while it requires 1 round and a communication of 3\u2113 bits in the online phase.\nProof: The offline phase of \u03a0 BitInj consists of generating \u2022 -shares of \u03bb b and \u03bb b \u03bb v . The case for \u03bb b is same as that of \u03a0 Bit2A resulting in two rounds and a communication of 3\u2113 + 1 bits. In parallel, P 0 execute \u03a0 aSh on \u03bb b \u03bb v resulting in an additional communication of 2\u2113 bits. In order to verify the correctness of this sharing, P 1 , P 2 , P 3 performs a check. During the check, P 1 sends one ring element to P 3 , while P 2 sends a hash value, resulting in an additional amortised communication of \u2113 bits. Thus the offline phase requires two rounds and an amortised communication of 6\u2113 + 1 bits.\nDuring the online phase, every pair from P 1 , P 2 , P 3 executes an instance of \u03a0 vSh resulting in one round and communication of 3\u2113 bits (Lemma C.1). IX provides a comparison of our sharing conversions with ABY3 [6]. Here, G1 denotes a two input garbled subtractor circuit, while G2 = Gar(2, Sub, \u2113) denotes two input garbled subtractor circuit along with its decoding information. Similarly, G3 = Gar(3, Sub, \u2113) and G4 = Gar(3, Adder, \u2113) denote three input garbled circuit for subtraction and addition respectively. Here \u2113 denotes the ring size in bits.", "publication_ref": ["b5", "b5"], "figure_ref": ["fig_1", "fig_1", "fig_1", "fig_1", "fig_1", "fig_1", "fig_1", "fig_1"], "table_ref": ["tab_20"]}, {"heading": "Cost Comparison: Table", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Conv.", "text": "Work Offline Online R. Comm. R. Comm.\nG2B ABY3 1 \u03ba 1 \u03ba This 1 \u03ba + 1 + |Decode| 1 3 G2A ABY3 1 |G3| + \u2113\u03ba 1 2\u2113\u03ba This 1 \u2113\u03ba + \u2113 + |G2| 1 3\u2113 B2G ABY3 0 0 1 2\u03ba This 1 \u03ba 1 \u03ba A2G ABY3 1 |G4| 1 2\u2113\u03ba This 1 \u2113\u03ba + |G1| 1 \u2113\u03ba A2B ABY3 3 12\u2113 log \u2113 + 12\u2113 1 + log \u2113 9\u2113 log \u2113 + 9\u2113 This 1 3\u2113 log \u2113 + 2\u2113 1 + log \u2113 3\u2113 log \u2113 + \u2113 Bit2A ABY3 1 24\u2113 2 18\u2113 This 2 3\u2113 + 1 1 3\u2113 B2A ABY3 3 12\u2113 log \u2113 + 12\u2113 1 + log \u2113 9\u2113 log \u2113 + 9\u2113 This 2 3\u2113 2 + \u2113 1 3\u2113 BitInj ABY3 1 36\u2113 3 27\u2113 This 2 6\u2113 + 1 1 3\u2113\nTable IX: Sharing conversions of ABY3 and Ours.", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_20"]}, {"heading": "APPENDIX D ANALYSIS OF ML PROTOCOLS", "text": "Lemma D.1 (Correctness). In the offline phase of protocol \u03a0 MultTr (Fig. 18), if a corrupt P 0 generates incorrect r t sharing, then the honest evaluators P 1 , P 2 , P 3 abort.", "publication_ref": [], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "Proof: To see the correctness, it suffices to show that", "text": "m 1 + m 2 = c where m 1 = r 2 \u2212 2 d r t 2 \u2212 r d,2 + c and m 2 = (r 1 + r 3 ) \u2212 2 d (r t 1 + r t 3 ) \u2212 (r d,1 + r d,3\n). Note that r = 2 d r t + r d where r t denoted the truncated value of r and r d denoted the last d bits of r. Then,\nm 1 + m 2 = r 2 \u2212 2 d r t 2 \u2212 r d,2 + c + (r 1 + r 3 ) \u2212 2 d (r t 1 + r t 3 ) \u2212 (r d,1 + r d,3 ) = (r 1 + r 2 + r 3 ) \u2212 2 d (r t 1 + r t 2 + r t 3 ) \u2212 (r d,1 + r d,2 + r d,3 ) + c = (r) \u2212 (2 d r t + r d ) + c = 0 + c = c\nLemma D.2 (Communication). Protocol \u03a0 MultTr (Fig. 18) requires 2 rounds and a communication of 6\u2113 bits in the offline phase, while it requires 1 round and a communication of 3\u2113 bits in the online phase.\nProof: During the offline phase, the offline phase of \u03a0 Mult is executed, resulting in one round and communication of 3\u2113 bits. In parallel, P 0 executes \u03a0 aSh on r t resulting in an additional communication of 2\u2113 bits (Lemma B.2). To verify the correctness of this sharing, parties P 1 , P 2 , P 3 performs a check, where P 1 sends one ring element and hash value to P 2 . This results in an additional amortized communication of \u2113 bits. Thus the offline phase requires two rounds and an amortized communication of 6\u2113 bits. The cost for online phase follows directly from \u03a0 Mult (Lemma B.4) Lemma D.3 (Communication). Protocol \u03a0 BitExt (Fig. ??) requires 1 round and a communication of 4\u2113 + 1 bits in the offline phase, while it requires 3 rounds and a communication of 5\u2113 + 2 bits in the online phase.\nProof: During the offline phase, parties execute one instance each of \u03a0 vSh and \u03a0 B vSh resulting in one round and a communication of \u2113 + 1 bits (Lemma C.1). Also, the offline phase for multiplication is performed resulting in an additional communication of 3\u2113 bits.\nDuring the online phase, parties first execute an arithmetic multiplication, resulting in one round and communication of 3\u2113 bits (Lemma B.4). The value rv is reconstructed towards both P 0 and P 3 , resulting in an additional round and an amortized communication of 2\u2113 bits. This is followed by the last round, where parties execute one instance of \u03a0 B vSh resulting in a communication of 2 bits. Thus the online phase requires three rounds and an amortized communication of 5\u2113 + 2 bits.  [6], in terms of ML protocols and special conversions.", "publication_ref": ["b5"], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "Cost Comparison: Table X provides a comparison of our work with ABY3", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Conv. Work", "text": "Offline Online R. Comm. R. Comm.  \n\u03a0 MultTr ABY3 2\u2113 \u2212 2 96\u2113 \u2212 42d \u2212 84 1 12\u2113 This 2 6\u2113 1 3\u2113 \u03a0 BitExt ABY3 1 24\u2113 log \u2113 log \u2113 18\u2113 log \u2113 This 1 4\u2113 + 1 3 5\u2113 +", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "APPENDIX E BENCHMARKING", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "A. Motivating 4PC", "text": "In this section, we justify the reason for operating in the 4PC setting over the 3PC setting through the lens of benchmarking and practical efficiency. We begin with the comparison of our 4PC secret sharing scheme with that of Gordon et al. [27], which shows the reason we built a new 4PC.\nIn Section E-A2 we compare the efficiency of our framework with ABY3. Since machine learning models take a long time to train, monetary cost becomes an important factor to consider when building PPML protocols, as shown in [28].\nMonetary cost is computed by calculating the total running time for each of the servers and the cost of hiring them, which is based upon the computing power of the server. Total running time is the total time taken for the evaluation phase, which excludes the input sharing and reconstruction phase. So, if we have a protocol that communicates very less but the total running time for the servers is high due to the computation, the monetary cost will also be high. We compare the total running times of our protocol against the others to show that we have a better balance in terms of computation and communication, making our monetary cost lower than the rest.\nRef.  ", "publication_ref": ["b26", "b27"], "figure_ref": [], "table_ref": []}, {"heading": "1) Comparison with the protocol of Gordon et al. [27]:", "text": "In Table XI, we compare the total online runtime of our 4PC protocol with that of Gordon et al. [27] for evaluating an AES-128 [59] circuit. As evident from the table, P 0 does not have to be active during the online phase, except for the sharing and the reconstruction phase. This means we can shut down the server that corresponds to P 0 for the entirety of the online evaluation phase, saving a lot in terms of monetary cost. The preprocessing phase for both protocols requires just 1 round of interaction.\n2) Motivation of 4PC for ML: Here, we argue that even though we operate in the 4PC setting, meaning we have 4 servers active instead of 3 as in ABY3, our total monetary cost is still lower than that of ABY3. ", "publication_ref": ["b26"], "figure_ref": [], "table_ref": []}, {"heading": "B. Comparison with the ML framework of ABY3 [6] in the semi-honest setting", "text": "We compare the performance of our protocol with the semihonest version of ABY3, giving them an advantage in terms of the threat model. We use ABY3S to denote the ABY3 protocol in the semi-honest setting. Our performance is the same for linear regression but as the protocols get more complex, the difference in performance increases in our favour. This is because in linear regression though we have the additional overhead of a hash, the cost is amortized, making our cost the same as ABY3S. For the other three algorithms, however, we outperform ABY3S due to our efficient protocols for bit extraction, bit injection, and Bit2A. Although we are worse than ABY3 in the offline phase due to our preprocessing for multiplication, our online phase is a lot more efficient for both training and prediction phases.    ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "APPENDIX F SECURITY OF OUR CONSTRUCTIONS", "text": "In this section, we prove the security of our \u03a0 4PC protocol in the {F setup , F Zero }-hybrid model, using the real world-ideal world paradigm. The ideal world functionality that realises \u03a0 4PC is given in Fig. 22.\nF 4PC interacts with the parties in P and the adversary S and is parameterized by a 4-ary function f , represented by a publicly known arithmetic circuit ckt over Z 2 \u2113 .\nInput: Upon receiving the input x, . . . , x I from the respective parties in P, do the following: if (Input, * ) message was received from Pi corresponding to xj , then ignore. Otherwise record\nx \u2032 j = xj internally. If x \u2032 j = Z 2 \u2113 , consider x \u2032 j = abort.\nOutput to adversary: If there exists j \u2208 {1, . . . , I} such that x \u2032 j = abort, send (Output, \u22a5) to all the parties. Else, send (Output, (y1, . . . , y O )) to the adversary S, where (y1, . . . , y O ) = f (x \u2032 1 , . . . , x \u2032 I ). Output to selected honest parties: Receive (select, {I}) from adversary S, where {I} denotes a subset of the honest parties. If an honest party belongs to I, send (Output, \u22a5), else send (Output, (y1, . . . , y O )). We begin with the case when P 0 is corrupted.", "publication_ref": [], "figure_ref": ["fig_2"], "table_ref": []}, {"heading": "Functionality F 4PC", "text": "Theorem F.1. In {F setup , F Zero }-hybrid model, \u03a0 4PC securely realizes the functionality F 4PC against a static, malicious adversary A, who corrupts P 0 .\nProof: Let A be a real-world adversary corrupting the distributor P 0 during the protocol \u03a0 4PC . We present an idealworld adversary (simulator) S 4PC for A in Fig. 23 that simulates messages for corrupt P 0 . The only communication to P 0 is during the output-reconstruction stage in the online phase. S 4PC can easily simulate these messages, with the knowledge of function output and the masks corresponding to the circuitoutput wires.\nThe simulator plays the role of the honest parties P1, P2, P3 and simulates each step of \u03a0 4PC to corrupt P0 as follows and finally outputs A's output. The simulator initializes a boolean variable flag = 0, which indicates whether an honest party aborts during the protocol.\nOffline Phase: S 4PC emulates Fsetup and gives the keys (k01, k02, k03, k012, k013, k023 and kP ) to P0. By emulating Fsetup, it learns the \u03bb-masks for all the wires in ckt.\n-Sharing Circuit-input Values: Here the simulator has to do nothing, as the offline phase involves no communication.\n-Gate Evaluation: No simulation is needed for the offline phase of an addition gate. For a multiplication gate g, the simulator emulates F Zero and gives A, B, \u0393 to P0. It then receives hash of \u03b3xy,1, \u03b3xy,2 and \u03b3xy,3 from P0 on behalf of P2, P3 and P1 respectively. S 4PC computes \u03b3xy,i for i \u2208 {1, 2, 3} and sets flag = 1, if any of the hash values received is inconsistent with the values computed.\n-Output Reconstruction: Here the simulator has to do nothing, as the offline phase involves no communication.\nIf flag = 1, S 4PC invokes F 4PC with input \u22a5 on behalf of P0.\nOnline Phase:\n-Sharing Circuit-input Values: For every input vj of P0, S 4PC receives mv j of behalf of P1, P2, P3. S 4PC sets flag = 1 if the received values mismatch. Else, it computes the input vj using mv j and the \u03bb-masks obtained in the offline phase.\n-Gate Evaluation: No simulation is needed for the online phase of both addition and multiplication gates.\n-Obtaining function outputs: If flag = 1, S 4PC invokes F 4PC with input \u22a5 on behalf of P0. Else it sends inputs {vj } extracted on behalf of P0 to F 4PC and receives the function outputs y1, . . . , y O .\n-Output Reconstruction: For each output yj for j \u2208 1, . . . , O, S 4PC computes my j = yj + \u03bby j , and sends my j and H(my j ) to P0 on behalf of P1 and P2 respectively. In parallel, he receives H(\u03bby j ,i) for i \u2208 {1, 2, 3} from P0, on behalf of P1, P2, P3. S 4PC initializes the set I to \u2205. Pi for i \u2208 {1, 2, 3}, is added to I, if hash of \u03bby j ,i mismatches with the corresponding hash received from P0. S 4PC then sends I to F 4PC and terminates.\nSimulator S 4PC The proof now simply follows from the fact that simulated view and real-world view of the adversary are computationally indistinguishable.\nWe next consider the case, when the adversary corrupts one of the evaluators, say P 1 . The cases of corrupt P 2 and P 3 are handled symmetrically.\nTheorem F.2. In the {F setup , F Zero }-hybrid model, \u03a0 4PC securely realizes the functionality F 4PC against a static, mali-cious adversary A, who corrupts P 1 .\nProof: Let A be a real-world adversary corrupting the evaluator P 1 during the protocol \u03a0 4PC . We now present the steps of the ideal-world adversary (simulator) S 4PC for A for this case in Fig. 24.\nThe simulator plays the role of the honest parties P0, P2, P3 and simulates each step of \u03a0 4PC to corrupt P1 as follows and finally outputs A's output. The simulator initializes a boolean variable flag = 0, which indicates whether an honest party aborts during the protocol.\nOffline Phase: S 4PC emulates Fsetup and gives the keys (k01, k12, k13, k012, k013, k123 and kP ) to P1. By emulating Fsetup, it learns the \u03bb-masks for all the wires in ckt.\n-Sharing Circuit-input Values: Here the simulator has to do nothing, as the offline phase involves no communication.\n-Gate Evaluation: No simulation is needed for the offline phase of an addition gate. For a multiplication gate g = (wx, wy, wz, \u00d7), the simulator emulates F Zero and gives A to P1. S 4PC computes \u03b3xy,i for i \u2208 {1, 2, 3} and sends \u03b3xy,3 and H(\u03b3xy,3) to P1 on behalf of P2 and P0 respectively. It receives \u03b3xy,2 from P1 on behalf of P3 and sets flag = 1, if the received value is inconsistent.\n-Output Reconstruction: Here the simulator has to do nothing, as the offline phase involves no communication.\nIf flag = 1, S 4PC invokes F 4PC with input \u22a5 on behalf of P0.\nOnline Phase:\n-Sharing Circuit-input Values: For every input vj of P1, S 4PC receives mv j of behalf of P2 and P3. S 4PC sets flag = 1 if the received values mismatch. Else, it computes the input vj using mv j and the \u03bb-masks obtained in the offline phase. For every input v k of Pi for i \u2208 {0, 2, 3}, S 4PC sets v k = 0 and sends mv k = 0 + \u03bbv k to P1 on behalf of Pi. S 4PC performs the exchange of hash of mv k honestly. -Output Reconstruction: For each output yj for j \u2208 1, . . . , O, S 4PC computes \u03bby j = my j \u2212 yj , and sends \u03bby j and H(\u03bby j ) to P1 on behalf of P2 and P0 respectively. In parallel, it receives \u03bby j ,3 and H(my j ) from P1 on behalf of P3 and P0 respectively. P0 is added to I, if hash of my j mismatches with the corresponding hash received from P1. Similarly, P3 is added to I, if \u03bby j ,3 mismatches with the corresponding value received from P1. S 4PC then sends I to F 4PC and terminates.", "publication_ref": [], "figure_ref": ["fig_2", "fig_2"], "table_ref": []}, {"heading": "Simulator S 4PC", "text": "Figure 24: Simulator for the case of corrupt P1", "publication_ref": [], "figure_ref": ["fig_2"], "table_ref": []}, {"heading": "A. Security Proof in Detail", "text": "This section covers the security proofs for most of our constructions. The proofs for the rest can be easily derived. The proofs use the real-world/ideal-world paradigm in which A is the adversary in the real-world and S is the simulator for the ideal-world, which acts as the honest parties in the protocol and simulates messages received by A. The simulator maintains a flag which is set to 0 at the start of the protocol. If an honest party abort, the flag is set to 1. Simulator for a particular protocol is represented as S with the protocol name as the subscript.\nThe simulation for a circuit ckt proceeds as follows: We start with the input sharing phase, and S sets the input of the honest parties to 0. The simulator can extract the input of the A from the sharing protocol \u03a0 Sh , details of which are provided in the simulation for \u03a0 Sh . Doing so gives the S all the inputs for the entire circuit, which means it can compute all the intermediate values and the output of the circuit. As we will see later, S will use this information to simulate each component of a circuit ckt.\nFor each of the constructions, we provide simulation proof for the case of corrupt P 0 and P 1 . The cases of corrupt P 2 and P 3 follows similar to that of P 1 .\na) Sharing Protocol: The ideal functionality realising protocol \u03a0 Sh is presented in Fig. 25.\nF Sh interacts with the parties in P and the adversary S. F Sh receives the input v from party Pi while it receives \u22a5 from the other parties. If v = \u22a5, then send \u22a5 to every party, else proceed with the computation.\nComputation of output: Randomly select \u03bbv,1, \u03bbv,2, \u03bbv,3 from Z 2 \u2113 and set mv = v + \u03bbv,1 + \u03bbv,2 + \u03bbv,3. The output shares are set as: v P 0 = (\u03bbv,1, \u03bbv,2, \u03bbv,3) v P 1 = (mv, \u03bbv,2, \u03bbv,3) v P 2 = (mv, \u03bbv,3, \u03bbv,1) v P 3 = (mv, \u03bbv,1, \u03bbv,2)\nOutput to adversary: If S sends abort, then send (Output, \u22a5) to all the parties. Otherwise, send (Output, v S ) to the adversary S, where v S denotes the share of v corresponding to the corrupt party.\nOutput to selected honest parties: Receive (select, {I}) from adversary S, where {I} denotes a subset of the honest parties. If an honest parties Pi belongs to I, send (Output, \u22a5), else send (Output, v i), where v i denotes the share of v corresponding to the honest party Pi. The simulator for the case of corrupt P 0 appears in Fig. 26.", "publication_ref": [], "figure_ref": ["fig_2", "fig_2"], "table_ref": []}, {"heading": "Functionality F Sh", "text": "Offline Phase: S Sh emulates Fsetup and gives the keys (k01, k02, k03, k012, k013, k023 and kP) to A. By emulating Fsetup, it learns the \u03bb-values corresponding to input v.\n-If Pi = P0, S Sh computes \u03bbv,j for j \u2208 1, 2, 3 on behalf of each Simulator S Sh Pj using the shared key.\n-If Pi = P k for k \u2208 {1, 2, 3}, S Sh computes \u03bb v,k using the key kP. In addition, the \u03bbv-shares corresponding to the honest parties are computed honestly by S Sh .\nOnline Phase:\n-If Pi = P0, S Sh receives mv of behalf of P1, P2, P3. S Sh sets flag = 1 if the received values mismatch. Else, it computes the input v = mv \u2212 \u03bbv,1 \u2212 \u03bbv,2 \u2212 \u03bbv,3.\n-If Pi = P0, S Sh sets v = 0 by assigning mv = \u03bbv,1+\u03bbv,2+\u03bbv,3.\nIf flag = 0 and Pi = P0, S Sh invokes F Sh with input v on behalf of P0. Else it invokes F Sh with input \u22a5 on behalf of P0. The simulator for the case of corrupt P 1 appears in Fig. 27.\nOffline Phase: S Sh emulates Fsetup and gives the keys (k01, k12, k13, k012, k013, k123 and kP ) to A. By emulating Fsetup, it learns the \u03bb-values corresponding to input v.\n-If Pi = P1, S Sh computes \u03bbv,1 using the key kP.\n-If Pi = P k for k \u2208 {0, 2, 3}, the \u03bbv-shares corresponding to the honest parties are computed honestly by S Sh .\nOnline Phase: b) Verifiable Arithmetic/Boolean Sharing: The ideal functionality realising protocol \u03a0 vSh is presented in Fig. 28.\n-If Pi = P1, S\nF vSh interacts with the parties in P and the adversary S. F Sh receives the input v from parties Pi, Pj while it receives \u22a5 from the other parties. If the received values mismatch, then send \u22a5 to every party, else proceed with the computation.\nComputation of output: Randomly select \u03bbv,1, \u03bbv,2, \u03bbv,3 from Z 2 \u2113 and set mv = v + \u03bbv,1 + \u03bbv,2 + \u03bbv,3. The output shares are set as: v P 0 = (\u03bbv,1, \u03bbv,2, \u03bbv,3) v P 1 = (mv, \u03bbv,2, \u03bbv,3) v P 2 = (mv, \u03bbv,3, \u03bbv,1) v P 3 = (mv, \u03bbv,1, \u03bbv,2)\nOutput to adversary: If S sends abort, then send (Output, \u22a5) to all the parties. Otherwise, send (Output, v S ) to the adversary S, where v S denotes the share of v corresponding to the corrupt Functionality F vSh party.\nOutput to selected honest parties: Receive (select, {I}) from adversary S, where {I} denotes a subset of the honest parties. If an honest parties Pi belongs to I, send (Output, \u22a5), else send (Output, v i), where v i denotes the share of v corresponding to the honest party Pi.", "publication_ref": [], "figure_ref": ["fig_2", "fig_2"], "table_ref": []}, {"heading": "Figure 28: Functionality for protocol \u03a0 vSh", "text": "The simulator for the case of corrupt P 0 appears in Fig. 29.\nOffline Phase: The simulation for the offline phase is similar to that of \u03a0 Sh (Pi, v) for the case of corrupt P0 (Fig. 26).\nOnline Phase: S vSh proceeds similar to that of \u03a0 Sh (Pi, v) for the case of corrupt P0 (Fig. 26). In addition, if Pj = P0, it receives H(mv) from A on behalf of P1, P2, and P3. S vSh sets flag = 1 if the received values mismatch.\nIf flag = 0 and Pj = P0, S vSh invokes F vSh with input v on behalf of P0. Else it invokes F vSh with input \u22a5 on behalf of P0. The simulator for the case of corrupt P 1 appears in Fig. 30.", "publication_ref": [], "figure_ref": ["fig_2", "fig_2", "fig_2", "fig_3"], "table_ref": []}, {"heading": "Simulator S vSh", "text": "Offline Phase: The simulation for the offline phase is similar to that of \u03a0 Sh (Pi, v) for the case of corrupt P1 (Fig. 27).\nOnline Phase: S vSh proceeds similar to that of \u03a0 Sh (Pi, v) for the case of corrupt P1 (Fig. 27). In addition, if Pj = P1, it receives H(mv) from A on behalf of P2, and P3. S vSh sets flag = 1 if the received values mismatch.\nIf flag = 0 and Pi = P1, S vSh invokes F vSh with input v on behalf of P1. Else it invokes F vSh with input \u22a5 on behalf of P1.  ", "publication_ref": [], "figure_ref": ["fig_2", "fig_2"], "table_ref": []}, {"heading": "Simulator S vSh", "text": "v P 0 = (\u03bb \u2032 v,1 , \u03bb \u2032 v,2 , \u03bb \u2032 v,3 ) v P 1 = (m \u2032 v , \u03bb \u2032\u2032 v,2 , \u03bb \u2032\u2032 v,3 ) v P 2 = (m \u2032\u2032 v , \u03bb \u2032\u2032\u2032 v,3 , \u03bb \u2032\u2032 v,1 ) v P 3 = (m \u2032\u2032\u2032 v , \u03bb \u2032\u2032\u2032 v,1 , \u03bb \u2032\u2032\u2032 v,2 )\nF Rec sends \u22a5 to every party if either of the following condition is met\n: i) \u03bb \u2032 v,1 = \u03bb \u2032\u2032 v,1 = \u03bb \u2032\u2032\u2032 v,1 , ii) \u03bb \u2032 v,2 = \u03bb \u2032\u2032 v,2 = \u03bb \u2032\u2032\u2032 v,2 , iii) \u03bb \u2032 v,3 = \u03bb \u2032\u2032 v,3 = \u03bb \u2032\u2032\u2032 v,3 or iv) m \u2032 v = m \u2032\u2032 v = m \u2032\u2032\u2032 v .\nElse it proceeds with the computation.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Computation of output:", "text": "Set v = mv \u2212 \u03bbv,1 \u2212 \u03bbv,2 \u2212 \u03bbv,3.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Functionality F Rec", "text": "Output to adversary: If S sends abort, then send (Output, \u22a5) to all the parties. Otherwise, send (Output, v) to the adversary S.\nOutput to selected honest parties: Receive (select, {I}) from adversary S, where {I} denotes a subset of the honest parties. If an honest party Pi belongs to I, send (Output, \u22a5), else send (Output, v).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Figure 31: Functionality for protocol \u03a0 Rec", "text": "The simulator for the case of corrupt P 0 appears in Fig. 32. As mentioned at the beginning of this section, S knows all of the intermediate values and the output of the ckt. S uses this information to simulate the \u03a0 Rec protocol.\nOnline Phase:\n-S Rec computes mv = v + \u03bbv,1 + \u03bbv,2 + \u03bbv,3. It then sends mv and H(mv) to A on behalf of P1 and P2 respectively.\n-\nS Rec receives H(\u03bb \u2032 v,1 ), H(\u03bb \u2032 v,2\n) and H(\u03bb \u2032 v,1 ) from A on behalf of P1, P2 and P3 respectively. S Rec sets flag = 1 if any of the received hash values is inconsistent.\nIf flag = 0, S Rec invokes F Rec with input (\u03bbv,1, \u03bbv,2, \u03bbv,3) on behalf of P0. Else it invokes F Rec with input \u22a5 on behalf of P0. The simulator for the case of corrupt P 1 appears in Fig. 33.", "publication_ref": [], "figure_ref": ["fig_2", "fig_3"], "table_ref": []}, {"heading": "Simulator S Rec", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Online Phase:", "text": "-S Rec sends \u03bbv,1 and H(\u03bbv,1) to A on behalf of P2 and P0\nrespectively.\n-S Rec receives \u03bb \u2032 v,3 and H(m \u2032 v ) from A on behalf of P3 and P0 respectively. S Rec sets flag = 1 if any of the received values is inconsistent.\nIf flag = 0, S Rec invokes F Rec with input (mv, \u03bbv,2, \u03bbv,3) on behalf of P1. Else it invokes F Rec with input \u22a5 on behalf of P1.  Computation of output: Compute x = mx \u2212 \u03bbx,1 \u2212 \u03bbx,2 \u2212 \u03bbx,3, y = my \u2212 \u03bby,1 \u2212 \u03bby,2 \u2212 \u03bby,3 and set z = xy. Randomly select \u03bbz,1, \u03bbz,2, \u03bbz,3 from Z 2 \u2113 and set mz = z + \u03bbz,1 + \u03bbz,2 + \u03bbz,3. The output shares are set as: z P 0 = (\u03bbz,1, \u03bbz,2, \u03bbz,3) z P 1 = (mz, \u03bbz,2, \u03bbz,3) z P 2 = (mz, \u03bbz,3, \u03bbz,1) z P 3 = (mz, \u03bbz,1, \u03bbz,2)", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Simulator S Rec", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Functionality F Mult", "text": "Output to adversary: If S sends abort, then send (Output, \u22a5) to all the parties. Otherwise, send (Output, z S ) to the adversary S, where z S denotes the share of z corresponding to the corrupt party.\nOutput to selected honest parties: Receive (select, {I}) from adversary S, where {I} denotes a subset of the honest parties. If an honest party Pi belongs to I, send (Output, \u22a5), else send (Output, z i), where z i denotes the share of z corresponding to the honest party Pi. The simulator for the case of corrupt P 0 appears in Fig. 35.", "publication_ref": [], "figure_ref": ["fig_3"], "table_ref": []}, {"heading": "Offline Phase:", "text": "-S Mult samples \u03bbz,j for j \u2208 {1, 2, 3} honestly using the shared keys obtained.\n-S Mult emulates F Zero functionality and gives the values A, B, and \u0393 to A.\n-S Mult receives H(\u03b3xy,1), H(\u03b3xy,2) and H(\u03b3xy,3) from A on behalf of P2, P3 and P1 respectively. S Mult sets flag = 1 if any of the received values is inconsistent.\nOnline Phase: There is nothing to simulate as P0 has no role during the online phase.\nIf flag = 0, S Mult invokes F Mult with input ( x P 0 , y P 0 ) on behalf of P0. Else it invokes F Mult with input \u22a5 on behalf of P0. The simulator for the case of corrupt P 1 appears in Fig. 36.", "publication_ref": [], "figure_ref": ["fig_3"], "table_ref": []}, {"heading": "Simulator S Mult", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Offline Phase:", "text": "-S Mult samples \u03bbz,j for j \u2208 {2, 3} honestly using the shared keys obtained.\n-S Mult emulates F Zero functionality and gives the value A to A.\n-S Mult sends \u03b3xy,3 and H(\u03b3xy,3) to A on behalf of P2 and P0 respectively. It receives \u03b3xy,2 from A on behalf of P3 and sets flag = 1 if the received value is inconsistent.\nOnline Phase:\n-S Mult simulates the computation of m \u2032 z shares honestly on behalf of P2 and P3.   ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Computation of output:", "text": "Compute xi = mx i \u2212 \u03bbx i ,1 \u2212 \u03bbx i ,2 \u2212 \u03bbx i ,3, yi = my i \u2212 \u03bby i ,1 \u2212 \u03bby i ,2 \u2212 \u03bby i ,3 for i \u2208 [d] and set z = d i=1\nxiyi. Randomly select \u03bbz,1, \u03bbz,2, \u03bbz,3 from Z 2 \u2113 and set mz = z + \u03bbz,1 + \u03bbz,2 + \u03bbz,3. The output shares are set as: z P 0 = (\u03bbz,1, \u03bbz,2, \u03bbz,3) z P 1 = (mz, \u03bbz,2, \u03bbz,3) z P 2 = (mz, \u03bbz,3, \u03bbz,1) z P 3 = (mz, \u03bbz,1, \u03bbz,2)\nOutput to adversary: If S sends abort, then send (Output, \u22a5) to all the parties. Otherwise, send (Output, z S ) to the adversary S, where z S denotes the share of z corresponding to the corrupt party.\nOutput to selected honest parties: Receive (select, {I}) from adversary S, where {I} denotes a subset of the honest parties. If an honest party Pi belongs to I, send (Output, \u22a5), else send (Output, z i), where z i denotes the share of z corresponding to the honest party Pi. The simulator for the case of corrupt P 0 appears in Fig. 38.", "publication_ref": [], "figure_ref": ["fig_3"], "table_ref": []}, {"heading": "Functionality F DotP", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Offline Phase:", "text": "-S DotP samples \u03bbz,j for j \u2208 {1, 2, 3} honestly using the shared keys obtained.\n-S DotP emulates F Zero functionality and gives the values A, B, and \u0393 to A.  The simulator for the case of corrupt P 1 appears in Fig. 39.", "publication_ref": [], "figure_ref": ["fig_3"], "table_ref": []}, {"heading": "Offline Phase:", "text": "-S DotP samples \u03bbz,j for j \u2208 {2, 3} honestly using the shared keys obtained.\n-S DotP emulates F Zero functionality and gives the value A to A.\n-S DotP sends \u03b3xy,3 and H(\u03b3xy,3) to A on behalf of P2 and P0 respectively. It receives \u03b3xy,2 from A on behalf of P3 and sets flag = 1 if the received value is inconsistent.   ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Computation of output:", "text": "Compute b = m b \u2295 \u03bb b,1 \u2295 \u03bb b,2 \u2295 \u03bb b,3 . Let b \u2032 denotes the value of bit b over an arithmetic ring Z 2 \u2113 . Randomly select \u03bb \u2032 b,1 , \u03bb \u2032 b,2 , \u03bb \u2032 b,3 from Z 2 \u2113 and set m \u2032 b = b \u2032 +\u03bb \u2032 b,1 + \u03bb \u2032 b,2 + \u03bb \u2032 b,3 .\nThe output shares are set as:\nb \u2032 P 0 = (\u03bb \u2032 b,1 , \u03bb \u2032 b,2 , \u03bb \u2032 b,3 ) b \u2032 P 1 = (m \u2032 b , \u03bb \u2032 b,2 , \u03bb \u2032 b,3 ) b \u2032 P 2 = (m \u2032 b , \u03bb \u2032 b,3 , \u03bb \u2032 b,1 ) b \u2032 P 3 = (m \u2032 b , \u03bb \u2032 b,1 , \u03bb \u2032 b,2 )\nOutput to adversary: If S sends abort, then send (Output, \u22a5) to all the parties. Otherwise, send (Output, b \u2032 S ) to the adversary S, where b \u2032 S denotes the share of b \u2032 corresponding to the corrupt party.\nOutput to selected honest parties: Receive (select, {I}) from adversary S, where {I} denotes a subset of the honest parties. If an honest party Pi belongs to I, send (Output, \u22a5), else send (Output, b \u2032 i), where b \u2032 i denotes the share of b \u2032 corresponding to the honest party Pi. The simulator for the case of corrupt P 0 appears in Fig. 41.", "publication_ref": [], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "Functionality F Bit2A", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Offline Phase:", "text": "-Corresponding to the invocation of \u03a0 aSh (P0, u) protocol, S Bit2A receives v3 from A on behalf of both P1 and P2. S Bit2A sets flag = 1 if the received values mismatch.\n-S Bit2A performs the check honestly and sets flag = 1 if the verification fails.\nOnline Phase: The steps corresponding to \u03a0 vSh and \u03a0 Mult are simulated similar to S vSh (Fig. 29) and S Mult (Fig. 35) respectively, for the case of corrupt P0.", "publication_ref": [], "figure_ref": ["fig_2", "fig_3"], "table_ref": []}, {"heading": "Simulator S Bit2A", "text": "If flag = 0, S Bit2A invokes F Bit2A with input ( b B P 0 ) on behalf of P0. Else it invokes F Bit2A with input \u22a5 on behalf of P0. The simulator for the case of corrupt P 1 appears in Fig. 42.\nOffline Phase:\n-Corresponding to the invocation of \u03a0 aSh (P0, u) protocol, S Bit2A sends v3 to A on behalf of P0. It then sends H(v3) to A on behalf of P2 and receives H(v \u2032 3 ) back. S Bit2A sets flag = 1 if it receives inconsistent hash value.\n-S Bit2A receives (x1, y1) from A on behalf of P3, performs the check honestly and sets flag = 1 if the verification fails.\nOnline Phase: The steps corresponding to \u03a0 vSh and \u03a0 Mult are simulated similar to S vSh (Fig. 30) and S Mult (Fig. 36) respectively, for the case of corrupt P1.\nIf flag = 0, S Bit2A invokes F Bit2A with input ( b B P 1 ) on behalf of P1. Else it invokes F Bit2A with input \u22a5 on behalf of P1.  (bv) P 0 = (\u03bb (bv),1 , \u03bb (bv),2 , \u03bb (bv),3 ) (bv) P 1 = (m (bv) , \u03bb (bv),2 , \u03bb (bv),3 ) (bv) P 2 = (m (bv) , \u03bb (bv),3 , \u03bb (bv),1 ) (bv) P 3 = (m (bv) , \u03bb (bv),1 , \u03bb (bv),2 )", "publication_ref": [], "figure_ref": ["fig_2", "fig_3", "fig_3"], "table_ref": []}, {"heading": "Simulator S Bit2A", "text": "Output to adversary: If S sends abort, then send (Output, \u22a5) to all the parties. Otherwise, send (Output, (bv) S ) to the adversary S, where (bv) S denotes the share of (bv) corresponding to the corrupt party.\nOutput to selected honest parties: Receive (select, {I}) from adversary S, where {I} denotes a subset of the honest parties. If an honest party Pi belongs to I, send (Output, \u22a5), else send (Output, (bv) i), where (bv) i denotes the share of (bv) corresponding to the honest party Pi. The simulator for the case of corrupt P 0 appears in Fig. 44.", "publication_ref": [], "figure_ref": ["fig_4"], "table_ref": []}, {"heading": "Functionality F BitInj", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Offline Phase:", "text": "-Corresponding to the invocation of \u03a0 aSh (P0, yj ) protocol, S BitInj receives yj,3 from A on behalf of both P1 and P2. S BitInj sets flag = 1 if the received values mismatch.\n-S BitInj performs the check honestly and sets flag = 1 if the verification fails.\nOnline Phase: The steps corresponding to \u03a0 vSh are simulated similar to S vSh (Fig. 29), for the case of corrupt P0.\nIf flag = 0, S BitInj invokes F BitInj with input ( b B P 0 , v P 0 ) on behalf of P0. Else it invokes F BitInj with input \u22a5 on behalf of P0. The simulator for the case of corrupt P 1 appears in Fig. 45.", "publication_ref": [], "figure_ref": ["fig_2", "fig_4"], "table_ref": []}, {"heading": "Simulator S BitInj", "text": "Offline Phase:\n-Corresponding to the invocation of \u03a0 aSh (P0, u) protocol, S BitInj sends yj,3 to A on behalf of P0. It then sends H(yj,3) to A on behalf of P2 and receives H(y \u2032 j,3 ) back. S BitInj sets flag = 1 if it receives inconsistent hash value.\n-S BitInj emulates F Zero functionality and gives A to A.\n-S BitInj receives z2 from A on behalf of P3, performs the check honestly and sets flag = 1 if the verification fails.\nOnline Phase: The steps corresponding to \u03a0 vSh are simulated similar to S vSh (Fig. 30), for the case of corrupt P1.\nIf flag = 0, S BitInj invokes F BitInj with input ( b B P 1 , v P 1 ) on behalf of P1. Else it invokes F BitInj with input \u22a5 on behalf of P1. F MultTr interacts with the parties in P and the adversary S. F MultTr receives \u2022 -shares of values x and y from the parties as input. If F MultTr receives \u22a5 from S, then send \u22a5 to every party, else proceed with the computation.", "publication_ref": [], "figure_ref": ["fig_3"], "table_ref": []}, {"heading": "Simulator S BitInj", "text": "Computation of output: Compute x = mx \u2212 \u03bbx,1 \u2212 \u03bbx,2 \u2212 \u03bbx,3, y = my \u2212 \u03bby,1 \u2212 \u03bby,2 \u2212 \u03bby,3 and set z t = (xy) t . Randomly select \u03bb z t ,1 , \u03bb z t ,2 , \u03bb z t ,3 from Z 2 \u2113 and set m z t = z t + \u03bb z t ,1 + \u03bb z t ,2 + \u03bb z t ,3 . The output shares are set as: z t P 0 = (\u03bb z t ,1 , \u03bb z t ,2 , \u03bb z t ,3 ) z t P 1 = (m z t , \u03bb z t ,2 , \u03bb z t ,3 ) z t P 2 = (m z t , \u03bb z t ,3 , \u03bb z t ,1 ) z t P 3 = (m z t , \u03bb z t ,1 , \u03bb z t ,2 )\nOutput to adversary: If S sends abort, then send (Output, \u22a5) to all the parties. Otherwise, send (Output, z t S ) to the adversary S, where z t S denotes the share of z t corresponding to the corrupt party.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Functionality F MultTr", "text": "Output to selected honest parties: Receive (select, {I}) from adversary S, where {I} denotes a subset of the honest parties. If an honest party Pi belongs to I, send (Output, \u22a5), else send (Output, z t i), where z t i denotes the share of z t corresponding to the honest party Pi.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Figure 46: Functionality for protocol \u03a0 MultTr", "text": "The simulator for the case of corrupt P 0 appears in Fig. 47.\nOffline Phase:\n-The steps corresponding to offline phase of \u03a0 Mult are simulated similar to offline phase of S Mult (Fig. 35), for the case of corrupt P0.\n-Corresponding to the invocation of \u03a0 aSh (P0, r t ) protocol, S MultTr receives r t 3 from A on behalf of both P1 and P2. S MultTr sets flag = 1 if the received values mismatch.\n-S MultTr performs the check honestly and sets flag = 1 if the verification fails.\nOnline Phase: There is nothing to simulate as P0 has no role during the online phase.\nIf flag = 0, S MultTr invokes F MultTr with input ( x P 0 , y P 0 ) on behalf of P0. Else it invokes F MultTr with input \u22a5 on behalf of P0. The simulator for the case of corrupt P 1 appears in Fig. 48.", "publication_ref": [], "figure_ref": ["fig_4", "fig_3", "fig_4"], "table_ref": []}, {"heading": "Simulator S MultTr", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Offline Phase:", "text": "-The steps corresponding to offline phase of \u03a0 Mult are simulated similar to offline phase of S Mult (Fig. 36), for the case of corrupt P1.\n-Corresponding to the invocation of \u03a0 aSh (P0, r t ) protocol, S MultTr sends r t 3 to A on behalf of P0. It then sends H(r t 3 ) to A on behalf of P2 and receives H(r t   The simulator for the case of corrupt P 0 appears in Fig. 50.", "publication_ref": [], "figure_ref": ["fig_3", "fig_6"], "table_ref": []}, {"heading": "Offline Phase:", "text": "-S BitExt samples a random r on behalf of P1, P2 and set x = msb(r).\n-The steps corresponding to \u03a0 vSh are simulated similar to S vSh (Fig. 29), for the case of corrupt P0.\nOnline Phase:\n-The steps corresponding to \u03a0 Mult and \u03a0 Rec are simulated similar to S Mult (Fig. 35) and S Rec (Fig. 32) respectively, for the case of corrupt P0.\n-The steps corresponding to \u03a0 vSh is simulated similar to S vSh (Fig. 29), for the case of corrupt P0.\nIf flag = 0, S BitExt invokes F BitExt with input (\u03bbv,1, \u03bbv,2, \u03bbv,3) on behalf of P0. Else it invokes F BitExt with input \u22a5 on behalf of P0. The simulator for the case of corrupt P 1 appears in Fig. 51.", "publication_ref": [], "figure_ref": ["fig_2", "fig_3", "fig_2", "fig_2", "fig_1"], "table_ref": []}, {"heading": "Simulator S BitExt", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Offline Phase:", "text": "-S BitExt samples a random r on behalf of P2 and set x = msb(r).\n-The steps corresponding to \u03a0 vSh are simulated similar to S vSh (Fig. 30), for the case of corrupt P1.\nOnline Phase:\n-The steps corresponding to \u03a0 Mult and \u03a0 Rec are simulated similar Simulator S BitExt to S Mult (Fig. 36) and S Rec (Fig. 33) respectively, for the case of corrupt P1.\n-The steps corresponding to \u03a0 vSh is simulated similar to S vSh (Fig. 30), for the case of corrupt P1.\nIf flag = 0, S BitExt invokes F BitExt with input (mv, \u03bbv,2, \u03bbv,3) on behalf of P1. Else it invokes F BitExt with input \u22a5 on behalf of P1. ", "publication_ref": [], "figure_ref": ["fig_3", "fig_3", "fig_3", "fig_3"], "table_ref": []}, {"heading": "Acknowledgements", "text": "Ajith Suresh would like to acknowledge financial support from Google PhD Fellowship 2019.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Tetrad: Actively Secure 4PC for Secure Training and Inference", "journal": "CoRR arXiv", "year": "2021", "authors": "N Koti; A Patra; R Rachuri; A Suresh"}, {"ref_id": "b1", "title": "Fast and accurate classification of echocardiograms using deep learning", "journal": "", "year": "2017", "authors": "A Madani; R Arnaout; M Mofrad; R Arnaout"}, {"ref_id": "b2", "title": "SecureML: A system for scalable privacypreserving machine learning", "journal": "", "year": "2017", "authors": "P Mohassel; Y Zhang"}, {"ref_id": "b3", "title": "EPIC: efficient private image classification (or: Learning from the masters)", "journal": "CT-RSA", "year": "2018", "authors": "E Makri; D Rotaru; N P Smart; F Vercauteren"}, {"ref_id": "b4", "title": "Chameleon: A hybrid secure computation framework for machine learning applications", "journal": "", "year": "2018", "authors": "M S Riazi; C Weinert; O Tkachenko; E M Songhori; T Schneider; F Koushanfar"}, {"ref_id": "b5", "title": "ABY 3 : A Mixed Protocol Framework for Machine Learning", "journal": "", "year": "2018", "authors": "P Mohassel; P "}, {"ref_id": "b6", "title": "SecureNN: Efficient and private neural network training", "journal": "IACR Cryptology ePrint Archive", "year": "2018", "authors": "S Wagh; D Gupta; N Chandran"}, {"ref_id": "b7", "title": "Secure twoparty computation is practical", "journal": "ASIACRYPT", "year": "2009", "authors": "B Pinkas; T Schneider; N P Smart; S C Williams"}, {"ref_id": "b8", "title": "Is multiparty computation any good in practice?", "journal": "in IEEE ICASSP", "year": "2011", "authors": "C Orlandi"}, {"ref_id": "b9", "title": "From keys to databasesreal-world applications of secure multi-party computation", "journal": "Comput. J", "year": "2018", "authors": "D W Archer; D Bogdanov; Y Lindell; L Kamm; K Nielsen; J I Pagter; N P Smart; R N Wright"}, {"ref_id": "b10", "title": "High-Throughput Semi-Honest Secure Three-Party Computation with an Honest Majority", "journal": "", "year": "2016", "authors": "T Araki; J Furukawa; Y Lindell; A Nof; K Ohara"}, {"ref_id": "b11", "title": "High-Throughput Secure Three-Party Computation for Malicious Adversaries and an Honest Majority", "journal": "", "year": "2017", "authors": "J Furukawa; Y Lindell; A Nof; O Weinstein"}, {"ref_id": "b12", "title": "Optimized Honest-Majority MPC for Malicious Adversaries -Breaking the 1 Billion-Gate Per Second Barrier", "journal": "", "year": "2017", "authors": "T Araki; A Barak; J Furukawa; T Lichter; Y Lindell; A Nof; K Ohara; A Watzman; O Weinstein"}, {"ref_id": "b13", "title": "A Framework for Constructing Fast MPC over Arithmetic Circuits with Malicious Adversaries and an Honest-Majority", "journal": "", "year": "2017", "authors": "Y Lindell; A Nof"}, {"ref_id": "b14", "title": "Fast large-scale honest-majority MPC for malicious adversaries", "journal": "CRYPTO", "year": "2018", "authors": "K Chida; D Genkin; K Hamada; D Ikarashi; R Kikuchi; Y Lindell; A Nof"}, {"ref_id": "b15", "title": "Minimising Communication in Honest-Majority MPC by Batchwise Multiplication Verification", "journal": "ACNS", "year": "2018", "authors": "P S Nordholt; M Veeningen"}, {"ref_id": "b16", "title": "Fast and Secure Three-party Computation: Garbled Circuit Approach", "journal": "", "year": "2015", "authors": "P Mohassel; M Rosulek; Y Zhang"}, {"ref_id": "b17", "title": "Secure computation with minimal interaction, revisited", "journal": "CRYPTO", "year": "2015", "authors": "Y Ishai; R Kumaresan; E Kushilevitz; A Paskin-Cherniavsky"}, {"ref_id": "b18", "title": "On the exact round complexity of secure threeparty computation", "journal": "CRYPTO", "year": "2018", "authors": "A Patra; D Ravi"}, {"ref_id": "b19", "title": "Fast secure computation for small population over the internet", "journal": "ACM CCS", "year": "2018", "authors": "M Byali; A Joseph; A Patra; D Ravi"}, {"ref_id": "b20", "title": "Deploying Secure Multi-Party Computation for Financial Data Analysis", "journal": "FC", "year": "2012", "authors": "D Bogdanov; R Talviste; J Willemson"}, {"ref_id": "b21", "title": "Applicationscale secure multiparty computation", "journal": "ESOP", "year": "2014", "authors": "J Launchbury; D Archer; T Dubuisson; E Mertens"}, {"ref_id": "b22", "title": "Students and taxes: a privacy-preserving social study using secure computation", "journal": "IACR Cryptology ePrint Archive", "year": "2015", "authors": "D Bogdanov; L Kamm; B Kubo; R Rebane; V Sokk; R Talviste"}, {"ref_id": "b23", "title": "Sharemind: A framework for fast privacy-preserving computations", "journal": "", "year": "2008", "authors": "D Bogdanov; S Laur; J Willemson"}, {"ref_id": "b24", "title": "Viff: Virtual ideal functionality framework", "journal": "", "year": "2007", "authors": "M Geisler"}, {"ref_id": "b25", "title": "ASTRA: Highthroughput 3PC over Rings with Application to Secure Prediction", "journal": "", "year": "2019", "authors": "H Chaudhari; A Choudhury; A Patra; A Suresh"}, {"ref_id": "b26", "title": "Secure computation with low communication from cross-checking", "journal": "ASIACRYPT", "year": "2018", "authors": "S D Gordon; S Ranellucci; X Wang"}, {"ref_id": "b27", "title": "Spot-light: Lightweight private set intersection from sparse OT extension", "journal": "CRYPTO", "year": "2019", "authors": "B Pinkas; M Rosulek; N Trieu; A Yanai"}, {"ref_id": "b28", "title": "Efficient Multiparty Protocols Using Circuit Randomization", "journal": "", "year": "1991", "authors": "D Beaver"}, {"ref_id": "b29", "title": "Precomputing Oblivious Transfer", "journal": "", "year": "1995", "authors": "D Beaver"}, {"ref_id": "b30", "title": "Efficient Multi-party Computation with Dispute Control", "journal": "", "year": "2006", "authors": "Z Beerliov\u00e1-Trub\u00edniov\u00e1; M Hirt"}, {"ref_id": "b31", "title": "Perfectly-Secure MPC with Linear Communication Complexity", "journal": "", "year": "2008", "authors": "Z Beerliov\u00e1-Trub\u00edniov\u00e1; M Hirt"}, {"ref_id": "b32", "title": "Near-Linear Unconditionally-Secure Multiparty Computation with a Dishonest Minority", "journal": "CRYPTO", "year": "2012", "authors": "E Ben-Sasson; S Fehr; R Ostrovsky"}, {"ref_id": "b33", "title": "An Efficient Framework for Unconditionally Secure Multiparty Computation", "journal": "IEEE Trans. Information Theory", "year": "2017", "authors": "A Choudhury; A Patra"}, {"ref_id": "b34", "title": "Multiparty Computation from Somewhat Homomorphic Encryption", "journal": "CRYPTO", "year": "2012", "authors": "I Damg\u00e5rd; V Pastro; N P Smart; S Zakarias"}, {"ref_id": "b35", "title": "Practical covertly secure MPC for dishonest majority -or: Breaking the SPDZ limits", "journal": "", "year": "2013", "authors": "I Damg\u00e5rd; M Keller; E Larraia; V Pastro; P Scholl; N P Smart"}, {"ref_id": "b36", "title": "An architecture for practical actively secure MPC with dishonest majority", "journal": "", "year": "2013", "authors": "M Keller; P Scholl; N P Smart"}, {"ref_id": "b37", "title": "MASCOT: Faster Malicious Arithmetic Secure Computation with Oblivious Transfer", "journal": "", "year": "2016", "authors": "M Keller; E Orsini; P Scholl"}, {"ref_id": "b38", "title": "Better preprocessing for secure multiparty computation", "journal": "ACNS", "year": "2016", "authors": "C Baum; I Damg\u00e5rd; T Toft; R W Zakarias"}, {"ref_id": "b39", "title": "Yet another compiler for active security or: Efficient MPC over arbitrary rings", "journal": "CRYPTO", "year": "2018", "authors": "I Damg\u00e5rd; C Orlandi; M Simkin"}, {"ref_id": "b40", "title": "SPDZ2k: Efficient MPC mod 2\u02c6k for Dishonest Majority", "journal": "CRYPTO", "year": "2018", "authors": "R Cramer; I Damg\u00e5rd; D Escudero; P Scholl; C Xing"}, {"ref_id": "b41", "title": "Overdrive: Making SPDZ great again", "journal": "", "year": "2018", "authors": "M Keller; V Pastro; D Rotaru"}, {"ref_id": "b42", "title": "TASTY: tool for automating secure two-party computations", "journal": "ACM-CCS", "year": "2010", "authors": "W Henecka; S K\u00f6gl; A Sadeghi; T Schneider; I Wehrenberg"}, {"ref_id": "b43", "title": "MNIST handwritten digit database", "journal": "", "year": "2010", "authors": "Y Lecun; C Cortes"}, {"ref_id": "b44", "title": "Improved Garbled Circuit: Free XOR Gates and Applications", "journal": "", "year": "2008", "authors": "V Kolesnikov; T Schneider"}, {"ref_id": "b45", "title": "Flexor: Flexible garbling for XOR gates that beats free-xor", "journal": "CRYPTO", "year": "2014", "authors": "V Kolesnikov; P Mohassel; M Rosulek"}, {"ref_id": "b46", "title": "Two Halves Make a Whole -Reducing Data Transfer in Garbled Circuits Using Half Gates", "journal": "", "year": "2015", "authors": "S Zahur; M Rosulek; D Evans"}, {"ref_id": "b47", "title": "Fast Garbling of Circuits Under Standard Assumptions", "journal": "", "year": "2015", "authors": "S Gueron; Y Lindell; A Nof; B Pinkas"}, {"ref_id": "b48", "title": "Efficient Garbling from a Fixed-Key Blockcipher", "journal": "", "year": "2013", "authors": "M Bellare; V T Hoang; S Keelveedhi; P Rogaway"}, {"ref_id": "b49", "title": "Foundations of Garbled Circuits", "journal": "", "year": "2012", "authors": "M Bellare; V T Hoang; P Rogaway"}, {"ref_id": "b50", "title": "", "journal": "ENCRYPTO Utils", "year": "2017", "authors": "P E G Cryptography"}, {"ref_id": "b51", "title": "The ultimate halloween candy power ranking", "journal": "", "year": "2017", "authors": "W Hickey"}, {"ref_id": "b52", "title": "Hedonic housing prices and the demand for clean air", "journal": "Journal of Environmental Economics and Management", "year": "1978", "authors": "D Harrison; D L Rubinfeld"}, {"ref_id": "b53", "title": "Weather conditions in world war two", "journal": "", "year": "2017", "authors": ""}, {"ref_id": "b54", "title": "CalCOFI -over 60 years of oceanographic data", "journal": "", "year": "2017", "authors": "S Dane"}], "figures": [{"figure_label": "", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "d)Linearity of the secret sharing schemes: Given the [\u2022]-sharing of x, y and public constants c 1 , c 2 , parties can locally compute [c 1 x + c 2 y] = c 1 [x] + c 2 [y].", "figure_data": ""}, {"figure_label": "1", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 1 :1Figure 1: \u2022 -sharing of a value v by party Pi.", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Figure 2 :2Figure 2: \u2022 -sharing of a value v by party P0.", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Figure 3 :3Figure 3: Reconstruction of value v among parties in P.", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "Figure 4 :4Figure 4: Multiplication Protocol.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_5", "figure_caption": "-P1, P2, P3 set bit b = abort if the verification for multiplication fails. Else set b = continue. -P1, P2, P3 send b to P0 who sends back abort, if he/she receives at least one abort bit. Else sends continue to P1, P2, P3. -P1, P2, P3 mutually exchange the message received from P0. Parties abort if the majority of the messages received are abort. Else they exchange the missing share as follows: -P0 receives mv from P1, P2 and H(mv) from P3 respectively. -P1 receives \u03bbv,1 from P2, P3 and H(\u03bbv,1) from P0 respectively. -P2 receives \u03bbv,2 from P3, P1 and H(\u03bbv,2) from P0 respectively. -P3 receives \u03bbv,3 from P1, P2 and H(\u03bbv,3) from P0 respectively.", "figure_data": ""}, {"figure_label": "5", "figure_type": "figure", "figure_id": "fig_6", "figure_caption": "Figure 5 :5Figure 5: Fair reconstruction of value v among parties in P.", "figure_data": ""}, {"figure_label": "7", "figure_type": "figure", "figure_id": "fig_7", "figure_caption": "Figure 7 :7Figure 7: Verifiable Arithmetic/Boolean sharing of a value v.", "figure_data": ""}, {"figure_label": "8", "figure_type": "figure", "figure_id": "fig_8", "figure_caption": "Figure 8 :8Figure 8: Verifiable Garbled sharing of a value v.", "figure_data": ""}, {"figure_label": "9", "figure_type": "figure", "figure_id": "fig_9", "figure_caption": "Figure 9 :9Figure 9: Dot Product Protocol.", "figure_data": ""}, {"figure_label": "10", "figure_type": "figure", "figure_id": "fig_10", "figure_caption": "Figure 10 :10Figure 10: Garbled to Boolean Sharing.", "figure_data": ""}, {"figure_label": "11", "figure_type": "figure", "figure_id": "fig_11", "figure_caption": "Figure 11 :11Figure 11: Garbled to Arithmetic Sharing.", "figure_data": ""}, {"figure_label": "12", "figure_type": "figure", "figure_id": "fig_12", "figure_caption": "Figure 12 :12Figure 12: Boolean to Garbled Sharing.", "figure_data": ""}, {"figure_label": "13", "figure_type": "figure", "figure_id": "fig_13", "figure_caption": "Figure 13 :13Figure 13: Arithmetic to Garbled Sharing.", "figure_data": ""}, {"figure_label": "14", "figure_type": "figure", "figure_id": "fig_14", "figure_caption": "Figure 14 :14Figure 14: Arithmetic to Boolean Sharing.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_15", "figure_caption": "y2). Here x \u2032 denotes the bit x over ring Z 2 \u2113 . Protocol \u03a0 Bit2A -If the verification succeeds, P1, P2, P3 converts u to u locally by setting mu = 0 and \u03bbu = \u2212 u . Online: Let v denotes the bit m b over ring Z 2 \u2113 . -Parties execute \u03a0 vSh (P1, P2, P3, v) to generate v . -Parties execute \u03a0 Mult on u and v to generate uv . -Parties locally compute b = v + u \u2212 2 uv .", "figure_data": ""}, {"figure_label": "15", "figure_type": "figure", "figure_id": "fig_16", "figure_caption": "Figure 15 :15Figure 15: Bit to Arithmetic Sharing.", "figure_data": ""}, {"figure_label": "16", "figure_type": "figure", "figure_id": "fig_17", "figure_caption": "Figure 16 :16Figure 16: Boolean to Arithmetic Sharing V2.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_18", "figure_caption": "h) Bit Injection (BitInj): b B v \u2192 bv : Let y 1 and y 2 denote the values \u03bb b and \u03bb b \u03bb v respectively over ring Z 2 \u2113 . Similarly, let x 0 , x 1 , x 2 and x 3 denote the values (m b m v ), (m b ), (m v \u22122m v m b ) and (2m b \u22121) respectively over ring Z 2 \u2113 . Then,", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_19", "figure_caption": "and P2 send z2 and H(\u2212z3) respectively to P3, where z2 = u2 \u2212 y2,2 and z3 = u3 \u2212 y2,3. -P3 sets z1 = u1 \u2212 y2,1 and abort if H(z1 + z2) = H(\u2212z3). Online: Let x0, x1, x2 and x3 denote the values (m b mv), (m b ), (mv \u2212 2mvm b ) and (2m b \u2212 1) respectively over ring Z 2 \u2113 . -Parties compute the following:", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_20", "figure_caption": "c3) and \u03a0 vSh (P3, P2, c1) to generate c2 , c3 and c1 respectively.-Parties locally compute bv = c1 + c2 + c3 .", "figure_data": ""}, {"figure_label": "17", "figure_type": "figure", "figure_id": "fig_21", "figure_caption": "Figure 17 :17Figure 17: Bit Injection: b B v A \u2192 bv A . In the offline phase, P 0 generates \u2022 -shares of \u03bb \u2032 b and \u03bb b \u03bb v where \u03bb \u2032 b denotes the bit \u03bb b over Z 2 \u2113 . The check for \u03bb \u2032 b is the same as the one for \u03a0 Bit2A , to check \u03bb b \u03bb v parties proceed as mentioned in protocol \u03a0 BitInj above. During the online phase, parties locally compute [\u2022]-shares of b\u2022v followed by generating \u2022 -shares of it by executing \u03a0 vSh protocol. Parties then locally add their shares to obtain b \u2022 v . V. PRIVACY PRESERVING MACHINE LEARNING Most of the intermediate values in machine learning algorithms involve operating over decimals. To represent decimal values, we use signed two's compliment over Z 2 \u2113 [3],[6],[26], where the most significant bit (msb) represents the sign and the last d bits represent the fractional part.", "figure_data": ""}, {"figure_label": "18", "figure_type": "figure", "figure_id": "fig_22", "figure_caption": "Figure 18 :18Figure 18: Multiplication with Truncation.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_23", "figure_caption": "Functions a) ReLU: The ReLU function is defined as relu(v) = max(0, v). This can be viewed as relu(v) = (1 \u2295 b)v where bit b = 1 if v < 0 and 0 otherwise. In order to generate relu(v) , parties first execute \u03a0 BitExt on v to obtain b B and locally compute 1 \u2295 b B . This is followed by executing \u03a0 BitInj on 1\u2295b B and v . The derivative of relu, denoted by drelu(v) = (1 \u2295 b).", "figure_data": ""}, {"figure_label": "19", "figure_type": "figure", "figure_id": "fig_24", "figure_caption": "Figure 19 :19Figure 19: Throughput Gain in Low-end Networks.", "figure_data": ""}, {"figure_label": "20", "figure_type": "figure", "figure_id": "fig_25", "figure_caption": "Figure 20 :20Figure 20: Functionality for Shared Key Setup", "figure_data": ""}, {"figure_label": "21", "figure_type": "figure", "figure_id": "fig_26", "figure_caption": "Figure 21 :21Figure 21: Generating [\u2022]-sharing of zero", "figure_data": ""}, {"figure_label": "5", "figure_type": "figure", "figure_id": "fig_27", "figure_caption": "Theorem B. 5 .5\u03a0 4PC requires one round with an amortized communication of 3M ring elements during the offline phase. In the online phase, \u03a0 4PC requires one round with an amortized communication of at most 3I ring elements in the Inputsharing stage, D rounds with an amortized communication of 3M ring elements for evaluation stage and one round with an amortized communication of 3O elements for the outputreconstruction stage. Proof: The proof follows from Lemmas B.1, B.4 and B.3. Lemma B.6 (Communication). Protocol \u03a0 fRec (Fig. 5) requires 4 rounds and an amortized communication of 8\u2113 bits in the online phase.", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_28", "figure_caption": "Lemma D. 4 (4Communication). Protocol ReLU (\u03a0 relu ) requires 3 rounds and a communication of 8\u2113 + 2 bits in the offline phase, while it requires 4 rounds and a communication of 8\u2113+2 bits in the online phase. Proof: The cost follows directly from Lemmas D.3 and C.11. Lemma D.5 (Communication). Protocol Sigmoid (\u03a0 sig ) requires 3 rounds and a communication of 15\u2113 + 7 bits in the offline phase, while it requires 5 rounds and a communication of 16\u2113 + 7 bits in the online phase. Proof: The cost follows directly from Lemmas D.3, B.4, C.9 and C.11.", "figure_data": ""}, {"figure_label": "22", "figure_type": "figure", "figure_id": "fig_29", "figure_caption": "Figure 22 :22Figure 22: Ideal world 4PC functionality", "figure_data": ""}, {"figure_label": "23", "figure_type": "figure", "figure_id": "fig_30", "figure_caption": "Figure 23 :23Figure 23: Simulator for the case of corrupt P0", "figure_data": ""}, {"figure_label": "25", "figure_type": "figure", "figure_id": "fig_31", "figure_caption": "Figure 25 :25Figure 25: Functionality for protocol \u03a0 Sh", "figure_data": ""}, {"figure_label": "26", "figure_type": "figure", "figure_id": "fig_32", "figure_caption": "Figure 26 :26Figure 26: Simulator S Sh for the case of corrupt P0", "figure_data": ""}, {"figure_label": "27", "figure_type": "figure", "figure_id": "fig_33", "figure_caption": "Figure 27 :27Figure 27: Simulator S Sh for the case of corrupt P1", "figure_data": ""}, {"figure_label": "29", "figure_type": "figure", "figure_id": "fig_34", "figure_caption": "Figure 29 :29Figure 29: Simulator S vSh for the case of corrupt P0", "figure_data": ""}, {"figure_label": "30", "figure_type": "figure", "figure_id": "fig_35", "figure_caption": "Figure 30 :30Figure 30: Simulator S vSh for the case of corrupt P1", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_36", "figure_caption": "FRec interacts with the parties in P and the adversary S. F Rec receives the \u2022 -shares of value v from party Pi for i \u2208 {0, 1, 2, 3}. The shares are", "figure_data": ""}, {"figure_label": "32", "figure_type": "figure", "figure_id": "fig_37", "figure_caption": "Figure 32 :32Figure 32: Simulator S Rec for the case of corrupt P0", "figure_data": ""}, {"figure_label": "33", "figure_type": "figure", "figure_id": "fig_38", "figure_caption": "Figure 33 :33Figure 33: Simulator S Rec for the case of corrupt P1", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_39", "figure_caption": "FMult interacts with the parties in P and the adversary S. F Mult receives \u2022 -shares of values x and y from the parties as input. If F Mult receives \u22a5 from S, then send \u22a5 to every party, else proceed with the computation.", "figure_data": ""}, {"figure_label": "34", "figure_type": "figure", "figure_id": "fig_40", "figure_caption": "Figure 34 :34Figure 34: Functionality for protocol \u03a0 Mult", "figure_data": ""}, {"figure_label": "35", "figure_type": "figure", "figure_id": "fig_41", "figure_caption": "Figure 35 :35Figure 35: Simulator for the case of corrupt P0", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_42", "figure_caption": "-S Mult sends m \u2032 z,1 and H(m \u2032 z,1 ) to A on behalf of P2 and P3 respectively. It receives m \u2032 z,3 and H(m \u2032 z,2 ) from A on behalf of P3 and P2 respectively. S Mult sets flag = 1 if any of the received values is inconsistent.If flag = 0, S Mult invokes F Mult with input ( x P 1 , y P 1 ) on behalf of P1. Else it invokes F Mult with input \u22a5 on behalf of P1.Simulator S Mult", "figure_data": ""}, {"figure_label": "36", "figure_type": "figure", "figure_id": "fig_43", "figure_caption": "Figure 36 :36Figure 36: Simulator for the case of corrupt P1", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_44", "figure_caption": "FDotP interacts with the parties in P and the adversary S. F DotP receives \u2022 -shares of vectors x and y from the parties as input.Here x and y are d-length vectors. If F DotP receives \u22a5 from S, then send \u22a5 to every party, else proceed with the computation.", "figure_data": ""}, {"figure_label": "37", "figure_type": "figure", "figure_id": "fig_45", "figure_caption": "Figure 37 :37Figure 37: Functionality for protocol \u03a0 Sh", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_46", "figure_caption": "-SDotP receives H(\u03b3xy,1), H(\u03b3xy,2) and H(\u03b3xy,3) from A on behalf of P2, P3 and P1 respectively. S DotP sets flag = 1 if any of the received values is inconsistent.Online Phase: There is nothing to simulate as P0 has no role during the online phase.If flag = 0, S DotP invokes F DotP with input ({ xi P 0 , yi P 0 } i\u2208[d] )on behalf of P0. Else it invokes F DotP with input \u22a5 on behalf of P0.Simulator S DotP", "figure_data": ""}, {"figure_label": "38", "figure_type": "figure", "figure_id": "fig_47", "figure_caption": "Figure 38 :38Figure 38: Simulator for the case of corrupt P0", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_48", "figure_caption": "-SDotP simulates the computation of m \u2032 z shares honestly on behalf of P2 and P3. -S DotP sends m \u2032 z,1 and H(m \u2032 z,1 ) to A on behalf of P2 and P3 respectively. It receives m \u2032 z,3 and H(m \u2032 z,2 ) from A on behalf of P3 and P2 respectively. S DotP sets flag = 1 if any of the received values is inconsistent. If flag = 0, S DotP invokes F DotP with input ({ xi P 1 , yi P 1 } i\u2208[d] ) on behalf of P1. Else it invokes F DotP with input \u22a5 on behalf of P1.", "figure_data": ""}, {"figure_label": "39", "figure_type": "figure", "figure_id": "fig_49", "figure_caption": "Figure 39 :39Figure 39: Simulator for the case of corrupt P1", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_50", "figure_caption": "FBit2A interacts with the parties in P and the adversary S. F Bit2A receives \u2022 B -share of a bit b from the parties as input. If F Bit2A receives \u22a5 from S, then send \u22a5 to every party, else proceed with the computation.", "figure_data": ""}, {"figure_label": "40", "figure_type": "figure", "figure_id": "fig_51", "figure_caption": "Figure 40 :40Figure 40: Functionality for protocol \u03a0 Bit2A", "figure_data": ""}, {"figure_label": "41", "figure_type": "figure", "figure_id": "fig_52", "figure_caption": "Figure 41 :41Figure 41: Simulator for the case of corrupt P0", "figure_data": ""}, {"figure_label": "42", "figure_type": "figure", "figure_id": "fig_53", "figure_caption": "Figure 42 :42Figure 42: Simulator for the case of corrupt P1", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_54", "figure_caption": "FBitInj interacts with the parties in P and the adversary S. F BitInj receives ( b B , v ) from the parties as input. If F BitInj receives \u22a5 from S, then send \u22a5 to every party, else proceed with the computation.Computation of output:Compute b = m b \u2295 \u03bb b,1 \u2295 \u03bb b,2 \u2295 \u03bb b,3 , v = mv \u2212 \u03bbv,1 \u2212 \u03bbv,2 \u2212 \u03bbv,3 and set (bv) = b \u2022 v. Randomly select \u03bb (bv),1 , \u03bb (bv),2 , \u03bb (bv),3 from Z 2 \u2113 and set m (bv) = (bv) + \u03bb (bv),1 + \u03bb (bv),2 + \u03bb (bv),3 . The output shares are set as:", "figure_data": ""}, {"figure_label": "43", "figure_type": "figure", "figure_id": "fig_55", "figure_caption": "Figure 43 :43Figure 43: Functionality for protocol \u03a0 BitInj", "figure_data": ""}, {"figure_label": "44", "figure_type": "figure", "figure_id": "fig_56", "figure_caption": "Figure 44 :44Figure 44: Simulator for the case of corrupt P0", "figure_data": ""}, {"figure_label": "45", "figure_type": "figure", "figure_id": "fig_57", "figure_caption": "Figure 45 :45Figure 45: Simulator for the case of corrupt P1", "figure_data": ""}, {"figure_label": "47", "figure_type": "figure", "figure_id": "fig_58", "figure_caption": "Figure 47 :47Figure 47: Simulator for the case of corrupt P0", "figure_data": ""}, {"figure_label": "348", "figure_type": "figure", "figure_id": "fig_59", "figure_caption": "3 \u2032Figure 48 :348Figure 48: Simulator for the case of corrupt P1", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_60", "figure_caption": "F 2 )2BitExt interacts with the parties in P and the adversary S. F BitExt receives \u2022 -share of value v from the parties as input. If F BitExt receives \u22a5 from S, then send \u22a5 to every party, else proceed with the computation.Computation of output:Compute v = mv \u2212 \u03bbv,1 \u2212 \u03bbv,2 \u2212 \u03bbv,3 and set b = msb(v) where msb denotes the most significant bit.Randomly select \u03bb b,1 , \u03bb b,2 , \u03bb b,3 from Z 2 1 and set m b = b\u2295\u03bb b,1 \u2295 \u03bb b,2 \u2295 \u03bb b,3 . The output shares are set as:b B P 0 = (\u03bb b,1 , \u03bb b,2 , \u03bb b,3 ) b B P 1 = (m b , \u03bb b,2 , \u03bb b,3 ) b B P 2 = (m b , \u03bb b,3 , \u03bb b,1 ) b B P 3 = (m b , \u03bb b,1 , \u03bb b,Output to adversary: If S sends abort, then send (Output, \u22a5) to all the parties. Otherwise, send (Output, b S ) to the adversary S, where b S denotes the share of b corresponding to the corrupt party.Output to selected honest parties: Receive (select, {I}) from adversary S, where {I} denotes a subset of the honest parties. If an honest party Pi belongs to I, send (Output, \u22a5), else send (Output, b i), where b i denotes the share of b corresponding to the honest party Pi.Functionality F BitExt", "figure_data": ""}, {"figure_label": "49", "figure_type": "figure", "figure_id": "fig_61", "figure_caption": "Figure 49 :49Figure 49: Functionality for protocol \u03a0 BitExt", "figure_data": ""}, {"figure_label": "50", "figure_type": "figure", "figure_id": "fig_62", "figure_caption": "Figure 50 :50Figure 50: Simulator for the case of corrupt P0", "figure_data": ""}, {"figure_label": "51", "figure_type": "figure", "figure_id": "fig_63", "figure_caption": "Figure 51 :51Figure 51: Simulator for the case of corrupt P0", "figure_data": ""}, {"figure_label": "II", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "TableIIIgives the concrete gain of the aforementioned algorithms over the most widely used MNIST dataset[44], which has 784 features, implemented with a batch size of 128. Moreover, our framework is able to process 23 online iterations of NN in a second for a batch size of 128, over LAN. This is a huge improvement over ABY3, which can process only 2.5 iterations, that too in the semi-honest setting. Similarly, for CNN, we can process 10.46 iterations as opposed to 2 of ABY3.", "figure_data": "NetworkLinear RegressionLogistic RegressionNNCNNLAN81.08\u00d727.07\u00d768.08\u00d745.64\u00d7WAN2.17\u00d72.76\u00d72.97\u00d73.19\u00d7"}, {"figure_label": "III", "figure_type": "table", "figure_id": "tab_2", "figure_caption": "", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_3", "figure_caption": ") from P1 and P2 respectively.-Pi for i \u2208 {1, 2, 3} abort if the received values are inconsistent. Else, he / she computes mz", "figure_data": "1my \u2212 \u03bby,1mx + \u03b3xy,1 + \u03bbz,1.-Parties exchange the following:-P1 receives m \u2032 z,1 and H(m \u2032 z,1 ) from P2 and P3 respectively.-P2 receives m \u2032 z,2 and H(m \u2032 z,2 ) from P3 and P1 respectively.-P3 receives m \u2032 z,3 and H(m \u2032 z,3"}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_4", "figure_caption": "exchange the following: -P1 receives m \u2032 z,1 and H(m \u2032 z,1 ) from P2 and P3 respectively. -P2 receives m \u2032 z,2 and H(m \u2032 z,2 ) from P3 and P1 respectively. -P3 receives m \u2032 z,3 and H(m \u2032 z,3 ) from P1 and P2 respectively. -Pi for i \u2208 {1, 2, 3} abort if the received values are inconsistent. Else, he / she computes mz", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_7", "figure_caption": "in our case. It contains 28\u00d728 pixel images of handwritten numbers and 784 features. For benchmarking of the prediction phase, we use the following real-world datasets: Conditions in World War Two", "figure_data": "Dataset#features #samplesCandy (CD) Power Ranking [52]1385Boston (BT) Housing Prices [53]14506Weather (WR)com/"}, {"figure_label": "IV", "figure_type": "table", "figure_id": "tab_9", "figure_caption": "", "figure_data": ""}, {"figure_label": "V", "figure_type": "table", "figure_id": "tab_11", "figure_caption": "", "figure_data": ""}, {"figure_label": "VI", "figure_type": "table", "figure_id": "tab_13", "figure_caption": "", "figure_data": ""}, {"figure_label": "VII", "figure_type": "table", "figure_id": "tab_15", "figure_caption": "", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_16", "figure_caption": "VIII provides the online throughput comparison of ABY3 and ours for secure prediction over real-world datasets in a LAN setting. The gains for linear regression range from 26.16\u00d7 to 145.18\u00d7 and from 5.69\u00d7 to 158.40\u00d7 for logistic regression. Similarly, we observed gains of 335.44\u00d7 and 598.44\u00d7 for NN and CNN respectively.", "figure_data": "Linear RegressionLogistic RegressionNNCNNRef.BTWRCICDEPREMNISTABY34.081.740.732.200.290.080.460.06This106.67106.67106.6712.5512.5512.55153.3937.43In WAN, even though our protocols are more communi-cation efficient as compared to ABY3, we could not fullycapitalize on it especially for Linear Regression and Logistic"}, {"figure_label": "VIII", "figure_type": "table", "figure_id": "tab_17", "figure_caption": "Online Throughput Comparison of ABY3 (Malicious) and This for Secure Prediction over LAN. (higher = better)", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_18", "figure_caption": "[56] R. G. Andrzejak, K. Lehnertz, F. Mormann, C. Rieke, P. David, and C. Elger, \"Indications of nonlinear deterministic and finite-dimensional structures in time series of brain electrical activity: Dependence on recording region and brain state,\" Physical review. E, Statistical, nonlinear, and soft matter physics, 2002.[57] H. Darwood, \"Epicurious -recipes with rating and nutrition,\" 2017.[Online]. Available: https://www.kaggle.com/hugodarwood/epirecipes/ [58] N. B\u00fcscher, D. Demmler, S. Katzenbeisser, D. Kretzmer, and T. Abril, P. Maene, N. Mertens, and N. P. Smart, \"Bristol Fashion MPC Circuits,\" https://homes.esat.kuleuven.be/ \u223c nsmart/MPC/, 2019.", "figure_data": "Schnei-der, \"Hycc: Compilation of hybrid protocols for practical secure com-putation,\" in Proceedings of the 2018 ACM SIGSAC Conference onComputer and Communications Security, CCS 2018, Toronto, ON,Canada, October 15-19, 2018, 2018.[59] V. A."}, {"figure_label": "X", "figure_type": "table", "figure_id": "tab_20", "figure_caption": "ML conversions of ABY3 and Ours. d denotes the number of features", "figure_data": ""}, {"figure_label": "XI", "figure_type": "table", "figure_id": "tab_22", "figure_caption": "Total Online Runtime (in seconds) ofGordon et al. and    This for evaluation on an AES-128 circuit (lower = better) over WAN.", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_23", "figure_caption": "XII shows that our total runtime for both training and prediction phases in the malicious case is lower for all the algorithms considered. For the training phase, we use a batch size of 128. The number of features for both training and prediction is 784.", "figure_data": "PhaseRef.Linear RegressionLogistic RegressionNNCNNTrainingABY32.018.9238.4141.45(s)This0.923.7613.0713.19PredictionABY31.458.3621.1222.48(s)This0.442.746.906.93Table XII: Total Online Runtime (in seconds) of ABY3 (Malicious)and This for Training and Prediction of Linear, Logistic, NN, andCNN models for d = 784 (lower = better) over a WAN setting."}, {"figure_label": "XIII", "figure_type": "table", "figure_id": "tab_25", "figure_caption": "Comparison of Online Phase of ABY3 (Semi-Honest) and This for ML Training (higher = better) In Table XIII, we compare the online phase of both protocols for ML training, in terms of the number of iterations per second they can process. In Table XIV and Table XVwe compare the online phase for prediction through two benchmarking units, one being the runtime and the other being the throughput, which is the number of queries we can process per second.", "figure_data": "NetworkRef.Linear RegressionLogistic RegressionNNCNNLANABY3S0.309.14480.811185.70(ms)This0.302.5517.1739.63WANABY3S0.161.544.074.47(s)This0.160.932.312.31"}, {"figure_label": "XIV", "figure_type": "table", "figure_id": "tab_26", "figure_caption": "Online Runtime of ABY3 (Semi-honest) and This for", "figure_data": "Secure Prediction of Linear, Logistic, NN, and CNN models for d =784 (lower = better)AlgorithmRef.LAN (queries/sec)WAN (queries/min)LinearABY3S106666.6712488.62RegressionThis106666.6712488.62LogisticABY3S3512.621248.86RegressionThis12549.022081.46NeuralABY3S66.41211.18NetworksThis153.39368.13CNNABY3S This21.47 37.4351.54 89.84"}, {"figure_label": "XV", "figure_type": "table", "figure_id": "tab_27", "figure_caption": "", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_28", "figure_caption": "Gate Evaluation: No simulation is needed for the online phase of addition gates. For a multiplication gate g = (wx, wy, wz, \u00d7), S 4PC computes and sends [m \u2032 z ] 1 and H([m \u2032 z ] 1 ) to P1 on behalf of P2 and P3 respectively. It receives H([m \u2032 z ] 2 ) and [m \u2032 z ] 3 from P1 on behalf of P2 and P3 respectively.S 4PC sets flag = 1, if any of the received values are inconsistent. -Obtaining function outputs: If flag = 1, S 4PC invokes F 4PC with input \u22a5 on behalf of P1. Else it sends inputs {vj } extracted on behalf of P1 to F 4PC and receives the function outputs y1, . . . , y O .", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "G2B ABY3 1 \u03ba This 1 3 G2A ABY3 1 2\u2113\u03ba This 1 3\u2113 B2G ABY3 1 2\u03ba This 1 \u03ba A2G ABY3 1 2\u2113\u03ba This 1 \u2113\u03ba A2B ABY3 1 + log \u2113 9\u2113 log \u2113 + 9\u2113 This 1 + log \u2113 3\u2113 log \u2113 + \u2113 B2A ABY3 1 + log \u2113 9\u2113 log \u2113 + 9\u2113 This 1 3\u2113", "formula_coordinates": [3.0, 95.15, 549.06, 169.66, 134.79]}, {"formula_id": "formula_1", "formula_text": "ABY3 1 12\u2113 This 1 3\u2113 Secure Comparison ABY3 log \u2113 18\u2113 log \u2113 This 3 5\u2113 + 2 Bit2A b B \u2192 b ABY3 2 18\u2113 This 1 3\u2113 BitInj b B v \u2192 bv ABY3 3", "formula_coordinates": [3.0, 343.9, 357.24, 206.32, 91.89]}, {"formula_id": "formula_2", "formula_text": "x \u2299 y = d i=1 x i y i .", "formula_coordinates": [4.0, 48.96, 548.81, 82.89, 14.33]}, {"formula_id": "formula_3", "formula_text": "v = v 1 + v 2 + v 3 . We use [\u2022] Pi to denote the [\u2022]-share of party P i for i \u2208 {1, 2, 3}. b) \u2022 -sharing: A value v", "formula_coordinates": [4.0, 318.96, 176.97, 252.1, 37.44]}, {"formula_id": "formula_4", "formula_text": "(v 2 , v 3 ), (v 3 , v 1 ) and (v 1 , v 2 ) such that v = v 1 + v 2 + v 3 .", "formula_coordinates": [4.0, 318.96, 226.29, 252.18, 21.69]}, {"formula_id": "formula_5", "formula_text": "v P1 = (v 2 , v 3 ), v P2 = (v 3 , v 1 ), v P3 = (v 1 , v 2 ) c) \u2022 -sharing: A value v is said to be \u2022 -shared among parties P 0 , P 1 , P 2 , P 3 , if -there exist values \u03bb v , m v \u2208 Z 2 \u2113 such that m v = v + \u03bb v .", "formula_coordinates": [4.0, 318.96, 253.41, 252.3, 56.85]}, {"formula_id": "formula_6", "formula_text": "v P 0 = (\u03bbv,1, \u03bbv,2, \u03bbv,3) v P 1 = (mv, \u03bbv,2, \u03bbv,3) v P 2 = (mv, \u03bbv,3, \u03bbv,1) v P 3 = (mv, \u03bbv,1, \u03bbv,2)", "formula_coordinates": [4.0, 351.84, 381.36, 190.18, 18.95]}, {"formula_id": "formula_7", "formula_text": "1 x + c 2 y] = (c 1 x 1 + c 2 y 1 , c 1 x 2 + c 2 y 2 , c 1 x 3 + c 2 y 3 ) = c 1 [x] + c 2 [y]", "formula_coordinates": [4.0, 343.08, 466.05, 210.99, 24.33]}, {"formula_id": "formula_8", "formula_text": "Pi for i \u2208 {0, 1, 2, 3} abort if the received values are inconsistent. Else computes v = mv \u2212 \u03bbv,1 \u2212 \u03bbv,2 \u2212 \u03bbv,3. Protocol \u03a0 Rec (P, v )", "formula_coordinates": [5.0, 52.05, 434.29, 242.84, 102.72]}, {"formula_id": "formula_9", "formula_text": "m z = z + \u03bb z = xy + \u03bb z = (m x \u2212 \u03bb x )(m y \u2212 \u03bb y ) + \u03bb z = m x m y \u2212 \u03bb x m y \u2212 \u03bb y m x + \u03bb x \u03bb y + \u03bb z", "formula_coordinates": [5.0, 338.28, 161.13, 212.97, 24.02]}, {"formula_id": "formula_10", "formula_text": "Online: Let m \u2032 z = mz \u2212 mxmy. -Parties locally compute the following: -P1, P3 compute m \u2032 z,2 = \u2212\u03bbx,2my \u2212 \u03bby,2mx + \u03b3xy,2 + \u03bbz,2. -P2, P1 compute m \u2032 z,3 = \u2212\u03bbx,3my \u2212 \u03bby,3mx + \u03b3xy,3 + \u03bbz,3. -P3, P2 compute m \u2032 z,1 = \u2212\u03bbx,", "formula_coordinates": [5.0, 322.05, 465.03, 233.12, 59.31]}, {"formula_id": "formula_11", "formula_text": "= (m \u2032 z,1 + m \u2032 z,2 + m \u2032 z,3 ) + mxmy = m \u2032 z + mxmy.", "formula_coordinates": [5.0, 330.09, 585.27, 234.92, 20.79]}, {"formula_id": "formula_12", "formula_text": ": For a bit v, v G is defined as v G Pi = K 0 v \u2208 {0, 1} \u03ba for i \u2208 {1, 2, 3} and v G P0 = K v v = K 0 v \u2295 vR,", "formula_coordinates": [6.0, 318.96, 442.85, 252.18, 32.36]}, {"formula_id": "formula_13", "formula_text": "v G P1 (resp. v G P2 , v G P3 ) and v G P0 is v. For a value v \u2208 Z 2 \u2113 , we abuse the notation v G to denote the set of \u2022 G -shares of each bit of v. Offline: -P1, P2, P3 samples a random K 0 v \u2208 {0, 1} \u03ba , computes K 1 v = K 0 v \u2295 R and set v G P 1 = v G P 2 = v G P 3 = K 0 v . -P1, P2, P3 compute commitment of K 0 v , K 1 v .", "formula_coordinates": [6.0, 318.96, 508.61, 252.3, 111.61]}, {"formula_id": "formula_14", "formula_text": "-Pi sends K 0 v \u2295 vR to P0, who sets it as v G P 0 . -Pi decommits the right key K v v to P0, who abort if the decommitment is incorrect. Protocol \u03a0 G Sh (Pi, v) Figure 6: \u2022 G -sharing of v by Pi for i \u2208 {1, 2, 3}. b) Input Sharing: Protocol \u03a0 G Sh (P i , v", "formula_coordinates": [6.0, 325.05, 552.29, 239.9, 163.95]}, {"formula_id": "formula_15", "formula_text": "If P i = P 0 , then \u03a0 G Sh (P i , v", "formula_coordinates": [7.0, 63.36, 139.49, 123.67, 12.78]}, {"formula_id": "formula_16", "formula_text": "\u03a0 G Sh (P 1 , v 1 ) and \u03a0 G Sh (P 2 , v 2 ) to generate v 1 G and v 2 G respectively. Parties then locally compute v G = v 1 G \u2295 v 2 G", "formula_coordinates": [7.0, 48.96, 161.45, 252.45, 34.08]}, {"formula_id": "formula_17", "formula_text": "d) Operations: Let u, v \u2208 {0, 1} be \u2022 G -shared with P 1 , P 2 , P 3 holding the shares (K 0 u , K 0 v ), and P 0 holding the shares (K 0 u \u2295 uR, K 0 v \u2295 vR). Let c denote the output. -XOR: The parties locally compute c G = u G \u2295 v G .", "formula_coordinates": [7.0, 48.96, 349.61, 252.1, 51.88]}, {"formula_id": "formula_18", "formula_text": "to obtain c G P0 = K c c . P i for i \u2208 {1, 2, 3} sets c G Pi = K 0 c .", "formula_coordinates": [7.0, 48.96, 445.25, 252.42, 24.89]}, {"formula_id": "formula_19", "formula_text": "Protocol \u03a0 vSh (Pi, Pj, v)", "formula_coordinates": [7.0, 65.98, 562.44, 94.3, 9.03]}, {"formula_id": "formula_20", "formula_text": "Offline: P1, P2, P3 locally sample random K 0 v \u2208 {0, 1} \u03ba , compute K 1 v = K 0 v \u2295 R and set v G P 1 = v G P 2 = v G P 3 = K 0 v .", "formula_coordinates": [7.0, 322.05, 198.36, 242.78, 24.27]}, {"formula_id": "formula_21", "formula_text": "-If (Pi, Pj ) = (P1, P0): -P1, P2 compute commitments Com(K 0 v ), Com(K 1 v", "formula_coordinates": [7.0, 325.05, 250.72, 199.49, 21.39]}, {"formula_id": "formula_22", "formula_text": "G P 0 = K v v . -If (Pi, Pj) = (P k , P0) for k \u2208 {2, 3}:", "formula_coordinates": [7.0, 325.05, 302.13, 239.96, 24.33]}, {"formula_id": "formula_23", "formula_text": "P 0 = K v v . -If (Pi, Pj) = (P1, P3) or (P2,", "formula_coordinates": [7.0, 325.05, 359.85, 128.32, 24.28]}, {"formula_id": "formula_24", "formula_text": "Protocol \u03a0 DotP ( x, y)", "formula_coordinates": [7.0, 335.98, 559.67, 82.9, 9.03]}, {"formula_id": "formula_25", "formula_text": "m \u2032 z,2 = d j=1 (\u2212\u03bbx j ,2my j \u2212 \u03bby j ,2mx j ) + \u03b3xy,2 + \u03bbz,2. -P2, P1: m \u2032 z,3 = d j=1 (\u2212\u03bbx j ,3my j \u2212 \u03bby j ,3mx j ) + \u03b3xy,3 + \u03bbz,3. -P3, P2: m \u2032 z,1 = d j=1 (\u2212\u03bbx j ,1my j \u2212 \u03bby j ,1mx j ) + \u03b3xy,1 + \u03bbz,1. -Parties", "formula_coordinates": [8.0, 55.05, 151.47, 239.96, 51.04]}, {"formula_id": "formula_26", "formula_text": "= (m \u2032 z,1 + m \u2032 z,2 + m \u2032 z,3 ) + + d j=1 (mx j my j ) = m \u2032 z + d j=1 (mx j my j ).", "formula_coordinates": [8.0, 59.97, 250.23, 235.04, 23.19]}, {"formula_id": "formula_27", "formula_text": "-P1, P2 locally sample random r \u2208 Z 2 \u2113 . Parties execute \u03a0 G", "formula_coordinates": [8.0, 55.05, 550.48, 239.9, 19.05]}, {"formula_id": "formula_28", "formula_text": "\u03a0 B vSh (P3, P0, v \u2295 r) to generate v \u2295 r B . -Parties locally compute v B = v \u2295 r B \u2295 r B .", "formula_coordinates": [8.0, 55.05, 677.65, 239.96, 24.35]}, {"formula_id": "formula_29", "formula_text": "\u03a0 A vSh (P3, P0, v \u2212 r) to generate v \u2212 r A . -Parties locally compute v A = v \u2212 r A + r A . Protocol \u03a0 G2A", "formula_coordinates": [8.0, 325.05, 131.34, 239.96, 204.18]}, {"formula_id": "formula_30", "formula_text": "v = (m v \u2295 \u03bb v,1 ) \u2295 (\u03bb v,2 \u2295 \u03bb v,3", "formula_coordinates": [8.0, 318.96, 382.65, 119.17, 10.34]}, {"formula_id": "formula_31", "formula_text": "-P2, P3 execute \u03a0 G vSh (P2, P3, x) to generate x G where x = mv \u2295 \u03bbv,1. -Parties locally compute v G = x G \u2295 y G . Protocol \u03a0 B2G", "formula_coordinates": [8.0, 325.05, 457.18, 239.96, 103.34]}, {"formula_id": "formula_32", "formula_text": "Similar to \u03a0 B2G , v = (m v \u2212 \u03bb v,1 ) \u2212 (\u03bb v,2 + \u03bb v,3", "formula_coordinates": [8.0, 318.96, 602.99, 252.18, 20.85]}, {"formula_id": "formula_33", "formula_text": ") \u2032 = u + r \u2032 b \u2212 2ur \u2032", "formula_coordinates": [9.0, 48.96, 485.21, 252.06, 22.24]}, {"formula_id": "formula_34", "formula_text": "Let r \u2032 b denotes the bit r b over ring Z 2 \u2113 . -P1 computes x1 = \u03bb b,3 \u2295 r b , y1 = (u2 + u3)(1 \u2212 2r \u2032 b ) + r \u2032 b + r and sends (x1, y1) to P3. -P2 computes y2 = u1(1 \u2212 2r \u2032 b ) \u2212 r and sends H(y2) to P3. -P3 computes x = \u03bb b \u2295 r b = x1 \u2295 \u03bb b,1 \u2295 \u03bb b,2 and abort if H(x \u2032 \u2212 y1) = H(", "formula_coordinates": [9.0, 59.49, 669.6, 235.55, 63.09]}, {"formula_id": "formula_35", "formula_text": "\u2113\u22121 i=0 2 i \u2022 v i , where v i denotes the ith bit of v over a ring Z 2 \u2113 . Note that v = \u2113\u22121 i=0 2 i \u2022 v i = \u2113\u22121 i=0 2 i \u2022 (m \u2032 vi + \u03bb \u2032 ui \u2212 2m \u2032 vi \u2022 \u03bb \u2032 ui )", "formula_coordinates": [9.0, 318.96, 190.33, 251.58, 60.21]}, {"formula_id": "formula_36", "formula_text": "-P1, P3 compute x = \u2113\u22121 i=0 2 i (qi + pi,2 \u2212 2qi \u2022 pi,2). -P2, P1 compute y = \u2113\u22121 i=0 2 i (pi,3 \u2212 2qi \u2022 pi,3). -P3, P2 compute z = \u2113\u22121 i=0 2 i (pi,1 \u2212 2qi \u2022 pi,1). -Parties generate x , y and z by executing \u03a0 vSh (P1, P3, x), \u03a0 vSh (P2, P1, y) and \u03a0 vSh (P3, P2, z) respectively. -Parties locally compute v = x + y + z . Protocol \u03a0 B2A", "formula_coordinates": [9.0, 325.05, 357.44, 239.96, 196.72]}, {"formula_id": "formula_37", "formula_text": "b \u2022 v = (m b \u2295 \u03bb b )(m v \u2212 \u03bb v ) = x 0 \u2212 x 1 y 1 + x 2 y 2 + x 3 y 3", "formula_coordinates": [9.0, 331.2, 642.93, 227.17, 10.65]}, {"formula_id": "formula_38", "formula_text": "A + B + \u0393 = 0. -P1 computes u2 = \u03bby 1 ,2\u03bbv,2 + \u03bby 1 ,2\u03bbv,3 + \u03bby 1 ,3\u03bbv,2 + A. -P2 computes u3 = \u03bby 1 ,3\u03bbv,3 + \u03bby 1 ,3\u03bbv,1 + \u03bby 1 ,1\u03bbv,3 + B. -P3 computes u1 = \u03bby 1 ,1\u03bbv,1 + \u03bby 1 ,1\u03bbv,2 + \u03bby 1 ,2\u03bbv,1 + \u0393. -P1", "formula_coordinates": [10.0, 59.49, 110.08, 225.08, 52.48]}, {"formula_id": "formula_39", "formula_text": "-P1, P3 compute c2 = x0 \u2212 x1\u03bbv,2 + x2y1,2 + x3y2,2. -P2, P1 compute c3 = \u2212x1\u03bbv,3 + x2y1,3 + x3y2,3. -P3, P2 compute c1 = \u2212x1\u03bbv,1 + x2y1,1 + x3y2,1. -Parties execute \u03a0 vSh (P1, P3, c2), \u03a0 vSh (P2, P1,", "formula_coordinates": [10.0, 55.05, 232.84, 208.88, 44.91]}, {"formula_id": "formula_40", "formula_text": "P \\ {P2} : r2, P \\ {P1} : r1, P \\ {P3} : r3", "formula_coordinates": [10.0, 82.53, 721.49, 189.41, 8.97]}, {"formula_id": "formula_41", "formula_text": "m1 = r2 \u2212 2 d r t 2 \u2212 r d,2 + c. P1 sends (m1, H(c)) to P2. -P2 computes m2 = (r1 + r3) \u2212 2 d (r t 1 + r t 3 ) \u2212 (r d,1 + r d,3", "formula_coordinates": [10.0, 329.49, 120.04, 235.52, 30.9]}, {"formula_id": "formula_42", "formula_text": "-P1, P3 compute [z \u2032 ] 2 = \u2212\u03bbx,2my \u2212 \u03bby,2mx + \u03b3xy,2 \u2212 r2. -P2, P1 compute [z \u2032 ] 3 = \u2212\u03bbx,3my \u2212 \u03bby,3mx + \u03b3xy,3 \u2212 r3. -P3, P2 compute [z \u2032 ] 1 = \u2212\u03bbx,1my \u2212 \u03bby,1mx + \u03b3xy,1 \u2212 r1.", "formula_coordinates": [10.0, 329.49, 219.87, 217.88, 34.14]}, {"formula_id": "formula_43", "formula_text": "-P1 receives [z \u2032 ]", "formula_coordinates": [10.0, 329.49, 267.75, 66.64, 10.17]}, {"formula_id": "formula_44", "formula_text": "(z \u2212 r) = [z \u2032 ] 1 + [z \u2032 ] 2 + [z \u2032 ] 3 + mxmy.", "formula_coordinates": [10.0, 418.77, 313.47, 143.48, 12.3]}, {"formula_id": "formula_45", "formula_text": "sig(v) = \uf8f1 \uf8f2 \uf8f3 0 v < \u2212 1 2 v + 1 2 \u2212 1 2 \u2264 v \u2264 1 2 1 v > 1 2", "formula_coordinates": [11.0, 99.0, 120.17, 144.73, 45.46]}, {"formula_id": "formula_46", "formula_text": "1 )b 2 (v+1/2)+(1\u2295b 2 ), where b 1 = 1 if v + 1/2 < 0 and b 2 = 1 if v \u2212 1/2 < 0.", "formula_coordinates": [11.0, 48.96, 164.73, 252.09, 21.57]}, {"formula_id": "formula_47", "formula_text": "P 0 -P 1 P 0 -P 2 P 0 -P 3 P 1 -P 2 P 1 -P 3 P 2 -P", "formula_coordinates": [11.0, 63.83, 503.91, 220.81, 8.6]}, {"formula_id": "formula_48", "formula_text": "w = w \u2212 \u03b1 B X T i \u2022 (X i \u2022 w \u2212 Y i )", "formula_coordinates": [11.0, 375.6, 416.61, 138.87, 23.52]}, {"formula_id": "formula_49", "formula_text": "w = w \u2212 \u03b1 B X T j \u2022 ( X j \u2022 w \u2212 Y j )", "formula_coordinates": [11.0, 354.6, 563.73, 184.83, 23.52]}, {"formula_id": "formula_50", "formula_text": "w = w \u2212 \u03b1 B X T i \u2022 (sig(X i \u2022 w) \u2212 Y i )", "formula_coordinates": [12.0, 96.0, 332.61, 157.94, 23.52]}, {"formula_id": "formula_51", "formula_text": "A i = relu(U i ), where U i = A i\u22121 \u2022 W i . A 0 is initialized to X j ,", "formula_coordinates": [12.0, 318.96, 238.41, 252.18, 21.25]}, {"formula_id": "formula_52", "formula_text": "E i = (E i+1 \u2022 W T i ) \u2297 drelu(U i ).", "formula_coordinates": [12.0, 362.4, 325.21, 130.89, 12.57]}, {"formula_id": "formula_53", "formula_text": "W i = W i \u2212 \u03b1 B A T i\u22121 \u2022 E i .", "formula_coordinates": [12.0, 330.84, 357.73, 109.41, 13.77]}, {"formula_id": "formula_54", "formula_text": "[(x 1 , x 2 ) \u2190 A(k) : (x 1 = x 2 ) \u2227 H k (x 1 ) = H k (x 2 )] \u2264 negl(\u03ba), where m = poly(\u03ba) and x 1 , x 2 \u2208 R {0, 1} m . b) Shared Key Setup: Let F : 0, 1 \u03ba \u00d7 0, 1 \u03ba \u2192 X be a secure PRF, with co-domain X being Z 2 \u2113 .", "formula_coordinates": [15.0, 48.96, 278.49, 252.22, 61.41]}, {"formula_id": "formula_55", "formula_text": "G2B ABY3 1 \u03ba 1 \u03ba This 1 \u03ba + 1 + |Decode| 1 3 G2A ABY3 1 |G3| + \u2113\u03ba 1 2\u2113\u03ba This 1 \u2113\u03ba + \u2113 + |G2| 1 3\u2113 B2G ABY3 0 0 1 2\u03ba This 1 \u03ba 1 \u03ba A2G ABY3 1 |G4| 1 2\u2113\u03ba This 1 \u2113\u03ba + |G1| 1 \u2113\u03ba A2B ABY3 3 12\u2113 log \u2113 + 12\u2113 1 + log \u2113 9\u2113 log \u2113 + 9\u2113 This 1 3\u2113 log \u2113 + 2\u2113 1 + log \u2113 3\u2113 log \u2113 + \u2113 Bit2A ABY3 1 24\u2113 2 18\u2113 This 2 3\u2113 + 1 1 3\u2113 B2A ABY3 3 12\u2113 log \u2113 + 12\u2113 1 + log \u2113 9\u2113 log \u2113 + 9\u2113 This 2 3\u2113 2 + \u2113 1 3\u2113 BitInj ABY3 1 36\u2113 3 27\u2113 This 2 6\u2113 + 1 1 3\u2113", "formula_coordinates": [17.0, 327.55, 393.88, 233.49, 167.23]}, {"formula_id": "formula_56", "formula_text": "m 1 + m 2 = c where m 1 = r 2 \u2212 2 d r t 2 \u2212 r d,2 + c and m 2 = (r 1 + r 3 ) \u2212 2 d (r t 1 + r t 3 ) \u2212 (r d,1 + r d,3", "formula_coordinates": [17.0, 318.96, 692.73, 252.18, 33.93]}, {"formula_id": "formula_57", "formula_text": "m 1 + m 2 = r 2 \u2212 2 d r t 2 \u2212 r d,2 + c + (r 1 + r 3 ) \u2212 2 d (r t 1 + r t 3 ) \u2212 (r d,1 + r d,3 ) = (r 1 + r 2 + r 3 ) \u2212 2 d (r t 1 + r t 2 + r t 3 ) \u2212 (r d,1 + r d,2 + r d,3 ) + c = (r) \u2212 (2 d r t + r d ) + c = 0 + c = c", "formula_coordinates": [18.0, 64.08, 71.69, 217.23, 70.98]}, {"formula_id": "formula_58", "formula_text": "\u03a0 MultTr ABY3 2\u2113 \u2212 2 96\u2113 \u2212 42d \u2212 84 1 12\u2113 This 2 6\u2113 1 3\u2113 \u03a0 BitExt ABY3 1 24\u2113 log \u2113 log \u2113 18\u2113 log \u2113 This 1 4\u2113 + 1 3 5\u2113 +", "formula_coordinates": [18.0, 327.42, 84.47, 233.73, 36.25]}, {"formula_id": "formula_59", "formula_text": "x \u2032 j = xj internally. If x \u2032 j = Z 2 \u2113 , consider x \u2032 j = abort.", "formula_coordinates": [19.0, 322.05, 521.19, 242.09, 21.54]}, {"formula_id": "formula_60", "formula_text": "-If Pi = P1, S", "formula_coordinates": [21.0, 325.05, 395.2, 67.98, 8.97]}, {"formula_id": "formula_61", "formula_text": "v P 0 = (\u03bb \u2032 v,1 , \u03bb \u2032 v,2 , \u03bb \u2032 v,3 ) v P 1 = (m \u2032 v , \u03bb \u2032\u2032 v,2 , \u03bb \u2032\u2032 v,3 ) v P 2 = (m \u2032\u2032 v , \u03bb \u2032\u2032\u2032 v,3 , \u03bb \u2032\u2032 v,1 ) v P 3 = (m \u2032\u2032\u2032 v , \u03bb \u2032\u2032\u2032 v,1 , \u03bb \u2032\u2032\u2032 v,2 )", "formula_coordinates": [22.0, 78.57, 631.32, 193.66, 30.87]}, {"formula_id": "formula_62", "formula_text": ": i) \u03bb \u2032 v,1 = \u03bb \u2032\u2032 v,1 = \u03bb \u2032\u2032\u2032 v,1 , ii) \u03bb \u2032 v,2 = \u03bb \u2032\u2032 v,2 = \u03bb \u2032\u2032\u2032 v,2 , iii) \u03bb \u2032 v,3 = \u03bb \u2032\u2032 v,3 = \u03bb \u2032\u2032\u2032 v,3 or iv) m \u2032 v = m \u2032\u2032 v = m \u2032\u2032\u2032 v .", "formula_coordinates": [22.0, 52.05, 681.96, 242.96, 20.79]}, {"formula_id": "formula_63", "formula_text": "Set v = mv \u2212 \u03bbv,1 \u2212 \u03bbv,2 \u2212 \u03bbv,3.", "formula_coordinates": [22.0, 156.93, 721.09, 122.6, 8.97]}, {"formula_id": "formula_64", "formula_text": "S Rec receives H(\u03bb \u2032 v,1 ), H(\u03bb \u2032 v,2", "formula_coordinates": [22.0, 334.53, 264.15, 108.65, 10.83]}, {"formula_id": "formula_65", "formula_text": "Compute xi = mx i \u2212 \u03bbx i ,1 \u2212 \u03bbx i ,2 \u2212 \u03bbx i ,3, yi = my i \u2212 \u03bby i ,1 \u2212 \u03bby i ,2 \u2212 \u03bby i ,3 for i \u2208 [d] and set z = d i=1", "formula_coordinates": [23.0, 322.05, 114.4, 242.96, 31.34]}, {"formula_id": "formula_66", "formula_text": "Compute b = m b \u2295 \u03bb b,1 \u2295 \u03bb b,2 \u2295 \u03bb b,3 . Let b \u2032 denotes the value of bit b over an arithmetic ring Z 2 \u2113 . Randomly select \u03bb \u2032 b,1 , \u03bb \u2032 b,2 , \u03bb \u2032 b,3 from Z 2 \u2113 and set m \u2032 b = b \u2032 +\u03bb \u2032 b,1 + \u03bb \u2032 b,2 + \u03bb \u2032 b,3 .", "formula_coordinates": [24.0, 52.05, 323.2, 242.96, 39.87]}, {"formula_id": "formula_67", "formula_text": "b \u2032 P 0 = (\u03bb \u2032 b,1 , \u03bb \u2032 b,2 , \u03bb \u2032 b,3 ) b \u2032 P 1 = (m \u2032 b , \u03bb \u2032 b,2 , \u03bb \u2032 b,3 ) b \u2032 P 2 = (m \u2032 b , \u03bb \u2032 b,3 , \u03bb \u2032 b,1 ) b \u2032 P 3 = (m \u2032 b , \u03bb \u2032 b,1 , \u03bb \u2032 b,2 )", "formula_coordinates": [24.0, 79.17, 370.11, 192.46, 31.2]}], "doi": ""}