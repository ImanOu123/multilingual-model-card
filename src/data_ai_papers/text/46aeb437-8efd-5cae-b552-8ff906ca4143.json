{"title": "A Level Set Theory for Neural Implicit Evolution under Explicit Flows", "authors": "Ishit Mehta; Manmohan Chandraker; Ravi Ramamoorthi", "pub_date": "2022-07-21", "abstract": "Coordinate-based neural networks parameterizing implicit surfaces have emerged as efficient representations of geometry. They effectively act as parametric level sets with the zero-level set defining the surface of interest. We present a framework that allows applying deformation operations defined for triangle meshes onto such implicit surfaces. Several of these operations can be viewed as energy-minimization problems that induce an instantaneous flow field on the explicit surface. Our method uses the flow field to deform parametric implicit surfaces by extending the classical theory of level sets. We also derive a consolidated view for existing methods on differentiable surface extraction and rendering, by formalizing connections to the level-set theory. We show that these methods drift from the theory and that our approach exhibits improvements for applications like surface smoothing, mean-curvature flow, inverse rendering and user-defined editing on implicit geometry.", "sections": [{"heading": "Introduction", "text": "Recent successes in generative modeling of shapes [13,48,54] and inverse rendering [43,71] are largely driven by implicit representations of geometry parameterized as multi-layer perceptrons (MLPs) (or neural implicits [16]). These networks can compactly represent highly-detailed surfaces at (theoretically) infinite resolution [36,55,61,62]; they are defined continuously in R 3 and are differentiableenabling their usage in gradient-based optimization [26,71] and learning [2,12,39] methods. Despite these advances, there is still a large body of work in geometry processing, computer vision and graphics which relies on explicit surface representations. Often these mesh-based algorithms are a better choice than their implicit counterparts. For instance, in case of inverse rendering, differentiable renderers for triangle meshes [18,28,29,44,73] are a) faster, b) more accurate, and c) can handle more complex light-transport effects, in comparison to the renderers designed for implicit surfaces [24,43,71]. Similarly, geometry processing algorithms for applications like surface smoothing and deformation [10,56,63] are vastly superior in terms of compute and memory requirements than the ones developed for neural implicit surfaces [69]. Most of these methods, however, are highly specific to mesh geometry and are not easily adaptable to MLP-defined surfaces. Our work is a theoretical attempt to bridge this gap.\nWe first introduce the following insight: several mesh-based algorithms define an energy-minimization problem that is solved using gradient descent; the gradients used by the optimizer to update the geometry can be viewed as analogous to an instantaneous explicit flow-field (V) applied on the surface. Informed by the literature on fluid simulation [7] and level-sets [46], deformation of a surface with such a flow field depends on the geometry representation.\nx \u2192 x \u2032 V\nThe Lagrangian representation involves tracking the surface explicitly as a set of a points (x) and connections (like triangles). The point-set is discrete and the connectivity is static, which keeps the optimization relatively simple; we can separately integrate the field at each point (update vertices x \u2192 x \u2032 ). But optimization of the resolution of the surface is non-trivial and can also get unwieldy for problems which involve surfaces with unknown topology.\n\u03d5 \u2192 \u03d5 \u2032 Alternatively, Eulerian descriptions can be used. Each point in space has an object-property \u03d5 associated with it, like the distance from the surface or its occupancy inside the enclosed volume. The surface here is implicitly defined with dynamic connectivity; one can smoothly vary the topology during optimization. Canonically, \u03d5 is defined only on a discrete voxel-grid and needs to be interpolated for points off the grid. Here, making instantaneous updates to the surface is more involved as it requires changing \u03d5 values for a large set of points. A neural implicit is a continuous variant of an Eulerian representation. Applying a flow field to such functions is non-trivial as updates are required in the parameter (j) space as opposed to directly updating \u03d5 to \u03d5 \u2032 .\nWe propose a parametric level-set evolution method ( \u00a7 4) which propagates neural implicit surfaces according to an explicitly generated flow field. Our method comprises of three repeating steps, 1) A non-differentiable surface extraction method like Marching Cubes [33] or Sphere Tracing [22] is used to obtain a Lagrangian representation corresponding to a neural implicit, 2) A mesh-based algorithm is used to derive a flow field on the explicit surface ( \u00a7 4.1), and 3) A corresponding Eulerian flow field is used to evolve the implicit geometry ( \u00a7 4.2). Previous methods [43,51,53] approach the problem of using mesh-based energy functions on Eulerian surfaces with the idea of differentiable extraction of Lagrangian representations. We show these methods are not in accordance with the level-set theory [47] ( \u00a7 5). The discussion also yields a more general proof ( \u00a7 5.1) for differentiable surface extraction from level set functions with arbitrary gradient norms (|\u2207\u03d5| \u0338 = 1). Our method is more formally connected to the theory and we validate it with experimental observations made on three diverse problem settings, 1) Curvature-based deformation ( \u00a7 6.1), where we demonstrate more accurate surface smoothing and mean-curvature flow than previous methods [51,69], 2) Inverse rendering of geometry ( \u00a7 6.2), where we show accurate recovery from multi-view images for high-genus shapes without object masks as in [43,71] (example in Fig. 1), and 3) User-defined shape editing ( \u00a7 6.3), where the implicit surface is deformed 60\u00d7 faster than previous work [69].", "publication_ref": ["b12", "b48", "b54", "b43", "b71", "b15", "b35", "b55", "b61", "b62", "b25", "b71", "b1", "b11", "b38", "b17", "b27", "b28", "b44", "b73", "b23", "b43", "b71", "b9", "b56", "b63", "b69", "b6", "b46", "b32", "b21", "b43", "b51", "b53", "b47", "b51", "b69", "b43", "b71", "b69"], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "Related Work", "text": "Coordinate-based MLPs have become a popular choice as function approximators for signals like images, videos and shapes [13,48,55,58,62]. Our work focuses on using MLPs for approximating implicit geometry. Such representations are compact, continuous and differentiable. These advantages are well suited with gradient-descent based optimization and learning problems. Recent developments in generative modeling of shapes [11,37,48,54], 3D consistent image synthesis [12,68], 3D reconstruction [5,59,74] and inverse rendering [26,45,70,71], all rely on representing geometry using MLPs. For a more detailed discussion on recent work regarding coordinate-based representations refer to the survey by Xie et al. [67], and for inverse rendering the survey by Tewari et al. [65].\nThere is also a rich literature on geometry processing [8,10,9,57,56] and inverse rendering [4,18,34,42] for explicit surface representations. Yang et al. [69] introduce some of the geometry processing ideas to neural implicit surfaces, but the method could be inaccurate ( \u00a7 6.1) and slow ( \u00a7 6.3).\nFor inverse rendering applications, differentiable renderers for triangle meshes are used for gradient-based optimization. Physics-based renderers differentiate through a light-simulation process [6,29,44,73] and provide accurate gradients. Alternatively, differentiable rasterization [28,32,50] can be used for high-performance gradient computation, but only for single-bounce rendering models. However, optimizing triangle meshes with gradient-descent is non-trivial. Careful design of the optimization method [18,42] and error functions [34] is required for robust optimization. To circumvent some of these issues, IDR [71] and DVR [43] use implicit surface representations like SDFs and occupancy functions [38] parameterized with MLPs. These methods mitigate some of the topological restrictions, but are not physics-based and are not in accordance with the level-set theory ( \u00a7 5.2). We propose an inverse rendering method which uses explicit differentiable renderers for parametrically defined implicit surfaces. The proposed method is not as sensitive to initialization as explicit methods [18,42] are, does not require an object mask like implicit methods [43,71] do, and maintains the ability to vary topology during optimization.\nOur method uses the level-set theory [47] as the foundation for optimizing and deforming parametric implicit surfaces. Previous methods [3,41,66] for the applications discussed in this work apply to non-parametric level sets. Perhaps the most related works to our method are MeshSDF [51] and RtS [15]. Compared to MeshSDF, our approach is more formally connected to the theory of level-sets ( \u00a7 4), applies to all parametric functions ( \u00a7 5.1), and works for a more diverse set of optimization problems like shape editing ( \u00a7 6.1, 6.3) and inverse rendering ( \u00a7 6.2) -deviating from experimental observations made by Remelli et al. [51] on learning-based settings. Compared to RtS [15], we show geometry processing applications along with theoretical parallels ( \u00a7 5) between parametric level-set methods like MeshSDF [51], DVR [43], IDR [71] and the classical theory [46]. Our inverse rendering method is shown to work ( \u00a7 6.2) for a set of high-genus shapes with a genus-0 initialization, in contrast to object-pose optimization or small genus changes shown in [15]. Recent work by Munkberg et al. [40] and Hasselgren et al. [23] also show promise in using explicit differentiable renderers with implicit geometry for inverse problems.", "publication_ref": ["b12", "b48", "b55", "b58", "b62", "b10", "b36", "b48", "b54", "b11", "b68", "b4", "b59", "b74", "b25", "b45", "b70", "b71", "b67", "b65", "b7", "b9", "b8", "b57", "b56", "b3", "b17", "b33", "b41", "b69", "b5", "b28", "b44", "b73", "b27", "b31", "b50", "b17", "b41", "b33", "b71", "b43", "b37", "b17", "b41", "b43", "b71", "b47", "b2", "b40", "b66", "b51", "b14", "b51", "b14", "b51", "b43", "b71", "b46", "b14", "b39", "b22"], "figure_ref": [], "table_ref": []}, {"heading": "Background", "text": "Consider a closed surface of arbitrary topology \u2202\u2126 evolving with respect to time t. We define a Lagrangian representation of this surface with a finite set of k points in R 3 as \u2202\u2126 L = {x i | x i \u223c \u2202\u2126; \u2200i \u2208 {1, 2, 3, . . . , k}}. This point-set can be viewed as a triangle mesh if an additional set of connections between the points is provided, and as a point cloud otherwise. Implicitly this surface can also be represented with a family of level-sets \u03d5 : R 3 \u2192 R, the zero iso-contour of which represents the surface \u2202\u2126 E = {x | \u03d5(x) = 0}. \u03d5 can be arbitrarily chosen, but a canonical choice is a signed-distance function (SDF) which satisfies:\n\u03d5(x) = (\u00b1) min x C \u2208\u2202\u2126 {||x \u2212 x C || 2 },(1)\nwhere x C is the closest point on the surface to x and the sign of \u03d5(x) denotes whether x is enclosed (\u2212) within the shape or not (+).\nParameterizing \u03d5 Analytically defining \u03d5 for simple and regular shapes is relatively straightforward [49], but is infeasible for most objects. Recent work on 3D reconstruction [43,71] and generative shape modeling [13,48] suggests parameterizing \u03d5 using a multi-layer perceptron (MLP) with j as its parameters. The networks are optimized by minimizing an energy function comprised of a distance term [48] and a gradient term [19] enforcing |\u2207\u03d5| to be 1. We use SIREN [55] as the parametric function of choice, although our method is agnostic to the network parameterization. The network acts approximately as an SDF at the rest state (t = 0), but may not retain the SDF property (Eq. 1) as the surface evolves. We denote this surface as \u2202\u2126 E (j) = {x | \u03a6(x; j) = 0}, where \u03a6 is parameterized with j as the weights and biases of the network. For clarity, we use \u03a6 for parametric level-sets and \u03d5 for non-parametric.", "publication_ref": ["b49", "b43", "b71", "b12", "b48", "b48", "b18", "b55"], "figure_ref": [], "table_ref": []}, {"heading": "Method", "text": "We begin the discussion by first characterizing the deformation of surfaces into Lagrangian ( \u00a7 4.1) and Eulerian ( \u00a7 4.2) settings. We show that gradient descent on energy functions defined for triangle meshes can be viewed as surface deformation under the dynamics of a flow field V, which is discretely defined only on the surface points \u2202\u2126 L . We can use this flow field to deform a continuous surface representation using the level-set equation. We extend the level-set equation to the case of parametric level-sets \u03a6 which enables us to use loss functions defined on triangle meshes to deform MLP-defined level-sets.\nParametric Level-Sets Eulerian \u2202\u2126E Lagrangian \u2202\u2126L MC \u2202\u03d5 \u2202t \u03a6(x; j) minx i E dx dt xi V(xi)\nUpdate j Fig. 2: Method Overview. We present a level-set method to evolve neural representations of implicit surfaces. Using Marching Cubes (MC) [33], a Lagrangian surface \u2202\u2126 L is extracted from an Eulerian representation \u2202\u2126 E encoded in the network parameters j. An energy function E is defined on \u2202\u2126 L which is minimized using gradient-descent. The gradients of the optimizer together act as a flow-field V on the surface points x, which is used to evolve the non-parametric \u03d5 using the level-set equation. The values of \u03d5 on the surface act as references to update the parameters j of the network.", "publication_ref": ["b32"], "figure_ref": [], "table_ref": []}, {"heading": "Lagrangian Deformation", "text": "As mentioned earlier, in the Lagrangian setting, the surface is defined with a finite set of points \u2202\u2126 L . A variety of methods in geometry processing and computer vision define an energy function E that is minimized to make instantaneous updates to \u2202\u2126 L . Some recent examples include optimizing point-clouds for viewsynthesis [1,52] and triangle-meshes for inverse-rendering of geometry [18,42]. The surface is updated using spatial gradients \u2202E \u2202x , which is well studied in numerical analysis [60] and optimization methods [14]. Through the lens of physics, these gradients induce an instantaneous flow field V(x), which can be used to evolve the surface by integrating the following ordinary differential equation (ODE):\ndx dt = \u2212 \u2202E \u2202x \u2192 V(x). \u25c1 Lagrangian Deformation (2)\nNumerically, this can be done using forward-Euler steps x t+1 = x t + \u2206tV t (x). This is easy to accomplish if the connectivity of the points remains static. More sophisticated integration schemes can also be used [60]. Here, in case of optimization problems solved using gradient descent, \u2206t is equivalent to the learning rate. Several works in shape deformation [21] and inverse rendering [42] can be subsumed by this ODE with different definitions for flow V and time-step \u2206t. We next show that these readily available energy functions and optimization algorithms defined for explicit surfaces can also be used to optimize MLP-defined level-sets.", "publication_ref": ["b0", "b52", "b17", "b41", "b60", "b13", "b60", "b20", "b41"], "figure_ref": [], "table_ref": []}, {"heading": "Eulerian Deformation", "text": "To avoid the topological complications associated with Lagrangian deformations, we can instead define a corresponding Eulerian deformation field. By definition, we know for points x \u2208 \u2202\u2126, \u03d5(x) = 0. Using implicit differentiation:\nd\u03d5(x) dt = \u2202\u03d5 \u2202t + \u2202\u03d5 \u2202x \u2202x \u2202t = \u2202\u03d5 \u2202t + \u2207\u03d5 \u2022 V = 0 \u25c1 From 2 \u21d0\u21d2 \u2202\u03d5 \u2202t = \u2212\u2207\u03d5 \u2022 V. \u25c1 Eulerian Deformation (3)\nThis partial differential equation (PDE) is sometimes referred to as the level-set equation [47], the material derivative [7] or the G-equation [35]. We extend this PDE to obtain an evolution method for parametric level-sets \u03a6. First, for each time step t, we extract a Lagrangian surface representation \u2202\u2126 t L from \u03a6 using MC [33]. Depending on the task at hand, an energy function E (e.g., photometric error for inverse rendering) is defined on \u2202\u2126 t L . Assuming E is differentiable, we compute \u2202E \u2202x = \u2212V t (x) for each vertex x i \u2208 \u2202\u2126 L . With the flow field V t , we update the level-set function as we would in the non-parametric case using forward-Euler steps:\n\u03d5 t+1 = \u03a6 t \u2212 \u2206t\u2207\u03a6 t \u2022 V t . \u25c1 From (3)(4)\nThe time step \u2206t here is a parameter which is dependent on the dynamics of the flow-field. If V is highly non-linear, taking smaller steps (i.e., \u2206t is small) is required, while for a simple field, larger values of \u2206t should suffice. For each time step, we take the values of non-parametric \u03d5 t+1 as the reference and update the parameters of \u03a6 accordingly. This is achieved by minimizing the following objective:\nmin j J(j) = 1 |\u2202\u2126 L | x\u2208\u2202\u2126 L ||\u03d5 t+1 (x) \u2212 \u03a6(x; j)|| 2 ,(5)\nusing gradient descent. Since the surface updates are small for each time step, the number of descent steps required is in the order of 10 2 . This makes the method convenient for obtaining neural representations of deformed variants of the initial geometry. After each optimization routine, we again extract the Lagrangian surface using MC [33], which is subsequently fed into a mesh-based energy-minimization problem. An overview of our method is shown in Figure 2.\nFor each of the applications we show in \u00a7 6, we define V t using a corresponding energy function, and minimize J for each time step.", "publication_ref": ["b47", "b6", "b34", "b32", "b32"], "figure_ref": [], "table_ref": []}, {"heading": "Theoretical Comparisons", "text": "The level-set method discussed in \u00a7 4.2 subsumes two related works, 1) Differentiable iso-surface extraction (MeshSDF) [51], and 2) Differentiable rendering of implicit surfaces (DVR/IDR) [43,71]. We first show that MeshSDF minimizes the level-set objective J defined in (5) with a single gradient-descent step. But the surface does not propagate in agreement with the level-set equation, as outlined in \u00a7 5.1. We then show that these two seemingly disparate works (MeshSDF and DVR) are closely related in \u00a7 5.2. We end the discussion with an explanation for how DVR deviates from the level-set equation.", "publication_ref": ["b51", "b43", "b71"], "figure_ref": [], "table_ref": []}, {"heading": "Differentiable Iso-Surface Extraction", "text": "Result 1 Differentiable Iso-Surface Extraction [51] takes a single gradientdescent step to minimize the level-set objective function J (Equation 5).\nInit Ours MeshSDF j Fig. 3: MeshSDF j does not follow the level-set equation. (Left) A planar surface defined implicitly with an MLP is influenced by a flow field in the direction of its normal. The motion attained using differentiable iso-surface extraction (Right) is inconsistent with the field. Our method (Center ) propagates the front as expected.\nProof. MeshSDF [51] defines a lossfunction L on a triangle mesh extracted using Marching Cubes [33] from an SDF parameterized with an MLP. They use an MLP \u03a6(x; j, z) conditioned on a latent-code z characterizing the shape. Using L they update the latent-code z, which is different from our goal of updating j for an unconditional \u03a6. To clarify this distinction, we use MeshSDF j to denote our variant which updates j. To update the parameters of the MLP, we compute the following gradient using the chain-rule:\n\u2202L \u2202j = x\u2208\u2202\u2126 L \u2202L \u2202x \u2202x \u2202\u03a6 \u2202\u03a6 \u2202j ,(6)\nwhere x are the vertices on the mesh and \u03a6 is an SDF. The first and the third gradient terms on the right are computed using automatic differentiation. The second term \u2202x \u2202\u03a6 can be approximated as the inverted surface normal \u2212n(x) = \u2212\u2207 x \u03a6 [51], when \u03a6 is an SDF. In the spirit of Lagrangian deformation (Equation 2), \u2212 \u2202L \u2202x acts as an instantaneous flow field V on the vertices x. The parameters of the MLP are then updated as:\nj \u2190 j \u2212 \u03bb \u2202L \u2202j = j \u2212 \u03bb x\u2208\u2202\u2126 L V \u2022 \u2207\u03a6 \u2202\u03a6 \u2202j ,(7)\nwhere \u03bb is the learning rate. Alternatively, we can also update j using the objective function defined in Equation 5 using gradient descent:\nj \u2190 j \u2212 \u03bb \u2202J \u2202j = j \u2212 \u03bb x\u2208\u2202\u2126 L 2(\u03d5 t+1 (x) \u2212 \u03a6(x; j)) \u2212 \u2202\u03a6 \u2202j = j \u2212 \u03f5 x\u2208\u2202\u2126 L V \u2022 \u2207\u03a6 \u2202\u03a6 \u2202j , \u25c1 From (4) (8\n)\nwhere \u03f5 is a constant. The last equivalency is valid when \u03d5 t+1 (x) \u2212 \u03a6(x; j) = \u2212\u2206tV \u2022 \u2207\u03a6 (Eq. 4), which is true only for the first gradient descent step. Subsequently, the value of \u03a6(x; j) changes as the parameters get updated. Comparing ( 7) and ( 8), we conclude that the optimization in MeshSDF j has the effect of taking a single gradient-descent step to minimize J. Note that while the proof by Remelli et al. [51] assumes \u03a6 is an SDF, the second update equation ( 8) does not. It is valid for all level-set functions, with no restrictions on the values of the gradient-norm (|\u2207\u03a6|) and is also valid for occupancy functions [38]. \u25a1 However, by taking a single step to update j, the surface does not propagate in agreement with the level-set equation (3). This is problematic for applications which require the surface to move as intended by the flow-field. An example application is shown in \u00a7 6.1. We also illustrate this with a toy example in Figure 3 where a planar surface propagates in the direction of its normal. A more formal discussion is in Result 2.\nResult 2 Dfferentiable iso-surface extraction [51] does not propagate the surfacefront as dictated by the flow field.\nProof. We show this with an example flow field. Consider the surface-front propagating with a constant speed \u03b2 in the direction of the normal. The corresponding Eulerian deformation is constant across the surface:\n\u2202\u03d5 \u2202t = \u2212|\u2207\u03d5|\u03b2 = \u2212\u03b2. \u25c1 Assuming \u03d5 is an SDF (9)\nWith the same flow field, we can estimate the instantaneous change in \u03a6 (parametric) for MeshSDF j as: 7) and (9) (10)\n\u2202\u03a6 \u2202t = \u2202\u03a6 \u2202j \u2202j \u2202t = \u2202\u03a6 \u2202j x\u2208\u2202\u2126 L \u2212\u03b2 \u2202\u03a6 \u2202j = \u2202\u03a6 \u2202j B. \u25c1 From (\nThe term B on the right is constant for every point x on the surface. The gradient \u2202\u03a6 \u2202j is dependent on the position where it is evaluated and hence front-propagation \u2202\u03a6 \u2202t is not constant. On the contrary, we minimize the objective function defined in (5) which ensures that the surface propagation is constant as in (9). \u25a1\nFor the implications of Result 1 and 2, and experimental comparisons, we defer the discussion to \u00a7 6.1.", "publication_ref": ["b51", "b51", "b32", "b51", "b37", "b51", "b4", "b8"], "figure_ref": [], "table_ref": []}, {"heading": "Differentiable Surface Rendering", "text": "An alternate way of extracting a Lagrangian surface \u2202\u2126 L from \u03a6 is by computing ray-surface intersections using ray-marching or sphere-tracing [22]. If ray-marching is differentiable [25,31], one can backpropagate gradients from error functions defined on \u2202\u2126 L to the parameters j defining the implicit surface. Recent developments in inverse rendering [38,71] rely on this idea. The explicit surface extracted using ray-marching differs from the one obtained using marching-cubes in two ways, 1) Ray-marching does not extract the connectivity (e.g., triangle faces) among the intersection points. This restricts the usage of loss functions which rely on attributes like the edge-length or differential operators like the Laplacian.\n2) The intersection points depend on the camera attributes.\nThe resolution of the image plane affects the density of points and the viewing direction determines the visibility. As a result, \u2202\u2126 L obtained using ray-marching could be sparser than the one obtained marching cubes. Furthermore, as we show in Result 3, by using differentiable ray-marching the parameters get updated exactly as when differentiable iso-surface extraction is used-although with a less favorable Lagrangian representation (sparser and no connectivity). This is in addition to the computational disadvantage associated with ray-marching.\nWe also formally show in Result 4 that surface evolution with differentiable ray-marching is in disagreement with level-set theory for tangential flows.\nResult 3 Surface evolution using differentiable ray-marching of parametric implicit surfaces [38,71] is the same as using differentiable iso-surface extraction [51] when the viewing direction v u is parallel to the normal n at the intersection point x u . The parameters j for the level-set function \u03a6 are updated as:\nj \u2190 j \u2212 \u03bb xu V \u2022 \u2207\u03a6 \u2202\u03a6 \u2202j ,(11)\nwhere x u are the visible points and V is the flow field. Comparing ( 11) and ( 7), the gradient-descent step is the same. As in the case of MeshSDF j , here the surface is evolved with a single step in the parameter space. We provide a more detailed proof for (11) in the Appendix.\nResult 4 Differentiable ray-marching of parametric implicit surfaces [38,71] disagrees with the level-set equation for tangential components V \u22a5 of the flow field V. The change in parameters \u2206j is: [38,71] Ours which could be nonzero. A detailed proof is in the Appendix. Referring to Eq. 3, for tangential flows the surface should not undergo any deformation, i.e. \u2202\u03d5 \u2202t = 0. However, since j gets updated as in (12), the surface does deform. We instead minimize the objective function J (Eq. 5) which is 0 for a tangential field. We show an example of tangential deformation in Figure 4. Experimental comparisons in \u00a7 6.2 validate that deforming \u03a6 accurately is critical for applications like inverse rendering.\n\u2206j = \u03bb xu \u00b1|V \u22a5 | tan(arccos(\u2207\u03a6 \u2022 v u )) \u2202\u03a6 \u2202j \u0338 = 0, (12\n)\nxu V \u22a5 vu Init DVR/IDR", "publication_ref": ["b21", "b24", "b30", "b37", "b71", "b37", "b71", "b51", "b37", "b71", "b37", "b71", "b11"], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "Applications", "text": "We focus on validating the proposed theory with computer graphics models in three different settings, 1) Curvature-based deformations ( \u00a7 6.1), which can be used to smooth/sharpen features and apply curvature defined flows on implicit surfaces, 2) Inverse rendering of geometry ( \u00a7 6.2), where a differentiable renderer for explicit geometry can be used to evolve implicit surfaces, and 3) User-defined deformations ( \u00a7 6.3), where a user can specify alterations for a given object.  To apply surface smoothing on parametric implicit surfaces, we first define a corresponding explicit force field. For the extracted Lagrangian surface \u2202\u2126 L at each time step, we minimize the Dirichletenergy functional on the surface. In the continuous setting, this is defined as:\nE(\u2202\u2126) = \u2202\u2126 ||\u2207x|| 2 dx.(13)\nMinimizing E can be shown [8] to induce the following explicit flow-field on the surface:\n\u2202x \u2202t = V(x) = \u03bb\u2206x = \u22122\u03bb\u03ba(x)n(x), (14\n)\nwhere \u03bb is a scalar diffusion coefficient, \u2206 is the Laplace-Beltrami operator and n is the normal. \u03ba is the mean-curvature, which for an implicit surface is defined as the divergence of the normalized gradient of \u03d5 (i.e., \u2207 \u2022 \u2207\u03d5 |\u2207\u03d5| ) [46]. It is equivalent to computing the laplacian \u2206\u03a6 of the MLP using automatic differentiation. In Figure 5 we show that such an estimation of the laplacian is noisy-significant magnitudes are observed even for surfaces with zero curvature. 1 Instead of using (14) as it is, which requires estimating \u2206\u03a6, we approximate V = \u03bb\u2206x \u2248 \u03bbLx; where L is the discrete Laplacian we can compute using the Lagrangian surface. Note that this is feasible only because of the hybrid (Eulerian+Lagrangian) nature of our method. We use the flow-field to update \u03a6 using the method outlined in \u00a7 4.2. Figure 6 shows qualitative comparisons for smoothing applied on two surfaces. We show a comparison with a method which applies deformation using the continuous Laplacian (\u2206\u03a6) (NFGP) [69]. When E is minimized using MeshSDF j [51], the deformation is not curvature based and high-frequency features are retained during the evolution.\nEquation ( 14) is referred to as mean-curvature flow [17]. Since our method deforms the surface in accordance with the flow-field, we can use (14)  Fig. 6: Surface smoothing on parametric level-sets. We apply surface smoothing on an MLP-defined implicit surface by minimizing Dirichlet energy on the corresponding explicit surface. We use a discrete Laplacian to define a flow-field on the surface; NFGP [69] uses its continuous counterpart and preserves too many high-frequency details. MeshSDF j [51] fails to smoothen the surface.\nmean-curvature flow on a parametrically defined \u03d5. Yang et al. [69] minimize an objective function which is handcrafted for a specific level-of-smoothness. Applying curvature-based flow is infeasible with their method since it would require a new optimization objective for each level-of-smoothness. As MeshSDF j [51] does not evolve the surface according to the level-set equation, the flow obtained with it is incorrect. We show an example flow on a genus-0 surface in Figure 7.", "publication_ref": ["b7", "b46", "b0", "b13", "b69", "b16", "b13", "b69", "b51", "b69", "b51"], "figure_ref": ["fig_3"], "table_ref": []}, {"heading": "Inverse Rendering of Geometry", "text": "We propose an inverse-rendering method which uses a differentiable renderer designed for triangle meshes to optimize geometry defined using parametric levelsets. As in the case of recent methods [4,43,71], we use an analysis-by-synthesis approach. A photometric error comparing the captured and the rendered images is minimized using gradient descent. The gradients of the error function are used to define an explicit flow-field. A corresponding Eulerian deformation field is Mean-Curvature Flow MeshSDF j Ours Fig. 7: We use an explicit mean-curvature flow-field to deform a parametrically defined implicit surface. When the same flow-field is used with MeshSDF, the deformation is not curvature-based. A genus-0 surface morphs into a sphere using our method while MeshSDF retains high-curvature regions. Fig. 8: Inverse rendering of high-genus shapes. A spherical surface is used for initialization. IDR [71], which uses differentiable rendering of implicit surfaces does not recover finer details. LSIG [42] uses a triangle-mesh and restricts the topology post initialization. Using an explicit differentiable renderer to optimize implicit geometry, our method can change topology during optimization and recover fine-details. Note that IDR requires an object mask and a neural renderer.\nobtained to evolve the level-set function \u03a6. As a result we can take large steps in inverse rendering of geometry with unconstrained topology and guarantees on mesh quality. The resulting optimization is robust and does not require an object-mask as in the (unlike [43,71]). We focus on geometry recovery from synthetic scenes with known reflectance. Our single-bounce forward rendering model uses a collocated camera and pointlight, with a known diffuse-Phong BRDF Although we choose Nvdiffrast [28] as the differentiable rasterizer in our method, in theory it can be swapped with any other differentiable renderer. Starting from an initial estimate \u03a6, for each timestep t we first extract the triangle mesh \u2202\u2126 t L and minimize a photometric error E. We use the gradients of E to define the flow-field as V t (x i ) = \u2212 \u2202E \u2202xi \u2212 \u03bbLx i , where Lx i is used for smooth evolution. Taking a single descent step for j is sufficient since the evolution does not need to follow a specific trajectory.", "publication_ref": ["b3", "b43", "b71", "b71", "b41", "b43", "b71", "b27"], "figure_ref": [], "table_ref": []}, {"heading": "LSIG [42] Ours", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Self Intersections", "text": "We evaluate the recovery on a diverse set of shapes, each of which is rendered from 100 random viewpoints. We use IDR [71] and LSIG [42] as baselines. We test IDR in three settings, 1) w/o Mask, 2) With known Phong shading, and 3) Using the Neural renderer in [71]. Quantitative comparisons are in Table 1 and qualitative comparisons are in Fig. 8. For a genus-0 shape (Bunny) LSIG [42] is able to recover accurate geometry, but the optimized meshes can have self Table 1: Quantitative evaluation on inverse rendering of geometry. An initial sphere is optimized to a diverse set of shapes from multi-view images. Chamfer distance is reported for geometric consistency and PSNR is reported to evaluate the visual appearance of optimized geometry. IDR [71] w/o Mask does not converge for any of the shapes. (marked -). Methods marked with \u2020 require object masks. LSIG [42] works well for a genus-0 shape (Bunny) but struggles with high-genus shapes. Best numbers are in orange . Shapes recovered using our method are shown on the top.\nintersections as shown on the left. It struggles with high-genus shapes as the mesh connectivity remains static throughout the optimization routine. Even with correct topology at initialization, the recovery is erroneous. Comparisons with IDR [71] are in Figure 9.", "publication_ref": ["b71", "b41", "b71", "b41", "b71", "b41", "b71"], "figure_ref": [], "table_ref": []}, {"heading": "User-defined Shape Editing", "text": "GT (Explicit) Ours (Implicit) Fig. 10: User-defined editing on parametric level-sets.\nWe demonstrate deformation operations on parametric level-sets using constraints defined by a user. The problem setup is in line with the extensive literature [10,56,57,72] on shape editing for triangle meshes. At t = 0, we first extract a mesh from a neural implicit surface using MC [33]. A user can specify handle regions on this surface to either rotate, translate or freeze parts of the shape along with their target locations. This generates a sparse deformation flow-field on the surface which we densify by minimizing a thin-shell energy function that penalizes local stretching and bending on the surface [64]. More details are in the Appendix. Estimating the flow-field requires solving a linear system \u2212k S \u2206V+k B \u2206 2 V = 0, where \u2206 and \u2206 2 are the laplacian and bi-laplacian operators. k S and k B are weighting terms for stretching and bending respectively. Additional constraints which adhere to user specifications are also added to the linear system [9]. With the obtained flow-field, we update the parameters of the\nIDR [71] Ours Target 1 \u25cb 2 \u25cb 3 \u25cb Mask Shading No Yes Yes No\nPhong Phong Neural Phong Fig. 9: Qualitative comparison for inverse rendering using implicit representations. We evaluate IDR in three different settings. 1 \u25cb Without objectmask supervision it fails to converge to a reasonable geometry. 2 \u25cb With a known-reflectance model (Phong) the silhouette of the object is recovered but without any details. 3 \u25cb It requires a rendering network (unknown reflectance) and an object-mask for good convergence-both of which not required for our method.\nlevel-set function such that the surface propagation is as intended. We also use gradient regularization as in [19]. An example deformation is shown in Fig. 18.", "publication_ref": ["b9", "b56", "b57", "b72", "b32", "b64", "b8", "b18"], "figure_ref": ["fig_0", "fig_0"], "table_ref": []}, {"heading": "Discussion", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Geom.", "text": "Mat. GT Lighting Fig. 11: Joint recovery of geometry, complex material and lighting.\nOur work formulates a level-set evolution method for parametrically defined implicit surfaces. It does not require surface extraction to be differentiable and can be used to apply mesh algorithms to neural implicit surfaces. We expect the proposed method to be particularly useful for inverse problems. We showcase one example of joint recovery of geometry, material and lighting from multi-view images in Fig. 11, where we use our surface evolution method along with components from [40]. Although the surface deformation is as dictated by the flow field, the corresponding implicit function may not retain gradient characteristics during evolution. This could become a pertinent problem for algorithms like sphere tracing [22] which require reliable distance queries, and is an interesting avenue for future research. We hope this work encourages further inquiry into recent work on geometry optimization by drawing connections to methods in computer vision and graphics developed in the pre-deep-learning era.\n3dmixers users roman hegglin and PhormaSolutions for the 3D models. We thank the anonymous reviewers for helpful comments and discussions.", "publication_ref": ["b39", "b21"], "figure_ref": ["fig_0", "fig_0"], "table_ref": []}, {"heading": "Appendix", "text": "We organize the Appendix according to the section numbers used in the main manuscript. In Section 5.2, the proofs for Result 3 and Result 4 are outlined. In Section 6.1, implementation details are added along with additional results in Figure 12 and Figure 13. In Section 6.2, implementation details for our inverse rendering experiments are discussed and qualitative comparisons with previous works are shown in Figure 16. An inverse rendering experiment using LSIG [42] with different geometry initializations is shown in Figure 15. Section 6.3 describes the user-defined shape editing method in more detail. A comparison with NFGP [69] is in Figure 17.", "publication_ref": ["b41", "b69"], "figure_ref": ["fig_0", "fig_0", "fig_0", "fig_0", "fig_0"], "table_ref": []}, {"heading": "Differentiable Surface Rendering", "text": "We first draw comparisons between Differentiable Volumetric Rendering 2 [43], Implicit Differentiable Renderer (IDR) [71] and Differentiable Iso-Surface Extraction in Result 3. Next, in Result 4, we show that methods in [43,71] deviate from the level-set theory for tangential flow fields.\nResult 3 Surface evolution using differentiable ray-marching of parametric implicit surfaces [38,71] is the same as using differentiable iso-surface extraction [51] when the viewing direction v u is parallel to the normal n at the intersection point x u . The parameters j for the level-set function \u03a6 are updated as:\nj \u2190 j \u2212 \u03bb xu V \u2022 \u2207\u03a6 \u2202\u03a6 \u2202j .\nProof. Inverse rendering methods in [43,71] find a surface-intersection point by marching a along ray that is spawned from the camera centre c, in the direction v u , for each pixel u. The intersection point x u is analytically defined as:\nx u = c + d u v u ,(15)\nwhere d u is the depth for x u . The distance d u in [43] is estimated from the camera centre. For IDR [71], the distance is computed from a point y close to the surface which modifies (15) to x u = y u + d u v u (y u is denoted as x 0 in [71]). In both the methods, a rendering loss function L (photometric error) is computed for pixels u \u2208 U . To update the geometry parameters j, the gradient \u2202L \u2202j is computed:\n\u2202L \u2202j = u\u2208U \u2202L \u2202x u \u2202x u \u2202j = u\u2208U \u2202L \u2202x u \u2202x u \u2202d u \u2202d u \u2202j = u\u2208U \u2202L \u2202x u \u2022 v u \u2202d u \u2202j (16\n)\nTo compute \u2202du \u2202j , we slightly deviate from the derivations in [43,71] for clarity. For points x u on the implicit surface, we know \u03a6(x u ) = 0. Using implicit differentiation:\n\u2202\u03a6 \u2202j + \u2202\u03a6 \u2202x u \u2202x u \u2202j = 0 \u21d0\u21d2 \u2202\u03a6 \u2202j + \u2202\u03a6 \u2202x u \u2202x u \u2202d u \u2202d u \u2202j = 0 \u21d0\u21d2 \u2202\u03a6 \u2202j + \u2202\u03a6 \u2202x u \u2022 v u \u2202d u \u2202j = 0 \u25c1 From (15) \u21d0\u21d2 \u2202d u \u2202j = \u2212 1 \u2202\u03a6 \u2202xu \u2022 v u \u2202\u03a6 \u2202j(17)\nFrom ( 16) and ( 17) we have:\n\u2202L \u2202j = \u2212 u\u2208U \u2202L \u2202x u \u2022 v u \u2202\u03a6 \u2202xu \u2022 v u \u2202\u03a6 \u2202j \u2248 \u2212 u\u2208U \u2202L \u2202x u \u2022 \u2207\u03a6 |\u2207\u03a6| 2 \u2202\u03a6 \u2202j (when v u \u2192 \u2207\u03a6)(18)\nTaking \u2212 \u2202L \u2202xu = V, we can update the parameters j using (18) and gradient descent as:\nj \u2190 j \u2212 \u03bb xu V \u2022 \u2207\u03a6 \u2202\u03a6 \u2202j .(19)\nEquation (19) shows that DVR/IDR and MeshSDF j are closely related, while Result 1 shows that these methods do not agree with the level-set theory. \u25a1 Result 4 Differentiable ray-marching of parametric implicit surfaces [38,71] disagrees with the level-set equation for tangential components V \u22a5 of the flow field V. The change in parameters \u2206j is:\n\u2206j = \u03bb xu \u00b1|V \u22a5 | tan(arccos(\u2207\u03a6 \u2022 v u )) \u2202\u03a6 \u2202j .(20)\nProof. From ( 18), we know the change in parameters j for methods in [43,71] is:\n\u2206j = \u03bb xu V \u2022 v u \u2207\u03a6 \u2022 v u \u2202\u03a6 \u2202j .(21)\nWhen the flow-field is tangential to the surface, V = V \u22a5 , and V \u22a5 \u22a5 \u2207\u03a6. The change in parameters for this flow-field is:\n\u2206j = \u03bb xu V \u22a5 \u2022 v u \u2207\u03a6 \u2022 v u \u2202\u03a6 \u2202j .(22)\nOurs NFGP [69] Fig. 12: Surface smoothing evolution on a half-noisy sphere. (Right) Our method can evolve a noisy surface using an explicit diffusion flow-field. This allows smoothing on implicitly defined surfaces with increasing levels of smoothness. (Left) Yang et al.'s [69] method uses an optimization objective for a single level of smoothness.\nWhen \u03a6 : R 2 \u2192 R is a level-set function defined in 2D, we can modify (22) as:\n\u2206j = \u03bb xu \u00b1|V \u22a5 | sin \u03b1 cos \u03b1 \u2202\u03a6 \u2202j where, \u03b1 = arccos(\u2207\u03d5 \u2022 v u ) and \u03a6 is an SDF = \u03bb xu \u00b1|V \u22a5 | tan \u03b1 \u2202\u03a6 \u2202j = \u03bb xu \u00b1|V \u22a5 | tan(arccos(\u2207\u03a6 \u2022 v u )) \u2202\u03a6 \u2202j .(23)\nThe parameters here could change depending on the angle subtended between the normal \u2207\u03a6 and the viewing direction v u . This dependence on the viewing direction is a result of using differentiable ray-marching. When the function is deformed using the level-set method described in the main paper, the change in parameters \u2206j does not depend on the viewing direction and is 0. For 3D level-set functions, the parameters could still change as the term V \u22a5 \u2022 v u in ( 22) could be non-zero.", "publication_ref": ["b43", "b71", "b43", "b71", "b37", "b71", "b51", "b43", "b71", "b43", "b71", "b14", "b71", "b43", "b71", "b17", "b18", "b37", "b71", "b43", "b71", "b69", "b69", "b21"], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "Curvature-based Deformation", "text": "For each shape, we optimize a SIREN [55] MLP with 5 layers, each of which has a 512-sized vector output. We use the publicly-released code 3 by Yang et al. [69] for SDF queries and optimization of the network. The flow-field defined in Equation ( 14) is used for smoothing. The learning rate is 10 \u22126 , the time-delta \u2206t is 0.95 and an eikonal regularization term (enforcing \u2207\u03a6 = 1) [20] is used with the error function defined in Equation (5). The regularization term is weighed 10 \u22123 times against the main objective. We use Adam optimizer [27] and use 200 gradient steps for each time step. The Lagrangian surface is extracted using Marching Cubes at (120 \u00b1 3) 3 resolution. Figure 12 shows the surface evolution with respect to time on a half-noisy sphere (similar to [63]). In addition to the results in the main manuscript, we show qualitative comparisons with other methods in Figure 13.\nInit MeshSDF [51] NFGP [69] Ours Fig. 13: Qualitative comparisons for surface smoothing. We apply surface smoothing on four computer graphics models encoded as parametric level-sets.\nBest viewed when zoomed-in. Fig. 15: LSIG [42] converges to a poor estimate with correct topology at initialization. Optimizing a triangle mesh for inverse rendering problems is non-trivial even when the initialization is close to the ground truth and has correct topology. For VBunny we rotate the target geometry and use it as initialization.\nThe shape optimized using LSIG [42] has correct topology but with poor mesh quality and reconstruction accuracy.", "publication_ref": ["b55", "b69", "b19", "b4", "b26", "b63", "b51", "b69", "b41", "b41"], "figure_ref": ["fig_0", "fig_0", "fig_0", "fig_0"], "table_ref": []}, {"heading": "Inverse Rendering", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Smoothness Term without with", "text": "Fig. 14: Ablation on smoothness regularization term in the flowfield for inverse rendering.\nOur method uses the same spherical initialization for all the shapes. The network is composed of 4 layers, with 512 neurons in each layer. The learning-rate is 2 \u00d7 10 \u22126 , the weight-decay factor is 0.1 and the time-delta \u2206t is 10 \u22124 . Each object is confined in a 2 3 volume and is rendered with Nvdiffrast [28].\nThe weight for the smoothness regularization term linearly decreases from 10 \u22123 to 0. An ablation is shown in Figure 14. We do not observe reliable improvements quantitatively with the regularizer, but do observer better convergence. The Phong shading model is used with 0.55 as the albedo value.\nWe show an experiment with different topological initializations for LSIG [42] in Figure 15. All the qualitative comparisons for results in Table 1 (main) are in Figure 16.", "publication_ref": ["b27", "b41"], "figure_ref": ["fig_0", "fig_0", "fig_0", "fig_0"], "table_ref": []}, {"heading": "User-defined Deformation", "text": "As discussed in the main paper, we use the thin-shell energy [64] loss to densify a sparsely defined flow-field from user inputs. It induces a flow field which is  characterized using an Euler-Lagrange equation:\n\u2212k s \u2206V + k b \u2206 2 V = 0. (24\n)\nWe know V for the regions on the surface where the user specifies the deformation and would like to estimate it for the entire surface such that there is minimum bending and stretching. Equation 24, however is a result of a linearized version of the thin-shell energy loss. In this case, the resultant deformations can be unpleasant. This is required for explicit surface deformation methods as they are expected to be conducive to real-time editing. On the contrary, our goal is to have plausible deformations which can be slightly more time consuming. For each editing operation (x \u2192 x \u2032 ), we break the deformation in T time steps as x \u2192 x 1 \u2192 x 2 \u2192 x 3 . . . x T . For each time-step t, we solve for (24) (using a sparse linear solver) with the following user constraints:\nV(x t\u22121 h ) = x t h \u2212 x t\u22121 h ,(25)\nwhere x h \u2208 H belongs to a set of handle vertices for which the user defines deformation. Having obtained the flow-field for all the points on the surface, we evolve the surface using an Euler step as x t = x t\u22121 + V(x t\u22121 ). Note the absence of a delta term (\u2206t) in the Euler step. This is because of how we define the flow-field; we know exactly where the surface is expected to be at a given time step (From ( 25)). This is different from gradient-based Euler integration where we take small steps in the direction of the flow-field. Since we know exactly where the surface is at time t (can assume \u03a6(x) = 0 for surface points), we can tweak the objective defined in Equation 5 (main):\nmin j J = 1 |\u2202\u2126 t L | x\u2208\u2126 t L ||\u03a6(x)|| 2 + \u03b2 x\u2208\u2126 (|\u2207\u03a6(x)| \u2212 1) 2 ,(26)\nwhere we also add Eikonal regularization. An example deformation is shown in Figure 17 including a comparison with NFGP [69]. Note that our goal with these  experiments is to showcase the versatility of the level-set method and not propose a method which performs accurate and real-time deformations; we would still pose this application of user-editing as a proof of concept. Several explicit-surface based methods [8] exist which can probably generate better deformations.\nImplementation Details We use pre-trained neural implicit representations provided in the publicly-released code by Yang et al. [69]. The number of time steps T is 20. The learning rate is 2\u00d710 \u22126 and 750 gradient steps are taken to minimize Equation 26 using Adam [27]. The regularization weighting term \u03b2 = 10 \u22124 .", "publication_ref": ["b64", "b69", "b7", "b69", "b26"], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "", "text": "Acknowledgements This work was supported in part by NSF CAREER 1751365, NSF IIS 2110409, ONR grant N000142012529, NSF Chase-CI grant 1730158, Adobe, Google, an Amazon Research Award, the Ronald L. Graham Chair and UC San Diego Center for Visual Computing. We thank Ceh Jan and", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Neural point-based graphics", "journal": "", "year": "2020", "authors": "K A Aliev; A Sevastopolsky; M Kolos; D Ulyanov; V Lempitsky"}, {"ref_id": "b1", "title": "imghum: Implicit generative models of 3d human shape and articulated pose", "journal": "", "year": "2021", "authors": "T Alldieck; H Xu; C Sminchisescu"}, {"ref_id": "b2", "title": "Level set approach to mean curvature flow in arbitrary codimension", "journal": "Journal of differential geometry", "year": "1996", "authors": "L Ambrosio; H M Soner"}, {"ref_id": "b3", "title": "Inverse path tracing for joint material and lighting estimation", "journal": "IEEE", "year": "2019", "authors": "D Azinovi\u0107; T M Li; A Kaplanyan; M Nie\u00dfner"}, {"ref_id": "b4", "title": "Neural rgb-d surface reconstruction", "journal": "", "year": "2021", "authors": "D Azinovi\u0107; R Martin-Brualla; D B Goldman; M Nie\u00dfner; J Thies"}, {"ref_id": "b5", "title": "Unbiased warped-area sampling for differentiable rendering", "journal": "ACM Trans. Graph", "year": "2020", "authors": "S Bangaru; T M Li; F Durand"}, {"ref_id": "b6", "title": "An introduction to fluid dynamics", "journal": "Cambridge university press", "year": "2000", "authors": "C K Batchelor; G Batchelor"}, {"ref_id": "b7", "title": "Polygon mesh processing", "journal": "CRC press", "year": "2010", "authors": "M Botsch; L Kobbelt; M Pauly; P Alliez; B L\u00e9vy"}, {"ref_id": "b8", "title": "On linear variational surface deformation methods", "journal": "IEEE transactions on visualization and computer graphics", "year": "2007", "authors": "M Botsch; O Sorkine"}, {"ref_id": "b9", "title": "Deformation transfer for detailpreserving surface editing", "journal": "Citeseer", "year": "2006", "authors": "M Botsch; R Sumner; M Pauly; M Gross"}, {"ref_id": "b10", "title": "Deep local shapes: Learning local sdf priors for detailed 3d reconstruction", "journal": "", "year": "2020", "authors": "R Chabra; J E Lenssen; E Ilg; T Schmidt; J Straub; S Lovegrove; R Newcombe"}, {"ref_id": "b11", "title": "pi-gan: Periodic implicit generative adversarial networks for 3d-aware image synthesis", "journal": "", "year": "2021", "authors": "E R Chan; M Monteiro; P Kellnhofer; J Wu; G Wetzstein"}, {"ref_id": "b12", "title": "Learning implicit fields for generative shape modeling", "journal": "", "year": "2019-06", "authors": "Z Chen; H Zhang"}, {"ref_id": "b13", "title": "An introduction to optimization", "journal": "John Wiley & Sons", "year": "2004", "authors": "E K Chong; S H Zak"}, {"ref_id": "b14", "title": "Differentiable surface rendering via non-differentiable sampling", "journal": "", "year": "2021", "authors": "F Cole; K Genova; A Sud; D Vlasic; Z Zhang"}, {"ref_id": "b15", "title": "On the effectiveness of weight-encoded neural implicit 3d shapes", "journal": "", "year": "2020", "authors": "T Davies; D Nowrouzezahrai; A Jacobson"}, {"ref_id": "b16", "title": "Implicit fairing of irregular meshes using diffusion and curvature flow", "journal": "", "year": "1999", "authors": "M Desbrun; M Meyer; P Schr\u00f6der; A H Barr"}, {"ref_id": "b17", "title": "Shape from tracing: Towards reconstructing 3d object geometry and svbrdf material from images via differentiable path tracing", "journal": "IEEE", "year": "2020", "authors": "P Goel; L Cohen; J Guesman; V Thamizharasan; J Tompkin; D Ritchie"}, {"ref_id": "b18", "title": "Implicit geometric regularization for learning shapes", "journal": "", "year": "2020", "authors": "A Gropp; L Yariv; N Haim; M Atzmon; Y Lipman"}, {"ref_id": "b19", "title": "Implicit geometric regularization for learning shapes", "journal": "", "year": "2020", "authors": "A Gropp; L Yariv; N Haim; M Atzmon; Y Lipman"}, {"ref_id": "b20", "title": "Neural mesh flow: 3d manifold mesh generation via diffeomorphic flows", "journal": "Curran Associates, Inc", "year": "2020", "authors": "K Gupta; M Chandraker; H Larochelle; M Ranzato; R Hadsell; M F Balcan"}, {"ref_id": "b21", "title": "Sphere tracing: A geometric method for the antialiased ray tracing of implicit surfaces", "journal": "The Visual Computer", "year": "1996", "authors": "J C Hart"}, {"ref_id": "b22", "title": "Shape, light & material decomposition from images using monte carlo rendering and denoising", "journal": "", "year": "2022", "authors": "J Hasselgren; N Hofmann; J Munkberg"}, {"ref_id": "b23", "title": "Sdfdiff: Differentiable rendering of signed distance fields for 3d shape optimization", "journal": "", "year": "2020", "authors": "Y Jiang; D Ji; Z Han; M Zwicker"}, {"ref_id": "b24", "title": "Sdfdiff: Differentiable rendering of signed distance fields for 3d shape optimization", "journal": "", "year": "2020-06", "authors": "Y Jiang; D Ji; Z Han; M Zwicker"}, {"ref_id": "b25", "title": "Neural lumigraph rendering", "journal": "", "year": "2021", "authors": "P Kellnhofer; L C Jebe; A Jones; R Spicer; K Pulli; G Wetzstein"}, {"ref_id": "b26", "title": "Adam: A method for stochastic optimization", "journal": "", "year": "2014", "authors": "D P Kingma; J Ba"}, {"ref_id": "b27", "title": "Modular primitives for high-performance differentiable rendering", "journal": "ACM Transactions on Graphics", "year": "2020", "authors": "S Laine; J Hellsten; T Karras; Y Seol; J Lehtinen; T Aila"}, {"ref_id": "b28", "title": "Differentiable monte carlo ray tracing through edge sampling", "journal": "ACM Trans. Graph. (Proc. SIGGRAPH Asia)", "year": "2018", "authors": "T M Li; M Aittala; F Durand; J Lehtinen"}, {"ref_id": "b29", "title": "Learning smooth neural functions via lipschitz regularization", "journal": "", "year": "2022", "authors": "H T D Liu; F Williams; A Jacobson; S Fidler; O Litany"}, {"ref_id": "b30", "title": "Dist: Rendering deep implicit signed distance function with differentiable sphere tracing", "journal": "", "year": "2020-06", "authors": "S Liu; Y Zhang; S Peng; B Shi; M Pollefeys; Z Cui"}, {"ref_id": "b31", "title": "Soft rasterizer: A differentiable renderer for image-based 3d reasoning", "journal": "", "year": "2019-10", "authors": "S Liu; T Li; W Chen; H Li"}, {"ref_id": "b32", "title": "Marching cubes: A high resolution 3d surface construction algorithm", "journal": "ACM siggraph computer graphics", "year": "1987", "authors": "W E Lorensen; H E Cline"}, {"ref_id": "b33", "title": "Unified shape and svbrdf recovery using differentiable monte carlo rendering", "journal": "ArXiv", "year": "2021", "authors": "F Luan; S Zhao; K Bala; Z Dong"}, {"ref_id": "b34", "title": "Nonsteady flame propagation: AGARDograph", "journal": "Elsevier", "year": "2014", "authors": "G H Markstein"}, {"ref_id": "b35", "title": "Acorn: Adaptive coordinate networks for neural scene representation", "journal": "ACM Trans. Graph. (SIGGRAPH)", "year": "2021", "authors": "J N P Martel; D B Lindell; C Z Lin; E R Chan; M Monteiro; G Wetzstein"}, {"ref_id": "b36", "title": "Modulated periodic activations for generalizable local functional representations", "journal": "", "year": "2021-10", "authors": "I Mehta; M Gharbi; C Barnes; E Shechtman; R Ramamoorthi; M Chandraker"}, {"ref_id": "b37", "title": "Occupancy networks: Learning 3d reconstruction in function space", "journal": "", "year": "2019", "authors": "L Mescheder; M Oechsle; M Niemeyer; S Nowozin; A Geiger"}, {"ref_id": "b38", "title": "A-sdf: Learning disentangled signed distance functions for articulated shape representation", "journal": "", "year": "2021", "authors": "J Mu; W Qiu; A Kortylewski; A Yuille; N Vasconcelos; X Wang"}, {"ref_id": "b39", "title": "Extracting Triangular 3D Models, Materials, and Lighting From Images", "journal": "", "year": "2021", "authors": "J Munkberg; J Hasselgren; T Shen; J Gao; W Chen; A Evans; T Mueller; S Fidler"}, {"ref_id": "b40", "title": "Level set surface editing operators", "journal": "", "year": "2002", "authors": "K Museth; D E Breen; R T Whitaker; A H Barr"}, {"ref_id": "b41", "title": "Large steps in inverse rendering of geometry", "journal": "ACM Transactions on Graphics (Proceedings of SIGGRAPH Asia)", "year": "2021-12", "authors": "B Nicolet; A Jacobson; W Jakob"}, {"ref_id": "b42", "title": "", "journal": "", "year": "", "authors": ""}, {"ref_id": "b43", "title": "Differentiable volumetric rendering: Learning implicit 3d representations without 3d supervision", "journal": "", "year": "2020-06", "authors": "M Niemeyer; L Mescheder; M Oechsle; A Geiger"}, {"ref_id": "b44", "title": "Mitsuba 2: A retargetable forward and inverse renderer", "journal": "Transactions on Graphics (Proceedings of SIGGRAPH Asia)", "year": "2019-12", "authors": "M Nimier-David; D Vicini; T Zeltner; W Jakob"}, {"ref_id": "b45", "title": "Unisurf: Unifying neural implicit surfaces and radiance fields for multi-view reconstruction", "journal": "", "year": "2021", "authors": "M Oechsle; S Peng; A Geiger"}, {"ref_id": "b46", "title": "Level set methods: an overview and some recent results", "journal": "Journal of Computational physics", "year": "2001", "authors": "S Osher; R P Fedkiw"}, {"ref_id": "b47", "title": "Fronts propagating with curvature-dependent speed: Algorithms based on hamilton-jacobi formulations", "journal": "Journal of computational physics", "year": "1988", "authors": "S Osher; J A Sethian"}, {"ref_id": "b48", "title": "Deepsdf: Learning continuous signed distance functions for shape representation", "journal": "", "year": "2019-06", "authors": "J J Park; P Florence; J Straub; R Newcombe; S Lovegrove"}, {"ref_id": "b49", "title": "", "journal": "", "year": "", "authors": "I Quilez"}, {"ref_id": "b50", "title": "Accelerating 3d deep learning with pytorch3d", "journal": "", "year": "2020", "authors": "N Ravi; J Reizenstein; D Novotny; T Gordon; W Y Lo; J Johnson; G Gkioxari"}, {"ref_id": "b51", "title": "Meshsdf: Differentiable iso-surface extraction", "journal": "Curran Associates, Inc", "year": "2020", "authors": "E Remelli; A Lukoianov; S Richter; B Guillard; T Bagautdinov; P Baque; P Fua; H Larochelle; M Ranzato; R Hadsell; M F Balcan"}, {"ref_id": "b52", "title": "Adop: Approximate differentiable onepixel point rendering", "journal": "", "year": "2021", "authors": "D R\u00fcckert; L Franke; M Stamminger"}, {"ref_id": "b53", "title": "Deep marching tetrahedra: a hybrid representation for high-resolution 3d shape synthesis", "journal": "", "year": "2021", "authors": "T Shen; J Gao; K Yin; M Y Liu; S Fidler"}, {"ref_id": "b54", "title": "Metasdf: Metalearning signed distance functions", "journal": "", "year": "2020", "authors": "V Sitzmann; E R Chan; R Tucker; N Snavely; G Wetzstein"}, {"ref_id": "b55", "title": "Implicit neural representations with periodic activation functions", "journal": "", "year": "2020", "authors": "V Sitzmann; J N Martel; A W Bergman; D B Lindell; G Wetzstein"}, {"ref_id": "b56", "title": "As-rigid-as-possible surface modeling", "journal": "Symposium on Geometry processing", "year": "2007", "authors": "O Sorkine; M Alexa"}, {"ref_id": "b57", "title": "Laplacian surface editing", "journal": "", "year": "2004", "authors": "O Sorkine; D Cohen-Or; Y Lipman; M Alexa; C R\u00f6ssl; H P Seidel"}, {"ref_id": "b58", "title": "Compositional pattern producing networks: A novel abstraction of development. Genetic programming and evolvable machines", "journal": "", "year": "2007", "authors": "K O Stanley"}, {"ref_id": "b59", "title": "Proceedings of the IEEE/CVF International Conference on Computer Vision", "journal": "", "year": "2021", "authors": "E Sucar; S Liu; J Ortiz; A J Davison"}, {"ref_id": "b60", "title": "An Introduction to Numerical Analysis. An Introduction to Numerical Analysis", "journal": "Cambridge University Press", "year": "2003", "authors": "E S\u00fcli; D Mayers"}, {"ref_id": "b61", "title": "Neural geometric level of detail: Real-time rendering with implicit 3D shapes", "journal": "", "year": "2021", "authors": "T Takikawa; J Litalien; K Yin; K Kreis; C Loop; D Nowrouzezahrai; A Jacobson; M Mcguire; S Fidler"}, {"ref_id": "b62", "title": "Fourier features let networks learn high frequency functions in low dimensional domains", "journal": "", "year": "2020", "authors": "M Tancik; P P Srinivasan; B Mildenhall; S Fridovich-Keil; N Raghavan; U Singhal; R Ramamoorthi; J T Barron; R Ng"}, {"ref_id": "b63", "title": "A signal processing approach to fair surface design", "journal": "", "year": "1995", "authors": "G Taubin"}, {"ref_id": "b64", "title": "Elastically deformable models", "journal": "", "year": "1987", "authors": "D Terzopoulos; J Platt; A Barr; K Fleischer"}, {"ref_id": "b65", "title": "Advances in neural rendering", "journal": "", "year": "2021", "authors": "A Tewari; J Thies; B Mildenhall; P Srinivasan; E Tretschk; Y Wang; C Lassner; V Sitzmann; R Martin-Brualla; S Lombardi"}, {"ref_id": "b66", "title": "A level-set approach to 3d reconstruction from range data", "journal": "International journal of computer vision", "year": "1998", "authors": "R T Whitaker"}, {"ref_id": "b67", "title": "Neural fields in visual computing and beyond", "journal": "", "year": "2021", "authors": "Y Xie; T Takikawa; S Saito; O Litany; S Yan; N Khan; F Tombari; J Tompkin; V Sitzmann; S Sridhar"}, {"ref_id": "b68", "title": "3d-aware image synthesis via learning structural and textural representations", "journal": "", "year": "2021", "authors": "Y Xu; S Peng; C Yang; Y Shen; B Zhou"}, {"ref_id": "b69", "title": "Geometry processing with neural fields. In: Thirty-Fifth Conference on Neural Information Processing Systems", "journal": "", "year": "2021", "authors": "G Yang; S Belongie; B Hariharan; V Koltun"}, {"ref_id": "b70", "title": "Volume rendering of neural implicit surfaces", "journal": "Advances in Neural Information Processing Systems", "year": "2021", "authors": "L Yariv; J Gu; Y Kasten; Y Lipman"}, {"ref_id": "b71", "title": "Multiview neural surface reconstruction by disentangling geometry and appearance", "journal": "Advances in Neural Information Processing Systems", "year": "2020", "authors": "L Yariv; Y Kasten; D Moran; M Galun; M Atzmon; B Ronen; Y Lipman"}, {"ref_id": "b72", "title": "Harmonic guidance for surface deformation", "journal": "Computer Graphics Forum", "year": "2005", "authors": "R Zayer; C R\u00f6ssl; Z Karni; H P Seidel"}, {"ref_id": "b73", "title": "Path-space differentiable rendering", "journal": "ACM Trans. Graph", "year": "2020", "authors": "C Zhang; B Miller; K Yan; I Gkioulekas; S Zhao"}, {"ref_id": "b74", "title": "Nice-slam: Neural implicit scalable encoding for slam", "journal": "", "year": "2021", "authors": "Z Zhu; S Peng; V Larsson; W Xu; H Bao; Z Cui; M R Oswald; M Pollefeys"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Fig. 1 :1Fig. 1: Inverse-rendering recovery.", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Fig. 4 :4Fig. 4: Tangential flow fields may deform surfaces when DVR/IDR is used for surface extraction. (Left) A parametric Eulerian circle undergoes tangential deformation V \u22a5 at surface points x u . (Middle) Using differentiable surface rendering, the surface deforms incorrectly. (Right) Our method agrees with the level-set equation and the resultant deformation is the identity.", "figure_data": ""}, {"figure_label": "5", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Fig. 5 :5Fig. 5: The laplacian \u2206\u03a6 of an MLP-defined levelset function is noisy. We show the mean-curvature values for a parametric levelset function of a square. Large values are observed for a zero-curvature surface.", "figure_data": ""}, {"figure_label": "16", "figure_type": "figure", "figure_id": "fig_5", "figure_caption": "Fig. 16 :16Fig. 16: Qualitative comparisons for Inverse Rendering of Geometry.", "figure_data": ""}, {"figure_label": "1718", "figure_type": "figure", "figure_id": "fig_6", "figure_caption": "Fig. 17 :Fig. 18 :1718Fig.17: User-defined rotation on an implicitly defined cylinder. (Left) User editing using our method is faster (takes 10 min) than (Right) NFGP which takes 10 hr for the same editing operation.", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "x \u2192 x \u2032 V", "formula_coordinates": [2.0, 420.84, 211.69, 30.41, 44.61]}, {"formula_id": "formula_1", "formula_text": "\u03d5(x) = (\u00b1) min x C \u2208\u2202\u2126 {||x \u2212 x C || 2 },(1)", "formula_coordinates": [4.0, 239.43, 329.4, 241.16, 15.31]}, {"formula_id": "formula_2", "formula_text": "Parametric Level-Sets Eulerian \u2202\u2126E Lagrangian \u2202\u2126L MC \u2202\u03d5 \u2202t \u03a6(x; j) minx i E dx dt xi V(xi)", "formula_coordinates": [5.0, 132.94, 116.49, 356.16, 74.72]}, {"formula_id": "formula_3", "formula_text": "dx dt = \u2212 \u2202E \u2202x \u2192 V(x). \u25c1 Lagrangian Deformation (2)", "formula_coordinates": [5.0, 192.98, 471.46, 287.61, 22.31]}, {"formula_id": "formula_4", "formula_text": "d\u03d5(x) dt = \u2202\u03d5 \u2202t + \u2202\u03d5 \u2202x \u2202x \u2202t = \u2202\u03d5 \u2202t + \u2207\u03d5 \u2022 V = 0 \u25c1 From 2 \u21d0\u21d2 \u2202\u03d5 \u2202t = \u2212\u2207\u03d5 \u2022 V. \u25c1 Eulerian Deformation (3)", "formula_coordinates": [6.0, 183.84, 137.2, 296.75, 46.79]}, {"formula_id": "formula_5", "formula_text": "\u03d5 t+1 = \u03a6 t \u2212 \u2206t\u2207\u03a6 t \u2022 V t . \u25c1 From (3)(4)", "formula_coordinates": [6.0, 216.7, 303.49, 263.89, 11.63]}, {"formula_id": "formula_6", "formula_text": "min j J(j) = 1 |\u2202\u2126 L | x\u2208\u2202\u2126 L ||\u03d5 t+1 (x) \u2212 \u03a6(x; j)|| 2 ,(5)", "formula_coordinates": [6.0, 205.14, 401.41, 275.45, 27.49]}, {"formula_id": "formula_7", "formula_text": "\u2202L \u2202j = x\u2208\u2202\u2126 L \u2202L \u2202x \u2202x \u2202\u03a6 \u2202\u03a6 \u2202j ,(6)", "formula_coordinates": [7.0, 256.93, 358.15, 223.66, 27.49]}, {"formula_id": "formula_8", "formula_text": "j \u2190 j \u2212 \u03bb \u2202L \u2202j = j \u2212 \u03bb x\u2208\u2202\u2126 L V \u2022 \u2207\u03a6 \u2202\u03a6 \u2202j ,(7)", "formula_coordinates": [7.0, 221.0, 477.62, 259.59, 27.5]}, {"formula_id": "formula_9", "formula_text": "j \u2190 j \u2212 \u03bb \u2202J \u2202j = j \u2212 \u03bb x\u2208\u2202\u2126 L 2(\u03d5 t+1 (x) \u2212 \u03a6(x; j)) \u2212 \u2202\u03a6 \u2202j = j \u2212 \u03f5 x\u2208\u2202\u2126 L V \u2022 \u2207\u03a6 \u2202\u03a6 \u2202j , \u25c1 From (4) (8", "formula_coordinates": [7.0, 181.8, 548.82, 294.55, 59.12]}, {"formula_id": "formula_10", "formula_text": ")", "formula_coordinates": [7.0, 476.35, 587.18, 4.24, 8.74]}, {"formula_id": "formula_11", "formula_text": "\u2202\u03d5 \u2202t = \u2212|\u2207\u03d5|\u03b2 = \u2212\u03b2. \u25c1 Assuming \u03d5 is an SDF (9)", "formula_coordinates": [8.0, 196.35, 324.78, 284.24, 22.31]}, {"formula_id": "formula_12", "formula_text": "\u2202\u03a6 \u2202t = \u2202\u03a6 \u2202j \u2202j \u2202t = \u2202\u03a6 \u2202j x\u2208\u2202\u2126 L \u2212\u03b2 \u2202\u03a6 \u2202j = \u2202\u03a6 \u2202j B. \u25c1 From (", "formula_coordinates": [8.0, 159.17, 389.31, 236.59, 27.49]}, {"formula_id": "formula_13", "formula_text": "j \u2190 j \u2212 \u03bb xu V \u2022 \u2207\u03a6 \u2202\u03a6 \u2202j ,(11)", "formula_coordinates": [9.0, 252.68, 288.14, 227.91, 26.35]}, {"formula_id": "formula_14", "formula_text": "\u2206j = \u03bb xu \u00b1|V \u22a5 | tan(arccos(\u2207\u03a6 \u2022 v u )) \u2202\u03a6 \u2202j \u0338 = 0, (12", "formula_coordinates": [9.0, 204.45, 419.5, 271.71, 26.35]}, {"formula_id": "formula_15", "formula_text": ")", "formula_coordinates": [9.0, 476.16, 426.24, 4.43, 8.74]}, {"formula_id": "formula_16", "formula_text": "xu V \u22a5 vu Init DVR/IDR", "formula_coordinates": [9.0, 269.98, 455.43, 95.49, 46.6]}, {"formula_id": "formula_17", "formula_text": "E(\u2202\u2126) = \u2202\u2126 ||\u2207x|| 2 dx.(13)", "formula_coordinates": [10.0, 186.54, 332.25, 159.06, 19.31]}, {"formula_id": "formula_18", "formula_text": "\u2202x \u2202t = V(x) = \u03bb\u2206x = \u22122\u03bb\u03ba(x)n(x), (14", "formula_coordinates": [10.0, 153.65, 391.02, 187.53, 22.31]}, {"formula_id": "formula_19", "formula_text": ")", "formula_coordinates": [10.0, 341.17, 397.76, 4.43, 8.74]}, {"formula_id": "formula_20", "formula_text": "IDR [71] Ours Target 1 \u25cb 2 \u25cb 3 \u25cb Mask Shading No Yes Yes No", "formula_coordinates": [14.0, 156.16, 113.17, 310.46, 100.85]}, {"formula_id": "formula_21", "formula_text": "j \u2190 j \u2212 \u03bb xu V \u2022 \u2207\u03a6 \u2202\u03a6 \u2202j .", "formula_coordinates": [15.0, 252.68, 438.56, 109.99, 26.35]}, {"formula_id": "formula_22", "formula_text": "x u = c + d u v u ,(15)", "formula_coordinates": [15.0, 274.57, 518.83, 206.03, 9.68]}, {"formula_id": "formula_23", "formula_text": "\u2202L \u2202j = u\u2208U \u2202L \u2202x u \u2202x u \u2202j = u\u2208U \u2202L \u2202x u \u2202x u \u2202d u \u2202d u \u2202j = u\u2208U \u2202L \u2202x u \u2022 v u \u2202d u \u2202j (16", "formula_coordinates": [15.0, 177.95, 608.61, 298.21, 26.8]}, {"formula_id": "formula_24", "formula_text": ")", "formula_coordinates": [15.0, 476.16, 615.35, 4.43, 8.74]}, {"formula_id": "formula_25", "formula_text": "\u2202\u03a6 \u2202j + \u2202\u03a6 \u2202x u \u2202x u \u2202j = 0 \u21d0\u21d2 \u2202\u03a6 \u2202j + \u2202\u03a6 \u2202x u \u2202x u \u2202d u \u2202d u \u2202j = 0 \u21d0\u21d2 \u2202\u03a6 \u2202j + \u2202\u03a6 \u2202x u \u2022 v u \u2202d u \u2202j = 0 \u25c1 From (15) \u21d0\u21d2 \u2202d u \u2202j = \u2212 1 \u2202\u03a6 \u2202xu \u2022 v u \u2202\u03a6 \u2202j(17)", "formula_coordinates": [16.0, 207.95, 159.77, 272.64, 103.92]}, {"formula_id": "formula_26", "formula_text": "\u2202L \u2202j = \u2212 u\u2208U \u2202L \u2202x u \u2022 v u \u2202\u03a6 \u2202xu \u2022 v u \u2202\u03a6 \u2202j \u2248 \u2212 u\u2208U \u2202L \u2202x u \u2022 \u2207\u03a6 |\u2207\u03a6| 2 \u2202\u03a6 \u2202j (when v u \u2192 \u2207\u03a6)(18)", "formula_coordinates": [16.0, 147.4, 293.28, 333.19, 38.3]}, {"formula_id": "formula_27", "formula_text": "j \u2190 j \u2212 \u03bb xu V \u2022 \u2207\u03a6 \u2202\u03a6 \u2202j .(19)", "formula_coordinates": [16.0, 252.68, 373.96, 227.91, 26.35]}, {"formula_id": "formula_28", "formula_text": "\u2206j = \u03bb xu \u00b1|V \u22a5 | tan(arccos(\u2207\u03a6 \u2022 v u )) \u2202\u03a6 \u2202j .(20)", "formula_coordinates": [16.0, 213.58, 497.09, 267.01, 26.35]}, {"formula_id": "formula_29", "formula_text": "\u2206j = \u03bb xu V \u2022 v u \u2207\u03a6 \u2022 v u \u2202\u03a6 \u2202j .(21)", "formula_coordinates": [16.0, 247.89, 563.49, 232.7, 26.38]}, {"formula_id": "formula_30", "formula_text": "\u2206j = \u03bb xu V \u22a5 \u2022 v u \u2207\u03a6 \u2022 v u \u2202\u03a6 \u2202j .(22)", "formula_coordinates": [16.0, 255.6, 633.6, 224.99, 28.69]}, {"formula_id": "formula_31", "formula_text": "\u2206j = \u03bb xu \u00b1|V \u22a5 | sin \u03b1 cos \u03b1 \u2202\u03a6 \u2202j where, \u03b1 = arccos(\u2207\u03d5 \u2022 v u ) and \u03a6 is an SDF = \u03bb xu \u00b1|V \u22a5 | tan \u03b1 \u2202\u03a6 \u2202j = \u03bb xu \u00b1|V \u22a5 | tan(arccos(\u2207\u03a6 \u2022 v u )) \u2202\u03a6 \u2202j .(23)", "formula_coordinates": [17.0, 139.98, 321.76, 340.61, 88.54]}, {"formula_id": "formula_32", "formula_text": "\u2212k s \u2206V + k b \u2206 2 V = 0. (24", "formula_coordinates": [21.0, 258.68, 137.01, 217.48, 11.72]}, {"formula_id": "formula_33", "formula_text": ")", "formula_coordinates": [21.0, 476.16, 139.08, 4.43, 8.74]}, {"formula_id": "formula_34", "formula_text": "V(x t\u22121 h ) = x t h \u2212 x t\u22121 h ,(25)", "formula_coordinates": [21.0, 260.0, 284.63, 220.59, 13.38]}, {"formula_id": "formula_35", "formula_text": "min j J = 1 |\u2202\u2126 t L | x\u2208\u2126 t L ||\u03a6(x)|| 2 + \u03b2 x\u2208\u2126 (|\u2207\u03a6(x)| \u2212 1) 2 ,(26)", "formula_coordinates": [21.0, 193.03, 420.62, 287.57, 29.47]}], "doi": "10.1145/3478513.3480501"}