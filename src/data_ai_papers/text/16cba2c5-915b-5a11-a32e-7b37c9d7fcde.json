{"title": "Accurate Unbounded Dependency Recovery using Generalized Categorial Grammars", "authors": "N Luan; Y Gu;  En; M Ar T En Van Sc H I J N De L; W Il Liam Sc H U L Er", "pub_date": "", "abstract": "Accurate recovery of predicate-argument dependencies is vital for interpretation tasks like information extraction and question answering, and unbounded dependencies may account for a significant portion of the dependencies in any given text. This paper describes a categorial grammar which, like other categorial grammars, imposes a small, uniform, and easily learnable set of semantic composition operations based on functor-argument relations, but like HPSG, is generalized to limit the number of categories used to those needed to enforce grammatical constraints. The paper also describes a novel reannotation system used to map existing resources based on Government and Binding Theory, like the Penn Treebank, into this categorial representation. This grammar is evaluated on an existing unbounded dependency recovery task (Rimell et al., 2009;Nivre et al., 2010).", "sections": [{"heading": "Introduction", "text": "Accurate recovery of predicate-argument dependencies is vital for interpretation tasks like information extraction and question answering, and unbounded dependencies may account for a significant portion of the dependencies in any given text. Many current interpretation models are based on PCFGs, trained on syntactic annotations from the Penn Treebank (Marcus et al., 1993). These often recover dependencies as a post-process to parsing, and often are not able to retrieve unbounded dependencies if they are optimized on syntactic representations that leave these dependencies out.\nCategorial grammars, on the other hand, have well-defined unbounded dependency representations based on functor-argument relations in a small and easily-learnable set of composition operations. Such grammars -in particular, Combinatory Categorial Grammar (CCG) (Steedman, 2000;Clark and Curran, 2007) -do well on unbounded dependency recovery tasks (Rimell et al., 2009) but not as well as models based on Head Driven Phrase-structure Grammar (HPSG) (Pollard and Sag, 1994;Miyao and Tsujii, 2005), given the same training. This may be attributed to implicit tradeoffs in many categorial frameworks that minimize the number of composition operations at the expense of large numbers of possible categories for each lexical item, which may lead to sparse data effects in training. HPSG models, in contrast, maintain a relatively large number of composition operations and a relatively small set of possible lexical categories, which are then used in a wider set of contexts.\nCan categorial grammars, which have well-studied semantic representations and are well suited for interpretation, obtain better performance on a general unbounded dependency extraction task if it adopts an HPSG-like strategy of re-using types in various contexts? This paper describes a categorial grammar which, like HPSG, is generalized to limit the number of categories used to those needed to enforce grammatical constraints, but like other categorial grammars, imposes a small, uniform, and easily learnable set of semantic composition operations based on functorargument relations. The paper also describes a novel reannotation system used to map existing resources based on Government and Binding Theory, like the Penn Treebank, into this categorial representation. This grammar is evaluated by training a state-of-the-art latent-variable parser on a version of the Penn Treebank reannotated into this generalized categorial grammar representation, and testing on an existing unbounded dependency recovery task (Rimell et al., 2009;Nivre et al., 2010).\nThe remainder of this paper is organized as follows. Section 2 describes related work on modeling unbounded dependencies and reannotation of syntax, Section 3 describes a generalized categorial grammar which provides transparent predicate-argument dependencies and generalizes similar categories across contexts, Section 4 describes how syntactically-annotated corpora can be reannotated into this framework, and Section 5 describes an evaluation of this system on an existing unbounded dependency recovery task.", "publication_ref": ["b19", "b36", "b7", "b33", "b32", "b24", "b33", "b27"], "figure_ref": [], "table_ref": []}, {"heading": "Related Work", "text": "This section describes related work in unbounded dependencies and syntax reannotation.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Unbounded Dependencies", "text": "This paper describes a general-purpose reannotation system and its application to the specific task of reannotating local argument-passing treatments of long-distance dependencies in a generalized categorial grammar. Unbounded dependencies are dependencies between constituents and points of attachment that have other constituents syntactically intervening. For example, the sentence What does the First Amendment protect? has a preposed constituent what that functions as a direct object of the transitive verb protect. The long distance between the source and destination of this type of dependency, paired with the relatively low probability of their occurrence in the language, and the fact that filler-gap annotations in syntactic resources such as the Penn Treebank are often stripped out, makes it very difficult for parsers to recognize this type of dependency correctly. While difficult to parse, this type of dependency is vital to the meaning of the sentence and of great importance in applications such as question answering and information extraction.\nRich grammar formalisms such as CCG (Steedman, 2000) have been shown to provide very accurate syntactic dependency extraction. This is thought to be because these formalisms explicitly model long-distance filler-gap dependencies inherent in relative clauses and interrogatives (Gildea and Hockenmaier, 2003). But formal systems like CCG, especially as reflected in reannotated Treebanks like CCGbank (Hockenmaier, 2003), comprise analyses of many phenomena: right node raising, light verbs, subject control, object control, coordinating conjunctions, etc., among which filler-gap constructions are just one component. Some of these analyses may be more easily automatically learnable (and thus more robust) than others. For example, CCG analyzes filler-gap constructions using essentially the same mechanism as right-side complementation, turning gaps into right-seeking functors using a special backward crossed composition combinator when gaps are not at the right periphery of constituents that contain them (Steedman, 2000). This distinction between peripheral and non-peripheral filler-gap constructions, and this merging of filler-gap constructions with right-side complementation, may produce different data densities in training corpora and make certain phenomena harder or easier to learn than, say, an HPSG-style analysis (Pollard and Sag, 1994), which treats all fillergap constructions the same, but distinguishes constituents containing gaps from constituents awaiting complements.\nNaturally, empirical questions about alternative syntactic analyses such as these cannot be resolved by fitting to syntactically annotated corpora, since the syntactic analyses do not agree. This paper therefore addresses the question of how to empirically distinguish between analyses of individual phenomena, or between entire formal systems, on the basis of learnability in a down-stream unbounded dependency recovery task. In particular, this paper describes a method for implementing syntactic analyses of various phenomena through automatic reannotation rules, which operate deterministically on a corpus like the Penn Treebank (Marcus et al., 1993) to produce a corpus with desired syntactic analyses. This reannotated corpus is then used to define a probabilistic grammar which is automatically annotated with additional latent variable values (Petrov and Klein, 2007) to introduce distinctions based on distributions of words and syntactic categories that increase the probability of the corpus (and improve the accuracy of parsing on held-out data), but do not affect the calculation of dependency structure. Dependency structures can then be extracted from parse trees produced by this grammar in a deterministic post-process, and mapped to the dependency representation used by Rimell et al. (2009) for evaluation.", "publication_ref": ["b36", "b11", "b12", "b36", "b32", "b19", "b31", "b33"], "figure_ref": [], "table_ref": []}, {"heading": "Reannotation", "text": "The reannotation process described in this paper is similar in purpose to efforts to convert Penn Treebank annotations into other grammar formalisms, e.g. CCG (Hockenmaier, 2003) and HPSG (Miyao et al., 2004). These reannotation processes consist of multiple phases for head-finding, binarization, and relabeling. However, unlike the Hockenmaier or Miyao et al. processes, the rule set described in this paper is intended to be modified and reused by researchers interested in manipulating analyses of individual phenomena (like distinguishing or consolidating filler-gap and right-node raising constructions) to test the generality and learnability of alternative syntactic representations on some down-stream task such as recovering unbounded dependencies. As such, the reannotation rules used in this process are defined to apply in a single top-down pass, pulling arguments and modifiers out of constituents until only a lexical head remains at the bottom. This single-pass architecture allows the rules for reannotating various linguistic phenomena to be relatively modular, so that they can be independently manipulated and evaluated.\nThe reannotation rules described in this paper are also similar to reannotation rules in the 'wsjsed' system (Blaheta, 2002), but that system was evaluated as an error-correction tool, rather than for making theoretically-motivated changes to syntactic analyses.\nThe reannotated grammar described in this paper exploits the rich traces and function labels in the Treebank that are typically ignored in parsing. These annotations are transformed into a categorial grammar representation of filler-gap constructions that makes use of 'gap' arguments, similar to the 'slash' arguments used in HPSG. Other approaches also exploit the trace and function labels of the Penn Treebank. Campbell (2004) proposed recovering trace information in a post-process following parsing. In contrast, the sample reannotation described in this paper incorporates filler-gap annotations into the corpus on which the parser is trained. Collins (1997), connected fillers with gaps and introduced a 'TRACE' category into the training data. Since this annotation does not change the constituent structure of the corpus, the addition of this gap annotation did not result in improved parsing results for Collins' gap-annotating model (model 3) as compared to the non-gap-annotating model (model 2). However, these are the kind of unbounded dependencies that need to be recovered in the evaluation described in this paper.", "publication_ref": ["b12", "b23", "b2", "b5", "b8"], "figure_ref": [], "table_ref": []}, {"heading": "Generalized Categorial Grammar", "text": "This paper explores the use of a generalized categorial grammar which has the transparent predicate-argument dependencies of traditional categorial grammars (based on function application), but is generalized to allow arbitrary sets of type-constructing operators. An extended set of type-constructing operators and a corresponding set of inference rules are then used to group syntactically-interchangeable signs -for example, those with peripheral and non-peripheral gaps or those occurring in post-nominal and predicative contexts -into equivalent categories.\nA generalized categorial grammar (Lambek, 1958;Bach, 1981;Oehrle, 1994) is a tuple \u2329U, O, R, X , M \u232a of a set U of primitive category types, a set O of type-constructing operators, a set R of inference rules, a set X of vocabulary items, and a mapping M from vocabulary items to complex types. The set of primitive category types U specify various linguistic forms for descriptions of entities or eventualities, corresponding to different clause types, 1 e.g.:\nV: finite verbal (they knew it) I: infinitive verbal (them to know it) B: base-form verbal (them know it) L: participial verbal (them known it) A: adjectival/predicative (them knowing it) R: adverbial (them knowingly) G: gerund (them knowing it) N: nominal form (e.g. their knowledge of it) D: determiner (their knowledge of it's) O: genitive (of their knowledge of it) E: embedded infinitive (for them to know it) C: complementized finite (that they know it) Q: interrogative (did they know it) S: complete utterance (know it)\nThe set of type-constructing operators O specify various kinds of arguments: 2 -a: initial argument -b: final argument -c: initial conjunct -d: final conjunct -g: filler-gap argument -h: held argument for right node raising -i: interrogative pronoun argument -r: relative pronoun argument Using this set of primitive category types U and type-constructing operators O, a set of complex categories C can be defined such that:\n1. every U is in C 2. every C \u00d7O\u00d7C is in C 3. nothing else is in C\nMapping M defines associations from vocabulary items x \u2208 X to meaning functions and associated categories of the form '(\u03bb ...) : u\u03d5 1 ...\u03d5 v \u03c8', where '(\u03bb ...)' is a meaning function and 'u\u03d5 1 ...\u03d5 v \u03c8' is a category consisting of output category u \u2208 U, a sequence of argument categories \u03d5 1 , ..., \u03d5 v \u2208 {-a, -b, -c, -d}\u00d7 C, and an optional non-local argument category \u03c8 \u2208 ({-r, -i}\u00d7C) \u222a {\u03b5}. Since this model will be used to generate predicate-argument relations but not scoping relations, these meaning functions are constrained to describe simple existentiallyquantified variables over instances of entities or eventualities, connected by a set of numbered argument relations. These meaning functions map instances of entities or eventualities i, j, k to truth values based on whether the described argument relations hold between these referents. These argument relations are defined as numbered functions (v i)= j from eventuality or predicate instances i to argument instances j identified by the number of the function v. The '0' function identifies j as i's predicate concept (so '0' maps entity or eventuality instances to instances of concepts associated with words in X ), the '1' function identifies j as i's first argument (e.g. its subject), the '2' function identifies j as i's second argument (e.g. its direct object), and so on. 3 A graphical representation of the predicate-argument relations generated by this system for the sentence The person who officials say stole millions, is shown in Figure 1. This is similar to the semantic dependency representations of Mel'\u010duk (1988) and Parsons (1990).\nThe meaning functions associated with most words specify just the predicate concept (which is here defined to match the word x):\nx \u2192 M (\u03bb i (0 i)=x) : u\u03d5 1 ...\u03d5 v (1a) 2\nThe -a and -b operators may be viewed as equivalent to the forward and backward slash, respectively, of Lambek (1958) or Bar-Hillel (1953) categorial grammars, except that they are not used to represent gap arguments or conjuncts. The -g operator is similar to the vertical or neutral slash of Kubota and Levine (2012), used to represent gap arguments. The -c and -d operators for conjuncts, the -h operator for rightward raising, and the -r and -i operators for relative and interrogative pronoun referents are novel extensions to the system. Meaning functions for relative pronouns (Equation 1b) and interrogative pronouns (Equation 1c) introduce additional arguments k, using operators -r or -i for the referent of the antecedent of a relative or interrogative pronoun respectively:\nx \u2192 M (\u03bb k i (0 i)=x \u2227 (v i)=k) : u\u03d5 1 ...\u03d5 v\u22121 -rc (1b) x \u2192 M (\u03bb k i (0 i)=x \u2227 (v i)=k) : u\u03d5 1 ...\u03d5 v\u22121 -ic (1c)\nInference rules are defined in terms of composition functions for arguments, modifiers, and conjuncts. These composition functions each take a meaning function g for an initial (left) child sign and a meaning function h for a final (right) child sign (each defining a set of entity or eventuality instances) and return a meaning function for the parent, which is itself a function from entity or eventuality instances i to truth values:\n\u2022 Composition functions for arguments f u\u03d5 1 ...\u03d5 v connect the referent j of an initial (left) child function g as an argument of referent i of a final (right) child function h, or vice versa:\nf u\u03d5 1 ...\u03d5 v\u22121 -ac def = \u03bb g h i \u2203 j (v i)= j \u2227 (g j) \u2227 (h i) (2a) f u\u03d5 1 ...\u03d5 v\u22121 -bc def = \u03bb g h i \u2203 j (v i)= j \u2227 (g i) \u2227 (h j) (2b)\n\u2022 Composition functions for initial and final modifiers ( f IM and f FM ) are categoryindependent and return the referent of the argument ( j) rather than of the predicate (i):\nf IM def = \u03bb g h j \u2203 i (1 i)= j \u2227 (g i) \u2227 (h j) (3a) f FM def = \u03bb g h j \u2203 i (1 i)= j \u2227 (g j) \u2227 (h i) (3b)\n\u2022 Composition functions for conjuncts are similar to composition functions for arguments, except that they only count conjunct arguments, for c, d\n\u2208 C: 4 f c-cd def = \u03bb g h i \u2203 j (1 i)= j \u2227 (g j) \u2227 (h i) (4a) f c-dd def = \u03bb g h i \u2203 j (2 i)= j \u2227 (g i) \u2227 (h j) (4b) f & def = \u03bb g h i \u2203 j k j=(2 i) \u2227 (0 i)=(0 j) \u2227 (1 j)=k \u2227 (g k) \u2227 (h j) (4c)\nThe set of inference rules R in the categorial grammar then apply these composition functions to compose and categorize super-lexical signs. These inference rules will use variables f , g, h over meaning functions, variables k over referents for possible values of gaps, variables u \u2208 U over primitive categories, variables c, d, e \u2208 U \u00d7({-a, -b, -c, -d}\u00d7 C) * over categories with local arguments, and variables \u03c8 \u2208 {-g, -h, -i, -r} \u00d7 C over non-local operators and argument categories: 5\n1. Inference rules for argument attachment apply functors of category c-ad or c-bd to initial or final arguments of category d. Non-local arguments k, using non-local operator and argument category \u03c8, are then propagated to the consequent from all possible combinations of antecedents, skipping over the composition function:\ng:d h: c-ad ( f c-ad g h): c g:d\u03c8 h: c-ad \u03bb k ( f c-ad (g k) h): c\u03c8 g:d h: c-ad\u03c8 \u03bb k ( f c-ad g (h k)): c\u03c8 g:d\u03c8 h: c-ad\u03c8 \u03bb k ( f c-ad (g k) (h k)): c\u03c8 (Aa-d) g: c-bd h:d ( f c-bd g h): c g: c-bd\u03c8 h:d \u03bb k ( f c-bd (g k) h): c\u03c8 g: c-bd h:d\u03c8 \u03bb k ( f c-bd g (h k)): c\u03c8 g: c-bd\u03c8 h:d\u03c8 \u03bb k ( f c-bd (g k) (h k)): c\u03c8 (Ae-h)\nFor example, to attach a verb to a direct object with or without a gap:\nread V-aN-bN a book about cars N V-aN Ae read V-aN-bN a book about N-gN V-aN-gN Ag 2.\nInference rules for modifier attachment apply initial or final modifiers of category u-ad to modificands of category c (again propagating non-local arguments \u03c8 to the consequent from all combinations of antecedents, so as to skip over the composition function):\ng: u-ad h:c ( f IM g h):c g: u-ad\u03c8 h:c \u03bb k ( f IM (g k) h):c\u03c8 g: u-ad h:c\u03c8 \u03bb k ( f IM g (h k)):c\u03c8 g: u-ad\u03c8 h:c\u03c8 \u03bb k ( f IM (g k) (h k)):c\u03c8 (Ma-d) g:c h: u-ad ( f FM g h):c g:c\u03c8 h: u-ad \u03bb k ( f FM (g k) h):c\u03c8 g:c h: u-ad\u03c8 \u03bb k ( f FM g (h k)):c\u03c8 g:c\u03c8 h: u-ad\u03c8 \u03bb k ( f FM (g k) (h k)):c\u03c8 (Me-h)\nFor example, to attach an adverbial modifier with or without a gap: 4 The last of these (4c) introduces lexical and compositional relations for elided conjunctions in sequences of three or more conjuncts (e.g. between creditors and investors in the conjunction creditors, investors, and employees). 5 A deductive system consists of inference rules of the form P Q R, meaning premises or antecedents P entail conclusion or consequent Q according to rule or side condition R (Shieber et al., 1995). Additionally, this notation assumes adjacent premises arise from adjacent and similarly ordered sequences of observations.\nsleep V-aN in Aix R-aN V-aN Me sleep V-aN in R-aN-gN V-aN-gNMg\n3. Inference rules for conjunct attachment apply conjunctions of category c-cd or c-dd to conjuncts of category d (including repeated initial conjuncts):\ng:d h: c-cd ( f c-cd g h): c g:d h: c-cd ( f & g h): c-cd g: c-dd h:d ( f c-dd g h): c (Ca-c) g:d\u03c8 h: c-cd\u03c8 \u03bb k ( f c-cd (g k) (h k)): c g:d\u03c8 h: c-cd\u03c8 \u03bb k ( f & (g k) (h k)): c-cd\u03c8 g: c-dd\u03c8 h:d\u03c8 \u03bb k ( f c-dd g (h k)): c (Cd-f)\nFor example, to combine three noun phrase conjuncts: \ng: c-ad \u03bb k ( f c-ad {k} g): c-gd g: c-bd \u03bb k ( f c-bd g {k}): c-gd g:c \u03bb k ( f IM {k} g):c-gd (Ga-c)\nFor example:\nis sleeping V-aN V-gN Ga we N drove V-aN-bN V-aN-gN Gb V-gN Ac is sleeping V-aN V-aN-gR Gc 5.\nInference rules for filler attachment apply gapped clauses to modificands or relative or interrogative phrases as fillers:\ng:e h: c-gd \n\u03bb i \u2203 j (g i) \u2227 (h i j):e g:d-re h: c-gd \u03bb k j \u2203 i (g k i) \u2227 (h i j): c-re g:d-ie h: c-gd \u03bb k j \u2203 i (g k i) \u2227 (h i j): c-ie (Fa-c)\n\u03bb i \u2203 j (g i) \u2227 (h i j):e (R)\nFor example: the car N which we drove This derivation yields the following lexical relations: (0 i 1 )=the, (0 i 2 )=person, (0 i 3 )=who, (0 i 4 )=officials, (0 i 5 )=say, (0 i 6 )=stole, (0 i 7 )=millions, and the following argument relations:\nV-rN N R the \u03bb i 1 (0 i 1 ) =the : D person \u03bb i 2 (0 i 2 ) =person : N-aD \u03bb i 2 \u2203 i 1 .. \u2227 (1 i 2 )=i 1 : N Aa who \u03bb i 2 i 3 (0 i 3 )=who \u2227 (1 i 3 )=i 2 : N-rN officials \u03bb i 4 (0 i 4 ) =officials : N say \u03bb i 5 (0 i 5 ) =say : V-aN-bV stole \u03bb i 6 (0 i 6 ) =stole : V-aN-bN millions \u03bb i 7 (0 i 7 ) =millions : N \u03bb i 6 \u2203 i 7 .. \u2227 (2 i 6 )=i 7 : V-aN Ae \u03bb i 3 i 6 .. \u2227 (1 i 6 )=i 3 : V-gN Ga \u03bb i 3 i 5 \u2203 i 6 .. \u2227 (2 i 5 )=i 6 : V-aN-gN Ag \u03bb i 3 i 5 \u2203 i 4 .. \u2227 (1 i 5 )=i 4 : V-gN Ac \u03bb i 2 i 5 \u2203 i 3 .. : V-rN Fc \u03bb i 2 \u2203 i 5 .. : N R\n(1 i 2 )=i 1 , (1 i 3 )=i 2 , (1 i 5 )=i 4 , (2 i 5 )=i 6 , (1 i 6 )=i 3 , (2 i 6 )=i 7 .\nThe semantic dependency relations for this sentence are represented graphically in Figure 1.  (V-aN-hN)-c(V-aN-hN)-d(V-aN-hN)\neat V-aN-bN V-aN-hN Hb (V-aN-hN)-c(V-aN-hN) Cc V-aN-hN Ca shrimp N V-aN Ha\nAn example derivation of the noun phrase the person who officials say stole millions, exemplifying F, G, and R rules, is shown in Figure 2; and an example derivation of the noun phrase creditors, investors and employees of the company, exemplifying C, E, and H rules, is shown in Figure 3. After all lambda expressions are applied to arguments in a derivation, each word is associated creditors \u03bb i 1 (0 i 1 ) =creditors : N-aD-bO \n\u03bb i 5 i 1 .. \u2227 (2 i 1 )\nCc \u03bb i 5 i 2 \u2203 i 3 .. \u2227 (2 i 2 )=i 3 \u2227 (1 i 3 )=i 2 \u2227 (0 i 2 )=(0 i 3 ) : (N-hO)-c(N-hO) Cb \u03bb i 5 i 2 \u2203 i 1 .. \u2227 (1 i 2 )=i 1 : N-hO Ca of \u03bb i 5 (0 i 5 ) =of : O-bN the \u03bb i 6 (0 i 6 ) =the : D company \u03bb i 7 (0 i 7 ) =company : N-aD \u03bb i 7 \u2203 i 6 .. \u2227 (1 i 7 )=i 6 : N Aa \u03bb i 5 \u2203 i 7 .. \u2227 (1 i 5 )=i 7 : O Ae \u03bb i 2 \u2203 i 5 .. : N Ha\nFigure 3: Example categorization of the noun phrase creditors investors and employees of the company. This derivation yields the following lexical relations: (0 i 1 )=creditors, (0 i 2 )=investors, (0 i 2 )=(0 i 3 )=and, (0 i 4 )=employees, (0 i 5 )=of, (0 i 6 )=the, (0 i 7 )=company, and the following argument relations:\n(2 i 1 )=i 5 , (2 i 2 )=i 5 , (2 i 4 )=i 5 , (1 i 2 )=i 1 , (2 i 2 )=i 3 , (1 i 3 )=i 2 , (2 i 3 )=i 4 , (1 i 5 )=i 7 , (1 i 7 )=i 6 .\nwith the variable of an existential quantifier. These existentially quantified variables can then be uniquely identified using numerical indices of words, and the numbered functions in lambda expressions (v i) = j are interpreted as dependency relations assigning the v th argument of i to be j.\nThis system has the attractive property that the same syntactic constraints can be assigned the same category in every context. This property is not shared by most categorial grammars: e.g. post-nominal and post-copular prepositional phrases often have different categories.", "publication_ref": ["b18", "b0", "b28", "b21", "b29", "b18", "b1", "b17", "b35"], "figure_ref": ["fig_0", "fig_0", "fig_1"], "table_ref": []}, {"heading": "Mapping Treebank to a Generalized Categorial Grammar", "text": "The reannotation system described in this paper defines its target grammar in terms of a set of reannotation rules. These reannotation rules work within a script that traverses each bracketed sentence in a corpus by selecting each pair of matching brackets from the top of the tree to the bottom, then running a sed-like pattern substitution rule on each selection (see Figure 4). Such rules can implement local syntactic transformations, as well as certain non-local transformations like adding gap arguments to constituents containing a particular trace marker, for example. Reannotation of the categorial grammar evaluated in this paper requires about 150 such rules. These rules are modular and can be reused or modified to experiment with different syntactic analyses.\nIn order to make the trace and function labels in the Treebank accessible to a PCFG-based latent variable annotator, they must be incorporated into the syntactic categories of each tree and propagated from filler to gap constituents, creating a categorial grammar with local associations between parents and immediate children. First all trace annotations for interrogatives, relative to produce a binary-branching categorial grammar derivation using gap arguments (c). Rules are applied to every constituent from the top of the tree down, using parentheses to delimit constituents above the current constituent, curly braces to delimit the current constituent, angle brackets to delimit child constituents, and square brackets to delimit constituents below children. Delimiters are then updated at every iteration.\nclauses, and topicalizations are transformed into gap arguments: -gN (for noun phrase gaps), -g(R-aN) (for adverbial phrase gaps), and -gS (for e.g. topicalized sentential gaps), which follow the category label for each constituent. Similar transformations localize it-clefts (it seems that...), tough constructions (tough to cut), parentheticals (he/she said), and certain types of inversion ('it rained,' she said), also using the gap operator -g. This is similar to the treatment of filler-gap constructions used in HPSG (Pollard and Sag, 1994).\nThen, specifiers of head projections are annotated as initial arguments, e.g. -aN for nominal subjects, and complements of head projections are annotated as final arguments: e.g. -bN for transitive verbs, prepositions, and certain adjectives, -bV for sentential complements, -bN-bN for ditransitive verbs, etc. The -h operator is then used to propagate directional dependencies in right node raising (they peeled and ate shrimp). These are similar to the 'subcat' feature in HPSG, or to the left and right slash in categorial grammar accounts of specification, complementation and right node raising.\nThen, interrogative and relative pronouns (e.g. what and which) are distinguished with -iN and -rN arguments, respectively, in order to regularize typical contexts for filler-gap traces.\nConjuncts are assigned -c and -d arguments to distinguish composition functions for conjuncts from composition functions for ordinary arguments. This distinction makes it possible for ordinary arguments to be shared among conjuncts.\nThe transform rules are defined as recursive rewrites that progress down the Treebank trees, propagating -a, -b, -c, -d, -g, -h, -i, and -r arguments as they go. Figure 4 shows a single step in a reannotation of the noun phrase the person who officials say stole millions. This set of recursive rules obtains about 94% coverage of the training set, consisting of sections 2-21 of the Penn Treebank. Trees not completely transformed by these rules are excluded from training. Since the system is evaluated on unbounded dependency annotations as described by Rimell et al. (2009), it is not necessary to apply this transformation to the test set.\nIn many cases the conversion to this categorial grammar replaces Treebank category labels with more general specifications. For example, in most contexts, adjective phrases, prepositional phrases, and progressive and passive verb phrases are replaced with a predicative category A-aN. This allows an HPSG-, GPSG-or CCG-like treatment of conjunction of any of these kinds of phrases with any other, following Sag et al. (1985), Gazdar et al. (1985), and Komagata (2002). This generalized predicative category is also used for noun phrase modifiers, and for noun phrases following the copular be. This annotation is compatible with additional specification of categories for adjective phrases (following words like become), or gerund phrases (following words like start), but these contexts cannot be reliably identified by the current reannotation.\nIn other cases, the conversion to categorial grammar distinguishes categories that are conflated in the Treebank. For example, the Treebank 'SBAR' category is distinguished into adjectival relative clauses V-rN, embedded questions V-iN, embedded inflected sentences C, embedded infinitival sentences E, nominal clauses N, adjectival modifier phrases A-aN, and adverbial modifier phrases R-aN (e.g. because . . . ). Treebank 'S' categories are similarly distinguished into inflected sentences V, infinitival sentences I, base form sentences B, adjectival sentences (small clauses) A, and participial sentences L. 7\nAlso, like other categorial grammars, this transform leaves trees in binary branching (Chomsky normal) form.", "publication_ref": ["b32", "b33", "b34", "b10", "b16"], "figure_ref": ["fig_4", "fig_4"], "table_ref": []}, {"heading": "Evaluation", "text": "To evaluate the reannotation system described in this paper, a version of the Penn Treebank was annotated with a generalized categorial grammar as described in Section 3. This required about 150 reannotation rules, with about 20 rules for each of noun phrases, verb phrases, prepositional phrases, adjectival phrases, and adverbial phrases, and about 50 rules for various sentence types. This reannotation was applied to Sections 02 to 21 of the WSJ portion of the Penn Treebank (Marcus et al., 1993). The resulting corpus then underwent three iterations of latent variable annotation, using the split-merge algorithm of Petrov et al. (2006). 8 Each iteration of this algorithm splits the categories in the training corpus randomly in two, runs the inside-outside algorithm (expectation maximization) on the resulting trees to maximize the probability of the training set, then merges those categories that contributed the least to the maximization. The categorial grammar type-constructing operators were then used to extract semantic dependency relations for each parsed sentence.\nThis evaluation used development and test sets from Rimell et al. (2009) for tuning the annotation mappings and testing, respectively. The de Marneffe et al. (2006) dependencies used in these sets are deterministically mapped to the comparable numeric relations used by the current system. 9 Thus, the dependencies 'nsubj' and 'nsubjpass' are mapped to a '1' relation, and 'dobj', 'pobj', and 'obj2' are mapped to a '2' relation. The dependencies 'advmod', 'prep', and 'nn' are also mapped to a '1' relation with the direction of the dependency reversed. 10\n7 It is important to note that these rules allow the word that to be treated as a relativizer rather than a relative pronoun, as it is in other categorial grammars, such as CCG.\n8 Under the current system, this number of split-merge iterations was empirically shown to yield the same results on development data as five iterations of split-merge, which is the recommended number for maximum accuracy without overfitting according to Petrov and Klein (2007). 9 This simplification of dependency labels to numbers can be losslessly reversed by looking at the categories of the involved predicates.\n10 One anonymous reviewer points out that this reversal of direction for modifier dependencies is similar to that described in dependency accounts of Tree Adjoining Grammars (Joshi, 1985;Candito and Kahane, 1998 Rimell et al. (2009) and Nivre et al. (2010) over a variety of constructions: object extraction from relative clauses (Obj RC), object extraction from reduced relative clauses (Obj Red), subject extraction from relative clauses (Sbj RC), free relatives (Free), object wh-questions (Obj Q), right node raising (RNR), and subject extraction from embedded clauses (Sbj Embed). Evaluated parsers are C&C (Clark and Curran, 2007), Enju (Miyao and Tsujii, 2005), DCU (Cahill et al., 2004), Rasp (Briscoe et al., 2006), Stanford (Klein and Manning, 2003), MST (McDonald, 2006), Malt (Nivre et al., 2006a,b). This system used the Berkley parser (Petrov and Klein, 2007) run on the reannotated categorial grammar. Due to differences between the de Marneffe et al. ( 2006) dependency representation and that of the current system, some deterministic modifications were required for evaluation against the Rimell et al. (2009) corpus. 11 1. If the hypothesized target of a dependency is a conjunction, the dependencies to each of its conjuncts are hypothesized instead;\n2. If the target of a dependency is a relativizer or a relative pronoun, the predicate it modifies is used in its place; and\n3. If the source predicate of a dependency has a category of O, the predicate that depends on the hypothesized target is hypothesized as the target.\nFor example, in this categorial grammar analysis of the phrase levels of health, the word of heads a phrase of category O, with health as an argument, and levels depends directly on health, so the dependency that is evaluated is from of to levels. Finally, following Rimell et al. (2009), the current system counts both dependencies in a conjunction as having been captured if the first is correct and the conjunction is modelled correctly. If the source has the same type of relation to the target in the gold standard as was output by the current system, the dependency is counted as correct. The final results are tabulated in comparison to those in Rimell et al. (2009) and Nivre et al. (2010) in Table 1. 12", "publication_ref": ["b19", "b30", "b33", "b9", "b13", "b6", "b33", "b27", "b7", "b24", "b4", "b3", "b15", "b31", "b33", "b33", "b33", "b27"], "figure_ref": [], "table_ref": ["tab_3"]}, {"heading": "Conclusion", "text": "This paper has presented a system for automatically reannotating syntactically-annotated corpora for the purpose of refining linguistically-informed phrase structure analyses of various phenomena. The paper has also presented a generalized categorial grammar reannotation developed using this system which combines the transparent predicate-argument structure of a categorial grammar with the categorial generality of an HPSG-like system. The system achieves unbounded dependency parsing accuracy favorably comparable to all the systems recently studied by Rimell et al. (2009) and Nivre et al. (2010) on this same task.\nThis system and the generalized categorial grammar reannotation rules (and other scripts needed to produce the reannotated corpus) are available at: http://sourceforge.net/projects/modelblocks/", "publication_ref": ["b33", "b27"], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgements", "text": "Thanks to Laura Rimell for providing the unbounded dependency corpus and for her clarifications regarding the unbounded dependency recovery task. Thanks also to Bob Levine and Carl Pollard for insightful discussions related to this project, and to the anonymous reviewers for their comments. This work was funded by a Department of Linguistics Targeted Investment for Excellence (TIE) grant for collaborative interdisciplinary projects conducted during the academic year 2012-13.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Discontinuous constituents in generalized categorial grammars", "journal": "", "year": "1981", "authors": "References Bach; E "}, {"ref_id": "b1", "title": "A quasi-arithmetical notation for syntactic description. Language", "journal": "", "year": "1953", "authors": "Y Bar-Hillel"}, {"ref_id": "b2", "title": "Handling noisy training and testing data", "journal": "", "year": "2002", "authors": "D Blaheta"}, {"ref_id": "b3", "title": "The second release of the RASP system", "journal": "", "year": "2006", "authors": "T Briscoe; J Carroll; R Watson"}, {"ref_id": "b4", "title": "Long-distance dependency resolution in automatically acquired wide-coverage PCFG-based lfg approximations", "journal": "", "year": "2004", "authors": "A Cahill; M Burke; J V Genabith; Way ; A "}, {"ref_id": "b5", "title": "Using linguistic principles to recover empty categories", "journal": "", "year": "2004", "authors": "R Campbell"}, {"ref_id": "b6", "title": "Can the TAG derivation tree represent a semantic graph", "journal": "", "year": "1998", "authors": "M.-H Candito; S Kahane"}, {"ref_id": "b7", "title": "Wide-coverage efficient statistical parsing with CCG and log-linear models", "journal": "Computational Linguistics", "year": "2007", "authors": "S Clark; J R Curran"}, {"ref_id": "b8", "title": "Three generative, lexicalised models for statistical parsing", "journal": "", "year": "1997", "authors": "M Collins"}, {"ref_id": "b9", "title": "Generating typed dependency parses from phrase structure parses", "journal": "", "year": "2006", "authors": ", M.-C De Marneffe; B Maccartney; C D Manning"}, {"ref_id": "b10", "title": "Generalized Phrase Structure Grammar", "journal": "Harvard University Press", "year": "1985", "authors": "G Gazdar; E Klein; G Pullum; I Sag"}, {"ref_id": "b11", "title": "Identifying semantic roles using combinatory categorial grammar", "journal": "", "year": "2003", "authors": "D Gildea; J Hockenmaier"}, {"ref_id": "b12", "title": "Data and Models for Statistical Parsing with Combinatory Categorial Grammar", "journal": "", "year": "2003", "authors": "J Hockenmaier"}, {"ref_id": "b13", "title": "How much context sensitivity is necessary for characterizing structural descriptions: Tree adjoining grammars", "journal": "Cambridge University Press", "year": "1985", "authors": "A K Joshi"}, {"ref_id": "b14", "title": "Questionbank: Creating a corpus of parseannotated questions", "journal": "", "year": "2006", "authors": "J Judge; A Cahill; J Van Genabith"}, {"ref_id": "b15", "title": "Accurate unlexicalized parsing", "journal": "", "year": "2003", "authors": "D Klein; C D Manning"}, {"ref_id": "b16", "title": "Coordination of unlike (?) categories: How not to distinguish categories", "journal": "", "year": "2002", "authors": "N Komagata"}, {"ref_id": "b17", "title": "Gapping as like-category coordination", "journal": "Logical Aspects of Computational Linguistics", "year": "2012", "authors": "Y Kubota; R Levine"}, {"ref_id": "b18", "title": "The mathematics of sentence structure", "journal": "American mathematical monthly", "year": "1958", "authors": "J Lambek"}, {"ref_id": "b19", "title": "Building a large annotated corpus of English: the Penn Treebank", "journal": "Computational Linguistics", "year": "1993", "authors": "M P Marcus; B Santorini; M A Marcinkiewicz"}, {"ref_id": "b20", "title": "Discriminative Learning and Spanning Tree Algorithms for Dependency Parsing", "journal": "", "year": "2006", "authors": "R Mcdonald"}, {"ref_id": "b21", "title": "Dependency syntax: theory and practice", "journal": "", "year": "1988", "authors": "I Mel'\u010duk"}, {"ref_id": "b22", "title": "Distinguishing phenogrammar from tectogrammar simplifies the analysis of interrogatives", "journal": "", "year": "2010", "authors": "V Mihalicek; C Pollard"}, {"ref_id": "b23", "title": "Corpus-oriented grammar development for acquiring a head-driven phrase structure grammar from the Penn Treebank", "journal": "", "year": "2004", "authors": "Y Miyao; T Ninomiya; J Tsujii"}, {"ref_id": "b24", "title": "Probabilistic disambiguation models for wide-coverage HPSG parsing", "journal": "", "year": "2005", "authors": "Y Miyao; J Tsujii"}, {"ref_id": "b25", "title": "Maltparser: A data-driven parser-generator for dependency parsing", "journal": "", "year": "2006", "authors": "J Nivre; J Hall; J Nilsson"}, {"ref_id": "b26", "title": "Labeled pseudo-projective dependency parsing with support vector machines", "journal": "Association for Computational Linguistics", "year": "2006", "authors": "J Nivre; J Hall; J Nilsson; G Eryi\u01e7it; S Marinov"}, {"ref_id": "b27", "title": "Evaluation of dependency parsers on unbounded dependencies", "journal": "", "year": "2010", "authors": "J Nivre; L Rimell; R Mcdonald; C G\u00f3mez-Rodr\u00edguez"}, {"ref_id": "b28", "title": "Term-labeled categorial type systems", "journal": "Linguistics and Philosophy", "year": "1994", "authors": "R T Oehrle"}, {"ref_id": "b29", "title": "Events in the Semantics of English", "journal": "MIT Press", "year": "1990", "authors": "T Parsons"}, {"ref_id": "b30", "title": "Learning accurate, compact, and interpretable tree annotation", "journal": "", "year": "2006", "authors": "S Petrov; L Barrett; R Thibaux; D Klein"}, {"ref_id": "b31", "title": "Improved inference for unlexicalized parsing", "journal": "Association for Computational Linguistics", "year": "2007", "authors": "S Petrov; D Klein"}, {"ref_id": "b32", "title": "Head-driven Phrase Structure Grammar", "journal": "University of Chicago Press", "year": "1994", "authors": "C Pollard; I Sag"}, {"ref_id": "b33", "title": "Unbounded dependency recovery for parser evaluation", "journal": "", "year": "2009", "authors": "L Rimell; S Clark; M Steedman"}, {"ref_id": "b34", "title": "Coordination and how to distinguish categories", "journal": "Natural Language & Linguistic Theory", "year": "1985", "authors": "I A Sag; G Gazdar; T Wasow; S Weisler"}, {"ref_id": "b35", "title": "Principles and implementation of deductive parsing", "journal": "Journal of Logic Programming", "year": "1995", "authors": "S M Shieber; Y Schabes; F C Pereira"}, {"ref_id": "b36", "title": "The syntactic process", "journal": "MIT Press/Bradford Books", "year": "2000", "authors": "M Steedman"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 1 :1Figure 1: Graphical representation of predicate-argument dependencies for the sentence The person who officials say stole millions.", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 2 :2Figure 2: Example categorization of the noun phrase the person who officials say stole millions.This derivation yields the following lexical relations: (0 i 1 )=the, (0 i 2 )=person, (0 i 3 )=who, (0 i 4 )=officials, (0 i 5 )=say, (0 i 6 )=stole, (0 i 7 )=millions, and the following argument relations:(1 i 2 )=i 1 , (1 i 3 )=i 2 , (1 i 5 )=i 4 , (2 i 5 )=i 6 , (1 i 6 )=i 3 , (2 i 6 )=i 7 .The semantic dependency relations for this sentence are represented graphically in Figure1.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "7. Inference rules for argument elision (including determiners of plural nouns) simply leave these arguments unspecified in the resulting meaning function: rules for right node raising introduction and attachment treat right-node raising as a type of non-local argument using operator -h:g: c-hd h: d \u03bb i \u2203 j (g j i) \u2227 (h j): c g: c-bd \u03bb k ( f c-bd g {k}): c-hd (", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "Figure 4 :4Figure 4: Sample sed-like reannotation rule introducing a gap tag at the top of a relative clause (a), and an application of this rule to the movement-based notation in the Penn Treebank (b)to produce a binary-branching categorial grammar derivation using gap arguments (c). Rules are applied to every constituent from the top of the tree down, using parentheses to delimit constituents above the current constituent, curly braces to delimit the current constituent, angle brackets to delimit child constituents, and square brackets to delimit constituents below children. Delimiters are then updated at every iteration.", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_3", "figure_caption": "Unbounded dependency results compared to those of other systems studied by", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "1. every U is in C 2. every C \u00d7O\u00d7C is in C 3. nothing else is in C", "formula_coordinates": [5.0, 69.94, 215.31, 83.54, 33.48]}, {"formula_id": "formula_1", "formula_text": "x \u2192 M (\u03bb i (0 i)=x) : u\u03d5 1 ...\u03d5 v (1a) 2", "formula_coordinates": [5.0, 68.44, 456.92, 304.88, 20.42]}, {"formula_id": "formula_2", "formula_text": "x \u2192 M (\u03bb k i (0 i)=x \u2227 (v i)=k) : u\u03d5 1 ...\u03d5 v\u22121 -rc (1b) x \u2192 M (\u03bb k i (0 i)=x \u2227 (v i)=k) : u\u03d5 1 ...\u03d5 v\u22121 -ic (1c)", "formula_coordinates": [6.0, 126.61, 252.04, 232.54, 29.48]}, {"formula_id": "formula_3", "formula_text": "f u\u03d5 1 ...\u03d5 v\u22121 -ac def = \u03bb g h i \u2203 j (v i)= j \u2227 (g j) \u2227 (h i) (2a) f u\u03d5 1 ...\u03d5 v\u22121 -bc def = \u03bb g h i \u2203 j (v i)= j \u2227 (g i) \u2227 (h j) (2b)", "formula_coordinates": [6.0, 138.51, 394.39, 220.64, 35.82]}, {"formula_id": "formula_4", "formula_text": "f IM def = \u03bb g h j \u2203 i (1 i)= j \u2227 (g i) \u2227 (h j) (3a) f FM def = \u03bb g h j \u2203 i (1 i)= j \u2227 (g j) \u2227 (h i) (3b)", "formula_coordinates": [6.0, 150.56, 471.08, 208.59, 35.63]}, {"formula_id": "formula_5", "formula_text": "\u2208 C: 4 f c-cd def = \u03bb g h i \u2203 j (1 i)= j \u2227 (g j) \u2227 (h i) (4a) f c-dd def = \u03bb g h i \u2203 j (2 i)= j \u2227 (g i) \u2227 (h j) (4b) f & def = \u03bb g h i \u2203 j k j=(2 i) \u2227 (0 i)=(0 j) \u2227 (1 j)=k \u2227 (g k) \u2227 (h j) (4c)", "formula_coordinates": [7.0, 119.14, 70.63, 254.18, 68.2]}, {"formula_id": "formula_6", "formula_text": "g:d h: c-ad ( f c-ad g h): c g:d\u03c8 h: c-ad \u03bb k ( f c-ad (g k) h): c\u03c8 g:d h: c-ad\u03c8 \u03bb k ( f c-ad g (h k)): c\u03c8 g:d\u03c8 h: c-ad\u03c8 \u03bb k ( f c-ad (g k) (h k)): c\u03c8 (Aa-d) g: c-bd h:d ( f c-bd g h): c g: c-bd\u03c8 h:d \u03bb k ( f c-bd (g k) h): c\u03c8 g: c-bd h:d\u03c8 \u03bb k ( f c-bd g (h k)): c\u03c8 g: c-bd\u03c8 h:d\u03c8 \u03bb k ( f c-bd (g k) (h k)): c\u03c8 (Ae-h)", "formula_coordinates": [7.0, 80.79, 252.34, 292.53, 45.26]}, {"formula_id": "formula_7", "formula_text": "read V-aN-bN a book about cars N V-aN Ae read V-aN-bN a book about N-gN V-aN-gN Ag 2.", "formula_coordinates": [7.0, 69.94, 315.84, 252.25, 46.16]}, {"formula_id": "formula_8", "formula_text": "g: u-ad h:c ( f IM g h):c g: u-ad\u03c8 h:c \u03bb k ( f IM (g k) h):c\u03c8 g: u-ad h:c\u03c8 \u03bb k ( f IM g (h k)):c\u03c8 g: u-ad\u03c8 h:c\u03c8 \u03bb k ( f IM (g k) (h k)):c\u03c8 (Ma-d) g:c h: u-ad ( f FM g h):c g:c\u03c8 h: u-ad \u03bb k ( f FM (g k) h):c\u03c8 g:c h: u-ad\u03c8 \u03bb k ( f FM g (h k)):c\u03c8 g:c\u03c8 h: u-ad\u03c8 \u03bb k ( f FM (g k) (h k)):c\u03c8 (Me-h)", "formula_coordinates": [7.0, 89.15, 386.59, 284.17, 45.23]}, {"formula_id": "formula_9", "formula_text": "sleep V-aN in Aix R-aN V-aN Me sleep V-aN in R-aN-gN V-aN-gNMg", "formula_coordinates": [7.0, 156.04, 450.25, 141.54, 26.66]}, {"formula_id": "formula_10", "formula_text": "g:d h: c-cd ( f c-cd g h): c g:d h: c-cd ( f & g h): c-cd g: c-dd h:d ( f c-dd g h): c (Ca-c) g:d\u03c8 h: c-cd\u03c8 \u03bb k ( f c-cd (g k) (h k)): c g:d\u03c8 h: c-cd\u03c8 \u03bb k ( f & (g k) (h k)): c-cd\u03c8 g: c-dd\u03c8 h:d\u03c8 \u03bb k ( f c-dd g (h k)): c (Cd-f)", "formula_coordinates": [8.0, 95.06, 96.37, 264.09, 45.26]}, {"formula_id": "formula_11", "formula_text": "g: c-ad \u03bb k ( f c-ad {k} g): c-gd g: c-bd \u03bb k ( f c-bd g {k}): c-gd g:c \u03bb k ( f IM {k} g):c-gd (Ga-c)", "formula_coordinates": [8.0, 95.02, 239.8, 264.13, 29.24]}, {"formula_id": "formula_12", "formula_text": "is sleeping V-aN V-gN Ga we N drove V-aN-bN V-aN-gN Gb V-gN Ac is sleeping V-aN V-aN-gR Gc 5.", "formula_coordinates": [8.0, 55.76, 275.1, 243.45, 52.73]}, {"formula_id": "formula_13", "formula_text": "\u03bb i \u2203 j (g i) \u2227 (h i j):e g:d-re h: c-gd \u03bb k j \u2203 i (g k i) \u2227 (h i j): c-re g:d-ie h: c-gd \u03bb k j \u2203 i (g k i) \u2227 (h i j): c-ie (Fa-c)", "formula_coordinates": [8.0, 79.07, 343.57, 280.08, 29.24]}, {"formula_id": "formula_14", "formula_text": "\u03bb i \u2203 j (g i) \u2227 (h i j):e (R)", "formula_coordinates": [8.0, 180.75, 456.59, 178.4, 23.01]}, {"formula_id": "formula_15", "formula_text": "V-rN N R the \u03bb i 1 (0 i 1 ) =the : D person \u03bb i 2 (0 i 2 ) =person : N-aD \u03bb i 2 \u2203 i 1 .. \u2227 (1 i 2 )=i 1 : N Aa who \u03bb i 2 i 3 (0 i 3 )=who \u2227 (1 i 3 )=i 2 : N-rN officials \u03bb i 4 (0 i 4 ) =officials : N say \u03bb i 5 (0 i 5 ) =say : V-aN-bV stole \u03bb i 6 (0 i 6 ) =stole : V-aN-bN millions \u03bb i 7 (0 i 7 ) =millions : N \u03bb i 6 \u2203 i 7 .. \u2227 (2 i 6 )=i 7 : V-aN Ae \u03bb i 3 i 6 .. \u2227 (1 i 6 )=i 3 : V-gN Ga \u03bb i 3 i 5 \u2203 i 6 .. \u2227 (2 i 5 )=i 6 : V-aN-gN Ag \u03bb i 3 i 5 \u2203 i 4 .. \u2227 (1 i 5 )=i 4 : V-gN Ac \u03bb i 2 i 5 \u2203 i 3 .. : V-rN Fc \u03bb i 2 \u2203 i 5 .. : N R", "formula_coordinates": [8.0, 204.84, 495.63, 39.76, 17.92]}, {"formula_id": "formula_16", "formula_text": "(1 i 2 )=i 1 , (1 i 3 )=i 2 , (1 i 5 )=i 4 , (2 i 5 )=i 6 , (1 i 6 )=i 3 , (2 i 6 )=i 7 .", "formula_coordinates": [9.0, 59.77, 216.92, 184.03, 11.13]}, {"formula_id": "formula_17", "formula_text": "eat V-aN-bN V-aN-hN Hb (V-aN-hN)-c(V-aN-hN) Cc V-aN-hN Ca shrimp N V-aN Ha", "formula_coordinates": [9.0, 167.88, 421.22, 186.98, 54.15]}, {"formula_id": "formula_18", "formula_text": "\u03bb i 5 i 1 .. \u2227 (2 i 1 )", "formula_coordinates": [10.0, 49.8, 159.56, 26.05, 20.78]}, {"formula_id": "formula_19", "formula_text": "Cc \u03bb i 5 i 2 \u2203 i 3 .. \u2227 (2 i 2 )=i 3 \u2227 (1 i 3 )=i 2 \u2227 (0 i 2 )=(0 i 3 ) : (N-hO)-c(N-hO) Cb \u03bb i 5 i 2 \u2203 i 1 .. \u2227 (1 i 2 )=i 1 : N-hO Ca of \u03bb i 5 (0 i 5 ) =of : O-bN the \u03bb i 6 (0 i 6 ) =the : D company \u03bb i 7 (0 i 7 ) =company : N-aD \u03bb i 7 \u2203 i 6 .. \u2227 (1 i 7 )=i 6 : N Aa \u03bb i 5 \u2203 i 7 .. \u2227 (1 i 5 )=i 7 : O Ae \u03bb i 2 \u2203 i 5 .. : N Ha", "formula_coordinates": [10.0, 90.49, 158.21, 269.52, 85.97]}, {"formula_id": "formula_20", "formula_text": "(2 i 1 )=i 5 , (2 i 2 )=i 5 , (2 i 4 )=i 5 , (1 i 2 )=i 1 , (2 i 2 )=i 3 , (1 i 3 )=i 2 , (2 i 3 )=i 4 , (1 i 5 )=i 7 , (1 i 7 )=i 6 .", "formula_coordinates": [10.0, 45.59, 273.0, 314.62, 20.69]}], "doi": ""}