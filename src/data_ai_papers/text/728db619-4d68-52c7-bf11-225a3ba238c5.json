{"title": "Forest Reranking: Discriminative Parsing with Non-Local Features *", "authors": "Liang Huang", "pub_date": "", "abstract": "Conventional n-best reranking techniques often suffer from the limited scope of the nbest list, which rules out many potentially good alternatives. We instead propose forest reranking, a method that reranks a packed forest of exponentially many parses. Since exact inference is intractable with non-local features, we present an approximate algorithm inspired by forest rescoring that makes discriminative training practical over the whole Treebank. Our final result, an F-score of 91.7, outperforms both 50-best and 100-best reranking baselines, and is better than any previously reported systems trained on the Treebank.", "sections": [{"heading": "Introduction", "text": "Discriminative reranking has become a popular technique for many NLP problems, in particular, parsing (Collins, 2000) and machine translation (Shen et al., 2005). Typically, this method first generates a list of top-n candidates from a baseline system, and then reranks this n-best list with arbitrary features that are not computable or intractable to compute within the baseline system. But despite its apparent success, there remains a major drawback: this method suffers from the limited scope of the nbest list, which rules out many potentially good alternatives. For example 41% of the correct parses were not in the candidates of \u223c30-best parses in (Collins, 2000). This situation becomes worse with longer sentences because the number of possible interpretations usually grows exponentially with the * Part of this work was done while I was visiting Institute of Computing Technology, Beijing, and I thank Prof. Qun Liu and his lab for hosting me. I am also grateful to Dan Gildea and Mark Johnson for inspirations, Eugene Charniak for help with his parser, and Wenbin Jiang for guidance on perceptron averaging. This project was supported by NSF ITR EIA-0205456.\nlocal non-local conventional reranking only at the root DP-based discrim. parsing exact N/A this work: forest-reranking exact on-the-fly sentence length. As a result, we often see very few variations among the n-best trees, for example, 50best trees typically just represent a combination of 5 to 6 binary ambiguities (since 2 5 < 50 < 2 6 ).\nAlternatively, discriminative parsing is tractable with exact and efficient search based on dynamic programming (DP) if all features are restricted to be local, that is, only looking at a local window within the factored search space (Taskar et al., 2004;Mc-Donald et al., 2005). However, we miss the benefits of non-local features that are not representable here.\nIdeally, we would wish to combine the merits of both approaches, where an efficient inference algorithm could integrate both local and non-local features. Unfortunately, exact search is intractable (at least in theory) for features with unbounded scope. So we propose forest reranking, a technique inspired by forest rescoring (Huang and Chiang, 2007) that approximately reranks the packed forest of exponentially many parses. The key idea is to compute non-local features incrementally from bottom up, so that we can rerank the n-best subtrees at all internal nodes, instead of only at the root node as in conventional reranking (see Table 1). This method can thus be viewed as a step towards the integration of discriminative reranking with traditional chart parsing.\nAlthough previous work on discriminative parsing has mainly focused on short sentences (\u2264 15 words) (Taskar et al., 2004;Turian and Melamed, 2007), our work scales to the whole Treebank, where\nVP 1,6 VBD 1,2 blah NP 2,6 NP 2,3 blah PP 3,6 b e 2 e 1\nFigure 1: A partial forest of the example sentence.\nwe achieved an F-score of 91.7, which is a 19% error reduction from the 1-best baseline, and outperforms both 50-best and 100-best reranking. This result is also better than any previously reported systems trained on the Treebank.", "publication_ref": ["b4", "b15", "b4", "b16", "b8", "b16", "b17"], "figure_ref": [], "table_ref": ["tab_0"]}, {"heading": "Packed Forests as Hypergraphs", "text": "Informally, a packed parse forest, or forest in short, is a compact representation of all the derivations (i.e., parse trees) for a given sentence under a context-free grammar (Billot and Lang, 1989). For example, consider the following sentence 0 I 1 saw 2 him 3 with 4 a 5 mirror 6 where the numbers between words denote string positions. Shown in Figure 1, this sentence has (at least) two derivations depending on the attachment of the prep. phrase PP 3,6 \"with a mirror\": it can either be attached to the verb \"saw\",\nVBD 1,2 NP 2,3 PP 3,6 VP 1,6 ,(*)\nor be attached to \"him\", which will be further combined with the verb to form the same VP as above. These two derivations can be represented as a single forest by sharing common sub-derivations. Such a forest has a structure of a hypergraph (Klein and Manning, 2001;Huang and Chiang, 2005), where items like PP 3,6 are called nodes, and deductive steps like (*) correspond to hyperedges. More formally, a forest is a pair V, E , where V is the set of nodes, and E the set of hyperedges. For a given sentence w 1:l = w 1 . . . w l , each node v \u2208 V is in the form of X i,j , which denotes the recognition of nonterminal X spanning the substring from positions i through j (that is, w i+1 . . . w j ). Each hyperedge e \u2208 E is a pair tails(e), head (e) , where head (e) \u2208 V is the consequent node in the deductive step, and tails(e) \u2208 V * is the list of antecedent nodes. For example, the hyperedge for deduction (*) is notated:\ne 1 = (VBD 1,2 , NP 2,3 , PP 3,6 ), VP 1,6\nWe also denote IN (v) to be the set of incoming hyperedges of node v, which represent the different ways of deriving v. For example, in the forest in Figure 1, IN (VP 1,6 ) is {e 1 , e 2 }, with e 2 = (VBD 1,2 , NP 2,6 ), VP 1,6 . We call |e| the arity of hyperedge e, which counts the number of tail nodes in e. The arity of a hypergraph is the maximum arity over all hyperedges. A CKY forest has an arity of 2, since the input grammar is required to be binary branching (cf. Chomsky Normal Form) to ensure cubic time parsing complexity. However, in this work, we use forests from a Treebank parser (Charniak, 2000) whose grammar is often flat in many productions. For example, the arity of the forest in Figure 1 is 3. Such a Treebank-style forest is easier to work with for reranking, since many features can be directly expressed in it. There is also a distinguished root node TOP in each forest, denoting the goal item in parsing, which is simply S 0,l where S is the start symbol and l is the sentence length.", "publication_ref": ["b0", "b9", "b7", "b3"], "figure_ref": [], "table_ref": []}, {"heading": "Forest Reranking", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Generic Reranking with the Perceptron", "text": "We first establish a unified framework for parse reranking with both n-best lists and packed forests.\nFor a given sentence s, a generic reranker selects the best parse\u0177 among the set of candidates cand (s) according to some scoring function:\ny = argmax y\u2208cand(s) score(y)(1)\nIn n-best reranking, cand (s) is simply a set of n-best parses from the baseline parser, that is, cand (s) = {y 1 , y 2 , . . . , y n }. Whereas in forest reranking, cand (s) is a forest implicitly representing the set of exponentially many parses.\nAs usual, we define the score of a parse y to be the dot product between a high dimensional feature representation and a weight vector w:\nscore(y) = w \u2022 f (y)(2)\nwhere the feature extractor f is a vector of d functions f = (f 1 , . . . , f d ), and each feature f j maps a parse y to a real number f j (y). Following (Charniak and Johnson, 2005), the first feature f 1 (y) = log Pr(y) is the log probability of a parse from the baseline generative parser, while the remaining features are all integer valued, and each of them counts the number of times that a particular configuration occurs in parse y. For example, one such feature f 2000 might be a question \"how many times is a VP of length 5 surrounded by the word 'has' and the period? \"\nwhich is an instance of the WordEdges feature (see Figure 2(c) and Section 3.2 for details).\nUsing a machine learning algorithm, the weight vector w can be estimated from the training data where each sentence s i is labelled with its correct (\"gold-standard\") parse y * i . As for the learner, Collins (2000) uses the boosting algorithm and Charniak and Johnson (2005) use the maximum entropy estimator. In this work we use the averaged perceptron algorithm (Collins, 2002) since it is an online algorithm much simpler and orders of magnitude faster than Boosting and MaxEnt methods.\nShown in Pseudocode 1, the perceptron algorithm makes several passes over the whole training data, and in each iteration, for each sentence s i , it tries to predict a best parse\u0177 i among the candidates cand (s i ) using the current weight setting. Intuitively, we want the gold parse y * i to be picked, but in general it is not guaranteed to be within cand (s i ), because the grammar may fail to cover the gold parse, and because the gold parse may be pruned away due to the limited scope of cand (s i ). So we define an oracle parse y + i to be the candidate that has the highest Parseval F-score with respect to the gold tree\ny * i : 1 y + i argmax y\u2208cand(s i ) F (y, y * i )(3)\nwhere function F returns the F-score. Now we train the reranker to pick the oracle parses as often as possible, and in case an error is made (line 6), perform an update on the weight vector (line 7), by adding the difference between two feature representations.\nPseudocode 1 Perceptron for Generic Reranking\n1: Input: Training examples {cand (si), y + i } N i=1 \u22b2 y + i is the oracle tree for si among cand (si) 2: w \u2190 0 \u22b2 initial weights 3: for t \u2190 1 . . . T do \u22b2 T iterations 4: for i \u2190 1 . . . N do 5:\u0177 = argmax y\u2208cand(s i ) w \u2022 f (y) 6: if\u0177 = y + i then 7: w \u2190 w + f (y + i ) \u2212 f (\u0177) 8: return w\nIn n-best reranking, since all parses are explicitly enumerated, it is trivial to compute the oracle tree. 2 However, it remains widely open how to identify the forest oracle. We will present a dynamic programming algorithm for this problem in Sec. 4.1.\nWe also use a refinement called \"averaged parameters\" where the final weight vector is the average of weight vectors after each sentence in each iteration over the training data. This averaging effect has been shown to reduce overfitting and produce much more stable results (Collins, 2002).", "publication_ref": ["b2", "b4", "b2", "b5", "b5"], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "Factorizing Local and Non-Local Features", "text": "A key difference between n-best and forest reranking is the handling of features. In n-best reranking, all features are treated equivalently by the decoder, which simply computes the value of each one on each candidate parse. However, for forest reranking, since the trees are not explicitly enumerated, many features can not be directly computed. So we first classify features into local and non-local, which the decoder will process in very different fashions.\nWe define a feature f to be local if and only if it can be factored among the local productions in a tree, and non-local if otherwise. For example, the Rule feature in Fig. 2(a) is local, while the Paren-tRule feature in Fig. 2(b) is non-local. It is worth noting that some features which seem complicated at the first sight are indeed local. For example, the WordEdges feature in Fig. 2(c), which classifies a node by its label, span length, and surrounding words, is still local since all these information are encoded either in the node itself or in the input sentence. In contrast, it would become non-local if we replace the surrounding words by surrounding POS tags, which are generated dynamically.\nMore formally, we split the feature extractor\nf = (f 1 , . . . , f d ) into f = (f L ; f N )\nwhere f L and f N are the local and non-local features, respectively. For the former, we extend their domains from parses to hyperedges, where f (e) returns the value of a local feature f \u2208 f L on hyperedge e, and its value on a parsey factors across the hyperedges (local productions),\nf L (y) = e\u2208y f L (e)(4)\nand we can pre-compute f L (e) for each e in a forest. Non-local features, however, can not be precomputed, but we still prefer to compute them as early as possible, which we call \"on-the-fly\" computation, so that our decoder can be sensitive to them at internal nodes. For instance, the NGramTree feature in Fig. 2 (d) returns the minimum tree fragement spanning a bigram, in this case \"saw\" and \"the\", and should thus be computed at the smallest common ancestor of the two, which is the VP node in this example. Similarly, the ParentRule feature in Fig. 2 (b) can be computed when the S subtree is formed. In doing so, we essentially factor non-local features across subtrees, where for each subtree y \u2032 in a parse y, we define a unit featuref (y \u2032 ) to be the part of f (y) that are computable within y \u2032 , but not computable in any (proper) subtree of y \u2032 . Then we have:\nf N (y) = y \u2032 \u2208yf N (y \u2032 ) (5)\nIntuitively, we compute the unit non-local features at each subtree from bottom-up. For example, for the binary-branching node A i,k in Fig. 3, the unit NGramTree instance is for the pair w j\u22121 , w j on the boundary between the two subtrees, whose smallest common ancestor is the current node. Other unit NGramTree instances within this span have already been computed in the subtrees, except those for the boundary words of the whole node, w i and w k\u22121 , which will be computed when this node is further combined with other nodes in the future.\nA i,k B i,j w i . . . w j\u22121 C j,k w j . . . w k\u22121", "publication_ref": [], "figure_ref": ["fig_0", "fig_0", "fig_0", "fig_0", "fig_0", "fig_1"], "table_ref": []}, {"heading": "Approximate Decoding via Cube Pruning", "text": "Before moving on to approximate decoding with non-local features, we first describe the algorithm for exact decoding when only local features are present, where many concepts and notations will be re-used later. We will use D(v) to denote the top derivations of node v, where D 1 (v) is its 1-best derivation. We also use the notation e, j to denote the derivation along hyperedge e, using the j i th subderivation for tail u i , so e, 1 is the best derivation along e. The exact decoding algorithm, shown in Pseudocode 2, is an instance of the bottom-up Viterbi algorithm, which traverses the hypergraph in a topological order, and at each node v, calculates its 1-best derivation using each incoming hyperedge e \u2208 IN (v). The cost of e, c(e), is the score of its sort buf to D(v) 16: procedure PUSHSUCC( e, j , heap) 17:\ne is v \u2192 u1 . . . u |e| 18:\nfor i in 1 . . . |e| do 19: (pre-computed) local features w \u2022 f L (e). This algorithm has a time complexity of O(E), and is almost identical to traditional chart parsing, except that the forest might be more than binary-branching.\nj \u2032 \u2190 j + b i \u22b2 b i is 1\nFor non-local features, we adapt cube pruning from forest rescoring (Chiang, 2007;Huang and Chiang, 2007), since the situation here is analogous to machine translation decoding with integrated language models: we can view the scores of unit nonlocal features as the language model cost, computed on-the-fly when combining sub-constituents.\nShown in Pseudocode 3, cube pruning works bottom-up on the forest, keeping a beam of at most k derivations at each node, and uses the k-best parsing Algorithm 2 of Huang and Chiang (2005) to speed up the computation. When combining the sub-derivations along a hyperedge e to form a new subtree y \u2032 = e, j , we also compute its unit non-local feature valuesf N ( e, j ) (line 25). A priority queue (heap in Pseudocode 3) is used to hold the candidates for the next-best derivation, which is initialized to the set of best derivations along each hyperedge (lines 7 to 9). Then at each iteration, we pop the best derivation (lines 12), and push its successors back into the priority queue (line 14). Analogous to the language model cost in forest rescoring, the unit feature cost here is a non-monotonic score in the dynamic programming backbone, and the derivations may thus be extracted out-of-order. So a buffer buf is used to hold extracted derivations, which is sorted at the end (line 15) to form the list of top-k derivations D(v) of node v. The complexity of this algorithm is O(E + V k log kN ) (Huang and Chiang, 2005), where O(N ) is the time for on-the-fly feature extraction for each subtree, which becomes the bottleneck in practice.", "publication_ref": ["b8", "b8", "b7", "b7"], "figure_ref": [], "table_ref": []}, {"heading": "Supporting Forest Algorithms", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Forest Oracle", "text": "Recall that the Parseval F-score is the harmonic mean of labelled precision P and labelled recall R:\nF (y, y * ) 2P R P + R = 2|y \u2229 y * | |y| + |y * | (6)\nwhere |y| and |y * | are the numbers of brackets in the test parse and gold parse, respectively, and |y \u2229 y * | is the number of matched brackets. Since the harmonic mean is a non-linear combination, we can not optimize the F-scores on sub-forests independently with a greedy algorithm. In other words, the optimal F-score tree in a forest is not guaranteed to be composed of two optimal F-score subtrees.\nWe instead propose a dynamic programming algorithm which optimizes the number of matched brackets for a given number of test brackets. For example, our algorithm will ask questions like,", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "\"when a test parse has 5 brackets, what is the maximum number of matched brackets?\"", "text": "More formally, at each node v, we compute an oracle function ora [v] : N \u2192 N, which maps an integer t to ora[v](t), the max. number of matched brackets Pseudocode 4 Forest Oracle Algorithm\n1: function ORACLE( V, E , y * ) 2: for v \u2208 V in topological order do 3: for e \u2208 BS(v) do 4: e is v \u2192 u1u2 . . . u |e| 5: ora[v] \u2190 ora[v] \u2295 (\u2297iora[ui]) 6: ora[v] \u2190 ora[v] \u21d1 (1, 1v\u2208y * ) 7: return F (y + , y * ) = maxt 2\u2022ora[TOP](t) t+|y * | \u22b2 oracle F1\nfor all parses y v of node v with exactly t brackets:\nora[v](t) max yv:|yv|=t |y v \u2229 y * | (7)\nWhen node v is combined with another node u along a hyperedge e = (v, u), w , we need to combine the two oracle functions ora [v] and ora[u] by distributing the test brackets of w between v and u, and optimize the number of matched bracktes. To do this we define a convolution operator \u2297 between two functions f and g:\n(f \u2297 g)(t) max t 1 +t 2 =t f (t 1 ) + g(t 2 )(8)\nFor instance:\nt f (t) 2 1 3 2 \u2297 t g(t) 4 4 5 4 = t (f \u2297 g)(t) 6 5 7 6 8 6\nThe oracle function for the head node w is then\nora[w](t) = (ora[v] \u2297 ora[u])(t \u2212 1) + 1 w\u2208y * (9)\nwhere 1 is the indicator function, returning 1 if node w is found in the gold tree y * , in which case we increment the number of matched brackets. We can also express Eq. 9 in a purely functional form\nora[w] = (ora[v] \u2297 ora[u]) \u21d1 (1, 1 w\u2208y * ) (10)\nwhere \u21d1 is a translation operator which shifts a function along the axes:\n(f \u21d1 (a, b))(t) f (t \u2212 a) + b (11)\nAbove we discussed the case of one hyperedge. If there is another hyperedge e \u2032 deriving node w, we also need to combine the resulting oracle functions from both hyperedges, for which we define a pointwise addition operator \u2295:\n(f \u2295 g)(t) max{f (t), g(t)}(12)\nShown in Pseudocode 4, we perform these computations in a bottom-up topological order, and finally at the root node TOP, we can compute the best global F-score by maximizing over different numbers of test brackets (line 7). The oracle tree y + can be recursively restored by keeping backpointers for each ora[v](t), which we omit in the pseudocode.\nThe time complexity of this algorithm for a sentence of l words is O(|E| \u2022 l 2(a\u22121) ) where a is the arity of the forest. For a CKY forest, this amounts to O(l 3 \u2022 l 2 ) = O(l 5 ), but for general forests like those in our experiments the complexities are much higher. In practice it takes on average 0.05 seconds for forests pruned by p = 10 (see Section 4.2), but we can pre-compute and store the oracle for each forest before training starts.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Forest Pruning", "text": "Our forest pruning algorithm (Jonathan Graehl, p.c.) is very similar to the method based on marginal probability (Charniak and Johnson, 2005), except that ours prunes hyperedges as well as nodes. Basically, we use an Inside-Outside algorithm to compute the Viterbi inside cost \u03b2(v) and the Viterbi outside cost \u03b1(v) for each node v, and then compute the merit \u03b1\u03b2(e) for each hyperedge:\n\u03b1\u03b2(e) = \u03b1(head (e)) + u i \u2208tails(e) \u03b2(u i )(13)\nIntuitively, this merit is the cost of the best derivation that traverses e, and the difference \u03b4(e) = \u03b1\u03b2(e) \u2212 \u03b2(TOP) can be seen as the distance away from the globally best derivation. We prune away all hyperedges that have \u03b4(e) > p for a threshold p. Nodes with all incoming hyperedges pruned are also pruned. The key difference from (Charniak and Johnson, 2005) is that in this algorithm, a node can \"partially\" survive the beam, with a subset of its hyperedges pruned. In practice, this method prunes on average 15% more hyperedges than their method.", "publication_ref": ["b2", "b2"], "figure_ref": [], "table_ref": []}, {"heading": "Experiments", "text": "We compare the performance of our forest reranker against n-best reranking on the Penn English Treebank (Marcus et al., 1993). The baseline parser is the Charniak parser, which we modified to output a   (Collins, 2000), and others are from (Charniak and Johnson, 2005), with simplifications. packed forest for each sentence. 3", "publication_ref": ["b10", "b4", "b2"], "figure_ref": [], "table_ref": []}, {"heading": "Data Preparation", "text": "We use the standard split of the Treebank: sections 02-21 as the training data (39832 sentences), section 22 as the development set (1700 sentences), and section 23 as the test set (2416 sentences). Following (Charniak and Johnson, 2005), the training set is split into 20 folds, each containing about 1992 sentences, and is parsed by the Charniak parser with a model trained on sentences from the remaining 19 folds. The development set and the test set are parsed with a model trained on all 39832 training sentences.\nWe implemented both n-best and forest reranking systems in Python and ran our experiments on a 64bit Dual-Core Intel Xeon with 3.0GHz CPUs. Our feature set is summarized in Table 2, which closely follows Charniak and Johnson (2005), except that we excluded the non-local features Edges, NGram, and CoPar, and simplified Rule and NGramTree features, since they were too complicated to compute. 4 We also added four unlexicalized local features from Collins (2000) to cope with data-sparsity.\nFollowing Charniak and Johnson (2005), we extracted the features from the 50-best parses on the training set (sec. 02-21), and used a cut-off of 5 to prune away low-count features. There are 0.8M features in our final set, considerably fewer than that of Charniak and Johnson which has about 1.3M fea- tures in the updated version. 5 However, our initial experiments show that, even with this much simpler feature set, our 50-best reranker performed equally well as theirs (both with an F-score of 91.4, see Tables 3 and 4). This result confirms that our feature set design is appropriate, and the averaged perceptron learner is a reasonable candidate for reranking. The forests dumped from the Charniak parser are huge in size, so we use the forest pruning algorithm in Section 4.2 to prune them down to a reasonable size. In the following experiments we use a threshold of p = 10, which results in forests with an average number of 123.1 hyperedges per forest. Then for each forest, we annotate its forest oracle, and on each hyperedge, pre-compute its local features. 6 Shown in Figure 4, these forests have an forest oracle of 97.8, which is 1.1% higher than the 50-best oracle (96.7), and are 8 times smaller in size.", "publication_ref": ["b2", "b2", "b4", "b2"], "figure_ref": ["fig_2"], "table_ref": ["tab_4", "tab_6"]}, {"heading": "Results and Analysis", "text": "Table 3 compares the performance of forest reranking against standard n-best reranking. For both systems, we first use only the local features, and then all the features. We use the development set to determine the optimal number of iterations for averaged perceptron, and report the F 1 score on the test set. With only local features, our forest reranker achieves an F-score of 91.25, and with the addition of non-  This improvement might look relatively small, but it is much harder to make a similar progress with n-best reranking. For example, even if we double the size of the n-best list to 100, the performance only goes up by 0.06% (Table 3). In fact, the 100best oracle is only 0.5% higher than the 50-best one (see Fig. 4). In addition, the feature extraction step in 100-best reranking produces huge data files and takes 44 hours in total, though this part can be parallelized. 8 On two CPUs, 100-best reranking takes 25 hours, while our forest-reranker can also finish in 26 hours, with a much smaller disk space. Indeed, this demonstrates the severe redundancies as another disadvantage of n-best lists, where many subtrees are repeated across different parses, while the packed forest reduces space dramatically by sharing common sub-derivations (see Fig. 4).\nTo put our results in perspective, we also compare them with other best-performing systems in Table 4. Our final result (91.7) is better than any previously reported system trained on the Treebank, although   2006) achieved an even higher accuarcy (92.1) by leveraging on much larger unlabelled data. Moreover, their technique is orthogonal to ours, and we suspect that replacing their n-best reranker by our forest reranker might get an even better performance. Plus, except for n-best reranking, most discriminative methods require repeated parsing of the training set, which is generally impratical (Petrov and Klein, 2008). Therefore, previous work often resorts to extremely short sentences (\u2264 15 words) or only looked at local features (Taskar et al., 2004;Henderson, 2004;Turian and Melamed, 2007). In comparison, thanks to the efficient decoding, our work not only scaled to the whole Treebank, but also successfully incorporated non-local features, which showed an absolute improvement of 0.44% over that of local features alone.", "publication_ref": ["b14", "b16", "b6", "b17"], "figure_ref": ["fig_2", "fig_2"], "table_ref": ["tab_6", "tab_6", "tab_8"]}, {"heading": "Conclusion", "text": "We have presented a framework for reranking on packed forests which compactly encodes many more candidates than n-best lists. With efficient approximate decoding, perceptron training on the whole Treebank becomes practical, which can be done in about a day even with a Python implementation. Our final result outperforms both 50-best and 100-best reranking baselines, and is better than any previously reported systems trained on the Treebank. We also devised a dynamic programming algorithm for forest oracles, an interesting problem by itself. We believe this general framework could also be applied to other problems involving forests or lattices, such as sequence labeling and machine translation.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "The structure of shared forests in ambiguous parsing", "journal": "", "year": "1989", "authors": "Sylvie Billot; Bernard Lang"}, {"ref_id": "b1", "title": "An efficient implementation of a new DOP model", "journal": "", "year": "2003", "authors": "Rens Bod"}, {"ref_id": "b2", "title": "Coarseto-fine-grained n-best parsing and discriminative reranking", "journal": "", "year": "2005", "authors": "Eugene Charniak; Mark Johnson"}, {"ref_id": "b3", "title": "Hierarchical phrasebased translation", "journal": "", "year": "2000", "authors": "Eugene Charniak"}, {"ref_id": "b4", "title": "Discriminative reranking for natural language parsing", "journal": "", "year": "2000", "authors": "Michael Collins"}, {"ref_id": "b5", "title": "Discriminative training methods for hidden markov models: Theory and experiments with perceptron algorithms", "journal": "", "year": "2002", "authors": "Michael Collins"}, {"ref_id": "b6", "title": "Discriminative training of a neural network statistical parser", "journal": "", "year": "2004", "authors": "James Henderson"}, {"ref_id": "b7", "title": "Better kbest Parsing", "journal": "", "year": "2005", "authors": "Liang Huang; David Chiang"}, {"ref_id": "b8", "title": "Forest rescoring: Fast decoding with integrated language models", "journal": "", "year": "2006", "authors": "Liang Huang; David Chiang"}, {"ref_id": "b9", "title": "Parsing and Hypergraphs", "journal": "", "year": "2001-10", "authors": "Dan Klein; Christopher D Manning"}, {"ref_id": "b10", "title": "Building a large annotated corpus of English: the Penn Treebank", "journal": "Computational Linguistics", "year": "1993", "authors": "Mitchell P Marcus; Beatrice Santorini; Mary Ann Marcinkiewicz"}, {"ref_id": "b11", "title": "Effective self-training for parsing", "journal": "", "year": "2006-06", "authors": "David Mcclosky; Eugene Charniak; Mark Johnson"}, {"ref_id": "b12", "title": "Online large-margin training of dependency parsers", "journal": "", "year": "2005", "authors": "Ryan Mcdonald; Koby Crammer; Fernando Pereira"}, {"ref_id": "b13", "title": "Improved inference for unlexicalized parsing", "journal": "", "year": "2007", "authors": "Slav Petrov; Dan Klein"}, {"ref_id": "b14", "title": "Discriminative log-linear grammars with latent variables", "journal": "", "year": "2008", "authors": "Slav Petrov; Dan Klein"}, {"ref_id": "b15", "title": "Discriminative reranking for machine translation", "journal": "", "year": "2005", "authors": "Libin Shen; Anoop Sarkar; Franz Josef Och"}, {"ref_id": "b16", "title": "Max-margin parsing", "journal": "", "year": "2004", "authors": "Ben Taskar; Dan Klein; Michael Collins; Daphne Koller; Chris Manning"}, {"ref_id": "b17", "title": "Scalable discriminative learning for natural language parsing and translation", "journal": "", "year": "2007", "authors": "Joseph Turian; I Dan Melamed"}], "figures": [{"figure_label": "2", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 2 :2Figure 2: Illustration of some example features. Shaded nodes denote information included in the feature.", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 3 :3Figure 3: Example of the unit NGramTree feature at node A i,k : A (B . . . w j\u22121 ) (C . . . w j ) .", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Figure 4 :4Figure 4: Forests (shown with various pruning thresholds) enjoy higher oracle scores and more compact sizes than n-best lists (on sec 23).", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "Comparison of various approaches for incorporating local and non-local features.", "figure_data": ""}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_4", "figure_caption": "Features used in this work. Those with a \u22c4 are from", "figure_data": ""}, {"figure_label": "3", "figure_type": "table", "figure_id": "tab_6", "figure_caption": "Forest reranking compared to n-best reranking on sec. 23. The pre-comp. column is for feature extraction, and training column shows the number of perceptron iterations that achieved best results on the dev set, and average time per iteration.", "figure_data": "local features, the accuracy rises to 91.69 (with beamsize k = 15), which is a 0.26% absolute improve-ment over 50-best reranking. 7"}, {"figure_label": "4", "figure_type": "table", "figure_id": "tab_8", "figure_caption": "Comparison of our final results with other best-performing systems on the whole Section 23. Types D, G, and S denote discriminative, generative, and semi-supervised approaches, respectively.", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "VP 1,6 VBD 1,2 blah NP 2,6 NP 2,3 blah PP 3,6 b e 2 e 1", "formula_coordinates": [2.0, 110.47, 62.7, 149.36, 96.99]}, {"formula_id": "formula_1", "formula_text": "VBD 1,2 NP 2,3 PP 3,6 VP 1,6 ,(*)", "formula_coordinates": [2.0, 128.95, 474.32, 169.85, 25.94]}, {"formula_id": "formula_2", "formula_text": "e 1 = (VBD 1,2 , NP 2,3 , PP 3,6 ), VP 1,6", "formula_coordinates": [2.0, 338.45, 128.44, 171.56, 11.32]}, {"formula_id": "formula_3", "formula_text": "y = argmax y\u2208cand(s) score(y)(1)", "formula_coordinates": [2.0, 377.02, 549.76, 162.99, 19.24]}, {"formula_id": "formula_4", "formula_text": "score(y) = w \u2022 f (y)(2)", "formula_coordinates": [2.0, 381.84, 700.21, 158.16, 11.18]}, {"formula_id": "formula_5", "formula_text": "y * i : 1 y + i argmax y\u2208cand(s i ) F (y, y * i )(3)", "formula_coordinates": [3.0, 113.2, 559.5, 185.6, 42.07]}, {"formula_id": "formula_6", "formula_text": "1: Input: Training examples {cand (si), y + i } N i=1 \u22b2 y + i is the oracle tree for si among cand (si) 2: w \u2190 0 \u22b2 initial weights 3: for t \u2190 1 . . . T do \u22b2 T iterations 4: for i \u2190 1 . . . N do 5:\u0177 = argmax y\u2208cand(s i ) w \u2022 f (y) 6: if\u0177 = y + i then 7: w \u2190 w + f (y + i ) \u2212 f (\u0177) 8: return w", "formula_coordinates": [3.0, 316.98, 77.2, 223.02, 96.1]}, {"formula_id": "formula_7", "formula_text": "f = (f 1 , . . . , f d ) into f = (f L ; f N )", "formula_coordinates": [4.0, 72.0, 250.56, 226.8, 24.67]}, {"formula_id": "formula_8", "formula_text": "f L (y) = e\u2208y f L (e)(4)", "formula_coordinates": [4.0, 145.35, 358.3, 153.46, 21.66]}, {"formula_id": "formula_9", "formula_text": "f N (y) = y \u2032 \u2208yf N (y \u2032 ) (5)", "formula_coordinates": [4.0, 141.06, 634.74, 157.75, 25.89]}, {"formula_id": "formula_10", "formula_text": "A i,k B i,j w i . . . w j\u22121 C j,k w j . . . w k\u22121", "formula_coordinates": [4.0, 363.75, 236.64, 125.2, 67.96]}, {"formula_id": "formula_11", "formula_text": "j \u2032 \u2190 j + b i \u22b2 b i is 1", "formula_coordinates": [5.0, 114.84, 387.5, 110.57, 10.53]}, {"formula_id": "formula_12", "formula_text": "F (y, y * ) 2P R P + R = 2|y \u2229 y * | |y| + |y * | (6)", "formula_coordinates": [5.0, 351.65, 421.59, 188.36, 27.53]}, {"formula_id": "formula_13", "formula_text": "1: function ORACLE( V, E , y * ) 2: for v \u2208 V in topological order do 3: for e \u2208 BS(v) do 4: e is v \u2192 u1u2 . . . u |e| 5: ora[v] \u2190 ora[v] \u2295 (\u2297iora[ui]) 6: ora[v] \u2190 ora[v] \u21d1 (1, 1v\u2208y * ) 7: return F (y + , y * ) = maxt 2\u2022ora[TOP](t) t+|y * | \u22b2 oracle F1", "formula_coordinates": [6.0, 75.78, 76.15, 220.28, 80.69]}, {"formula_id": "formula_14", "formula_text": "ora[v](t) max yv:|yv|=t |y v \u2229 y * | (7)", "formula_coordinates": [6.0, 117.65, 203.02, 181.16, 19.91]}, {"formula_id": "formula_15", "formula_text": "(f \u2297 g)(t) max t 1 +t 2 =t f (t 1 ) + g(t 2 )(8)", "formula_coordinates": [6.0, 105.81, 337.64, 192.99, 17.78]}, {"formula_id": "formula_16", "formula_text": "t f (t) 2 1 3 2 \u2297 t g(t) 4 4 5 4 = t (f \u2297 g)(t) 6 5 7 6 8 6", "formula_coordinates": [6.0, 95.43, 383.06, 179.94, 39.45]}, {"formula_id": "formula_17", "formula_text": "ora[w](t) = (ora[v] \u2297 ora[u])(t \u2212 1) + 1 w\u2208y * (9)", "formula_coordinates": [6.0, 77.45, 455.22, 221.35, 11.72]}, {"formula_id": "formula_18", "formula_text": "ora[w] = (ora[v] \u2297 ora[u]) \u21d1 (1, 1 w\u2208y * ) (10)", "formula_coordinates": [6.0, 85.47, 541.4, 213.33, 11.72]}, {"formula_id": "formula_19", "formula_text": "(f \u21d1 (a, b))(t) f (t \u2212 a) + b (11)", "formula_coordinates": [6.0, 115.1, 600.48, 183.71, 11.18]}, {"formula_id": "formula_20", "formula_text": "(f \u2295 g)(t) max{f (t), g(t)}(12)", "formula_coordinates": [6.0, 115.41, 700.21, 183.4, 11.18]}, {"formula_id": "formula_21", "formula_text": "\u03b1\u03b2(e) = \u03b1(head (e)) + u i \u2208tails(e) \u03b2(u i )(13)", "formula_coordinates": [6.0, 330.69, 436.16, 209.32, 23.92]}], "doi": ""}