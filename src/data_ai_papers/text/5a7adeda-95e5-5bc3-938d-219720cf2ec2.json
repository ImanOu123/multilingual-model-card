{"title": "SemTag and Seeker: Bootstrapping the semantic web via automated semantic annotation", "authors": "Stephen Dill; Nadav Eiron; David Gibson; Daniel Gruhl; R Guha; Anant Jhingran; Tapas Kanungo; Sridhar Rajagopalan; Andrew Tomkins; John A Tomlin; Jason Y Zien", "pub_date": "", "abstract": "This paper describes Seeker, a platform for large-scale text analytics, and SemTag, an application written on the platform to perform automated semantic tagging of large corpora. We apply SemTag to a collection of approximately 264 million web pages, and generate approximately 434 million automatically disambiguated semantic tags, published to the web as a label bureau providing metadata regarding the 434 million annotations. To our knowledge, this is the largest scale semantic tagging effort to date. We describe the Seeker platform, discuss the architecture of the SemTag application, describe a new disambiguation algorithm specialized to support ontological disambiguation of large-scale data, evaluate the algorithm, and present our final results with information about acquiring and making use of the semantic tags. We argue that automated large scale semantic tagging of ambiguous content can bootstrap and accelerate the creation of the semantic web.", "sections": [{"heading": "INTRODUCTION", "text": "The WWW has had a tremendous impact on society and business in just a few years by making information instantly and ubiquitously available. During this transition from physical to electronic means for information transport, the content and encoding of information has remained natural language. Today, this is perhaps the most significant obstacle to streamlining business processes via the web. In order that processes may execute without human intervention, documents must become more machine understandable.\nThe Semantic Web [5] is a vision of a future web of machineunderstandable documents and data. 1 On a machine understandable web, it will be possible for programs to easily determine what documents are about. For instance, the people, places, events, and other entities that a document mentions will be canonically annotated within it. As a consequence, it is hoped that a new breed of smarter applications will become available. Where will the data come from? For the semantic web vision to come to fruition, two classes of meta-data must become extensive and pervasive. The first is ontological support in the form of webavailable services which will maintain metadata about entities and provide them when needed. The second is large-scale availability of annotations within documents encoding canonical references to mentioned entities.\nCopyright is held by the author/owner(s).\nWWW2003, May 20-24, 2003, Budapest, Hungary.", "publication_ref": ["b4", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "ACM xxx.", "text": "Ontological support for the semantic web is an active area of both research and business development, but not the focus of this paper. Instead, we use the TAP ontology [30] in our experiments.\nIn partial support of the second class of data, document annotations, it is expected that enterprises will make business data available in Semantic Web formats (RDF, XML, or OWL). It is also expected that productivity tools will make it possible for individuals to author semantically annotated documents.\nNonetheless, for all this to happen, we need applications that can effectively leverage semantically tagged data. In turn, these applications cannot be useful unless there is enough semantically tagged data on the web in the first place. Unfortunately, today's reality is that few documents contain such annotations a priori, and we are in a state of circular dependency. Organizations that might create powerful tools based on semantic annotations are leery of sinking significant developmental effort while the number of available tags remains small; and content creators are similarly unwilling to create annotations while no tools exist to make use of them. The size of the web makes this bootstrapping problem is both formidable and acute.", "publication_ref": ["b29"], "figure_ref": [], "table_ref": []}, {"heading": "Our contributions", "text": "SemTag is an application that performs automated semantic tagging of large corpora. We apply SemTag to a collection of approximately 264 million web pages, and generate approximately 434 million automatically disambiguated semantic tags, published to the web as a label bureau [37] providing metadata regarding the 434 million annotations. To our knowledge, this is the largest scale semantic tagging effort to date, and demonstrates the viability of bootstrapping a web scale semantic network. The key challenge is resolving ambiguities in a natural language corpus. To this end, we introduce a new disambiguation algorithm called TBD, for Taxonomy-Based Disambiguation.\nMaintaining and updating a corpus the size of the Web requires infrastructure of a scale which most tagging applications cannot be expected to support. We also need a platform which different tagging applications can share. Seeker is a platform designed for this purpose. It provides highly scalable core functionality to support the needs of SemTag and other automated semantic annotation algorithms.", "publication_ref": ["b36"], "figure_ref": [], "table_ref": []}, {"heading": "Paper structure", "text": "The remainder of the paper will consist of a review of the current state of the art (Section 2), an outline of the SemTag application approach (Section 3), the results of running the SemTag application on the web corpus (Section 4), an outline of what the underlying Seeker system requires (Section 5), a brief discussion of the design and implementation of that system (Section 6) followed by general conclusions (Section 7).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "RELATED LITERATURE", "text": "In the last couple of years, as part of the Semantic Web activity, a number of different systems have been built. These systems help perform one of two tasks: (1) create ontologies, and (2) annotate web pages with ontology derived semantic tags. By and large, both classes of systems have been focused on manual and semiautomatic tooling to improve the productivity of a human ontologist or annotator rather than on fully automated methods. Such systems have the advantage that humans can provide extremely fine-grained semantic tags. However, as reported in [11], even with the machine assistance, this is an arduous, time consuming and error-prone task.\nA number of annotation tools for producing semantic markups exist. Protege-2000 [28] is a tool which supports the creation of ontologies for the semantic web. OntoAnnotate [34], a framework for the semantic web, includes tools for both manual and semi-automatic annotation of pages. Annotea [17] provides RDFbased markup but it does not support information extraction nor is it linked to an ontology server. SHOE, [14] was one the earliest systems for adding semantic annotations to web pages. SHOE Knowledge Annotator allows users to mark up pages in SHOE guided by ontologies available locally or via a URL. These marked up pages can be reasoned about by SHOE-aware tools such as SHOE Search. Such tools are described in [36,19]. AeroDAML [23] is an interesting tools which takes an ontology and automatically produces a semantically marked up page which can then be checked by a human.\nMore recently, there have been efforts to automate some of these tasks using machine learning as a palliative measure. The principal tool is \"wrapping\" (see, for instance, [18,20,10]). These systems try and extract detailed structural data out of the pages and require significant training before they can be productive. Furthermore, such systems don't work against common shared ontologies, which is the focus of the semantic web.\nSemTag is different from both these classes of systems in that it tags very large numbers of pages, with terms from a standard ontology, in an automated fashion. Furthermore, since SemTag operates as a centralized application with access to the entire database and associated metadata, it has many advantages over a local, per-page tagger. For example, it can make use of corpus-wide statistics to increase the quality of semantic tags. It can easily be re-run as new annotation algorithms and new semantic repositories become available. And it can perform operations that are only possible in the presence of many tags, such as automated alias discovery. More recent work, e.g. [22], which combines natural language understanding with learning to automatically generate annotations for specific domains is similar in spirit to SemTag. The current focus of SemTag is detecting the occurrence of particular entities in web pages. One of the critical steps in this process is that of resolving ambiguities. This is an area with a rich body of work ([40, 32, 21, 26, 29]) from the language understanding community.\nIn this paper, we present results of SemTag using the TAP knowledge base [31]. TAP is a shallow knowledge base that contains a broad range of lexical and taxonomic information about popular objects like: Music, movies, authors, sports, autos, health, etc. We used the TAP knowedge base in its standard ontology. Building a web scale ontology will require much larger knowledge bases. Future work involves using techniques such as those described in [31] to bootstrap from TAP to build much larger and richer ontologies.\nWith SemTag's current shallow level of understanding, RDFS [7] provides an adequate language for representing the annotations it generates. We expect that in the future, as SemTag's level of understanding improves, we will have to use more advanced languages [24] and move towards OWL [38]. SemTag is built on the Seeker platform for large scale text analytics. The explosive growth of the web, and the difficulty of performing complex data analysis tasks on unstructured data, has led to several different lines of research and development. Of these, the most prominent are the web search engines, (see for instance [12,3]) which have been primarily designed to address the problem of \"information overload.\" A number of interesting techniques have been suggested in this area, however since this is not the direct focus of this paper, we omit these here. The interested reader is referred to the survey by Broder and Henzinger [8].\nSeveral authors [1,15,4,33,25] describe relational approaches to web analysis. In this model, data on the web is seen as a collection of relations (for instance, the \"points to\" relation) each of which are realized by a function and accessed through a relational engine. This allows a user to describe his or her query in declarative form (SQL, typically) and leverages the machinery of SQL to execute the query. In all of these approaches, the data is fetched dynamically from the network on a lazy basis, and therefore, runtime performance is heavily penalized.\nThe Stanford WebBase project [16], while targeting a system that allows easy sequential and random access to a copy of the web, does not provide the same prototyping and development environment Seeker does. Specifically, it lacks the functionality that allows developers to annotate web pages, and easily reuse the results of other analysis components.\nCompaq SRC web-in-a-box (WIB) project [39] is another system designed to allow researchers to develop text analysis tools that have access to a copy of the web. While WIB allows analysis components to annotate web pages, it does not provide storage for any derived data (such as people or organizations) other than web pages. Furthermore, its architecture does not allow users to compose complex data mining modules from simpler data mining modules, or re-use data.\nThe Internet Archive [35], has a different objective. The data is crawled and hosted, as is the case in web search engines. In addition, a streaming data interface is provided which allows applications to access the data for analysis. However, a sophisticated querying system is not provided, nor is a method to perform large scale data analysis.", "publication_ref": ["b10", "b27", "b33", "b16", "b13", "b35", "b18", "b22", "b17", "b19", "b9", "b21", "b30", "b30", "b6", "b23", "b37", "b11", "b2", "b7", "b0", "b14", "b3", "b32", "b24", "b15", "b34"], "figure_ref": [], "table_ref": []}, {"heading": "SEMTAG: A SEMANTIC TAGGER", "text": "Consider a world in which all documents on the web contained semantic annotations based on TAP. So the sentence: \"The Chicago Bulls announced yesterday that Michael Jordan will. . . \" would appear as:\nThe <resource ref=\"http://tap.stanford.edu/ BasketballTeam_Bulls\">Chicago Bulls</resource> announced yesterday that <resource ref= \"http://tap.stanford.edu/AthleteJordan,_Michael\"> Michael Jordan</resource> will...'' Thus, the annotation: <resource ref=\"http://tap.stanford.edu/ AthleteJordan,_Michael\">Michael Jordan</resource> says that the string \"Michael Jordan\" refers to the resource whose URI is \"http://tap.stanford.edu/AthleteJordan, Michael.\" It is expected that querying this URI will result in encoded information which provides greater detail about this resource.\nThe bulk of documents on the web today do not contain annotations of this form. Consequently, application developers cannot rely on such annotations. On the other side, website creators are unlikely to add annotations in the absence of applications that use these annotations. A natural approach to break this cycle and provide an early set of widespread semantic tags is automated generation. This is the goal of SemTag. SemTag seeks to provide an automated processes for adding these to the existing HTML corpus on the Web. In this paper, we look at what needs to be done to address this problem at the scale of the web.\nWe adapt the concept of a label bureau from PICS so that an application of the Semantic Web can obtain semantic annotations for a page from a third party even when the author of the page has annotated the page. Semantic annotations can be retrieved separately from the documents to which they refer. To request annotations in this way, an application contacts a Semantic Label Bureau. A semantic label bureau is an HTTP server that understands a particular query syntax. It can provide annotations for documents that reside on other servers.\nBecause SemTag does not have write access to the original document, the resulting annotations are written into a web-available database. The contents of this data base are made available via a semantic label bureau from which it is possible to extract semantic tags using a variety of mechanisms. For instance, one application may request the semantic tags for a given document, while another may request all semantic tags regarding a particular object (say, the basketball player Michael Jordan).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "SemTag flow", "text": "The overall SemTag architecture is shown in Figure 1 Spotting pass Documents are retrieved from the Seeker store, tokenized, and then processed to find all instances of the approximately 72K labels that appear in the TAP taxonomy. Each resulting label is saved with ten words to either side as a \"window\" of context around the particular candidate object. This first stage takes place at approximately 10,000 documents per second on the Seeker infrastructure, naively distributed over 64 machines.\nLearning pass A representative sample of the data is then scanned to determine the corpus-wide distribution of terms at each internal node of the taxonomy, as described in Section 3.3. This processing takes place at approximately 8,000 windows/second on a single machine.\nTagging pass Finally, the windows must be scanned once more to disambiguate each reference. When a string is finally determined to refer to an actual TAP object, a record is entered into a database of final results containing the URL, the reference, and any other associated metadata. This pass can be performed sequentially at approximately 1,200-3,000 windows/second on a single machine. For details on the algorithm used in doing this see section 3.3.", "publication_ref": [], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "SemTag Ambiguity resolution", "text": "In this section, we describe the Taxonomy Based Disambiguation (TBD) algorithm. TBD performs disambiguation of references to entities within a large-scale ontology. Ambiguity within SemTag: Automated tagging algorithms, unlike human tagged data, can have significant levels of mis-classification. Thus, sources of ambiguity within the ontology is a significant concern. There are two fundamental categories of ambiguities:\n1. Some labels appear at multiple locations in the TAP ontology. For instance, the string \"Michael Jordan\" may refer to a statistician, a basketball player, or many others. This occurs infrequently in the current taxonomy, but we expect it to occur with increasing frequency as the taxonomy grows.\n2. Some entities have labels that occur in contexts that have no representative in the taxonomy. For instance, the term Natalia sometimes refers to the musician, but ordinarily denotes simply a person's first name, which has no entry in the taxonomy. This occurs frequently in our current data set, and will probably continue to occur frequently even as the taxonomy grows.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Evolution of ontologies :", "text": "Ontologies such as TAP will continue to evolve. Our expectation is that tailored algorithms with humantuned parameters will be applied to a small number of critical sections, with automated approaches still dealing with the bulk of the ontology. In keeping with this philosophy TBD makes use of two classes of training information:\nAutomatic metadata A large amount of automatically-generated metadata allows the algorithm to estimate whether windows around candidate references are likely to have been generated within a particular subtree of the taxonomy.\nManual metadata A small amount of manually-generated metadata (approximately 700 yes/no judgments regarding whether a label in a given context refers to some objects) gives the algorithm information regarding nodes of the taxonomy that contain highly ambiguous or unambiguous labels. These judgments are used to determine which portions of the taxonomy can most fruitfully benefit from particular disambiguation schemes.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Overview of TBD", "text": "We begin with a few formal definitions. Terms are italicized when first defined.\nAn ontology O is defined by four elements. A set of classes, C, a subClass relation S \u2286 C \u00d7 C, a set of instances I, and a type relation T \u2286 I \u00d7 C. We use the notation t(i, c) to denote the boolean function (i, c) \u2208 T and s(c1, c2) likewise. We assume that instances are closed over super-classing. Namely, for any i, c1, c2, t(i, c1)&s(c1, c2) \u21d2 t(i, c2).\nAn taxonomy T is defined by three elements: a set of nodes, V ; a root r \u2208 V ; and finally, a parent function, p : V \u2192 V . We require that (1) the root is its own parent, p(r) = r, (2) for all other nodes, this is not so, i.e. if v = r, p(v) = v, and (3) the root r is in the ancestry of every node, i.e. for every v \u2208 V , r \u2208 {v, p(v), p(p(v)), p(p(p(v))), . . .}. Henceforth, we will use \u03c0(v) to denote the ancestry chain of v. The internal nodes of the taxonomy are given by {u : u = p(v)for some v}. A taxonomy can be derived given an ontology, which is a more general concept.\nEach node v \u2208 V is associated with a set of labels, L(v). For instance, taxonomy nodes about cats, football, computers and cars all contain the label \"jaguar.\" A spot ( , c) is a label in a context c \u2208 C, where C is the space of all possible contexts. The context consists of 10 preceding and 10 succeeding words of text surrounding the label, culled from the document in which the label occurred. We use the spot to tag the label with its semantic tag, which is always an node of T .\nWith each internal node u \u2208 T we associate a similarity function fu : C \u2192 [0, 1] mapping from a context to a similarity. Good similarity functions have the property that the higher the similarity, the more likely that the spot contains a reference to an entity that belongs in the subtree rooted at u. The similarity functions encapsulate the automatically-generated metadata regarding nodes of the taxonomy.\nWe can use the similarity function to define an algorithm Sim to guess whether a particular context c is appropriate for a particular node, as follows. We will then use Sim to define TBD. The definition of Sim is given in Figure 2.\nSim(c, v) Let b = argmin u\u2208\u03c0(v) {fu(c)} if b = r return 0 else return 1", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Figure 2: Algorithm Sim", "text": "For our problem instance, we must focus on disambiguating references in the taxonomy versus references outside the taxonomy. If the focus is instead on disambiguating references that may belong to multiple nodes of the taxonomy, then the test b = r should be replaced with b = p(v).\nFinally, with a small number of popular internal nodes u \u2208 T we associate a measurement (m a u , m s u ) \u2208 [0, 1] 2 . m a u gives the probability as measured by human judgments that spots for the subtree rooted at u are on topic. m s u gives the probability that Sim correctly judges whether spots for the subtree rooted at u are on topic. Thus, the set of measurements encapsulates the manuallygenerated metadata in the system, and can be seen as a training set for the algorithm.\nAlgorithm TBD is defined in Figure 3. The algorithm returns 1 or 0 to indicate whether a particular context c is on topic for a node v \u2208 T .\nThus, the small numbers of measurements allow TBD to determine whether it is operating in a region of the taxonomy that is TBD(c, u)\nLet u be the nearest ancestor of v with a measurement.\nif | 0.5 \u2212 m a u |>| 0.5 \u2212 m s u | if m a u > 0.5 return 1 else return 0 else if m s u > 0.5 return Sim(c, u) else return 1 -Sim(c, u)\nFigure 3: Algorithm TBD highly unambiguous, or a region that is highly ambiguous. If the former, it will choose to adopt references with certainly; if the latter, it will apply a probabilistic algorithm.\nIn Section 4 we evaluate various different approaches to the similarity function fu.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "RESULTS", "text": "We implemented the SemTag algorithm described above, and applied it to a set of 264 million pages producing 270G of dump data corresponding to 550 million labels in context. Of these labels, approximately 79% are judged to be on-topic, resulting in a final set of about 434 million spots, with accuracy around 82%. Details are given below.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Methodology", "text": "As described above, we first dumped context surrounding each spot. We then processed those contexts as follows:\nLexicon generation: We built a collection of 1.4 million unique words occurring in a random subset of windows containing approximately 90 million total words. Following standard practice, we created a final lexicon of 200,000 words from the 1.4 million unique words by taking the most frequent 200,100, and removed the most frequent 100. All further computations were performed in the 200,000-dimensional vector space defined by this set of terms.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Similarity functions:", "text": "We estimated the distribution of terms corresponding to each of the 192 most common internal nodes of the taxonomy in order to derive the similarity function fu described in Section 3.3. We experimented with several standard similarity measures; the results are given in Section 4.2.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Measurement values:", "text": "Based on 750 relevance judgments from human judges, we determined the measurement values associated with the 24 largest taxonomy nodes, as described in Section 3.3.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Full TBD processing:", "text": "We applied the TBD algorithm to the entire dataset of 550 million spots using the family of similarity functions deemed to be most effective in Section 4.2, and using the humanand machine-generated metadata described above.\nEvaluation: Finally, we collected an additional 378 human judgments against a previously unevaluated set of contexts in order to evaluate the effectiveness of TBD.\nWe now describe briefly our process for collecting human judgments, our measure of accuracy, and some baseline experiments regarding the difficulty that human judges have in coming to a single unambiguous conclusion about a particular spot.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Evaluation and human judgments", "text": "As is well known from research in Knowledge Acquisition [13] and more recently from studies of manual semantic tagging of documents, there are many cases where different people choose different terms from an ontology with which to tag a phrase or a document. Therefore, we need to be careful when evaluating the results of SemTag.\nWe created a web-based tool that displays to an evaluator a spot consisting of a label in a context. The tool asks the evaluator to determine whether the spot is on topic for a particular node of TAP. This information is used to generate the measurements of Section 3.3.\nBecause there are several locations in TAP that may be appropriate for a particular entry (we evaluate this phenomenon below), the tool also checks to see if TBD suggested that the spot belongs elsewhere-if so, the tool also asks whether the algorithm's output is a valid answer.\nWe gathered two sets of evaluations. For the first set of evaluations, a set of 11 volunteers were asked to examine 1100 selections made by SemTag. The first 2/3 of these evaluations were used as human-generated metadata for TBD. The remaining 1/3 of the evaluations were used to score the performance of the algorithm.\nFinally, a set of three volunteers were each asked to evaluate the same set of 200 labels in context, using the same tool described above. Of these 200, all three evaluators agreed on 137; i.e., only 68.5% were unambiguous to the humans. Furthermore, the tool was modified in this experiment to allow the users to indicate that a particular piece of context (typically ten words to either side of the label) was insufficient to understand the denotation of the label. The evaluators each selected this option in only 2.5% of the instances. Therefore, we conclude that while a 10-word window to either side of a label is typically sufficient to understand the sense of the label, human judgment is highly ambiguous regarding the placement of the label into the taxonomy.\nThe remainder of this section proceeds as follows. Section 4.2 describes our evaluation of different similarity functions. Sections 4.3 and 4.4 then give results of a sensitivity analysis to the availability of machine-and human-generated metadata to develop the similarity functions and measurement values respectively of Section 3.3.", "publication_ref": ["b12"], "figure_ref": [], "table_ref": []}, {"heading": "Similarity between a Spot and a Collection", "text": "Consider some fixed node of the taxonomy, and a new spot ( , c) that may belong in the subtree rooted at that node. As presented in Section 3.3, TBD must determine whether the context c corresponding to the new spot looks similar to the contexts that typically occur around spots from that node. We evaluate four standard candidates for similarity functions.\nFirst, we must cover the preliminaries. We generate a 200Kdimensional vector (over the terms of the lexicon) corresponding to each internal node u \u2208 T , or more precisely, to the contexts that occur around spots for the u. In scheme \"Prob\", each entry of the vector is simply the probability of the term occurring in the window. In scheme \"TF-IDF\", each entry of the vector is the frequency of the term occurring at that node, divided by the corpus frequency of the term. In all cases, the vectors are normalized to length 1.\nNext, we consider two variants of algorithms to compute the similarity of a spot given a vector. Algorithm \"IR\" computes the standard \"cosine measure\" vector product of the sparse vector corresponding to the current spot and the (probably dense) vector corresponding to the node. Algorithm \"Bayes\"computes the probability that the terms in the context would have been generated by a source generating terms independently according to the distribution given by the vector corresponding to u.  The results are show in Table 1. As the table shows, the most effective scheme is the cosine measure with tf-idf weightings. Furthermore, the tf-idf weighting scheme dominates the unweighted scheme, and so we adopt it henceforth for our other comparisons, and simply compare the IR and Bayes algorithms.", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_1"]}, {"heading": "Algorithm", "text": "Overall, the accuracy of classification under the favored scheme is roughly 82%. As we show later, even comparing human judgements to other human judgments shows a systematic error rate of  roughly this amount, leading us to believe that significant improvements will be quite difficult to achieve.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Sensitivity to availability of human-derived metadata", "text": "Next, we consider the sensitivity of TBD to the amount of humanderived metadata present in the system. When TBD makes use of all human-derived metadata, there are 24 internal nodes of T with measurements. Figure 4 shows for each such node what fraction of the total labels are covered by that node. The first node with measurement data is the root r, whose subtree covers all measurements; thus, the leftmost point of the graph has y-value 100. The next node with measurement data corresponds to cities in the United States, and covers around 13% of the total spots. The actual values, and node labels, are given in Table 2.\nFigure 5 shows the performance of TBD when only i of the 24 total measurements are available to the system. As the figure shows, TBD is effective even with extremely minimal metadata.", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_3"]}, {"heading": "Sensitivity to availability of machine-generated metadata", "text": "Finally, we consider the sensitivity of the algorithm to the amount of automatically-generated metadata maintained at internal nodes of the taxonomy. As described above, the representation of the similarity function is a vector of 200K dimensions. We now consider keeping only the largest few dimensions of that vector for each of the internal nodes of the taxonomy. We proceed as follows. We fix some fraction f , and for each internal node u \u2208 T with vector u, we keep only the largest max (100, f \u2022 | {i| ui = 0} |) entries of u. Table 3 shows, for various different values of the fraction f , the total number of non-zero entries over all internal nodes (i.e., the total number of values that must be maintained in order to execute   TBD), and the performance of the IR and Bayes algorithms using this smaller set of machine-generated metadata. The performance of the IR algorithm is extremely stable down to 100 non-zero entries per node, and the performance of the Bayes algorithm begins to degrade slightly sooner.", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_5"]}, {"heading": "SYSTEM REQUIREMENTS", "text": "The purpose of this paper is to describe an approach to largescale automated centralized semantic tagging delivered to consumers through a label bureau. SemTag is an application that demonstrates the feasibility of this approach. However, SemTag relies upon Seeker, which we have developed as an ongoing platform to support increasingly sophisticated text analytics applications, particularly including future generations of semantic taggers.\nThe goal of Seeker is to provide Scalable, Extensible Extraction of Knowledge from Erratic Resources. An erratic resource is one that may have limited availability, a rapid rate of change, contain conflicting or questionable content, or may be impossible to ingest in totality (e.g., the World Wide Web). We have identified the following design goals: Composibility There are multiple ways a page might be annotated. These annotations should be available to other annotators, to allow for more complex observations to be created incrementally. This requirement of shared annotation is not unlike the blackboard system approach [27].\nModularity Various types of annotations require differing methodologies. The architecture needs to support the \"plugging in\" different approaches, as well as the switching to newer, better implementations of existing approaches as they evolve.\nExtensibility As we have found with SemTag, approaches to annotation evolve rapidly when confronted with real data. It is thus important that the Seeker architecture allow essentially arbitrary new approaches to annotation to be constructed and deployed.\nScalability Scalability is important in two respects; first, the ability to develop a particular annotation approach on a representative subset of the corpora is an important design tool. Once an approach has been proved out on a test sub-corpora, it is desirable that the code scaled up to a multi-billion document corpora with minimal changes (e.g., none).\nRobustness On very large, distributed systems, failure of individual components is not a possibility, it is a certainty. The system needs to deal intelligently with failure of portions of the system, so that the faults in one component do not bring the whole system down.", "publication_ref": ["b26"], "figure_ref": [], "table_ref": []}, {"heading": "THE SEEKER DESIGN", "text": "To meet the design requirements expressed in Section 5, we adopt the architecture shown in Figure 6. Because the system must be modular and extensible, we adopt a web services style architecture in which all agents communicate with each other through a set of language-independent networklevel APIs defined on an XML substrate. To support scalability and robustness, we classify a small set of critical services within this web services framework as infrastructure components. These are large, scalable, well-tested, distributed, high-performance components that provide baseline functionality such as crawling, indexing, storage of data and annotations, and query processing. A larger set of loosely coupled analysis agents communicate through a centralized data store (itself an infrastructure service). Such an agent may execute at a different time and place, and in a different language, than another agent it depends on. The runtime environment performs monitoring and control of all services in the system. For analysis agents, the runtime monitors them, manages their work flow, scheduling, and (where possible) parallelism, and causes them to see the set of data and annotations necessary for their success.\nThe current Seeker environment consists of 128 dual processor 1GHz machines, each attached via switched gigabit network to 1/2 terabyte of network attached storage. Half of this cluster was used for the SemTag tests. Since each of these nodes runs at approximately 200 documents per second, the total time taken to reprocess the web is 32 hours.\nIO for this speed completely occupies one of the two 1GHz processors, requiring that the spotter/classifier run at around 200 docs per second (3MB/sec) on a single 1GHz processor. This limits the complexity of the spotter/classifier that can run.\nIn Section 6.1 we describe the XML substrate of Figure 6. Section 6.2 then describes the current set of infrastructure components within Seeker. Finally, Section 6.3 describes the analysis agents, which include the various components of SemTag.", "publication_ref": [], "figure_ref": ["fig_2", "fig_2"], "table_ref": []}, {"heading": "The XML substrate", "text": "Functionality in Seeker is delivered through a network services model, in which components publish their availability through a centralized registry, and export a network-level API. Thus, Seeker is a service oriented architecture (SOA): a local-area, loosely-coupled, pull-based, distributed computation system. We require high speed (\u2248 10, 000 RPCs per second), high availability (automatic fail-over to backup services), and efficient multiple programming language support (due to integration and performance issues). As a result we choose to base our network services on Vinci [2] a SOAP [6]-derived package designed for higher performance intra-net applications.\nVinci uses a lightly encoded XML (employing the xtalk protocol) over raw TCP sockets to provide the required RPC rate. It includes translation gateways allowing SOAP components to be integrated with minimal difficulty.", "publication_ref": ["b1", "b5"], "figure_ref": [], "table_ref": []}, {"heading": "Infrastructure components", "text": "Infrastructure services must address issues of reliability and scalability; therefore, the implementation of these core services includes a systems engineering problem. The main infrastructure components of Seeker include a centralized store, an extensible full-text indexer, a scalable web crawler, and a query processing component called the joiner. We will cover here only the components that are relevant to semantic tagging applications.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "The Data Store", "text": "The data store is the central repository for all long-term shared data storage within Seeker. The store not only serves as a storage service for the rest of Seeker, but it also serves as the main communication medium between miners. Annotators store their output in the data store, and other miners depending on them retrieve that information from the store, possibly much later and in a very different environment, enabling loose coupling of miners.\nA Seeker store contains entities, each of which is identified by a globally unique 128 bit Universal Entity Identifier (or UEID). The store provides both fast batched and random access to entities. Entities are of a particular entity type. A web page would be stored as an entity of type \"Page,\" for instance, while the information about a particular person would be stored as an entity of type \"Person\".\nThe key/value pairs associated with an entity describe all the information that has been extracted about that entity.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "The Indexer", "text": "The Seeker system contains a generic large-scale distributed indexer capable of indexing sequences of tokens. The index built contains not only a positional text index of the web, but also additional document annotations generated by miners. The indexer is fed documents as a stream of tokens, similar to the MultiText model [9], which allows us to achieve high performance during indexing due to the simple data model. For flexibility, each token that is indexed can have arbitrary attribute data associated with it. Analysis agents can generate additional tokens that overlay text tokens to indicate higher-level semantic information. These tokens are indexed along with the text, and may be used in queries to mix semantic information with full-text queries.", "publication_ref": ["b8"], "figure_ref": [], "table_ref": []}, {"heading": "The Joiner", "text": "Indexers within the system are generic components. The indexer described above builds and serves a positional index that allows proximity queries, phrase search, and so forth. However, for some applications, an index that supports range queries of numeric values might be more appropriate-consider for example queries for locations within a particular region. Other queries may desire in-formation about closure of spans of information, or be geospatial in nature or be part of a hand selected collection or any of a number of restrictions.\nThe joiner is a service that takes a request, for example SELECT url FROM web WHERE SemTag = 'Athlete,Jorden,_Michael' and PageLocation within 20 miles of SanJose and returns the set of URLs of pages that meet the restriction criteria.\nThe joiner allows more complicated annotators to only examine those documents which meet some basic criteria, allowing them to take more time on those pages of interest.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Analysis agents", "text": "An analysis agent is an encapsulated piece of functionality that executes in the Seeker environment, roughly equivalent to a \"module\" in a traditional programming language. As such, it is a completely generic object that could perform simple processing of individual pages, or could perform complex distributed operations with built-in fault tolerance and parallelism. Clearly, it is not possible to provide development tools that will make all annotators easy to write. Instead, we identified a limited but common class of analysis agents called annotators and we have worked to provide significant support for these agents, while allowing the more sophisticated user full generality to create more complex agents. All the initial Sem-Tag components are annotators. We then define miners to be agents that do not fall into this limited set.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Annotators", "text": "An annotator is defined as an analysis agent that can be written to process each entity of a certain type independently. We focus immediately on the most common category of annotators, in which the entity type is the page, and the annotator performs some local processing on each web page, and writes back results to the store in the form of an annotation. For example, analysis agents that scan each web page and recognize geographic locations, or proper names, or weights and measures, or indications that the page contains pornographic content, are all annotators. Similarly, analysis agents that perform complex tokenization, summarization, or language identification, or that automatically translate between languages, are also annotators.\nAnnotators manifest strong locality of reference in that they can be run independently on each individual web page without reference to other pages. Thus, they can be executed by the system on a machine with limited resources, and handed one page at a time.\nThe system provides special support for annotators, making them almost trivial to program. The programmer need write only a simple process one page() function, and the system will make sure the function is applied to all pages in the dataset, and the results are published in the store for all others annotators to use.\nIn SemTag, the operation of dumping all windows containing references to TAP objects is coded as an annotator. Due to the simplicity of creating and running annotators, it was possible to post-process the TAP RDF file in order to extract the labels for each node of the ontology, create an annotator to extract the windows around each label, and run the annotator on the full set of data, within a 24 hours period.\nA similar annotator can be used to write annotations back into the store once processing has completed on the large collections of windows. However the intermediate processing, generation of automatic metadata, and incorporation of manual metadata from human judgments, does not fit the limited definition of an annotator, and must therefore be coded a more general miner.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Miners", "text": "Miners are analysis agents that need to look at a number of entities (of one or more entity type) together in order to arrive at their conclusions. The overall SemTag application (using the TBD algorithm) is a good example of such a system, as it looks at the results of spots on many pages in order to disambiguate them.\nExamples of other cross-entity miners are those that generate cooccurrence information, aggregate site information, and hub and authority scores.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "CONCLUSIONS AND FUTURE DIREC-TIONS", "text": "We believe that automated tagging is essential to bootstrap the Semantic Web. As the results of the experiments with SemTag show, it is possible to achieve interestingly high levels of accuracy even with relatively simple approaches to disambiguation. In the future we expect that there will be many different approaches and algorithms to automated tagging. Unfortunately, storing a copy of the web and creating the infrastructure for running a tagger on billions of pages is beyond the scope of most researchers. It is our goal to provide a tagging of the web as a label bureau. Further, we would also like to provide Seeker as a public service for the research community to try various experimental approaches for automated tagging.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgments", "text": "We would like to thanks our colleagues in the Seeker development, business and management teams for their contributions: Rakesh Agrawal Finally, a special thanks to Bruce Baumgart for hardware wizardry that made the experiments described above possible.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "The lorel query language for semistructured data", "journal": "International Journal of Digital Libraries", "year": "1997", "authors": "S Abiteboul; D Quass; J Mchugh; J Widom; J Wiener"}, {"ref_id": "b1", "title": "Vinci: A service-oriented architecture for rapid development of web applications", "journal": "", "year": "2001", "authors": "R Agrawal; R Bayardo; D Gruhl; S Papadimitriou"}, {"ref_id": "b2", "title": "", "journal": "", "year": "", "authors": "Altavista "}, {"ref_id": "b3", "title": "Applications of a Web query language", "journal": "", "year": "1997", "authors": "G Arocena; A Mendelzon; G Mihaila"}, {"ref_id": "b4", "title": "Semantic web", "journal": "Scientific American", "year": "2000", "authors": "T Berners-Lee; J Hendler; O Lassila"}, {"ref_id": "b5", "title": "", "journal": "Simple Object Acceess Protocol", "year": "2000-05", "authors": "D Box; D Ehnebuske; G Kakivaya; A Layman; N Mendelsohn; H F Nielsen; S Thatte; D Winder"}, {"ref_id": "b6", "title": "Rdf schema", "journal": "", "year": "", "authors": "D Brickley; R V Guha"}, {"ref_id": "b7", "title": "Algorithmic aspects of information retrieval on the web", "journal": "Kluwer Academic Publishers", "year": "", "authors": "A Broder; M R Henzinger"}, {"ref_id": "b8", "title": "Shortest substring ranking", "journal": "", "year": "1995-11", "authors": "C Clarke; G Cormack; F Burkowski"}, {"ref_id": "b9", "title": "A structured wrapper induction system for extracting information from semi-structured documents", "journal": "", "year": "2001", "authors": "W Cohen; L Jensen"}, {"ref_id": "b10", "title": "From manual to semi-automatic semantic annotation: About ontology-based text annotation tools", "journal": "", "year": "2000-08", "authors": "M Erdmann; A Maedche; H Schnurr; S Staab"}, {"ref_id": "b11", "title": "Google", "journal": "", "year": "", "authors": ""}, {"ref_id": "b12", "title": "Towards Principles for the Design of Ontologies Used for Knowledge Sharing", "journal": "Kluwer Academic Publishers", "year": "1993", "authors": "T R Gruber"}, {"ref_id": "b13", "title": "Searching the web with shoe", "journal": "", "year": "2000", "authors": "J Heflin; J Hendler"}, {"ref_id": "b14", "title": "Adaptive query processing: Technology in evolution", "journal": "IEEE Data Engineering Bulletin", "year": "2000", "authors": "J M Hellerstein; M J Franklin; S Chandrasekaran; A Deshpande; K Hilldrum; D Maden; V Raman; M A Shah"}, {"ref_id": "b15", "title": "WebBase: A repository of Web pages", "journal": "", "year": "2000", "authors": "J Hirai; S Raghavan; A Paepcke; H Garcia-Molina"}, {"ref_id": "b16", "title": "Annotea: an open RDF infrastructure for shared web annotations", "journal": "", "year": "2001", "authors": "J Kahan; M.-R Koivunen"}, {"ref_id": "b17", "title": "Wrapper induction for information extraction", "journal": "", "year": "1997", "authors": "N Kushmerick; D S Weld; R B Doorenbos"}, {"ref_id": "b18", "title": "Large scale acquisition and maintenance from the web without source access", "journal": "", "year": "2001", "authors": "T Leonard; H Glaser"}, {"ref_id": "b19", "title": "Automatic data extraction from lists and tables in web sources", "journal": "", "year": "2001-08", "authors": "K Lerman; C Knoblock; S Minton"}, {"ref_id": "b20", "title": "Corpus-based techniques for word sense disambiguation", "journal": "", "year": "1997", "authors": "G.-A Levow"}, {"ref_id": "b21", "title": "Learning to generate semantic annotation for domain specific sentences", "journal": "", "year": "", "authors": "J Li; L Zhang; Y Yu"}, {"ref_id": "b22", "title": "AeroDAML: Applying information extraction to generate DAML annotations from web pages", "journal": "", "year": "", "authors": "P K Lockheed"}, {"ref_id": "b23", "title": "Description logics emerge from ivory towers", "journal": "", "year": "2001", "authors": "D L Mcguinness"}, {"ref_id": "b24", "title": "Efficient queries over web views", "journal": "Springer-Verlag", "year": "1998", "authors": "G Mecca; A Mendelzon; P Merialdo"}, {"ref_id": "b25", "title": "Word sense disambiguation and its application to the internet search", "journal": "", "year": "1999", "authors": "R Mihalcea"}, {"ref_id": "b26", "title": "Some problems of the basic organization in problem-solving programs", "journal": "", "year": "1962", "authors": "A Newell"}, {"ref_id": "b27", "title": "Creating semantic web contents with protege-2000", "journal": "IEEE Intelligent Systems", "year": "2001", "authors": "N F Noy; M Sintek; S Decker; M Crubezy; R W Fergerson; M A Musen"}, {"ref_id": "b28", "title": "Semantic indexing and typed hyperlinking", "journal": "", "year": "1997", "authors": "J Pustejovsky; B Boguraev; M Verhagen; P Buitelaar; M Johnston"}, {"ref_id": "b29", "title": "Tap: Towards a web of data", "journal": "", "year": "", "authors": "R Guha; R Mccool"}, {"ref_id": "b30", "title": "A corpus-based approach for building semantic lexicons", "journal": "", "year": "1997", "authors": "E Riloff; J Shepherd"}, {"ref_id": "b31", "title": "Automatic word sense discrimination", "journal": "Computational Linguistics", "year": "1998", "authors": "H Sch\u00fctze"}, {"ref_id": "b32", "title": "Squeal: A structured query language for the web", "journal": "", "year": "2000", "authors": "E Spertus; L A Stein"}, {"ref_id": "b33", "title": "An annotation framework for the semantic web", "journal": "", "year": "2001-01", "authors": "S Staab; A Maedche; S Handschuh"}, {"ref_id": "b34", "title": "The Internet Archive", "journal": "", "year": "", "authors": ""}, {"ref_id": "b35", "title": "MnM: Ontology driven semi-automatic and automatic support for semantic markup", "journal": "EKAW", "year": "2002", "authors": "M Vargas-Vera; E Motta; J Domingue; M Lanzoni; A Stutt; F Ciravegna"}, {"ref_id": "b36", "title": "Platform for internet content selection", "journal": "W3C", "year": "", "authors": ""}, {"ref_id": "b37", "title": "W3C. Web ontology language", "journal": "", "year": "", "authors": ""}, {"ref_id": "b38", "title": "Sense tagging: Semantic tagging with a lexicon", "journal": "", "year": "1997", "authors": "Y Wilks; M Stevenson"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 1 :1Figure 1: The SemTag architecture. works in three phases:", "figure_data": ""}, {"figure_label": "45", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 4 :Figure 5 :45Figure 4: Percentage of spots influenced by hand classified data", "figure_data": ""}, {"figure_label": "6", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Figure 6 :6Figure 6: Architecture of the Seeker system.", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "", "figure_data": ""}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_3", "figure_caption": "", "figure_data": ""}, {"figure_label": "3", "figure_type": "table", "figure_id": "tab_5", "figure_caption": "", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "Sim(c, v) Let b = argmin u\u2208\u03c0(v) {fu(c)} if b = r return 0 else return 1", "formula_coordinates": [4.0, 83.68, 264.5, 107.13, 46.62]}, {"formula_id": "formula_1", "formula_text": "if | 0.5 \u2212 m a u |>| 0.5 \u2212 m s u | if m a u > 0.5 return 1 else return 0 else if m s u > 0.5 return Sim(c, u) else return 1 -Sim(c, u)", "formula_coordinates": [4.0, 103.85, 579.42, 107.5, 103.98]}], "doi": ""}