{"title": "Bayesian Symbol-Refined Tree Substitution Grammars for Syntactic Parsing", "authors": "Hiroyuki Shindo; Yusuke Miyao; Akinori Fujino; Masaaki Nagata", "pub_date": "", "abstract": "We propose Symbol-Refined Tree Substitution Grammars (SR-TSGs) for syntactic parsing. An SR-TSG is an extension of the conventional TSG model where each nonterminal symbol can be refined (subcategorized) to fit the training data. We aim to provide a unified model where TSG rules and symbol refinement are learned from training data in a fully automatic and consistent fashion. We present a novel probabilistic SR-TSG model based on the hierarchical Pitman-Yor Process to encode backoff smoothing from a fine-grained SR-TSG to simpler CFG rules, and develop an efficient training method based on Markov Chain Monte Carlo (MCMC) sampling. Our SR-TSG parser achieves an F1 score of 92.4% in the Wall Street Journal (WSJ) English Penn Treebank parsing task, which is a 7.7 point improvement over a conventional Bayesian TSG parser, and better than state-of-the-art discriminative reranking parsers.", "sections": [{"heading": "Introduction", "text": "Syntactic parsing has played a central role in natural language processing. The resulting syntactic analysis can be used for various applications such as machine translation (Galley et al., 2004;DeNeefe and Knight, 2009), sentence compression (Cohn and Lapata, 2009;Yamangil and Shieber, 2010), and question answering (Wang et al., 2007). Probabilistic context-free grammar (PCFG) underlies many statistical parsers, however, it is well known that the PCFG rules extracted from treebank data via maximum likelihood estimation do not perform well due to unrealistic context freedom assumptions (Klein and Manning, 2003).\nIn recent years, there has been an increasing interest in tree substitution grammar (TSG) as an alternative to CFG for modeling syntax trees (Post and Gildea, 2009;Tenenbaum et al., 2009;. TSG is a natural extension of CFG in which nonterminal symbols can be rewritten (substituted) with arbitrarily large tree fragments. These tree fragments have great advantages over tiny CFG rules since they can capture non-local contexts explicitly such as predicate-argument structures, idioms and grammatical agreements . Previous work on TSG parsing Post and Gildea, 2009;Bansal and Klein, 2010) has consistently shown that a probabilistic TSG (PTSG) parser is significantly more accurate than a PCFG parser, but is still inferior to state-of-the-art parsers (e.g., the Berkeley parser (Petrov et al., 2006) and the Charniak parser (Charniak and Johnson, 2005)). One major drawback of TSG is that the context freedom assumptions still remain at substitution sites, that is, TSG tree fragments are generated that are conditionally independent of all others given root nonterminal symbols. Furthermore, when a sentence is unparsable with large tree fragments, the PTSG parser usually uses naive CFG rules derived from its backoff model, which diminishes the benefits obtained from large tree fragments.\nOn the other hand, current state-of-the-art parsers use symbol refinement techniques (Johnson, 1998;Collins, 2003;Matsuzaki et al., 2005). Symbol refinement is a successful approach for weakening context freedom assumptions by dividing coarse treebank symbols (e.g. NP and VP) into subcategories, rather than extracting large tree fragments. As shown in several studies on TSG parsing (Zuidema, 2007;Bansal and Klein, 2010), large tree fragments and symbol refinement work complementarily for syntactic parsing. For example, Bansal and Klein (2010) have reported that deterministic symbol refinement with heuristics helps improve the accuracy of a TSG parser.\nIn this paper, we propose Symbol-Refined Tree Substitution Grammars (SR-TSGs) for syntactic parsing. SR-TSG is an extension of the conventional TSG model where each nonterminal symbol can be refined (subcategorized) to fit the training data. Our work differs from previous studies in that we focus on a unified model where TSG rules and symbol refinement are learned from training data in a fully automatic and consistent fashion. We also propose a novel probabilistic SR-TSG model with the hierarchical Pitman-Yor Process (Pitman and Yor, 1997), namely a sort of nonparametric Bayesian model, to encode backoff smoothing from a fine-grained SR-TSG to simpler CFG rules, and develop an efficient training method based on blocked MCMC sampling.\nOur SR-TSG parser achieves an F1 score of 92.4% in the WSJ English Penn Treebank parsing task, which is a 7.7 point improvement over a conventional Bayesian TSG parser, and superior to state-of-the-art discriminative reranking parsers.", "publication_ref": ["b10", "b7", "b4", "b28", "b27", "b16", "b23", "b26", "b23", "b0", "b20", "b2", "b15", "b6", "b19", "b30", "b0", "b0", "b22"], "figure_ref": [], "table_ref": []}, {"heading": "Background and Related Work", "text": "Our SR-TSG work is built upon recent work on Bayesian TSG induction from parse trees (Post and Gildea, 2009;. We firstly review the Bayesian TSG model used in that work, and then present related work on TSGs and symbol refinement.\nA TSG consists of a 4-tuple, G = (T, N, S, R), where T is a set of terminal symbols, N is a set of nonterminal symbols, S \u2208 N is the distinguished start nonterminal symbol and R is a set of productions (a.k.a. rules). The productions take the form of elementary trees i.e., tree fragments of height \u2265 1. The root and internal nodes of the elementary trees are labeled with nonterminal symbols, and leaf nodes are labeled with either terminal or nonterminal symbols. Nonterminal leaves are referred to as frontier nonterminals, and form the substitution sites to be combined with other elementary trees.\nA derivation is a process of forming a parse tree. It starts with a root symbol and rewrites (substi-tutes) nonterminal symbols with elementary trees until there are no remaining frontier nonterminals. Figure 1a shows an example parse tree and Figure 1b shows its example TSG derivation. Since different derivations may produce the same parse tree, recent work on TSG induction (Post and Gildea, 2009;) employs a probabilistic model of a TSG and predicts derivations from observed parse trees in an unsupervised way.\nA Probabilistic Tree Substitution Grammar (PTSG) assigns a probability to each rule in the grammar. The probability of a derivation is defined as the product of the probabilities of its component elementary trees as follows.\np (e) = x\u2192e\u2208e p (e |x ) ,\nwhere e = (e 1 , e 2 , . . .) is a sequence of elementary trees used for the derivation, x = root (e) is the root symbol of e, and p (e |x ) is the probability of generating e given its root symbol x. As in a PCFG, e is generated conditionally independent of all others given x.\nThe posterior distribution over elementary trees given a parse tree t can be computed by using the Bayes' rule:\np (e |t ) \u221d p (t |e ) p (e) .\nwhere p (t |e ) is either equal to 1 (when t and e are consistent) or 0 (otherwise). Therefore, the task of TSG induction from parse trees turns out to consist of modeling the prior distribution p (e). Recent work on TSG induction defines p (e) as a nonparametric Bayesian model such as the Dirichlet Process (Ferguson, 1973) or the Pitman-Yor Process to encourage sparse and compact grammars.\nSeveral studies have combined TSG induction and symbol refinement. An adaptor grammar (Johnson et al., 2007a) is a sort of nonparametric Bayesian TSG model with symbol refinement, and is thus closely related to our SR-TSG model. However, an adaptor grammar differs from ours in that all its rules are complete: all leaf nodes must be terminal symbols, while our model permits nonterminal symbols as leaf nodes. Furthermore, adaptor grammars have largely been applied to the task of unsupervised structural induction from raw texts such as morphology analysis, word segmentation (Johnson and Goldwater, 2009), and dependency grammar induction (Cohen et al., 2010), rather than constituent syntax parsing. An all-fragments grammar (Bansal and Klein, 2010) is another variant of TSG that aims to utilize all possible subtrees as rules. It maps a TSG to an implicit representation to make the grammar tractable and practical for large-scale parsing. The manual symbol refinement described in (Klein and Manning, 2003) was applied to an all-fragments grammar and this improved accuracy in the English WSJ parsing task. As mentioned in the introduction, our model focuses on the automatic learning of a TSG and symbol refinement without heuristics.", "publication_ref": ["b23", "b23", "b8", "b13", "b12", "b3", "b0", "b16"], "figure_ref": ["fig_0", "fig_0"], "table_ref": []}, {"heading": "Symbol-Refined Tree Substitution Grammars", "text": "In this section, we propose Symbol-Refined Tree Substitution Grammars (SR-TSGs) for syntactic parsing. Our SR-TSG model is an extension of the conventional TSG model where every symbol of the elementary trees can be refined to fit the training data. Figure 1c shows an example of SR-TSG derivation. As with previous work on TSG induction, our task is the induction of SR-TSG derivations from a corpus of parse trees in an unsupervised fashion. That is, we wish to infer the symbol subcategories of every node and substitution site (i.e., nodes where substitution occurs) from parse trees. Extracted rules and their probabilities can be used to parse new raw sentences.", "publication_ref": [], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "Probabilistic Model", "text": "We define a probabilistic model of an SR-TSG based on the Pitman-Yor Process (PYP) (Pitman and Yor, 1997), namely a sort of nonparametric Bayesian model. The PYP produces power-law distributions, which have been shown to be well-suited for such uses as language modeling (Teh, 2006b), and TSG induction . One major issue as regards modeling an SR-TSG is that the space of the grammar rules will be very sparse since SR-TSG allows for arbitrarily large tree fragments and also an arbitrarily large set of symbol subcategories. To address the sparseness problem, we employ a hierarchical PYP to encode a backoff scheme from the SR-TSG rules to simpler CFG rules, inspired by recent work on dependency parsing .\nOur model consists of a three-level hierarchy. Table 1 shows an example of the SR-TSG rule and its backoff tree fragments as an illustration of this threelevel hierarchy. The topmost level of our model is a distribution over the SR-TSG rules as follows.\ne |x k \u223c G x k G x k \u223c PYP d x k , \u03b8 x k , P sr-tsg (\u2022 |x k ) ,\nwhere x k is a refined root symbol of an elementary tree e, while x is a raw nonterminal symbol in the corpus and k = 0, 1, . . . is an index of the symbol subcategory. Suppose x is NP and its symbol subcategory is 0, then x k is NP 0 . The PYP has three parameters: is a base distribution over infinite space of symbolrefined elementary trees rooted with x k , which provides the backoff probability of e. The remaining parameters d x k and \u03b8 x k control the strength of the base distribution.\n(d x k , \u03b8 x k , P sr-tsg ). P sr-tsg (\u2022 |x k ) SR-TSG SR-CFG RU-CFG\nThe backoff probability P sr-tsg (e |x k ) is given by the product of symbol-refined CFG (SR-CFG) rules that e contains as follows.\nP sr-tsg (e |x k ) = f \u2208F (e) s c f \u00d7 i\u2208I(e) (1 \u2212 s ci ) \u00d7 H (cfg-rules (e |x k )) \u03b1 |x k \u223c H x k H x k \u223c PYP d x , \u03b8 x , P sr-cfg (\u2022 |x k ) ,\nwhere F (e) is a set of frontier nonterminal nodes and I (e) is a set of internal nodes in e. c f and c i are nonterminal symbols of nodes f and i, respectively. s c is the probability of stopping the expansion of a node labeled with c. SR-CFG rules are CFG rules where every symbol is refined, as shown in Table 1. The function cfg-rules (e |x k ) returns the SR-CFG rules that e contains, which take the form of x k \u2192 \u03b1. Each SR-CFG rule \u03b1 rooted with x k is drawn from the backoff distribution H x k , and H x k is produced by the PYP with parameters: d x , \u03b8 x , P sr-cfg . This distribution over the SR-CFG rules forms the second level hierarchy of our model.\nThe backoff probability of the SR-CFG rule, P sr-cfg (\u03b1 |x k ), is given by the root-unrefined CFG (RU-CFG) rule as follows,\nP sr-cfg (\u03b1 |x k ) = I (root-unrefine (\u03b1 |x k )) \u03b1 |x \u223c I x I x \u223c PYP d x , \u03b8 x , P ru-cfg (\u2022 |x ) ,\nwhere the function root-unrefine (\u03b1 |x k ) returns the RU-CFG rule of \u03b1, which takes the form of x \u2192 \u03b1. The RU-CFG rule is a CFG rule where the root symbol is unrefined and all leaf nonterminal symbols are refined, as shown in Table 1. Each RU-CFG rule \u03b1 rooted with x is drawn from the backoff distribution I x , and I x is produced by a PYP. This distribution over the RU-CFG rules forms the third level hierarchy of our model. Finally, we set the backoff probability of the RU-CFG rule, P ru-cfg (\u03b1 |x ), so that it is uniform as follows.\nP ru-cfg (\u03b1 |x ) = 1 |x \u2192 \u2022| .\nwhere |x \u2192 \u2022| is the number of RU-CFG rules rooted with x. Overall, our hierarchical model encodes backoff smoothing consistently from the SR-TSG rules to the SR-CFG rules, and from the SR-CFG rules to the RU-CFG rules. As shown in Cohen et al., 2010), the parsing accuracy of the TSG model is strongly affected by its backoff model. The effects of our hierarchical backoff model on parsing performance are evaluated in Section 5.", "publication_ref": ["b22", "b25", "b3"], "figure_ref": [], "table_ref": ["tab_0", "tab_0", "tab_0"]}, {"heading": "Inference", "text": "We use Markov Chain Monte Carlo (MCMC) sampling to infer the SR-TSG derivations from parse trees. MCMC sampling is a widely used approach for obtaining random samples from a probability distribution. In our case, we wish to obtain derivation samples of an SR-TSG from the posterior distribution, p (e |t, d, \u03b8, s ).\nThe inference of the SR-TSG derivations corresponds to inferring two kinds of latent variables: latent symbol subcategories and latent substitution sites. We first infer latent symbol subcategories for every symbol in the parse trees, and then infer latent substitution sites stepwise. During the inference of symbol subcategories, every internal node is fixed as a substitution site. After that, we unfix that assumption and infer latent substitution sites given symbolrefined parse trees. This stepwise learning is simple and efficient in practice, but we believe that the joint learning of both latent variables is possible, and we will deal with this in future work. Here we describe each inference algorithm in detail.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Inference of Symbol Subcategories", "text": "For the inference of latent symbol subcategories, we adopt split and merge training (Petrov et al., 2006) as follows. In each split-merge step, each symbol is split into at most two subcategories. For example, every NP symbol in the training data is split into either NP 0 or NP 1 to maximize the posterior probability. After convergence, we measure the loss of each split symbol in terms of the likelihood incurred when removing it, then the smallest 50% of the newly split symbols as regards that loss are merged to avoid overfitting. The split-merge algorithm terminates when the total number of steps reaches the user-specified value.\nIn each splitting step, we use two types of blocked MCMC algorithm: the sentence-level blocked Metroporil-Hastings (MH) sampler and the treelevel blocked Gibbs sampler, while (Petrov et al., 2006) use a different MLE-based model and the EM algorithm. Our sampler iterates sentence-level sampling and tree-level sampling alternately.\nThe sentence-level MH sampler is a recently proposed algorithm for grammar induction (Johnson et al., 2007b;. In this work, we apply it to the training of symbol splitting. The MH sampler consists of the following three steps: for each sentence, 1) calculate the inside probability (Lari and Young, 1991) in a bottom-up manner, 2) sample a derivation tree in a top-down manner, and 3) accept or reject the derivation sample by using the MH test. See  for details. This sampler simultaneously updates blocks of latent variables associated with a sentence, thus it can find MAP solutions efficiently.\nThe tree-level blocked Gibbs sampler focuses on the type of SR-TSG rules and simultaneously up-dates all root and child nodes that are annotated with the same SR-TSG rule. For example, the sampler collects all nodes that are annotated with S 0 \u2192 NP 1 VP 2 , then updates those nodes to another subcategory such as S 0 \u2192 NP 2 VP 0 according to the posterior distribution. This sampler is similar to table label resampling (Johnson and Goldwater, 2009), but differs in that our sampler can update multiple table labels simultaneously when multiple tables are labeled with the same elementary tree. The tree-level sampler also simultaneously updates blocks of latent variables associated with the type of SR-TSG rules, thus it can find MAP solutions efficiently.", "publication_ref": ["b20", "b20", "b14", "b17", "b12"], "figure_ref": [], "table_ref": []}, {"heading": "Inference of Substitution Sites", "text": "After the inference of symbol subcategories, we use Gibbs sampling to infer the substitution sites of parse trees as described in (Cohn and Lapata, 2009;Post and Gildea, 2009). We assign a binary variable to each internal node in the training data, which indicates whether that node is a substitution site or not. For each iteration, the Gibbs sampler works by sampling the value of each binary variable in random order. See  for details.\nDuring the inference, our sampler ignores the symbol subcategories of internal nodes of elementary trees since they do not affect the derivation of the SR-TSG. For example, the elementary trees \"(S 0 (NP 0 NNP 0 ) VP 0 )\" and \"(S 0 (NP 1 NNP 0 ) VP 0 )\" are regarded as being the same when we calculate the generation probabilities according to our model. This heuristics is helpful for finding large tree fragments and learning compact grammars.", "publication_ref": ["b4", "b23"], "figure_ref": [], "table_ref": []}, {"heading": "Hyperparameter Estimation", "text": "We treat hyperparameters {d, \u03b8} as random variables and update their values for every MCMC iteration. We place a prior on the hyperparameters as follows:\nd \u223c Beta (1, 1), \u03b8 \u223c Gamma (1, 1).\nThe values of d and \u03b8 are optimized with the auxiliary variable technique (Teh, 2006a).", "publication_ref": ["b24"], "figure_ref": [], "table_ref": []}, {"heading": "Experiment", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Settings", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Data Preparation", "text": "We ran experiments on the Wall Street Journal (WSJ) portion of the English Penn Treebank data set (Marcus et al., 1993), using a standard data split (sections 2-21 for training, 22 for development and 23 for testing). We also used section 2 as a small training set for evaluating the performance of our model under low-resource conditions. Henceforth, we distinguish the small training set (section 2) from the full training set (sections 2-21). The treebank data is right-binarized (Matsuzaki et al., 2005) to construct grammars with only unary and binary productions. We replace lexical words with count \u2264 5 in the training data with one of 50 unknown words using lexical features, following (Petrov et al., 2006). We also split off all the function tags and eliminated empty nodes from the data set, following (Johnson, 1998).", "publication_ref": ["b18", "b19", "b20", "b15"], "figure_ref": [], "table_ref": []}, {"heading": "Training and Parsing", "text": "For the inference of symbol subcategories, we trained our model with the MCMC sampler by using 6 split-merge steps for the full training set and 3 split-merge steps for the small training set. Therefore, each symbol can be subdivided into a maximum of 2 6 = 64 and 2 3 = 8 subcategories, respectively. In each split-merge step, we initialized the sampler by randomly splitting every symbol in two subcategories and ran the MCMC sampler for 1000 iterations. After that, to infer the substitution sites, we initialized the model with the final sample from a run on the small training set, and used the Gibbs sampler for 2000 iterations. We estimated the optimal values of the stopping probabilities s by using the development set.\nWe obtained the parsing results with the MAX-RULE-PRODUCT algorithm (Petrov et al., 2006) by using the SR-TSG rules extracted from our model. We evaluated the accuracy of our parser by bracketing F1 score of predicted parse trees. We used EVALB 1 to compute the F1 score. In all our experiments, we conducted ten independent runs to train our model, and selected the one that performed best on the development set in terms of parsing accuracy.   .\nFigure 2: Histogram of SR-TSG and TSG rule sizes on the small training set. The size is defined as the number of CFG rules that the elementary tree contains.", "publication_ref": ["b20"], "figure_ref": [], "table_ref": []}, {"heading": "Results and Discussion", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Comparison of SR-TSG with TSG", "text": "We compared the SR-TSG model with the CFG and TSG models as regards parsing accuracy. We also tested our model with three backoff hierarchy settings to evaluate the effects of backoff smoothing on parsing accuracy. Table 2 shows the F1 scores of the CFG, TSG and SR-TSG parsers for small and full training sets. In Table 2, SR-TSG (P sr-tsg ) denotes that we used only the topmost level of the hierarchy. Similary, SR-TSG (P sr-tsg , P sr-cfg ) denotes that we used only the P sr-tsg and P sr-cfg backoff models.\nOur best model, SR-TSG (P sr-tsg , P sr-cfg , P ru-cfg ), outperformed both the CFG and TSG models on both the small and large training sets. This result suggests that the conventional TSG model trained from the vanilla treebank is insufficient to resolve Model F1 (\u2264 40) F1 (all) TSG (no symbol refinement) Post and Gildea (2009) 82.6 -  The performance of the SR-TSG parser was strongly affected by its backoff models. For example, the simplest model, P sr-tsg , performed poorly compared with our best model. This result suggests that the SR-TSG rules extracted from the training set are very sparse and cannot cover the space of unknown syntax patterns in the testing set. Therefore, sophisticated backoff modeling is essential for the SR-TSG parser. Our hierarchical PYP modeling technique is a successful way to achieve backoff smoothing from sparse SR-TSG rules to simpler CFG rules, and offers the advantage of automatically estimating the optimal backoff probabilities from the training set.\nWe compared the rule sizes and frequencies of SR-TSG with those of TSG. The rule sizes of SR-TSG and TSG are defined as the number of CFG rules that the elementary tree contains. Figure 2 shows a histogram of the SR-TSG and TSG rule sizes (by unrefined token) on the small training set. For example, SR-TSG rules: S 1 \u2192 NP 0 VP 1 and S 0 \u2192 NP 1 VP 2 were considered to be the same token. In Figure 2, we can see that there are almost the same number of SR-TSG rules and TSG rules with size = 1. However, there are more SR-TSG rules than TSG rules with size \u2265 2. This shows that an SR-TSG can use various large tree fragments depending on the context, which is specified by the symbol subcategories.", "publication_ref": ["b23"], "figure_ref": [], "table_ref": ["tab_2", "tab_2"]}, {"heading": "Comparison of SR-TSG with Other Models", "text": "We compared the accuracy of the SR-TSG parser with that of conventional high-performance parsers. Table 3 shows the F1 scores of an SR-TSG and conventional parsers with the full training set. In Table 3, SR-TSG (single) is a standard SR-TSG parser, and SR-TSG (multiple) is a combination of sixteen independently trained SR-TSG models, following the work of (Petrov, 2010).\nOur SR-TSG (single) parser achieved an F1 score of 91.1%, which is a 6.4 point improvement over the conventional Bayesian TSG parser reported by . Our model can be viewed as an extension of Cohn's work by the incorporation of symbol refinement. Therefore, this result confirms that a TSG and symbol refinement work complementarily in improving parsing accuracy. Compared with a symbol-refined CFG model such as the Berkeley parser (Petrov et al., 2006), the SR-TSG model can use large tree fragments, which strengthens the probability of frequent syntax patterns in the training set. Indeed, the few very large rules of our model memorized full parse trees of sentences, which were repeated in the training set.\nThe SR-TSG (single) is a pure generative model of syntax trees but it achieved results comparable to those of discriminative parsers. It should be noted that discriminative reranking parsers such as (Charniak and Johnson, 2005) and (Huang, 2008) are constructed on a generative parser. The reranking parser takes the k-best lists of candidate trees or a packed forest produced by a baseline parser (usually a generative model), and then reranks the candidates using arbitrary features. Hence, we can expect that combining our SR-TSG model with a discriminative reranking parser would provide better performance than SR-TSG alone.\nRecently, (Petrov, 2010) has reported that combining multiple grammars trained independently gives significantly improved performance over a single grammar alone. We applied his method (referred to as a TREE-LEVEL inference) to the SR-TSG model as follows. We first trained sixteen SR-TSG models independently and produced a 100-best list of the derivations for each model. Then, we erased the subcategory information of parse trees and selected the best tree that achieved the highest likelihood under the product of sixteen models. The combination model, SR-TSG (multiple), achieved an F1 score of 92.4%, which is a state-of-the-art result for the WSJ parsing task. Compared with discriminative reranking parsers, combining multiple grammars by using the product model provides the advantage that it does not require any additional training. Several studies (Fossum and Knight, 2009;Zhang et al., 2009) have proposed different approaches that involve combining k-best lists of candidate trees. We will deal with those methods in future work.\nLet us note the relation between SR-CFG, TSG and SR-TSG. TSG is weakly equivalent to CFG and generates the same set of strings. For example, the TSG rule \"S \u2192 (NP NNP) VP\" with probability p can be converted to the equivalent CFG rules as follows: \"S \u2192 NP NNP VP \" with probability p and \"NP NNP \u2192 NNP\" with probability 1. From this viewpoint, TSG utilizes surrounding symbols (NNP of NP NNP in the above example) as latent variables with which to capture context information. The search space of learning a TSG given a parse tree is O (2 n ) where n is the number of internal nodes of the parse tree. On the other hand, an SR-CFG utilizes an arbitrary index such as 0, 1, . . . as latent variables and the search space is larger than that of a TSG when the symbol refinement model allows for more than two subcategories for each symbol. Our experimental results comfirm that jointly modeling both latent variables using our SR-TSG assists accurate parsing.", "publication_ref": ["b21", "b20", "b2", "b11", "b21", "b9", "b29"], "figure_ref": [], "table_ref": ["tab_4"]}, {"heading": "Conclusion", "text": "We have presented an SR-TSG, which is an extension of the conventional TSG model where each symbol of tree fragments can be automatically subcategorized to address the problem of the conditional independence assumptions of a TSG. We proposed a novel backoff modeling of an SR-TSG based on the hierarchical Pitman-Yor Process and sentence-level and tree-level blocked MCMC sampling for training our model. Our best model significantly outperformed the conventional TSG and achieved state-of-the-art result in a WSJ parsing task. Future work will involve examining the SR-TSG model for different languages and for unsupervised grammar induction.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgements", "text": "We would like to thank Liang Huang for helpful comments and the three anonymous reviewers for thoughtful suggestions. We would also like to thank Slav Petrov and Hui Zhang for answering our questions about their parsers.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Simple, Accurate Parsing with an All-Fragments Grammar", "journal": "", "year": "2010", "authors": "Mohit Bansal; Dan Klein"}, {"ref_id": "b1", "title": "Unsupervised Induction of Tree Substitution Grammars for Dependency Parsing", "journal": "", "year": "2010", "authors": "Phil Blunsom; Trevor Cohn"}, {"ref_id": "b2", "title": "Coarseto-Fine n-Best Parsing and MaxEnt Discriminative Reranking", "journal": "", "year": "2005", "authors": "Eugene Charniak; Mark Johnson"}, {"ref_id": "b3", "title": "Variational Inference for Adaptor Grammars", "journal": "", "year": "2010", "authors": "David M Shay B Cohen; Noah A Blei;  Smith"}, {"ref_id": "b4", "title": "Sentence Compression as Tree Transduction", "journal": "Journal of Artificial Intelligence Research", "year": "2009", "authors": "Trevor Cohn; Mirella Lapata"}, {"ref_id": "b5", "title": "Inducing Tree-Substitution Grammars", "journal": "Journal of Machine Learning Research", "year": "2010", "authors": "Trevor Cohn; Phil Blunsom; Sharon Goldwater"}, {"ref_id": "b6", "title": "Head-Driven Statistical Models for Natural Language Parsing", "journal": "Computational Linguistics", "year": "2003", "authors": "Michael Collins"}, {"ref_id": "b7", "title": "Synchronous Tree Adjoining Machine Translation", "journal": "", "year": "2009", "authors": "Steve Deneefe; Kevin Knight"}, {"ref_id": "b8", "title": "A Bayesian Analysis of Some Nonparametric Problems", "journal": "Annals of Statistics", "year": "1973", "authors": "S Thomas;  Ferguson"}, {"ref_id": "b9", "title": "Combining Constituent Parsers", "journal": "", "year": "2009", "authors": "Victoria Fossum; Kevin Knight"}, {"ref_id": "b10", "title": "What's in a Translation Rule", "journal": "Information Sciences", "year": "2004", "authors": "Michel Galley; Mark Hopkins; Kevin Knight; Daniel Marcu"}, {"ref_id": "b11", "title": "Forest Reranking : Discriminative Parsing with Non-Local Features", "journal": "", "year": "2008", "authors": "Liang Huang"}, {"ref_id": "b12", "title": "Improving nonparameteric Bayesian inference: experiments on unsupervised word segmentation with adaptor grammars", "journal": "", "year": "2009", "authors": "Mark Johnson; Sharon Goldwater"}, {"ref_id": "b13", "title": "Adaptor Grammars : A Framework for Specifying Compositional Nonparametric Bayesian Models", "journal": "Advances in Neural Information Processing Systems", "year": "2007", "authors": "Mark Johnson; L Thomas; Sharon Griffiths;  Goldwater"}, {"ref_id": "b14", "title": "Bayesian Inference for PCFGs via Markov chain Monte Carlo", "journal": "", "year": "2007", "authors": "Mark Johnson; L Thomas; Sharon Griffiths;  Goldwater"}, {"ref_id": "b15", "title": "PCFG Models of Linguistic Tree Representations", "journal": "Computational Linguistics", "year": "1998", "authors": "Mark Johnson"}, {"ref_id": "b16", "title": "Accurate Unlexicalized Parsing", "journal": "", "year": "2003", "authors": "Dan Klein; D Christopher;  Manning"}, {"ref_id": "b17", "title": "Applications of Stochastic Context-Free Grammars Using the Inside-Outside Algorithm", "journal": "Computer Speech and Language", "year": "1991", "authors": "K Lari; S J Young"}, {"ref_id": "b18", "title": "Building a Large Annotated Corpus of English: The Penn Treebank", "journal": "Computational Linguistics", "year": "1993", "authors": "P Mitchell; Beatrice Marcus; Mary Ann Santorini;  Marcinkiewicz"}, {"ref_id": "b19", "title": "Probabilistic CFG with latent annotations", "journal": "", "year": "2005", "authors": "Takuya Matsuzaki; Yusuke Miyao; Jun'ichi Tsujii"}, {"ref_id": "b20", "title": "Learning Accurate, Compact, and Interpretable Tree Annotation", "journal": "", "year": "2006", "authors": "Slav Petrov; Leon Barrett; Romain Thibaux; Dan Klein"}, {"ref_id": "b21", "title": "Products of Random Latent Variable Grammars", "journal": "", "year": "2010", "authors": "Slav Petrov"}, {"ref_id": "b22", "title": "The two-parameter Poisson-Dirichlet distribution derived from a stable subordinator", "journal": "The Annals of Probability", "year": "1997", "authors": "Jim Pitman; Marc Yor"}, {"ref_id": "b23", "title": "Bayesian Learning of a Tree Substitution Grammar", "journal": "", "year": "2009", "authors": "Matt Post; Daniel Gildea"}, {"ref_id": "b24", "title": "A Bayesian Interpretation of Interpolated Kneser-Ney. NUS School of Computing", "journal": "", "year": "2006", "authors": "Yee Whye Teh"}, {"ref_id": "b25", "title": "A Hierarchical Bayesian Language Model based on Pitman-Yor Processes", "journal": "", "year": "2006", "authors": "Y W Teh"}, {"ref_id": "b26", "title": "Fragment Grammars: Exploring Computation and Reuse in Language", "journal": "", "year": "2009", "authors": "J Tenenbaum; N D Tj O'donnell;  Goodman"}, {"ref_id": "b27", "title": "What is the Jeopardy Model ? A Quasi-Synchronous Grammar for QA", "journal": "", "year": "2007", "authors": "Mengqiu Wang; A Noah; Teruko Smith;  Mitamura"}, {"ref_id": "b28", "title": "Bayesian Synchronous Tree-Substitution Grammar Induction and Its Application to Sentence Compression", "journal": "", "year": "2010", "authors": "Elif Yamangil; M Stuart;  Shieber"}, {"ref_id": "b29", "title": "K-Best Combination of Syntactic Parsers", "journal": "", "year": "2009", "authors": "Hui Zhang; Min Zhang; Haizhou Chew Lim Tan;  Li"}, {"ref_id": "b30", "title": "Parsimonious Data-Oriented Parsing", "journal": "", "year": "2007", "authors": "Willem Zuidema"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 1 :1Figure 1: (a) Example parse tree. (b) Example TSG derivation of (a). (c) Example SR-TSG derivation of (a). The refinement annotation is hyphenated with a nonterminal symbol.", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "Example three-level backoff.", "figure_data": ""}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_2", "figure_caption": "Comparison of parsing accuracy with the small and full training sets. *Our reimplementation of", "figure_data": ""}, {"figure_label": "3", "figure_type": "table", "figure_id": "tab_4", "figure_caption": "Our parsing performance for the testing set compared with those of other parsers. *Results for the development set (\u2264 100).", "figure_data": "structural ambiguities caused by coarse symbol an-notations in a training corpus. As we expected, sym-bol refinement can be helpful with the TSG modelfor further fitting the training set and improving theparsing accuracy."}], "formulas": [{"formula_id": "formula_0", "formula_text": "p (e) = x\u2192e\u2208e p (e |x ) ,", "formula_coordinates": [2.0, 374.32, 264.86, 102.15, 20.18]}, {"formula_id": "formula_1", "formula_text": "p (e |t ) \u221d p (t |e ) p (e) .", "formula_coordinates": [2.0, 373.02, 430.16, 104.75, 9.47]}, {"formula_id": "formula_2", "formula_text": "e |x k \u223c G x k G x k \u223c PYP d x k , \u03b8 x k , P sr-tsg (\u2022 |x k ) ,", "formula_coordinates": [3.0, 340.49, 591.71, 169.8, 25.01]}, {"formula_id": "formula_3", "formula_text": "(d x k , \u03b8 x k , P sr-tsg ). P sr-tsg (\u2022 |x k ) SR-TSG SR-CFG RU-CFG", "formula_coordinates": [3.0, 395.78, 693.53, 141.88, 13.21]}, {"formula_id": "formula_4", "formula_text": "P sr-tsg (e |x k ) = f \u2208F (e) s c f \u00d7 i\u2208I(e) (1 \u2212 s ci ) \u00d7 H (cfg-rules (e |x k )) \u03b1 |x k \u223c H x k H x k \u223c PYP d x , \u03b8 x , P sr-cfg (\u2022 |x k ) ,", "formula_coordinates": [4.0, 89.0, 354.1, 194.65, 67.94]}, {"formula_id": "formula_5", "formula_text": "P sr-cfg (\u03b1 |x k ) = I (root-unrefine (\u03b1 |x k )) \u03b1 |x \u223c I x I x \u223c PYP d x , \u03b8 x , P ru-cfg (\u2022 |x ) ,", "formula_coordinates": [4.0, 90.0, 664.43, 193.21, 41.93]}, {"formula_id": "formula_6", "formula_text": "P ru-cfg (\u03b1 |x ) = 1 |x \u2192 \u2022| .", "formula_coordinates": [4.0, 375.7, 379.06, 99.38, 22.09]}, {"formula_id": "formula_7", "formula_text": "d \u223c Beta (1, 1), \u03b8 \u223c Gamma (1, 1).", "formula_coordinates": [5.0, 353.43, 668.38, 161.36, 9.71]}], "doi": ""}