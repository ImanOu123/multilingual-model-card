{"title": "A Scalable Framework for Discovering Coherent Co-clusters in Noisy Data", "authors": "Meghana Deodhar; Gunjan Gupta; Joydeep Ghosh; Hyuk Cho; Inderjit Dhillon", "pub_date": "", "abstract": "Clustering problems often involve datasets where only a part of the data is relevant to the problem, e.g., in microarray data analysis only a subset of the genes show cohesive expressions within a subset of the conditions/features. The existence of a large number of non-informative data points and features makes it challenging to hunt for coherent and meaningful clusters from such datasets. Additionally, since clusters could exist in different subspaces of the feature space, a co-clustering algorithm that simultaneously clusters objects and features is often more suitable as compared to one that is restricted to traditional \"one-sided\" clustering. We propose Robust Overlapping Co-Clustering (ROCC), a scalable and very versatile framework that addresses the problem of efficiently mining dense, arbitrarily positioned, possibly overlapping co-clusters from large, noisy datasets. ROCC has several desirable properties that make it extremely well suited to a number of real life applications.", "sections": [{"heading": "Motivation", "text": "When clustering certain real world datasets, it has been observed that only a part of the data forms cohesive clusters. For example, in the case of microarray data, typically only a small subset of the genes cluster well and the rest can be considered noninformative (Gupta & Ghosh, 2006). Problems addressed by eCommerce businesses, such as market basket analysis and fraud detection involve huge, noisy Appearing in Proceedings of the 26 th International Conference on Machine Learning, Montreal, Canada, 2009. Copyright 2009 by the author(s)/owner(s).\ndatasets with coherent patterns occurring only in small pockets of the data. Moreover, for such data, coherent clusters could be arbitrarily positioned in subspaces formed by different, possibly overlapping subsets of features, e.g., different subsets of genes may be correlated across different subsets of experiments in microarray data. Additionally, it is possible that some features may not be relevant to any cluster.\nTraditional clustering algorithms like k -means or approaches such as feature clustering (Dhillon et al., 2003a) do not allow clusters existing in different subsets of the feature space to be detected easily. Coclustering simultaneously clusters the data along multiple axes, e.g., in the case of microarray data it simultaneously clusters the genes as well as the experiments (Cheng & Church, 2000) and can hence detect clusters existing in different subspaces of the feature space. In this paper we focus on real life datasets, where co-clusters are arbitrarily positioned in the data matrix, could be overlapping and are obfuscated by the presence of a large number of irrelevant points. Our goal is to discover dense, arbitrarily positioned and overlapping co-clusters in the data, while simultaneously pruning away non-informative objects and features.", "publication_ref": ["b12", "b7", "b4"], "figure_ref": [], "table_ref": []}, {"heading": "Related Work", "text": "Density based clustering algorithms such as DB-SCAN (Ester et al., 1996), OPTICS and Bregman Bubble Clustering (Gupta & Ghosh, 2006) have a motivation similar to our proposed approach and use the notion of local density to cluster only a relevant subset of the data into multiple dense clusters. However, all of these approaches are developed for one-sided clustering only, where the data points are clustered based on their similarity across the entire set of features. In contrast, both co-clustering (biclustering) and subspace clustering approaches locate clusters in subspaces of the feature space. The literature in both areas is recent but explosive, so we refer to the surveys and comparative studies in (Madeira & Oliveira, 2004;Parsons et al., 2004;Prelic et al., 2006) as good starting points. As we shall see in Section 3, none of the existing methods provide the full set of capabilities that the proposed method provides.\nCo-clustering was first applied to gene expression data by Cheng and Church (2000), who used a greedy search heuristic to generate arbitrarily positioned, overlapping co-clusters, based on a homogeneity constraint. However, their iterative insertion and deletion based algorithm is expensive, since it identifies individual coclusters sequentially rather than all at once. The algorithm also causes random perturbations to the data while masking discovered biclusters, which reduces the clustering quality. The plaid model approach (Lazzeroni & Owen, 2002) improves upon this by directly modeling overlapping clusters, but still cannot identify multiple co-clusters simultaneously. These algorithms are not very general as they assume additive Gaussian noise models. Neither can they effectively handle missing data.\nIn addition to the greedy, iterative algorithms discussed above, deterministic algorithms such as Bi-Max (Prelic et al., 2006) and OPSM (Ben-Dor et al., 2002) have also been proposed. The BiMax approach is based on a simple, binary data model, which results in a number of co-clusters that is exponential in the number of genes and experiments, making it impractical in case of large datasets. The order preserving sub matrix algorithm (OPSM) looks for submatrices in which the expression levels of all the genes induce the same linear ordering of the experiments. This algorithm although very accurate, is designed to identify only a single co-cluster. A recent extension to OPSM (Zhang et al., 2008) finds multiple, overlapping co-clusters in noisy datasets, but is very expensive in the number of features.\nBregman Co-Clustering (BCC), proposed by Banerjee et al. (2007), is a highly efficient, generalized framework for partitional co-clustering (Madeira & Oliveira, 2004) that works with any distance measure that is a Bregman divergence, or equivalently any noise distribution from the regular exponential family. The BCC framework is however restricted to grid-based, partitional co-clustering and assigns every point in the data matrix to exactly one co-cluster, i.e., the co-clustering is exhaustive and exclusive. Parsons et al. (2004) present a survey of subspace clustering algorithms, which includes bottom-up grid based methods like CLIQUE and iterative top-down algorithms like PROCLUS. However, most of them are computationally intensive, need extensive tuning to get meaningful results and identify uniform clusters with very similar values rather than clusters with coherent trends or patterns. The pCluster model (Wang et al., 2002) and the more recent reg-cluster model (Xu et al., 2006) generalize subspace clustering and aim to identify arbitrary scaling and shifting co-regulations patterns. However, unlike our proposed approach, these pattern-based, heuristic approaches do not use a principled cost function and do not scale well due to high complexity in the number of features.", "publication_ref": ["b9", "b12", "b16", "b19", "b20", "b4", "b13", "b20", "b2", "b26", "b0", "b16", "b19", "b22", "b24"], "figure_ref": [], "table_ref": []}, {"heading": "Our Contributions", "text": "We propose Robust Overlapping Co-clustering (ROCC), a novel approach for discovering dense, arbitrarily positioned co-clusters in large, possibly high-dimensional datasets. Our approach is robust in the presence of noisy and irrelevant objects as well as features, which our algorithm automatically detects and prunes during the clustering process. ROCC is based on a systematically developed objective function, which is minimized by an iterative procedure that provably converges to a locally optimal solution. ROCC is also robust to the noise model of the data and can be tailored to use the most suitable distance measure for the data, selected from a large class of distance measures known as Bregman divergences.\nThe final objective of ROCC is achieved in two steps. In the first step, the Bregman co-clustering algorithm is adapted to automatically prune away noninformative data points and perform feature selection by eliminating non-discriminative features and hence cluster only the relevant part of the dataset. This step finds co-clusters arranged in a grid structure, but only a predetermined number of rows and columns are assigned to the co-clusters. Note however that this result cannot be achieved by simply removing some rows/columns from the BCC result. An agglomeration step then appropriately merges similar co-clusters to discover dense, arbitrarily positioned, overlapping co-clusters. Figure 1 contrasts the nature of the coclusters identified by ROCC with those found by BCC and illustrates the way in which they are conceptually derived from the partitional model of BCC.\nThe ROCC framework has the following key features that distinguish it from existing co-clustering algorithms:\n1. The ability to mine the most coherent co-clusters from large and noisy datasets. overlapping co-clusters in a principled manner by iteratively minimizing a suitable cost function.", "publication_ref": [], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "Detection of arbitrarily positioned and possibly", "text": "3. Generalization to all Bregman divergences, including squared Euclidean distance, commonly used for clustering microarray data and Idivergence, commonly used for text data clustering (Dhillon et al., 2003b).\n4. The ability to naturally deal with missing data values, without introducing random perturbations or bias in the data.\n5. Efficient detection of all co-clusters simultaneously rather than sequentially, enabling scalability to large and high-dimensional datasets.\nAs far as we know, no existing co-clustering algorithm (Zhang et al., 2008;Xu et al., 2006;Banerjee et al., 2007;Cheng & Church, 2000) has all of the above properties. Our contribution is significant, since as described in Section 1 there exist several applications where all these properties are necessary for discovering meaningful patterns.", "publication_ref": ["b8", "b26", "b24", "b0", "b4"], "figure_ref": [], "table_ref": []}, {"heading": "Problem Definition", "text": "We begin with the formulation of the first step of the ROCC algorithm. Let m be the total number of rows (data points) and n the total number of columns (features). The data can be represented as an m\u00d7n matrix Z of data points and features. Let s r and s c be the specified number of rows and columns, respectively, to be retained after pruning. If the exact values are not known, it is sufficient to set s r and s c conservatively to large values since the algorithm (Section 5.3) does a second round of pruning as needed. Our aim is to simultaneously cluster s r rows and s c columns of Z into a grid of k row clusters and l column clusters. The co-clusters will hence be comprised of s r \u00d7 s c entries selected from the m \u00d7 n entries of Z. Let K and L denote the sets consisting of the s r clustered rows and the s c clustered columns respectively. Let \u03c1 be a mapping from the s r rows \u2208 K to the k row clusters and \u03b3 be a mapping from the s c columns \u2208 L to the l column clusters. Let squared Euclidean distance be the selected distance measure 1 . We want to find a coclustering defined by (\u03c1, \u03b3) and sets K and L for the specified s r and s c that minimize the following objective function\nk g=1 l h=1 u\u2208K:\u03c1(u)=g v\u2208L:\u03b3(v)=h w uv (z uv \u2212\u1e91 uv ) 2 , (1)\nwhere z uv is the original value in row u, column v of the matrix, assigned to row cluster g and column cluster h and\u1e91 uv is the value approximated within cocluster g-h. w uv is the non-negative weight associated with matrix entry z uv , which allows the algorithm to deal with missing values and data uncertainties. For example, the weights for known values can be set to 1 and missing values can be effectively ignored by setting their weights to 0. The objective function is hence the element-wise squared error between the original and the approximated value, summed only over the clustered elements (s r \u00d7 s c ) of the matrix Z. The value\u1e91 uv can be approximated in several ways, depending on the type of summary statistics that each co-cluster preserves. Banerjee et al. (2007) identify six possible sets of summary statistics, of increasing complexity, that one might be interested in preserving in the reconstructed matrix\u1e90, which lead to six different co-clustering schemes. Two of these approximation schemes for\u1e91 uv are described in Section 5.3.\nIn the next step of ROCC, the goal is to agglomerate similar co-clusters to recover the arbitrarily positioned co-clusters. In order to agglomerate co-clusters, we first define a distance measure between two candidate co-clusters (cc1 and cc2) as follows. Let cc denote the co-cluster formed by the union of the rows and columns in cc1 and cc2. The matrix entries\u1e91 uv in cc are approximated using the selected approximation scheme. The average element-wise error e for cc is computed as e = 1 N zuv \u2208cc (z uv \u2212\u1e91 uv ) 2 , where N is the number of elements in cc. The error e is defined to be the distance between cc1 and cc2.", "publication_ref": ["b0"], "figure_ref": [], "table_ref": []}, {"heading": "ROCC Algorithm", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Solving Step 1 of the ROCC Problem", "text": "A co-clustering (\u03c1, \u03b3), that minimizes the objective function (1), can be obtained by an iterative algorithm.\nThe objective function can be expressed as a sum of row or column errors, computed over the s r rows and s c columns assigned to co-clusters. If row u is assigned to row cluster g, the row error is the error summed over the appropriate s c elements in the row, i.e., if \u03c1(u) = g, then E u (g) = l h=1 v\u2208L:\u03b3(v)=h w uv (z uv \u2212\u1e91 uv (g)) 2 . For a fixed \u03b3, the best choice of the row cluster assignment for row u is the g that minimizes this error, i.e., \u03c1 new (u) = arg g min E u (g). After computing the best row cluster assignment for all the m rows, the top s r rows with minimum error are selected to participate in the current row clusters. A similar approach is used to assign columns to column clusters. Note that the rows/columns that are not included in the current s r /s c rows/columns assigned to co-clusters are still retained since they could be included in the co-clusters in future iterations.\nGiven the current row and column cluster assignments (\u03c1, \u03b3), the values\u1e91 uv within each co-cluster have to be updated by recomputing the required co-cluster statistics based on the approximation scheme. This problem is identical to the Minimum Bregman Information (MBI) problem presented in (Banerjee et al., 2007) for updating the matrix reconstruction\u1e90. Solving the MBI problem for this update is guaranteed to decrease the objective function. This iterative procedure is described in Figure 2.\nStep 1(i) decreases the objective function due to the property of the MBI solution, while Steps 1(ii) and 1(iii) directly decrease the objective function. The objective function hence decreases at every iteration. Since this function is bounded from below by zero, the algorithm is guaranteed to converge to a locally optimal solution.", "publication_ref": ["b0"], "figure_ref": ["fig_3"], "table_ref": []}, {"heading": "Solving Step 2 of the ROCC Problem", "text": "We now provide a heuristic to hierarchically agglomerate similar co-clusters. The detailed steps are:\n(i) Pruning co-clusters. Since the desired number of co-clusters is expected to be significantly smaller than the number of co-clusters at this stage of the algorithm, co-clusters with the largest error values can be filtered out in this step. Filtering also reduces the computation effort required by the following merging step. If one has no idea of the final number of coclusters, a simple and efficient filtering heuristic is to select the error cut-off value as the one at which the sorted co-cluster errors show the largest increase between consecutive values. The co-clusters with errors greater than the cut-off are filtered out. Alternatively, if the final number of co-clusters to be found is prespecified, it can be used to prune away an appropriate number of co-clusters with the largest errors.\n(ii) Merging similar co-clusters. This step involves hierarchical, pairwise agglomeration of the coclusters left at the end of the pruning step (Step 2(i)) to recover the true co-clusters. Each agglomeration identifies the \"closest\" pair of co-clusters that can be well represented by a single co-cluster model and are thus probably part of the same original co-cluster, and merges them to form a new co-cluster 2 . \"Closest\" here is in terms of the smallest value of distance as defined in Section 4. The rows and columns of the new cocluster consist of the union of the rows and columns of the two merged co-clusters. Merging co-clusters in this manner allows co-clusters to share rows and columns and hence allows partial overlap between co-clusters. If the number of co-clusters to be identified is prespecified, one can stop merging when this number is reached. If not, merging is continued all the way until only a single co-cluster (or a reasonably small number of co-clusters) is left. The increase in the distance between successively merged co-clusters is then computed and the set of co-clusters just before the largest increase is selected as the final solution.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Overall ROCC Meta-Algorithm", "text": "In this section we put together the procedures described in Sections 5.1 and 5.2 and present the complete ROCC algorithm. The key idea is to overpartition the data into small co-clusters arranged in a grid structure and then agglomerate similar, partitioned co-clusters to recover the desired co-clusters. The iterative procedure (Section 5.1) is run with large enough values for the number of row and column clusters (k and l). Similarly, the s r and s c input parameters are set to sufficiently large values. Since the pruning step (Step 2(i) in Section 5.2) takes care of discarding less coherent co-clusters, setting s r \u2265 s true r and s c \u2265 s true c is sufficient. The resulting k \u00d7 l clusters are then merged as in hierarchical agglomerative clustering until a suitable stopping criterion is reached. The pseudo-code for the complete algorithm is illustrated in Figure 2.\nApproximation Schemes. The ROCC algorithm can use each of the six schemes (co-clustering bases) listed by Banerjee et al. (2007) for approximating the matrix entries\u1e91 uv . For concreteness, we illustrate two specific approximation schemes with squared Euclidean distance, which give rise to block co-clusters and pattern-based co-clusters respectively 3 . The 2 A variant of this algorithm can be derived by adopting Ward's method (Ward, 1963) to agglomerate co-clusters. Empirically we found little difference between the two approaches.\n3 These co-cluster definitions correspond to basis 2 and meta-algorithm in Figure 2 uses C to refer to the selected co-clustering basis.\nBlock co-clusters. Let the co-cluster row and column indices be denoted by sets U and V respectively. In this case, a matrix entry is approximated as\u1e91 uv = z UV , where z UV = 1 |U||V | u\u2208U,v\u2208V z uv is the mean of all the entries in the co-cluster.\nPattern-based co-clusters. z uv is approximated a\u015d z uv = z uV + z Uv \u2212 z UV , where z uV = 1 |V | v\u2208V z uv is the mean of the entries in row u whose column indices are in V and z Uv = 1 |U| u\u2208U z uv is the mean of the entries in column v whose row indices are in U . This approximation can identify co-clusters that show a coherent trend or pattern in the data values, making it suitable for clustering gene expression data .\nDistance Measures. In Section 4 we developed the objective function (1) assuming squared Euclidean distance as the distance measure. The objective function and the iterative procedure to minimize it can be generalized to all Bregman divergences (Banerjee et al., 2007). The selected Bregman divergence is denoted by d \u03c6 in Figure 2. Step  \n(iii): Update \u03b3 (iiia). \u2200[v] n 1 , \u03b3(v) = arg h min k g=1 u\u2208K:\u03c1(u)=g w uv d \u03c6 (z uv ,\u1e91 uv (h)) (iiib). L =", "publication_ref": ["b0", "b23", "b0"], "figure_ref": ["fig_3", "fig_3", "fig_3"], "table_ref": []}, {"heading": "ROCC with Pressurization", "text": "The iterative minimization procedure in Step 1 of the ROCC algorithm begins with random initialization for \u03c1 and \u03b3, which could lead to poor local minima. A better local minimum can be achieved by applying an extension of the pressurization technique used by BBC (Gupta & Ghosh, 2006). Our strategy is to begin by clustering all the data and iteratively shave off data points and features till s r rows and s c columns are left. Let s press r (j) and s press c (j) denote the number of data points and features to be clustered using the Step 1 procedure (Figure 2) in the j th iteration of pressurization. s press r (1) and s press c\n(1) are initialized to m and n respectively, after which these parameters are decayed exponentially till s press r (j) = s r and s press c (j) = s c . The rate of decay is controlled by parameters \u03b2 row and \u03b2 col , which lie between 0 and 1. At iteration j, s press r\n(j) = s r + \u230a(m \u2212 s r ) * \u03b2 j\u22121 row \u230b and s press c (j) = s c + \u230a(m \u2212 s c ) * \u03b2 j\u22121 col \u230b.\nThe intuition is that by beginning with all the data being clustered and then slowly reducing the fraction of data clustered, co-clusters can move around considerably from their initial positions to enable the discovery of small, coherent patterns.", "publication_ref": ["b12"], "figure_ref": ["fig_3"], "table_ref": []}, {"heading": "Experimental Results", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Finding Co-clusters in Microarray Data", "text": "We now evaluate the performance of ROCC on two yeast microarray datasets, the Lee dataset (Lee et al., 2004) and the Gasch dataset (Gasch et al., 2000). The Lee dataset consists of gene expression values of 5612 yeast genes across 591 experiments and can be obtained from the Stanford Microarray Database (http://genome-www5.stanford.edu/). The Gasch dataset consists of the expression values of 6151 yeast genes under 173 environmental stress conditions and is available at http://genome-www.stanford.edu/ yeast stress/. Since the ground truth for both datasets is available only in the form of pairwise linkages between the genes that are known to be functionally related, we compare the quality of the co-clusters identified by different co-clustering algorithms by computing the overlap lift (Gupta & Ghosh, 2006) for the genes in each co-cluster. Overlap lift measures how many times more correct links are predicted as compared to random chance and is related to a normalized version of the proportion of disconnected genes measure used by (Prelic et al., 2006). On these datasets, the aim is to find the most coherent and biologically useful 150 to 200 co-clusters. We run ROCC (with pressurization) on the Lee dataset with the input parameters set to s r = 2000, s c = 400, k = 50 and l = 10 and on the Gasch dataset with s r = 500, s c = 120, k = 80, l = 15. Based on the final number of clusters to be identified, Step 2 of ROCC prunes all but the best 200 co-clusters and then continues merging until 150 co-clusters are left. The set of co-clusters just before the largest increase in merge distance is returned as the solution.\nFigure 3 compares the performance of ROCC with prominent co-clustering algorithms, i.e., Cheng and Church's Biclustering algorithm, the OPSM algorithm (Ben-Dor et al., 2002), the BiMax algorithm (Prelic et al., 2006), and the BCC algorithm on the Lee and Gasch microarray datasets. Through extensive experimentation, Prelic et al. (2006) show that the OPSM and the BiMax algorithms outperform other well known co-clustering algorithms like Samba (Tanay et al., 2002), ISA (Bergmann et al., 2003) and xMotif (Murali & Kasif, 2003) on real microarray data. The BiMax and OPSM results were generated using the BicAT software( http://www. tik.ee.ethz.ch/sop/bicat/) (Barkow et al., 2006). Since it would be infeasible to evaluate the exponential number of co-clusters identified by BiMax, we selected the first 200 co-clusters for comparison. Though OPSM is designed to return only the best co-cluster, it is extended in BicAT to return up to 100 largest coclusters among those that achieve the optimal score. The value of the l parameter for OPSM was set to 10. The Biclustering algorithm 4 is run with the number of clusters equal to 200. The value of the parameter \u03b1 is set to the average H-score (Cheng & Church, 2000) of the co-clusters in the ROCC solution with the highest overlap lift over varying s r and s c values, i.e., \u03b1 = 0.032 for Lee and \u03b1 = 0.017 for Gasch 5 . Since BCC clusters all the data, pruning is carried out by a post-processing step. This step sorts the rows and columns by their distance to the corresponding cluster representatives and selects the s r rows and s c columns with smallest errors. In the Lee and Gasch datasets respectively, around 15% and 3% of the matrix entries are missing. As described in Section 5, ROCC and BCC can ignore missing entries by appropriately setting the weight matrix. The missing entries in the data matrix input to the other algorithms are replaced by random values in the same range as the known expression values. Both ROCC and BCC use squared Euclidean distance and find pattern-based co-clusters. BCC uses the same s r and s c values as Figure 3 shows that on both datasets, ROCC does much better than the other co-clustering approaches in terms of the overlap lift of the gene clusters. The figure also displays above each bar, the percentage of the data matrix entries clustered by the corresponding algorithm. On the Lee dataset, it is interesting that although ROCC clusters a much larger fraction of the data matrix entries than Biclustering, OPSM and BiMax, the co-clusters are of superior quality. The Gasch dataset is more noisy than Lee, which explains why a larger fraction of the dataset has to be pruned as compared to Lee to get meaningful clusters. Lesion studies confirmed that both step 1 and step 2 of the ROCC algorithm contribute to the improvement in performance, step 1 being more important. We empirically compared only step 1 with other approaches (BCC, BBC, k-means) on the Lee and Gasch datasets, for different fractions of retained data (for other algorithms the least fitting data was discarded in a postprocessing step). ROCC with only step 1 was significantly better than all others for 10% or more of the data discarded. A more detailed description is presented in (Deodhar et al., 2008).\nMost of the gene clusters identified by ROCC on the Lee dataset were biologically significant, with very low p-values. Table 1 summarizes some of the identified high purity gene clusters. The coverage (x/y) indicates that x out of the y known members of a category were found. In contrast, the 10 best gene clusters identified by Biclustering had an average p-value of 5.50e-04. ", "publication_ref": ["b15", "b10", "b12", "b20", "b2", "b20", "b20", "b21", "b3", "b18", "b1", "b4", "b6"], "figure_ref": ["fig_4", "fig_4"], "table_ref": ["tab_0"]}, {"heading": "Simultaneous Feature Selection and Clustering", "text": "We now illustrate an interesting application of the ROCC algorithm to perform feature selection along one axis, while simultaneously clustering along the other. ROCC interleaves feature selection with clustering and iteratively improves both, which is intuitively better than independently performing feature selection a priori and then clustering using the identi-  fied features (Law et al., 2004). Additionally, ROCC also clusters related features, achieving simultaneous dimensionality reduction.\nWe consider an exemplary application of ROCC in the above context to a lung cancer microarray dataset (Gordon et al., 2002) with 12533 genes and 181 human tissue samples. The samples belong to two lung cancer classes, malignant pleural mesothelioma (31 samples) and adenocarcinoma (150 samples). In this application, the aim is to cluster the samples, to recover the two existing sample groups in an unsupervised manner, using the expression values of the genes as features. Many of the genes are known to be noninformative and have noisy expression values, which makes feature selection an important issue. We use a version of the dataset that is pre-processed based on domain knowledge, where genes that do not show substantial variation in expression values across the samples are removed as described in , resulting in a set of 2401 genes. Even though the pre-processing step results in removing several non-discriminative genes, we apply ROCC to test if any more genes can be identified, that on pruning will improve sample cluster accuracy further. For this application, ROCC (with pressurization) is set up to cluster all the samples and prune along the \"gene\" axis.\nNote that the agglomeration procedure (Step 2) is not required for this application.\nSample clustering solutions are evaluated by computing the accuracy of the cluster labels with respect to the true class labels as defined in . Figure 4 displays the sample cluster accuracy of ROCC at different fractions of genes clustered.\nFor comparison, the sample cluster accuracy values of BCC, which uses all the genes to obtain a co-clustering of genes and samples, and k -means, which uses all the genes as features to cluster the samples are also plotted as straight lines in the same figure. These experiments are performed on the column standardized dataset, where every column has zero mean and unit variance. BCC and ROCC use squared Euclidean distance and find pattern-based co-clusters with k = 20,l = 2. The results are averaged over 20 runs. One can see that ROCC gives almost perfect clustering, even with only 10% of the genes selected, significantly better than BCC and k -means.  ", "publication_ref": ["b14", "b11"], "figure_ref": ["fig_6"], "table_ref": []}, {"heading": "Concluding Remarks", "text": "In this paper, we have presented Robust Overlapping Co-clustering as a comprehensive framework capable of dealing with several challenges in clustering real life datasets. ROCC is robust to the presence of irrelevant data points and features, and discovers coherent co-clusters very accurately as illustrated in Section 6. Moreover, though ROCC requires several input parameters to be supplied, i.e., s r , s c , k and l, it is relatively very robust to the choice of these parameters because of the post-processing steps as detailed in Section 5.3. While in this paper we focused on clustering microarray data, it would be worthwhile to investigate the applicability of suitable instances of the ROCC framework to clustering problems in different domains like text mining and market basket analysis.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "A generalized maximum entropy approach to Bregman co-clustering and matrix approximation", "journal": "Jl. Machine Learning Research", "year": "2007", "authors": "A Banerjee; I Dhillon; J Ghosh; S Merugu; D Modha"}, {"ref_id": "b1", "title": "Bicat: a biclustering analysis toolbox", "journal": "Bioinformatics", "year": "2006", "authors": "S Barkow; S Bleuler; A Prelic; P Zimmermann; E Zitzler"}, {"ref_id": "b2", "title": "Discovering local structure in gene expression data: the order-preserving submatrix problem", "journal": "", "year": "2002", "authors": "A Ben-Dor; B Chor; R Karp; Z Yakhini"}, {"ref_id": "b3", "title": "Iterative signature algorithm for the analysis of largescale gene expression data", "journal": "Phys. Rev. E. Stat. Nonlin. Soft Matter Phys", "year": "2003", "authors": "S Bergmann; J Ihmels; N Barkai"}, {"ref_id": "b4", "title": "Biclustering of expression data", "journal": "Proc. Intell. Syst. Mol. Bio. '", "year": "2000", "authors": "Y Cheng; G M Church"}, {"ref_id": "b5", "title": "Co-clustering of human cancer microarrays using minimum sum-squared residue co-clustering", "journal": "IEEE/ACM Trans. on Comp. Bio. and Bioinfo", "year": "2008", "authors": "H Cho; I Dhillon"}, {"ref_id": "b6", "title": "", "journal": "", "year": "2008", "authors": "M Deodhar; H Cho; G Gupta; J Ghosh; I Dhillon"}, {"ref_id": "b7", "title": "A divisive information-theoretic feature clustering algorithm for text classification", "journal": "Jl. Machine Learning Research", "year": "2003", "authors": "I Dhillon; S Mallela; R Kumar"}, {"ref_id": "b8", "title": "Information-theoretic co-clustering", "journal": "", "year": "2003", "authors": "I Dhillon; S Mallela; D Modha"}, {"ref_id": "b9", "title": "A density-based algorithm for discovering clusters in large spatial databases with noise", "journal": "", "year": "1996", "authors": "M Ester; H Kriegel; J Sander; X Xu"}, {"ref_id": "b10", "title": "Genomic expression program in the response of yeast cells to environmental changes", "journal": "Molecular Cell Biology", "year": "2000", "authors": "A Gasch; P Spellman; C Kao;  Carmel-Harel"}, {"ref_id": "b11", "title": "Translation of microarray data into clinically relevant cancer diagnostic tests using gene expression ratios in lung cancer and mesothelioma", "journal": "Cancer Research", "year": "2002", "authors": "G J Gordon; R V Jensen; L Hsiao; S R Gullans"}, {"ref_id": "b12", "title": "Bregman bubble clustering: A robust, scalable framework for locating multiple, dense regions in data", "journal": "", "year": "2006", "authors": "G Gupta; J Ghosh"}, {"ref_id": "b13", "title": "Plaid models for gene expression data", "journal": "Statistica Sinica", "year": "2002", "authors": "L Lazzeroni; A B Owen"}, {"ref_id": "b14", "title": "Simultaneous feature selection and clustering using a mixture model", "journal": "IEEE Trans. PAMI", "year": "2004", "authors": "M Law; M Figueiredo; A K Jain"}, {"ref_id": "b15", "title": "A probabilistic functional network of yeast genes", "journal": "Science", "year": "2004", "authors": "I Lee; S Date; A Adai; E Marcotte"}, {"ref_id": "b16", "title": "Biclustering algorithms for biological data analysis: A survey", "journal": "", "year": "2004", "authors": "S C Madeira; A L Oliveira"}, {"ref_id": "b17", "title": "", "journal": "IEEE/ACM Trans. on Comp. Bio. and Bioinfo", "year": "", "authors": ""}, {"ref_id": "b18", "title": "Extracting conserved gene expression motifs from gene expression data", "journal": "Pacific Symposium on Biocomp", "year": "2003", "authors": "T Murali; S Kasif"}, {"ref_id": "b19", "title": "Subspace clustering for high dimensional data: a review", "journal": "SIGKDD Explor. Newsl", "year": "2004", "authors": "L Parsons; E Haque; H Liu"}, {"ref_id": "b20", "title": "A systematic comparison and evaluation of biclustering methods for gene expression data", "journal": "Bioinformatics", "year": "2006", "authors": "A Prelic; S Bleuler; P Zimmermann; A Wille"}, {"ref_id": "b21", "title": "Discovering statistically significant biclusters in gene expression data", "journal": "Bioinformatics", "year": "2002", "authors": "A Tanay; R Sharan; R Shamir"}, {"ref_id": "b22", "title": "Clustering by pattern similarity in large data sets", "journal": "", "year": "2002", "authors": "H Wang; W Wang; J Yang; P Yu"}, {"ref_id": "b23", "title": "Hierarchical grouping to optimize an objective function", "journal": "Jl. of American Stat. Assoc", "year": "1963", "authors": "J Ward"}, {"ref_id": "b24", "title": "Mining shifting-and-scaling co-regulation patterns on gene expression profiles", "journal": "", "year": "2006", "authors": "X Xu; Y Lu; A Tung; W Wang"}, {"ref_id": "b25", "title": "Discovering coherent biclusters from gene expression data using zero-suppressed binary decision diagrams", "journal": "IEEE/ACM Trans. on Comp. Bio. and Bioinfo", "year": "2005", "authors": "S Yoon; C Nardini; L Benini; G D Micheli"}, {"ref_id": "b26", "title": "Mining approximate order preserving clusters in the presence of noise", "journal": "", "year": "2008", "authors": "M Zhang; W Wang; J Liu"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 1 .1Figure 1. Nature of clusters identified by BCC and ROCC. Shaded areas represent clustered elements, rearranged according to cluster labels, while non-shaded areas denote discarded values.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "m\u00d7n , s r , s c , k, l, basis C, d \u03c6 Output: Set of co-clusters Step 1 Begin with a random co-clustering (\u03c1, \u03b3) Repeat Step (i): Update co-cluster models, \u2200[g] k 1 , [h] l 1 , Update statistics for co-cluster (g, h) based on basis C to compute new\u1e91 values Step (ii): Update \u03c1 (iia). \u2200[u] m 1 , \u03c1(u) = arg g min l h=1 v\u2208L:\u03b3(v)=h w uv d \u03c6 (z uv ,\u1e91 uv (g)) (iib). K = the set of s r rows with least error from among the m rows", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "the set of s c columns with least error from among the n columns until convergence Step 2: Post-process (see text for details) (i) Prune co-clusters with large errors. (ii) Merge similar co-clusters until stopping criterion is reached. return identified co-clusters.", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Figure 2 .2Figure 2. Pseudo-code for ROCC Meta-Algorithm", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "Figure 3 .3Figure 3. Comparison of ROCC with other co-clustering algorithms on the Lee and Gasch datasets. The number above each bar indicates the percentage of the data matrix entries clustered by each algorithm.", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_6", "figure_caption": "Figure 4 .4Figure 4. Lung Cancer data: sample clustering accuracy", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "Examples of biologically significant clusters found by ROCC on the Lee dataset.", "figure_data": "# genesCategory(Coverage)p-value20tRNA ligase (8/36)6.63e-1463ER membrane (14/84)3.886e-1420PF00270-DEAD (12/51)<1e-1412Glycolysis (8/16)<1e-1424PF00660-SRP1-TIP1 (22/30)<1e-14"}], "formulas": [{"formula_id": "formula_0", "formula_text": "k g=1 l h=1 u\u2208K:\u03c1(u)=g v\u2208L:\u03b3(v)=h w uv (z uv \u2212\u1e91 uv ) 2 , (1)", "formula_coordinates": [3.0, 317.52, 180.2, 223.96, 31.17]}, {"formula_id": "formula_1", "formula_text": "(iii): Update \u03b3 (iiia). \u2200[v] n 1 , \u03b3(v) = arg h min k g=1 u\u2208K:\u03c1(u)=g w uv d \u03c6 (z uv ,\u1e91 uv (h)) (iiib). L =", "formula_coordinates": [5.0, 62.83, 552.81, 190.78, 38.79]}, {"formula_id": "formula_2", "formula_text": "(j) = s r + \u230a(m \u2212 s r ) * \u03b2 j\u22121 row \u230b and s press c (j) = s c + \u230a(m \u2212 s c ) * \u03b2 j\u22121 col \u230b.", "formula_coordinates": [5.0, 307.44, 280.04, 234.02, 28.18]}], "doi": ""}