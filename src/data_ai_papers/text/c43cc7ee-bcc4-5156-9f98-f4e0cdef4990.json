{"title": "VisKoP: Visual Knowledge oriented Programming for Interactive Knowledge Base Question Answering", "authors": "Zijun Yao; Yuanyong Chen; Xin Lv; Shulin Cao; Amy Xin; Jifan Yu; Hailong Jin; Jianjun Xu; Peng Zhang; Lei Hou; Juanzi Li", "pub_date": "", "abstract": "We present Visual Knowledge oriented Programming platform (VisKoP), a knowledge base question answering (KBQA) system that integrates human into the loop to edit and debug the knowledge base (KB) queries. VisKoP not only provides a neural program induction module, which converts natural language questions into knowledge oriented program language (KoPL), but also maps KoPL programs into graphical elements. KoPL programs can be edited with simple graphical operators, such as \"dragging\" to add knowledge operators and \"slot filling\" to designate operator arguments. Moreover, VisKoP provides auto-completion for its knowledge base schema and users can easily debug the KoPL program by checking its intermediate results. To facilitate the practical KBQA on a million-entity-level KB, we design a highly efficient KoPL execution engine for the back-end. Experiment results show that VisKoP is highly efficient and user interaction can fix a large portion of wrong KoPL programs to acquire the correct answer. The VisKoP online demo 1 , highly efficient KoPL engine 2 , and screencast video 3  are now publicly available. * Equal contribution. \u2020 Corresponding author. 1 demoviskop.xlore.cn (Stable release of this paper) and viskop.xlore.cn (Beta release with new features).", "sections": [{"heading": "Introduction", "text": "Knowledge Base Question Answering (KBQA) aims to find answers to factoid questions with an external Knowledge Base (KB). Researchers have fully explored the KBQA (Lan et al., 2021) task and the most common solution is to convert userposed natural language questions into KB query programs via semantic parsing and then give a final result by executing queries on the KB, such as SPARQL (Mihindukulasooriya et al., 2020;Gu et al., 2021), \u03bb-DCS (Wang et al., 2015;Shin et al., 2021), and KoPL (Cao et al., 2022a,b). Recently, many KBQA systems (H\u00f6ffner et al., 2013;Cui et al., 2016;Abdelaziz et al., 2021; that implement those advanced semantic parsing algorithms in an online environment, have been developed.\nAlthough semantic parsing methods have gained considerable achievement, there is still no guarantee to precisely parse every user-posed question given the limitations of current machine learning techniques. Figure 1 demonstrates an example of semantic parsing results by the state-of-the-art KBQA model (Cao et al., 2022a). As the posed question does not follow the identical distribution of the training dataset adopted by the semantic parsing model (Shaw et al., 2021;Yin et al., 2021), it is falsely parsed with the Or operator, which should be an And operator, causing the structure error of the KB query. Meanwhile, it is extremely difficult for the semantic parsing model to correctly predict all the knowledge elements in a question (Cao et al., 2022b). As shown in the example, the \"shares border with\" relation is falsely predicted as a \"statement is subject of\" relation, causing an argument error in the KB query. However, existing KBQA systems do not provide easy access to manipulating the KB query programs and thus users cannot intervene in the query execution.\nFortunately, several program-based KB query languages for complex reasoning consisting of modularized operators have come up, making KBQA easy to visualize . With applicable visual representation of KB queries, intended users are capable of identifying errors in the programs generated by semantic parsing and correct them. Based on these observations, we raise a natural question: How to design a visualized KBQA system that eases users to inspect and debug those KB query programs?\nPresented System. We demonstrate Visual Knowledge oriented Programming (VisKoP) platform, an interactive, visualized and program-based KBQA system. VisKoP provides an interactive knowledge oriented programming environment, allowing users to monitor and debug the KB queries with graphical operators. In comparison with existing KBQA systems, VisKoP is easier to use due to its following characteristics:\n\u2022 Knowledge oriented programming. VisKoP is the first KBQA system to support Knowledge oriented Programming Language (KoPL) (Cao et al., 2022a). As a program-based KB query language, KoPL provides modularized program style for users to interact with knowledge elements, within its wide range of knowledge operators. Besides, KoPL can be converted into various different KB query languages via GraphQ IR (Nie et al., 2022).\n\u2022 Visualized interface. VisKoP maps programming with KoPL into a series of graphical operations-\"dragging\" to add new knowledge operators, \"connecting\" the knowledge operators to add dependencies, and \"slot-filling\" to specify knowledge arguments. We conduct user study and find that with the help of the visualized programming interface, users can find the correct answer in an average 110.6 seconds, which alleviates the problem caused by error-prone semantic parsing algorithms. Meanwhile, our efficiency study shows that the execution engine is significantly faster than the original KoPL engine and Virtuoso by 16\u00d7 and 5\u00d7, respectively.\nContributions.\n(1) We design a visualized knowledge oriented programming platform for KBQA, which integrates human into the loop to write and debug KB queries. (2) We implement a high performing KoPL execution engine that scales KoPL to an up-to-date million-entity-level KB.\nThe development and deployment of VisKoP validates the effectiveness of allowing questioners to monitor the error in the KB queries. The visual programming platform provides external human guidance on the neural program induction model, and potentially improves the robustness the system.", "publication_ref": ["b12", "b15", "b9", "b23", "b22", "b10", "b8", "b4", "b20", "b28", "b5", "b4", "b18"], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "Preliminaries", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Knowledge Base", "text": "As defined by KoPL (Cao et al., 2022a), KB consists of 4 kinds of basic knowledge elements: Entities are unique objects that are identifiable in the real world, e.g., Germany. Concepts are sets of entities that have some characteristics in common, e.g., Country. Relations depict the relationship between entities or concepts. Entities are linked to their concepts via relation instance of, while concept hierarchy is organized via relation subclass of. Attributes link entities to data value descriptions, e.g., day of birth. Attributes can be further classfied into 4 types: date, year, string, and numbers.\nThese knowledge elements are further organized into 3 kinds of structured representation in triplets: Relational knowledge are triplets organized as (head entity, relation, tail entity). Literal knowledge are triplets organized as (entity, attribute, value). Qualifier knowledge are bound with relational or literal knowledge to specify under which condition they are true. The qualifiers are organized as (relational/attribute knowledge, attribute, value). ", "publication_ref": ["b4"], "figure_ref": [], "table_ref": []}, {"heading": "Interactive Programming Interface", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Knowledge Base Question Answering", "text": "KBQA provides a natural-language-based interface for users to access knowledge in the KB. It inputs a natural language question q = {q 1 , . . . , q n }, where q i is the i th word, and outputs the answer utterance a. The answer is either the knowledge elements (e.g., entity name) in the KB, or the result of a combination of logical or algebraic operations performed on the knowledge elements.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "KoPL", "text": "KoPL stands for knowledge oriented programming language consisting of 26 different knowledge operators. Natural language questions can be presented as KoPL programs, which are constructed as connected knowledge operators. Each operator has two categories of input: operator argument(s), and dependency input(s). Operator arguments are instructions on how to perform the operator, which are usually determined by the semantics of the question; Dependency inputs are outputs of previous knowledge operators that are linked to the current operator. For example, in Figure 1, operator Relate(shares border with, forward) has two arguments-shares border with and forward, while the dependency input comes from the Find operator. KoPL programs can be executed on the background KB to obtain the answer. More details are included in Appendix A.\nOne essential characteristic of KoPL is that, as modularized knowledge operators, the intermediate result of each operator is preserved and can thus be inspected and debugged. Given the modularity and inspectability of KoPL, we design the VisKoP platform, as described below.", "publication_ref": [], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "The VisKoP Platform", "text": "The implementation of our VisKoP platform focuses on 4 designing principles: I. Graphical Element Visualization: Userposed questions should be parsed into the KoPL program, and shown as graphical elements.\nII. Interactive Programming: The system needs to enable users to edit and correct the KoPL program with knowledge schema auto-completion and intermediate results demonstration.\nIII. Highly Efficient Execution: The system should support large scale KBs for practical usage with low execution latency.\nIV. Transparent Execution: The execution footprint of each operator should be preserved for inspection within interactive programming.\nIn particular, the first two principles are undertaken by the interactive programming interface in the front-end and the last two principles are undertaken by the highly efficient KoPL program execution engine in the back-end. The overall architecture of VisKoP is shown in Figure 2.\nThe implemented VisKoP is deployed as an openly available website 1 . The highly efficient KoPL execution engine is also provided as an opensource Python extension toolkit 2 .", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Interactive Programming Interface", "text": "Graphical Element Visualization. VisKoP allows users to ask natural language questions and parse them into KoPL programs instead of writing KoPL programs from scratch. The process is carried out by a neural program induction module, as shown in Figure 2, whose backbone is a sequenceto-sequence pre-trained language model. Here we choose BART (Lewis et al., 2020) as the backbone and fine-tune it on the KQA Pro dataset (Cao et al., 2022a). It accepts natural language questions as input, and output the KoPL program in the depth first search order. The KoPL programs are converted to meet the format of sequence generation.\nVisKoP visualizes KoPL program as a tree structure in the editing panel, where the nodes in the tree are knowledge operators with arguments. Argument inputs are modeled as filling slots in the knowledge operators and dependency inputs are modeled as directed edges between different knowledge operators. We define 3 kinds of graphical actions that users may take within the KoPL program: dragging to add new operators, linking to indicate knowledge elements flow, and slot-filling to designate arguments of the knowledge operators.\nInteractive Programming. For users that are less skilled at KoPL programming or less familiar with the schema of the underlying KB, VisKoP implements a series of auxiliary functions. Firstly, the KB schema is mainly associated with arguments of the knowledge operators. VisKoP helps to autocomplete knowledge elements via string matching when users try to fill in the argument slots. Next, to ensure the grammatical correctness of the KoPL program whose users submit to run, we implement linking legitimacy checking. VisKoP warns users when the the submitted program is not a tree or the dependency is illegal (e.g., The output of the Count operator cannot be input to the QFilterStr operator). Finally, intermediate execution results of each knowledge operator are returned from the back-end and presented on the visualized interface where users may debug their KoPL program.", "publication_ref": ["b13", "b4"], "figure_ref": [], "table_ref": []}, {"heading": "Highly Efficient KoPL Engine", "text": "The highly efficient KoPL engine is responsible for most parts of the back-end by reading the KoPL program as input and outputing the answer.\nHighly Efficient Execution. KoPL program execution should be highly efficient for supporting large-scale KBs. Towards this goal, we adopt three implementation strategies: inverted indices construction, knowledge operators merging, and data structure optimization.\nThe first step is to construct inverted indices, which maps different types of attribute values and relations to their involved entities. These inverted indices prevent knowledge operators from enumerating over all the entities in the KB to recall corresponding knowledge elements. Subsequently, the great deal of time consumed by the engine to filter out entities satisfying certain constraint from the overall KB comes to our attention. This is represented by consecutive FindAll operator and filtering operators (e.g., FilterStr). We propose to merge the two consecutive operators and construct corresponding inverted indices. Finally, for all key-value pair data structures, we use the running time of the questions in the KQA Pro dataset on the millionentity level KB as the metric, to greedily search out the optimal storage structure. The searching space contains hash map, red-black tree, trie tree, and ternary search tree.\nTransparent Execution. Showing the intermediate results in the front-end requires the execution engine to preserve the outputs of each operator in the KoPL program and use them to monitor the behavior of the knowledge query. Meanwhile, users can debug the input KoPL program by inspecting the intermediate results to locate the bug.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Usage Example", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Interactive Programming Interface", "text": "The online website of VisKoP is illustrated in Figure 3. We give an example of how to interact with the system to obtain the correct answer by questioning \"How many countries share borders with both Germany and France?\", which cannot be correctly parsed by the semantic parsing algorithm.\nNeural program induction. VisKoP accepts KB queries in natural language. The users input the question in the input box on the top of the website. Clicking on the Parse button parses the natural language question into its corresponding KoPL program, to be displayed on the editing panel at the bottom of the website. The predicted answer is shown by clicking the Run button in the top of the editing panel. Here, VisKoP provides the common functionality as a KBQA system.\nKoPL program debugging. As shown by Figure 3, users can easily identify two errors. One issue comes from the structural aspect. The answer should be counted on the intersection of two sets of country, each sharing border with Germany and France, respectively. To replace the operator Or with the operator And, users may first click on the Or operator for selection, and then press the backspace key to delete it. The And operator is added by selecting Add in the drop-down box and clicking on the button. By linking the new operator to its dependency operators and the output operator, users can easily fix the structural error.\nThe other issue is the falsely recognized argument for the Relate operator. The desired countries should share borders with Germany, rather than the statement is subject of relation. The relation name specified by the KB schema is auto-completed in the pop-up drop down box, as shown in Figure 4.", "publication_ref": [], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "4", "text": "How many countries share borders with both Germany and France? Figure 3: Screenshot of the interactive programming interface of VisKoP. When user tries to parse \"How many countries share borders with both Germany and France?\", the semantic parsing algorithm falsely predict the Or operator, and one of the argument inputs of the Relate operator. This further results in the wrong answer \"17\". We marked this errors in the red box, and put the correct graphical elements in the nearby green box.  ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "KoPL Engine", "text": "The high performing KoPL engine incorporated in the back-end is developed as an independent extension for Python. It provides one line installation code from the command line by running \"pip install kopl-engine\". Users can execute the KoPL program using the scripts provided at the end of this section.\nUsers are first required to provide the KB in JSON file per the request by KoPL 4 . The execution 4 https://kopl.xlore.cn/en/doc/4_helloworld engine is initialized by converting the KB into data structure in the memory and constructing all the indices. Before executing the KoPL program, the engine parses the program represented in Python data structure (See Appendix B for the data structure introduction.) into the data structure used inside the engine. After that, users can call the forward method of the engine to get execution results. ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Evaluation", "text": "We evaluate the execution efficiency of the backend KoPL engine. We also perform user study and case study to examine the limitations of VisKoP.  Experimental setup. We use the training data of KQA Pro (Cao et al., 2022a) as the test-bed, which contains 94,376 quries in both KoPL and SPARQL program. We compare VisKoP against the original KoPL engine released by Cao et al. (2022a). We also compare it with Virtuoso for the SPARQL queries. All experiments are conducted on a single Intel Xeon 5218R CPU with 1.0TB RAM. We use wall time as the comparison metric.   The averaged running time is reported in Table 2. VisKoP is almost 16\u00d7 faster than the original KoPL engine and 5\u00d7 faster than Virtuoso executing equivalent SPARQL queries. We also show the running time distribution of VisKoP and Virtuoso in Figure 5. VisKoP is faster than Virtuoso because: (1) The distribution peak of VisKoP comes smaller than Virtuoso; (2) The maximum running time of VisKoP is much smaller than Virtuoso.", "publication_ref": ["b4", "b4"], "figure_ref": ["fig_3"], "table_ref": ["tab_7"]}, {"heading": "5.1", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "User Study and Case Study", "text": "We manually annotate 20 natural language questions which cannot be correctly answered without user correction and ask 6 different users to use VisKoP to find the answer. After users interact with VisKoP, the accuracy rate reaches 65.8%, with an average of 110.7 seconds per question and a median of 68.0 seconds. These results indicate that integrating human into the loop significantly broadens the boundaries of the KBQA system's capabilities. Meanwhile, apart from knowledge elements not included in the KB, there are still questions that are extremely difficult to answer due to their obscure knowledge elements. For example, to answer \"How many video game is SONY published in 2020?\", one need to find the Sony Interactive Entertainment entity rather than the Sony, which also occurs in the KB and our testers can hardly find the Sony Interactive Entertainment entity.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Related Works", "text": "In general, KBQA methods can be grouped into two categories: 1) semantic parsing (Berant et al., 2013;Yih et al., 2015;Cheng et al., 2017;Liang et al., 2017;Cao et al., 2022b), which translates natural language questions into logical forms, whose execution on the KB achieves the answer; 2) information retrieval (Bordes et al., 2014;Xu et al., 2016;Miller et al., 2016;Shi et al., 2021;Zhang et al., 2022), which ranks the entities from the retrieved question-specific sub-KB to get the answer. Our VisKoP falls into the semantic parsing category. Specifically, VisKoP translates a question into the multi-step program, pertaining to the neural program induction (NPI) paradigm (Lake et al., 2015;Neelakantan et al., 2017;Liang et al., 2017;Wong et al., 2021;Cao et al., 2022a).\nThe main challenge of NPI is that questionprogram parallel data are expensive to obtain and the program's huge search space makes the learning challenging. Existing works tackle this issue only by learning from question-answer pairs with various reinforcement learning techniques (Liang et al., 2017; or synthesizing questionprogram data to alleviate the data scarcity problem (Cao et al., 2022a;Gu et al., 2021). In this paper, our VisKoP proposes a different solution to this task by integrating humans into the program induction loop, providing external human guidance to program induction model, and potentially improving the system robustness.\nCompared with other KBQA systems, including ReTraCk , SEMPRE (Berant et al., 2013), TRANX (Yin and Neubig, 2018), DTQA (Abdelaziz et al., 2021), our VisKoP is the first to enable users to interact with the system via a visual platform and intermediate results checking.", "publication_ref": ["b2", "b27", "b7", "b14", "b5", "b3", "b25", "b16", "b21", "b30", "b11", "b17", "b14", "b24", "b4", "b14", "b4", "b9", "b2", "b29"], "figure_ref": [], "table_ref": []}, {"heading": "Conclusion and Future Work", "text": "We demonstrate VisKoP, a KBQA platform that allows users to monitor, edit, and debug KB queries. VisKoP is also accompanied with a highly efficient engine that scales KoPL execution to a millionentity-level KB. In the future, it is intriguing to allow users to customize the KB. It is also important to provide guidance for users to recognize the true knowledge elements in the large scale KB.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Limitations", "text": "As a KBQA system, VisKoP is still highly dependent on the correctness and broad knowledge coverage of the background KB. It is extremely difficult to find the correct answer when the relevant knowledge elements are unincluded or incorrect in the KB. Also, if there are confusing knowledge elements, as we mention in Section 5.2 that users can hardly identify the Sony Interactive Entertainment entity, it is difficult for users to correct the KoPL program.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Ethics Statement", "text": "Intended Use. VisKoP is designed for users to edit their knowledge base queries with graphical elements.\nPotential Misuse. As we count, there are 339, 531 human female entities and 1, 458, 903 male entities in total. It can lead to gender biased answers on the grounds that a number of females do not exist in the KB. This problem stems from the imbalanced data (Wikidata), and can be solved when Wikidata includes more female entities. Therefore, it's important to allow users to debug the knowledge base in future work.\nData. The VisKoP is built on a high-quality subset of Wikidata, which attributes to the intelligence of the crowd.\nUser Study. The participants in the user study part are volunteers recruited from graduate students majoring in engineering. Before the user study experiments, all participants are provided with detailed guidance in both written and oral form. The only recorded user-related information is usernames, which are anonymized and used as identifiers to mark different participants.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "A KoPL Definition", "text": "The functions used in this paper are the same as those mentioned in Cao et al. (2022a), so we will not devote a great deal of space for details. The specific meaning of each function can be found in (Cao et al., 2022a) or on our website 6 . Here we only briefly introduce the philosophy of these operators: Query Operators find and return the knowledge elements in the KB by matching their names. e.g., Find returns the corresponding entities according to the input entity name. Filter Operators take a set of knowledge elements as input, and keep the knowledge elements that satisfy the given conditions as output. e.g., Filter-Concept takes a set of entities as input and output entities that belong to a given concept. Verification Operators are used to determine whether the output of the previous function has some relationship to the given value. This type of operators is often used to answer judgement questions. e.g., VerifyNum can judge whether the function output is greater than (less than, equal to) a given value. Selection Operators select some knowledge elements from the output of previous function under the given condition. e.g., SelectAmong can select the entity with the largest or smallest value of an attribute from a given set. Set Operators do inter-set operations on the output of two functions. e.g., And can take the union of two sets.", "publication_ref": ["b4", "b4"], "figure_ref": [], "table_ref": []}, {"heading": "B KoPL Program Format", "text": "In python, each knowledge operator is represented as a Dict in Python with three keys: function corresponds to the name of the knowledge operator. inputs corresponds to the argument inputs of the knowledge operator. And dependencies corresponds to the dependency inputs of the knowledge operator. For example, KoPL program in Figure 3 can be represented as: ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "C Questions for User Study", "text": "We list the 20 questions used in the user study and the corresponding answers in Table 3.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgments", "text": "This work is supported by National Key R&D Program of China (2020AAA0105203), and a grant from the Institute for Guo Qiang, Tsinghua University (2019GQB0003)", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "2021. A semantic parsing and reasoning-based approach to knowledge base question answering", "journal": "", "year": "", "authors": "Ibrahim Abdelaziz; Srinivas Ravishankar; Pavan Kapanipathi; Salim Roukos; Alexander G Gray"}, {"ref_id": "b1", "title": "Neural program induction for KBQA without gold programs or query annotations", "journal": "", "year": "2019-08-10", "authors": "Amrita Ghulam Ahmed Ansari; Vishwajeet Saha; Mohan Kumar; Karthik Bhambhani; Soumen Sankaranarayanan;  Chakrabarti"}, {"ref_id": "b2", "title": "Semantic parsing on Freebase from question-answer pairs", "journal": "", "year": "2013", "authors": "Jonathan Berant; Andrew Chou; Roy Frostig; Percy Liang"}, {"ref_id": "b3", "title": "Question answering with subgraph embeddings", "journal": "", "year": "2014", "authors": "Antoine Bordes; Sumit Chopra; Jason Weston"}, {"ref_id": "b4", "title": "KQA pro: A dataset with explicit compositional programs for complex question answering over knowledge base", "journal": "", "year": "2022", "authors": "Shulin Cao; Jiaxin Shi; Liangming Pan; Lunyiu Nie; Yutong Xiang; Lei Hou; Juanzi Li; Bin He; Hanwang Zhang"}, {"ref_id": "b5", "title": "Program transfer for answering complex questions over knowledge bases", "journal": "", "year": "2022", "authors": "Shulin Cao; Jiaxin Shi; Zijun Yao; Xin Lv; Jifan Yu; Lei Hou; Juanzi Li; Zhiyuan Liu; Jinghui Xiao"}, {"ref_id": "b6", "title": "ReTraCk: A flexible and efficient framework for knowledge base question answering", "journal": "", "year": "2021", "authors": "Shuang Chen; Qian Liu; Zhiwei Yu; Chin-Yew Lin; Jian-Guang Lou; Feng Jiang"}, {"ref_id": "b7", "title": "Learning structured natural language representations for semantic parsing", "journal": "Long Papers", "year": "2017", "authors": "Jianpeng Cheng; Siva Reddy; Vijay Saraswat; Mirella Lapata"}, {"ref_id": "b8", "title": "KBQA: an online template based question answering system over freebase", "journal": "IJCAI/AAAI Press", "year": "2016-07-15", "authors": "Wanyun Cui; Yanghua Xiao; Wei Wang"}, {"ref_id": "b9", "title": "Beyond iid: three levels of generalization for question answering on knowledge bases", "journal": "", "year": "2021", "authors": "Yu Gu; Sue Kase; Michelle Vanni; Brian Sadler; Percy Liang; Xifeng Yan; Yu Su"}, {"ref_id": "b10", "title": "Tbsl question answering system demo", "journal": "", "year": "2013", "authors": "K H\u00f6ffner; L Unger;  B\u00fchmann;  Lehmann;  Ngomo; P Gerber;  Cimiano"}, {"ref_id": "b11", "title": "Human-level concept learning through probabilistic program induction", "journal": "Science", "year": "2015", "authors": "B Lake; R Salakhutdinov; J Tenenbaum"}, {"ref_id": "b12", "title": "A survey on complex knowledge base question answering: Methods, challenges and solutions", "journal": "", "year": "2021", "authors": "Yunshi Lan; Gaole He; Jinhao Jiang; Jing Jiang; Wayne Xin Zhao; Ji Wen"}, {"ref_id": "b13", "title": "BART: Denoising sequence-to-sequence pre-training for natural language generation, translation, and comprehension", "journal": "", "year": "2020", "authors": "Mike Lewis; Yinhan Liu; Naman Goyal; Marjan Ghazvininejad; Abdelrahman Mohamed; Omer Levy; Veselin Stoyanov; Luke Zettlemoyer"}, {"ref_id": "b14", "title": "Neural symbolic machines: Learning semantic parsers on Freebase with weak supervision", "journal": "Association for Computational Linguistics", "year": "2017", "authors": "Chen Liang; Jonathan Berant; Quoc Le; Kenneth D Forbus; Ni Lao"}, {"ref_id": "b15", "title": "Leveraging semantic parsing for relation linking over knowledge bases", "journal": "", "year": "2020", "authors": "Nandana Mihindukulasooriya; Gaetano Rossiello; Pavan Kapanipathi; Ibrahim Abdelaziz; Srinivas Ravishankar; Mo Yu; Alfio Gliozzo; Salim Roukos; Alexander Gray"}, {"ref_id": "b16", "title": "Key-value memory networks for directly reading documents", "journal": "Association for Computational Linguistics", "year": "2016", "authors": "Alexander Miller; Adam Fisch; Jesse Dodge;  Amir-Hossein; Antoine Karimi; Jason Bordes;  Weston"}, {"ref_id": "b17", "title": "Learning a natural language interface with neural programmer", "journal": "", "year": "2017-04-24", "authors": "Arvind Neelakantan; V Quoc; Mart\u00edn Le; Andrew Abadi; Dario Mccallum;  Amodei"}, {"ref_id": "b18", "title": "GraphQ IR: Unifying the semantic parsing of graph query languages with one intermediate representation", "journal": "", "year": "2022", "authors": "Lunyiu Nie; Shulin Cao; Jiaxin Shi; Jiuding Sun; Qi Tian; Lei Hou; Juanzi Li; Jidong Zhai"}, {"ref_id": "b19", "title": "Complex program induction for querying knowledge bases in the absence of gold programs", "journal": "Transactions of the Association for Computational Linguistics", "year": "2019", "authors": "Amrita Saha; Ghulam Ahmed Ansari; Abhishek Laddha; Karthik Sankaranarayanan; Soumen Chakrabarti"}, {"ref_id": "b20", "title": "Compositional generalization and natural language variation: Can a semantic parsing approach handle both?", "journal": "", "year": "2021", "authors": "Peter Shaw; Ming-Wei Chang; Panupong Pasupat; Kristina Toutanova"}, {"ref_id": "b21", "title": "TransferNet: An effective and transparent framework for multi-hop question answering over relation graph", "journal": "Association for Computational Linguistics", "year": "2021", "authors": "Jiaxin Shi; Shulin Cao; Lei Hou; Juanzi Li; Hanwang Zhang"}, {"ref_id": "b22", "title": "Constrained language models yield few-shot semantic parsers", "journal": "Association for Computational Linguistics", "year": "2021", "authors": "Richard Shin; Christopher Lin; Sam Thomson; Charles Chen; Subhro Roy; Adam Emmanouil Antonios Platanios; Dan Pauls; Jason Klein; Benjamin Eisner;  Van Durme"}, {"ref_id": "b23", "title": "Building a semantic parser overnight", "journal": "Association for Computational Linguistics", "year": "2015", "authors": "Yushi Wang; Jonathan Berant; Percy Liang"}, {"ref_id": "b24", "title": "Leveraging language to learn program abstractions and search heuristics", "journal": "PMLR", "year": "2021-07-24", "authors": "Catherine Wong; Kevin Ellis; Joshua B Tenenbaum; Jacob Andreas"}, {"ref_id": "b25", "title": "Question answering on Freebase via relation extraction and textual evidence", "journal": "", "year": "2016", "authors": "Kun Xu; Siva Reddy; Yansong Feng; Songfang Huang; Dongyan Zhao"}, {"ref_id": "b26", "title": "Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics", "journal": "Association for Computational Linguistics", "year": "", "authors": ""}, {"ref_id": "b27", "title": "Semantic parsing via staged query graph generation: Question answering with knowledge base", "journal": "Association for Computational Linguistics", "year": "2015", "authors": "Ming-Wei Wen-Tau Yih; Xiaodong Chang; Jianfeng He;  Gao"}, {"ref_id": "b28", "title": "Compositional generalization for neural semantic parsing via spanlevel supervised attention", "journal": "", "year": "2021", "authors": "Pengcheng Yin; Hao Fang; Graham Neubig; Adam Pauls; Yu Emmanouil Antonios Platanios; Sam Su; Jacob Thomson;  Andreas"}, {"ref_id": "b29", "title": "TRANX: A transition-based neural abstract syntax parser for semantic parsing and code generation", "journal": "Association for Computational Linguistics", "year": "2018", "authors": "Pengcheng Yin; Graham Neubig"}, {"ref_id": "b30", "title": "Subgraph retrieval enhanced model for multi-hop knowledge base question answering", "journal": "", "year": "2022", "authors": "Jing Zhang; Xiaokang Zhang; Jifan Yu; Jian Tang; Jie Tang; Cuiping Li; Hong Yan; Chen "}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 1 :1Figure1: Semantic parsing results for natural language question \"How many countries share borders with Germany and France?\" given by state-of-the-art model trained on KQA Pro. Errors are marked in red color.", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 4 :4Figure 4: Left: Screenshot of the auto-completion in slot-filling. Right: Screenshot of the intermediate result of the And operator, which shows the satisfied countries.", "figure_data": ""}, {"figure_label": "5", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Figure 5 :5Figure 5: Running time distribution.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "6https://kopl.xlore.cn/en/doc/2_function.html 1 program = {[", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "", "figure_data": "ProgramMerging OperatorsInvertedIndicesSearch Inverted IndicesAnswerGenerate (Intermediate) ResultKnowledge BaseFigure 2: The overall system architecture of VisKoP."}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_5", "figure_caption": "Efficiency KB preparation. VisKoP is deployed on a millionentity-level KB extracted from Wikidata. In particular, we use the original Wikdiata dump 5 and only keep the entities that have a Wikipedia page. The statistics is shown in Table 1.", "figure_data": "# Entity # Concept # Relation # Attribute6,284,26968,2611,0801,352"}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_6", "figure_caption": "Statistics of the knowledge base.", "figure_data": ""}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_7", "figure_caption": "Running time averaged over all the queries.", "figure_data": ""}], "formulas": [], "doi": "10.24963/ijcai.2019/679"}