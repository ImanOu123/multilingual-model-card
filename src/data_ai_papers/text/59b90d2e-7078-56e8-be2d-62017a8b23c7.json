{"title": "From Conjunctive Queries to Instance Queries in Ontology-Mediated Querying", "authors": "Cristina Feier; Carsten Lutz; Frank Wolter", "pub_date": "", "abstract": "We consider ontology-mediated queries (OMQs) based on expressive description logics of the ALC family and (unions) of conjunctive queries, studying the rewritability into OMQs based on instance queries (IQs). Our results include exact characterizations of when such a rewriting is possible and tight complexity bounds for deciding rewritability. We also give a tight complexity bound for the related problem of deciding whether a given MMSNP sentence is equivalent to a CSP.", "sections": [{"heading": "Introduction", "text": "An ontology-mediated query (OMQ) is a database-style query enriched with an ontology that contains domain knowledge, aiming to deliver more complete answers [Calvanese et al., 2009;Bienvenu et al., 2014;Bienvenu and Ortiz, 2015]. In OMQs, ontologies are often formulated in a description logic (DL) and query languages of interest include conjunctive queries (CQs), unions of conjunctive queries (UCQs), and instance queries (IQs). While CQs and UCQs are widely known query languages that play a fundamental role also in database systems and theory, IQs are more closely linked to DLs. In fact, an IQ takes the form C(x) with C a concept formulated in the DL that is also used for the ontology, and thus the expressive power of IQs depends on the ontology language. OMQs based on (U)CQs are more powerful than OMQs based on IQs as the latter only serve to return all objects from the data that are instances of a given class.\nIt is easy to see that IQs can express tree-shaped CQs with a single answer variable as well as unions thereof. In fact, this observation has been used in many technical constructions in the area, see for example [Calvanese et al., 1998;Glimm et al., 2008;Lutz, 2008;Eiter et al., 2012a]. Intriguingly, though, it was observed by Zolin [2007] that treeshaped CQs are not the limit of IQ-rewritability when we have an expressive DL such as ALC or ALCI at our disposal. For example, the CQ r(x, x), which asks to return all objects from the data that are involved in a reflexive r-loop, can be rewritten into the equivalent ALC-IQ P \u2192 \u2203r.P (x). Here, P behaves like a monadic second-order variable due to the open-world assumption made for OMQs: we are free to interpret P in any possible way and when making P true at an object we are forced to make also \u2203r.P true if and only if the object is involved in a reflexive r-loop. It is an interesting question, raised in [Zolin, 2007;Kikot and Zolin, 2013;Kikot et al., 2013], to precisely characterize the class of CQs that are rewritable into IQs. An important step into this direction has been made by Kikot and Zolin [2013] who identify a large class of CQs that are rewritable into IQs: a CQ is rewritable into an ALCI-IQ if it is connected and every cycle passes through the (only) answer variable; for rewritability into an ALC-IQ, one additionally requires that all variables are reachable from the answer variable in a directed sense. It remained open whether these classes are depleting, that is, whether they capture all CQs that are IQ-rewritable.\nThere are two additional motivations to study the stated question. The first one comes from concerns about the practical implementation of OMQs. When the ontology is formulated in a more inexpressive 'Horn DL', OMQ evaluation is possible in PTIME data complexity and a host of techniques for practically efficient OMQ evaluation is available, see for example [P\u00e9rez-Urbina et al., 2010;Eiter et al., 2012b;Trivela et al., 2015;Lutz et al., 2009]. In the case of expressive DLs such as ALC and ALCI, OMQ evaluation is CONP-complete in data complexity and efficient implementation is much more challenging. In particular, there are hardly any systems that fully support such OMQs when the actual queries are (U)CQs. In contrast, the evaluation of OMQs based on (expressive DLs and) IQs is supported by several systems such as Pellet, Hermit, and PAGOdA [Sirin et al., 2007;Glimm et al., 2014;Zhou et al., 2015]. For this reason, rewriting (U)CQs into IQs has been advocated in [Zolin, 2007;Kikot and Zolin, 2013;Kikot et al., 2013] as an approach towards efficient OMQ evaluation with expressive DLs and (U)CQs. The experiments and optimizations reported in [Kikot et al., 2013] show the potential (and challenges) of this approach.\nThe second motivation stems from the connection between OMQs and constraint satisfaction problems (CSPs) [Bienvenu et al., 2014;Lutz and Wolter, 2017]. Let (L, Q) denote the class of OMQs based on ontologies formulated in the DL L and the query language Q. It was observed in [Bienvenu et al., 2014] that (ALCI, IQ) is closely related to the complement of CSPs while (ALCI, UCQ) is closely related to the complement of the logical generalization MMSNP of CSP; we further remark that MMSNP is a notational variant of the complement of (Boolean) monadic disjunctive Datalog. Thus, characterizing OMQs from (ALCI, UCQ) that are rewritable into (ALCI, IQ) is related to characterizing MM-SNP sentences that are equivalent to a CSP, and we also study the latter problem. In fact, the main differences to the OMQ case are that unary queries are replaced with Boolean ones and that predicates can have unrestricted arity.\nThe main aim of this paper is to study the rewritability of OMQs from (L, (U)CQ) into OMQs from (L, IQ), considering as L the basic expressive DL ALC as well as extensions of ALC with inverse roles, role hierarchies, the universal role, and functional roles. We provide precise characterizations, tight complexity bounds for deciding whether a given OMQ is rewritable, and show how to construct the rewritten query when it exists. In fact, we prove that the classes of CQs from [Kikot and Zolin, 2013] are depleting, but we go significantly beyond that: while [Zolin, 2007;Kikot and Zolin, 2013;Kikot et al., 2013] aim to find IQ-rewritings that work for any ontology, we consider the more fine-grained question of rewriting into an IQ an OMQ (T , \u03a3, q(x)) where T is a DL TBox formalizing the ontology, \u03a3 is an ABox signature, and q(x) is the actual query. The 'any ontology' setup then corresponds to the special case where T is empty and \u03a3 is full. However, gaving a non-empty TBox or a non-full ABox signature results in additional (U)CQs to become rewritable. While we admit modification of the TBox during rewriting, it turns out that this is mostly unnecessary: only in some rather special cases, a moderate extension of the TBox pays off. All this requires non-trivial generalizations of the query classes and IQ-constructions from [Kikot and Zolin, 2013]. Our completeness proofs involve techniques that stem from the connection between OMQs and CSP such as a lemma about ABoxes of high girth due to Feder and Vardi [1998]. The rewritings we construct are of polynomial size when we work with the empty TBox, but can otherwise become exponential in size.\nRegarding IQ-rewritability as a decision problem, we show NP-completeness for the case of the empty TBox. This can be viewed as an underapproximation for the case with non-empty TBox and ABox signature. With non-empty TBoxes, complexities are higher. When the ABox signature is full, we obtain 2EXPTIME-completeness for DLs with inverse roles and an EXPTIME lower bound and a CONEX-PTIME upper bound for DLs without inverse roles. With unrestricted ABox signature, the problem is 2NEXPTIMEcomplete for DLs with inverse roles and NEXPTIME-hard (and in 2NEXPTIME) for DLs without inverse roles. All lower bounds hold for CQs and all upper bounds capture UCQs. We also prove that it is 2NEXPTIME-complete to decide whether a given MMSNP sentence is equivalent to a CSP. This problem was known to be decidable [Madelaine and Stewart, 2007], but the complexity was open.\nWe also consider ALCIF , the extension of ALCI with functional roles, for which IQ-rewritability turns out to be undecidable and much harder to characterize. We give a rather subtle characterization for the case of the empty TBox and full ABox signature and show that the decision problem is then decidable and NP-complete. Since it is not clear how to apply CSP techniques, we use an approach based on ultrafil-ters, starting from what was done for ALC without functional roles in [Kikot and Zolin, 2013].\nFull proofs are in the appendix, available at http://www. informatik.uni-bremen.de/tdki/research/papers.html.", "publication_ref": ["b0", "b0", "b0", "b0", "b0", "b1", "b0", "b0", "b0", "b0", "b2", "b0", "b2", "b0", "b0", "b0", "b0", "b0", "b0", "b0", "b0", "b0", "b0", "b0", "b0", "b2", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "Preliminaries", "text": "We use standard description logic notation and refer to [Baader et al., 2017] for full details. In contrast to the standard DL literature, we carefully distinguish between the concept language and the TBox language. We consider four concept languages. Recall that ALC-concepts are formed according to the syntax rule\nC, D ::= A | \u00acC | C D | C D | \u2203r.C | \u2200r.C\nwhere A ranges over concept names and r over role names.\nAs usual, we use C \u2192 D as an abbreviation for \u00acC D. ALCI-concepts additionally admit the use of inverse roles r \u2212 in concept constructors \u2203r \u2212 .C and \u2200r \u2212 .C. With a role, we mean a role name or an inverse role. ALC u -concepts additionally admit the use of the universal role u in concept constructors \u2203u.C and \u2200u.C. In ALCI u -concepts, both inverse roles and the universal role are admitted.\nWe now introduce several TBox languages. For L one of the four concept languages introduced above, an L-TBox is a finite set of concept inclusions C D where C and D are L concepts. So each concept language also serves as a TBox language, but there are additional TBox languages of interest. We include the letter H in the name of a TBox language to indicate that role inclusions r s are also admitted in the TBox and likewise for the letter F and functionality assertions func(r) where in both cases r, s are role names or inverse roles in case that the concept language used admits inverse roles. So it should be understood, for example, what we mean with an ALCHI u -TBox and an ALCF I-TBox. As usual, the semantics is defined in terms of interpretations, which take the form I = (\u2206 I , \u2022 I ) with \u2206 I a non-empty domain and \u2022 I an interpretation function. An interpretation is a model of a TBox T if it satisfies all inclusions and assertions in T , defined in the usual way. We write T |= r s if every model of T also satisfies the role inclusion r s.\nAn ABox is a set of concept assertions A(a) and role assertions r(a, b) where A is a concept name, r a role name, and a, b are individual names. We use ind(A) to denote the set of all individual names that occur in A. An interpretation is a model of an ABox A if it satisfies all concept and role assertions in A, that is, a \u2208 A I when A(a) is in A and (a, b) \u2208 r I when r(a, b) is in A. An ABox is consistent with a TBox T if A and T have a common model. A signature \u03a3 is a set of concept and role names. We use sig(T ) to denote the set of concept and role names that occur in the TBox T , and likewise for other syntactic objects such as ABoxes. A \u03a3-ABox is an ABox A such that sig(A) \u2286 \u03a3.\nA conjunctive query (CQ) is of the form q(x) = \u2203y \u03d5(x, y), where x and y are tuples of variables and \u03d5(x, y) is a conjunction of atoms of the form A(x) or r(x, y) with A a concept name, r a role name, and x, y \u2208 x \u222a y. We call x the answer variables of q(x) and y quantified variables. For purposes of uniformity, we use r \u2212 (x, y) as an alternative notation to denote an atom r(y, x) in a CQ. In fact, when speaking about an atom r(x, y) in a CQ q(x), we generally also include the case that r = s \u2212 and s(y, x) is the actual atom in q(x), unless explicitly noted otherwise. Every CQ q(x) = \u2203y \u03d5(x, y) gives raise to a directed graph G q whose nodes are the elements of x \u222a y and that contains an edge from x to y if \u03d5(x, y) contains an atom r(x, y). The corresponding undirected graph is denoted G u q (it might contain self loops). We can thus use standard terminology from graph theory to CQs, saying for example that a CQ is connected. A homomorphism from q(x) to an interpretation I is a function h : x \u222a y \u2192 \u2206 I such that h(x) \u2208 A I for every atom A(x) of q(x) and (h(x), h(y)) \u2208 r I for every atom r(x, y) of q(x). We write I |= q(a) and call a an answer to q(x) on I if there is a homomorphism from q(x) to I with h(x) = a.\nA union of conjunctive queries (UCQ) q(x) is a disjunction of one or more CQs that all have the same answer variables x. We say that a UCQ is connected if every CQ in it is. The arity of a (U)CQ is the number of answer variables in it. For L \u2208 {ALC, ALCI, ALC u , ALCI u }, an L-instance query (L-IQ) takes the form C(x) where C is an L concept and x a variable. We write I |= C(a) if a \u2208 C I . All instance queries have arity 1.\nAn ontology-mediated query (OMQ) takes the form Q = (T , \u03a3, q(x)) with T a TBox, \u03a3 \u2286 sig(T ) \u222a sig(q) an ABox signature, and q(x) a query. 1 The arity of Q is the arity of q(x) and Q is Boolean if it has arity zero. When \u03a3 is sig(T )\u222a sig(q), then for brevity we denote it with \u03a3 full and speak of the full ABox signature. Let A be a \u03a3-ABox. A tuple a \u2208 ind(A) is an answer to Q on A if I |= q(a) for all models I of A and T . We say that Q is empty if for all \u03a3-ABoxes A, there is no answer to Q on\nA. Let Q 1 , Q 2 be OMQs, Q i = (T i , \u03a3, q i (x)) for i \u2208 {1, 2}. Then Q 1 is contained in Q 2 , written Q 1 \u2286 Q 2 ,\nif for all \u03a3-ABoxes A, every answer to Q 1 on A is also an answer to Q 2 on A. Further, Q 1 and Q 2 are equivalent, written\nQ 1 \u2261 Q 2 , if Q 1 \u2286 Q 2 and Q 2 \u2286 Q 1 .\nWe use (L, Q) to refer to the OMQ language in which the TBox is formulated in the language L and where the actual queries are from the language Q, such as in (ALCF , UCQ). For brevity, we generally write (L, IQ) instead of (L, L -IQ) when L is the concept language underlying the TBox language L, so for example (ALCHI, IQ) is short for (ALCHI, ALCI-IQ). Definition 1. Let (L, Q) be an OMQ language. An OMQ Q = (T , \u03a3, q(x)) is (L, Q)-rewritable if there is an OMQ Q from (L, Q) such that the answers to Q and to Q are identical on any \u03a3-ABox that is consistent with T . In this case, we say that Q is rewritable into Q and call Q a rewriting of Q.\nLet (L, Q) be an OMQ-language. IQ-rewritability in (L, Q) is the problem to decide whether a given (unary) OMQ Q = (T , \u03a3, q(x)) from (L, Q) is (L, IQ)-rewritable; for brevity, we simply speak of IQ-rewritability of Q when this is the case. The following examples show that IQ-rewritability of Q depends on several factors. All claims made are sanctioned by results established in this paper. Example 2. (1) IQ-rewritability depends on the topology of the actual query. Let q 1 (x) = r(x, x). The OMQ (\u2205, \u03a3 full , q 1 (x)) is rewritable into the OMQ (\u2205, \u03a3 full , C(x)) from (ALC, IQ) where C is P \u2192 \u2203r.P. In contrast, let q 2 (x) = \u2203y s(x, y) \u2227 r(y, y). The OMQ (\u2205, \u03a3 full , q 2 (x)) is not rewritable into an OMQ from (ALCI, IQ).\n(2) If we are not allowed to extend the TBox, IQrewritability depends on whether or not inverse roles are available. Let \u03a3 = {r, s} and q(x) = \u2203y r(y, x) \u2227 s(y, x). The OMQ Q = (\u2205, \u03a3, q(x)) is rewritable into the OMQ (\u2205, \u03a3, C(x)) from (ALCI, IQ) where C is P \u2192 \u2203r \u2212 .\u2203s.P. Q is also rewritable into the OMQ (T , \u03a3, C (x)) from (ALC, IQ) where T = {\u2203s.P \u2200r.P }, and C is P \u2192 P , but it is not rewritable into any OMQ (T , \u03a3, C (x)) from (ALC, IQ) with T = \u2205.\n(3) IQ-rewritability depends on the TBox. Let\nq(x) = \u2203x 1 \u2203y 1 \u2203y 2 \u2203z A(x) \u2227 r(x, x 1 ) \u2227 r(x 1 , y 1 ) \u2227 r(x 1 , y 2 ) \u2227 r(y 1 , z) \u2227 r(y 2 , z) \u2227 B 1 (y 1 ) \u2227 B 2 (y 2 ).\nThe OMQ (\u2205, \u03a3 full , q(x)) is not rewritable into an OMQ from (ALCI, IQ). Let T = {A \u2203r.\u2203r.(B 1 B 2 \u2203r. )}. The OMQ (T , \u03a3 full , q(x)) is rewritable into the OMQ (T , \u03a3 full , A(x)) from (ALC, IQ).\n(4) IQ-rewritability depends on the ABox signature. Let q(x) be the CQ from (3) without the atom A(x) and let T be as in (3). The OMQ (T , \u03a3 full , q(x)) is not rewritable into an OMQ from (ALCI, IQ). Let \u03a3 = {A}. The OMQ (T , \u03a3, q(x)) is rewritable into the OMQ (T , \u03a3, A(x)) from (ALC, IQ).\nNote that we are allowed to completely rewrite the TBox when constructing IQ-rewritings, which might seem questionable from a practical perspective. Fortunately, though, it turns out the TBox can always be left untouched or, in some rare cases, only needs to be slightly extended. Also note that an alternative definition of IQ-rewritability obtained by dropping the restriction to ABoxes consistent with T in Definition 1. All results obtained in this paper hold under both definitions. We comment on this throughout the paper and refer to the alternative version as unrestricted IQ-rewritability.", "publication_ref": ["b0"], "figure_ref": [], "table_ref": []}, {"heading": "Characterizations", "text": "We aim to provide characterizations of OMQs that are IQrewritable. On the one hand, these characterizations clarify which OMQs are IQ-rewritable and which are not. On the other hand, they form the basis for deciding IQ-rewritability. We first concentrate on the case of DLs (and IQs) with inverse roles and then move on to DLs without inverse roles. In the final part of this section, we consider the case where the TBox is empty, both with and without inverse roles.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "The Case With Inverse Roles", "text": "To state the characterization, we need some preliminaries. Let q(x) be a CQ. A cycle in q(x) is a sequence of non-identical atoms r 0 (x 0 , x 1 ), . . . , r n\u22121 (x n\u22121 , x n ) in q(x), n \u2265 1, where 2 1. r 0 , . . . , r n\u22121 are (potentially inverse) roles, 2. x i = x j for 0 \u2264 i < j < n, and\nx 0 = x n .\nThe length of this cycle is n. We say that q(x) is x-acyclic if every cycle in it passes through x and use q con (x) to denote the result of restricting q(x) to those atoms that only use variables reachable in G u q from x. Both notions are lifted to UCQs by applying them to every CQ in the UCQ. A contraction of q(x) is a CQ obtained from q(x) by zero or more variable identifications, where the identification of x with any other variable yields x.\nLet T be an ALCHI u -TBox and q(x) a UCQ. We use q acyc (x) to denote the UCQ that consists of all x-acyclic CQs obtained by starting with a contraction of a CQ from q(x) and then replacing zero or more atoms r(y, z) with s(y, z) when T |= s r. We write q con acyc (x) to denote (q acyc ) con (x). Theorem 3. Let L \u2208 {ALCI, ALCHI} and let Q = (T , \u03a3, q(x)) be a unary OMQ from (L, UCQ) that is nonempty. Then the following are equivalent:\n1. Q is IQ-rewritable, that is, it is rewritable into an OMQ Q = (T , \u03a3, C(x)) from (L, IQ); 2. Q is rewritable into an OMQ Q = (T , \u03a3, C(x)) from (L, IQ); 3. Q \u2261 (T , \u03a3, q con acyc (x)\n). When L is replaced with L u , then the same equivalences hold except that q con acyc is replaced with q acyc . Note that Theorem 3 excludes empty OMQs, but these are trivially IQ-rewritable. It implies that, in the considered cases, it is never necessary to modify the TBox when constructing an IQ-rewriting. Further, it emerges from the proof that it is never necessary to introduce fresh role names in the rewriting (while fresh concept names are crucial). Theorem 3 also applies to unrestricted IQ-rewritability (where also ABoxes are admitted that are inconsistent with the TBox from the OMQ): unrestricted IQ-rewritability trivially implies IQrewritability and the converse is an easy consequence of the fact that every OMQ that is IQ-rewritable has an IQ-rewriting based on the same TBox.\nWe now give some ideas about the proof of Theorem 3. The most interesting implication is \"1 \u21d2 3\". A central step is to show that if Q = (T , \u03a3, q(x)) is IQ-rewritable into an OMQ Q , then Q \u2286 Q acyc := (T , \u03a3, q acyc (x)), that is, when A |= Q(a) for some \u03a3-ABox A, then A |= Q acyc (a). To this end, we first construct from A a \u03a3-ABox A g of high girth (that is, without small cycles) in a way such that (a) A g homomorphically maps to A and (b) from A |= Q (a) it follows that A g |= Q (a), thus A g |= Q(a). Due to the high girth of A g and exploiting (a variation of the) tree model property for ALCHI, we can then show that A g |= Q(a) implies A g |= Q acyc (a). Because of (a), it follows that A |= Q acyc (a). In the direction \"3 \u21d2 2\", we construct actual rewritings, based on the following lemma, an extension of a result of Kikot and Zolin [Kikot and Zolin, 2013] with TBoxes and ABox signatures (and UCQs instead of CQs).\nLemma 4. Let Q = (T , \u03a3, q(x)) be an OMQ from (ALCHI u , UCQ). Then 1. if q(x) is x-acyclic and connected, then Q is rewritable into an OMQ (T , \u03a3, C(x)) with C(x) an ALCI-IQ and 2. if q(x) is x-acyclic, then Q is rewritable into an OMQ (T , \u03a3, C(x)) with C(x) an ALCI u -IQ.\nThe size of the IQs C(x) is polynomial in the size of q(x).\nWe give the construction of the ALCI-IQ q (x) in Point 1 of Lemma 4. Let Q = (T , \u03a3, q(x)) be an OMQ from (ALCHI u , UCQ) with q(x) x-acyclic and connected. To construct q (x), we first construct for each CQ p(x) in q(x) an ELI-concept C p , that is, an ALCI-concept that uses only the constructors , \u2203r.C, and \u2203r \u2212 .C. In fact, since p(x) is xacyclic and connected, we can repeatedly choose and remove atoms of the form r(x, y) that occur in a cycle in p(x) and will eventually end up with a tree-shaped CQ p (x). 3 Here, treeshaped means that the undirected graph G u p is a tree and that there are no multi-edges, that is, if r(y, z) is an atom, then there is no atom s(y, z) with s = r. Next, extend p (x) to obtain another tree-shaped CQ p (x) by taking a fresh concept name P / \u2208 \u03a3, and adding r(x , y) and P (x ) for each removed atom r(x, y), x a fresh variable. We can now view p (x) as an ELI-concept C p in the obvious way. The desired\nALCI-IQ q (x) is (P \u2192 p(x) a CQ in q(x) C p )(x).", "publication_ref": ["b0"], "figure_ref": [], "table_ref": []}, {"heading": "The Case Without Inverse Roles", "text": "We consider OMQs whose TBoxes are formulated in a DL L that does not admit inverse roles. Note that inverse roles are then also not admitted in the IQ used in the rewriting. We first observe that this has less impact than one might expect: inverse roles in the IQ-rewriting can be eliminated and in fact Points 1 and 3 from Theorem 3 are still equivalent. However, there is also a crucial difference: unless the universal role is present, the elimination of inverse roles requires an extension of the TBox and thus the equivalence of Points 1 and 2 of Theorem 3 fails. In fact, this is illustrated by Point (2) of Example 2. We thus additionally characterize IQ-rewritability without modifying the TBox. We also show that, with the universal role, it is not necessary to extend the TBox.\nWe start with some preliminaries. An extended conjunctive query (eCQ) is a CQ that also admits atoms of the form C(x), C a (potentially compound) concept, and UeCQs and extended ABoxes (eABoxes) are defined analogously. The semantics is defined in the expected way. Every eCQ q(x) gives rise to an eABox A q by viewing the variables in q(x) as individual names and the atoms as assertions.\nLet q(x) be an eCQ. We use dreach(q) to denote the set of all variables reachable from x in the directed graph G q and say that q(x) is x-accessible if dreach(q) contains all variables. For V a set of variables from q(x) that includes x, q(x)| V denotes the restriction of q(x) to the atoms that use only variables from V .\nLet T be an ALC-TBox. An eCQ p(x) is a T -decoration of a CQ q(x) if 1. p(x) is obtained from q(x) by adding, for each y \u2208 dreach(q) and each subconcept C of T , the atom C(y) or the atom \u00acC(y);\n2. the eABox A p is consistent with T .\nFor a UCQ q(x), we use q deco (x) to denote the UeCQ that consists of all eCQs p(x)| dreach(p) (x), where p(x) is a Tdecoration of a CQ from q(x). We write q deco acyc (x) to denote (q acyc ) deco (x). We now give the results announced above. Theorem 5. Let L \u2208 {ALC, ALCH} and let Q = (T , \u03a3, q(x)) be a unary OMQ from (L, UCQ) that is nonempty. Then the following are equivalent:\n1. Q is rewritable into an OMQ from (L, IQ); 2. Q is rewritable into an OMQ (T \u222a T , \u03a3, C(x)) from (L, IQ); 3. Q is rewritable into an OMQ from (LI, IQ); If \u03a3 = \u03a3 full , then the following are equivalent: 4. Q is rewritable into an OMQ Q = (T , \u03a3 full , C(x)) from (L, IQ);\n5. Q \u2261 (T , \u03a3 full , q deco acyc (x)). If, furthermore, L is replaced with L u and LI with LI u , then Conditions 1 to 3 are further equivalent to: 6. Q is rewritable into an OMQ Q = (T , \u03a3, C(x)) from (L u , IQ).\nCharacterizing IQ-rewritability in the case where L \u2208 {ALC, ALCH}, the TBox (is non-empty and) cannot be extended, and \u03a3 = \u03a3 full remains an open problem.\nIn the directions \"3 \u21d2 2\", \"5 \u21d2 4\", and \"3 \u21d2 6\", we have to construct IQ-rewritings. This is done by starting with the rewriting from the proof of Lemma 4 and then modifying it appropriately. As in the case of Theorem 3, it is straightforward to see that all results stated in Theorem 5 also apply to unrestricted IQ-rewritability.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "The Case of Empty TBoxes", "text": "We consider OMQs in which the TBox is empty as an important special case. Since it is then not interesting to have an ABox signature, this corresponds to the rewritability of (U)CQs into L-instance queries, for some concept language L (and thus no OMQs are involved). The importance of this case is due to the fact that it provides an 'underapproximation' of the IQ-rewritability of OMQs, while also being easier to characterize and computationally simpler.\nWe say that an UCQ q(x) is L-IQ-rewritable if there is an L-IQ q (x) that is equivalent to q(x) in the sense that the OMQs (\u2205, \u03a3 full , q(x)) and (\u2205, \u03a3 full , q (x)) are equivalent (and in passing, we define the equivalence between two UCQs in exactly the same way). The following proposition makes precise what we mean by underapproximation.\nProposition 6. Let L \u2208 {ALC, ALCI, ALC u , ALCI u }. If a UCQ q(x) is L-IQ-rewritable, then so is any OMQ (T , \u03a3, q(x)) from (LH, UCQ).\nProposition 6 is essentially a corollary of Theorem 7 below. As illustrated by Case (3) of Example 2, its converse fails.\nWe now characterize IQ-rewritability in the case of the empty TBox. A subquery of a CQ q(x) is a CQ q (x) obtained from q(x) by dropping atoms. A subquery of a UCQ q(x) is a UCQ obtained by including as a CQ at most one subquery of each CQ in q(x).\nTheorem 7. Let q(x) be a UCQ. Then 1. q(x) is rewritable into an ALCI-IQ iff there is a subquery q (x) of q(x) that is x-acyclic, connected, and equivalent to q(x); 2. q(x) is rewritable into an ALC-IQ iff there is a subquery q (x) of q(x) that is x-acyclic, x-accessible, and equivalent to q(x). When L-IQs are replaced with L u -IQs, then the same equivalences hold except that connectedness/x-accessibility is dropped.\nNote that Theorem 7 also characterizes rewritability of CQs; the query q (x) is then also a CQ rather than a UCQ. This is in contrast to Theorems 3 and 5 where the queries q con acyc (x) and q deco acyc (x) are UCQs even when the query q(x) from the OMQ that we start with is a CQ. Another crucial difference is that q con acyc (x) and q deco acyc (x) can be of size exponential in the size of the original OMQ while the query q (x) in Theorem 7 is of size polynomial in the size of q(x).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Complexity", "text": "We determine the complexity of deciding IQ-rewritability in various OMQ languages, based on the established characterizations and starting with the case of empty TBoxes. Theorem 8. For every Q \u2208 {CQ, U CQ} and L \u2208 {ALC, ALCI, ALC u , ALCI u }, it is NP-complete to decide whether a given query from Q is L-IQ-rewritable.\nThe upper bound in Theorem 8 is by guessing the query q (x) from Theorem 7 and verifying that it satisfies the properties stated there. The lower bound is by a reduction from 3-colorability.\nWe next consider the case where TBoxes can be nonempty, starting with the assumption that the ABox signature is full since this results in (slightly) lower complexity. Theorem 9. Let Q \u2208 {CQ, UCQ}. For OMQs based on the full ABox signature, IQ-rewritability is 1. EXPTIME-hard in (ALC, Q) and in CONEXPTIME in (ALCH, Q) and 2. 2EXPTIME-complete in (ALCI, Q) and (ALCHI, Q).\nThe lower bounds are by reduction from OMQ evaluation on ABoxes of the form {A(a)}, A a concept name, which is EXPTIME-complete in (ALCH, CQ) and 2EXPTIMEcomplete in (ALCHI, CQ) [Lutz, 2008]. The upper bounds are derived from the OMQ containment checks suggested by Condition 3 of Theorem 3 and Condition 4 of Theorem 5. Since we work with the full ABox signature, the nonemptiness condition from these theorems is void (there are no empty OMQs) and OMQ containment is closely related to OMQ evaluation, which allows us to derive upper bounds for the former from the latter; in fact, these bounds are exactly the ones stated in Theorem 9. We have to exercise some care, for two reasons: first, we admit UCQs as the actual query and thus the trivial reduction of OMQ containment to OMQ evaluation that is possible for CQs (which can be viewed as an ABox) does not apply. And second, we aim for upper bounds that exactly match the complexity of OMQ containment while the UCQs q con acyc (x) and q deco acyc (x) involved in the containment checks are of exponential size. What rescues us is that each of the CQs in these UCQs is only of polynomial size.\nWe finally consider the case where the ABox signature is unrestricted. Theorem 10. IQ-rewritability is 1. NEXPTIME-hard in (ALC, CQ) and 2. 2NEXPTIME-complete in all of (ALCI, CQ), (ALCI, UCQ), (ALCHI, CQ), (ALCHI, UCQ).\nThe lower bound in Point 1 is by reduction from OMQ emptiness in (ALC, CQ), which is NEXPTIME-complete [Baader et al., 2016]. For the one in Point 2, we use a reduction from OMQ containment, which is 2NEXPTIMEcomplete in (ALCI, CQ) [Bourhis and Lutz, 2016]. The upper bounds are obtained by appropriate containment checks as suggested by our characterizations, and we again have to deal with UCQs with exponentially many CQs. Note that Theorem 10 leaves open the complexity of IQ-rewritability in (ALC, CQ), between NEXPTIME and 2NEXPTIME. The same gap exists for OMQ containment [Bourhis and Lutz, 2016] as well as in the related problems of FO-rewritability and Datalog-rewritability [Feier et al., 2017].", "publication_ref": ["b1", "b0", "b0", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "Functional Roles", "text": "We consider DLs with functional roles. A fundamental observation is that for the basic such DL ALCF , IQ-rewritability is undecidable. This can be proved by a reduction from OMQ emptiness in (ALCF , IQ) [Baader et al., 2016]. Theorem 11. In (ALCF , CQ), IQ-rewritability is undecidable.\nIn the following, we show that decidability is regained in the case where the TBox is empty (apart from functionality assertions). This is challenging because functionality assertions have a strong and subtle impact on rewritability. As before, the only interesting ABox signature to be combined with 'empty' TBoxes is the full ABox signature. We use F to denote the TBox language in which TBoxes are sets of functionality assertions and concentrate on rewriting into IQs that may use inverse roles. Example 12. Consider the CQ p(x) = \u2203y(s(x, y) \u2227 r(y, y)) from Point 1 of Example 2. Then Q s = (T s , \u03a3 full , p(x)) and Q r = (T r , \u03a3 full , p(x)) with T w = {func(w)} for w \u2208 {r, s} are both rewritable into an OMQ (T w , \u03a3 full , q w (x)) with q w (x) an ALCI-IQ. The rewritings are neither trivial to find nor entirely easy to understand. In fact, for q s (x) we can use \u2200s.P \u2192 \u2203s.(P \u2192 \u2203r.P ). For q r (x), we introduce three fresh concept names rather than a single one and use them in a way inspired by graph colorings: q r (x) = (\u2200s.  \n(P i \u2192 \u2203r.P i )).1\u2264i\u22643\nBefore giving a characterization of rewritable queries, we introduce some preliminaries. Let q(x) be a CQ and T an ALCIF -TBox. A sequence x 0 , . . . , x n of variables in q(x) is a functional path in q(x) from x 0 to x n w.r.t. T if for all i < n there is a role r such that func(r) \u2208 T and r(x i , x i+1 ) is in q(x). We say that q(x) is f-acyclic w.r.t. T if for every cycle r 0 (x 0 , x 1 ), . . . , r n\u22121 (x n\u22121 , x n ) in q(x), one of the following holds:\n\u2022 there is a functional path in q(x) from x to some x i ;\n\u2022 func(r i ) \u2208 T or func(r \u2212 i ) \u2208 T for all i < n and there is a functional path y 0 , . . . , y m in q(x) with x 0 = y 0 = y m such that {x 0 , . . . , x n\u22121 } \u2286 {y 0 , . . . , y m }.\nWe are now ready to state the characterization.\nTheorem 13. An OMQ Q = (T , \u03a3 full , q(x)) from (F , UCQ) is rewritable into an OMQ from (F , ALCI-IQ) iff there is a subquery q (x) of q(x) that is f-acyclic, connected, and equivalent to q(x).\nWhen ALCI-IQ is replaced with ALCI u -IQ, the same equivalence holds except that connectedness is dropped.\nThe proof of Theorem 13 extends the ultrafilter construction from [Kikot and Zolin, 2013]. We remark that the \"if\" direction in Theorem 13 even holds for OMQs Q = (T , \u03a3, q(x)) from (ALCIF , UCQ). Thus, the case of the 'empty' TBox can again be seen as an underapproximation of the general case. We further remark that T remains unchanged in the construction of the IQ-rewritings and that the constructed rewritings are of polynomial size.\nTheorem 14. For OMQs from (F , UCQ), rewritability into (F , ALCI-IQ) is NP-complete.", "publication_ref": ["b0", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "MMSNP and CSP", "text": "Recall from the introduction that the OMQ languages studied in this paper are closely related to CSPs and their logical generalization MMSNP. In fact, the techniques used to establish the results in Sections 3 and 4 can be adapted to determine the complexity of deciding whether a given MMSNP sentence is equivalent to a CSP. In a nutshell, we prove that an MMSNP-sentence is equivalent to a CSP iff it is preserved under disjoint union and equivalent to a generalized CSP (a CSP with multiple templates), and that both properties can be reduced to containment between MMSNP sentences which is 2NEXPTIME-complete [Bourhis and Lutz, 2016]. The latter reduction involves constructing an MMSNP sentence \u03d5 acyc that is reminiscent of the query q acyc in Theorem 3. Full details are given in the appendix.\nTheorem 15. It is 2NEXPTIME-complete to decide whether a given MMSNP-sentence is equivalent to a CSP.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Conclusion", "text": "We have made a leap forward in understanding the relation between (U)CQs and IQs in ontology-mediated querying. Interesting open problems include a characterization of IQrewritability for DLs with functional roles when the TBox is non-empty and characterizations for DLs with transitive roles. The remarks after Theorem 4 and 10 mention further problems left open. In addition, it would be worthwhile to continue the effort from [Kikot et al., 2013] to understand the value of IQ-rewritings for the purposes of efficient practical implementation.", "publication_ref": ["b0"], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgements", "text": "Cristina Feier and Carsten Lutz were supported by ERC Consolidator Grant 647289 CODA. Frank Wolter was supported by EPSRC UK grant EP/M012646/1.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "The computational structure of monotone monadic SNP and constraint satisfaction: A study through datalog and group theory", "journal": "Feder and Vardi", "year": "1998", "authors": "[ References;  Baader"}, {"ref_id": "b1", "title": "The complexity of conjunctive query answering in expressive description logics", "journal": "Springer", "year": "2008", "authors": "Carsten Lutz"}, {"ref_id": "b2", "title": "Tractable query answering and rewriting under description logic constraints", "journal": "", "year": "2007", "authors": "R Stewart ; Florent; Iain A Madelaine;  Stewart;  P\u00e9rez-Urbina"}], "figures": [{"figure_label": "", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "1\u2264i\u22643", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Pi ) \u2192 (\u2203s.(", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "C, D ::= A | \u00acC | C D | C D | \u2203r.C | \u2200r.C", "formula_coordinates": [2.0, 337.47, 197.59, 197.34, 8.74]}, {"formula_id": "formula_1", "formula_text": "A. Let Q 1 , Q 2 be OMQs, Q i = (T i , \u03a3, q i (x)) for i \u2208 {1, 2}. Then Q 1 is contained in Q 2 , written Q 1 \u2286 Q 2 ,", "formula_coordinates": [3.0, 54.0, 385.93, 243.0, 31.57]}, {"formula_id": "formula_2", "formula_text": "Q 1 \u2261 Q 2 , if Q 1 \u2286 Q 2 and Q 2 \u2286 Q 1 .", "formula_coordinates": [3.0, 131.2, 429.76, 149.34, 9.65]}, {"formula_id": "formula_3", "formula_text": "q(x) = \u2203x 1 \u2203y 1 \u2203y 2 \u2203z A(x) \u2227 r(x, x 1 ) \u2227 r(x 1 , y 1 ) \u2227 r(x 1 , y 2 ) \u2227 r(y 1 , z) \u2227 r(y 2 , z) \u2227 B 1 (y 1 ) \u2227 B 2 (y 2 ).", "formula_coordinates": [3.0, 315.0, 200.29, 242.99, 31.57]}, {"formula_id": "formula_4", "formula_text": "x 0 = x n .", "formula_coordinates": [3.0, 464.48, 664.2, 37.05, 9.65]}, {"formula_id": "formula_5", "formula_text": "1. Q is IQ-rewritable, that is, it is rewritable into an OMQ Q = (T , \u03a3, C(x)) from (L, IQ); 2. Q is rewritable into an OMQ Q = (T , \u03a3, C(x)) from (L, IQ); 3. Q \u2261 (T , \u03a3, q con acyc (x)", "formula_coordinates": [4.0, 61.47, 245.42, 235.53, 65.33]}, {"formula_id": "formula_6", "formula_text": "ALCI-IQ q (x) is (P \u2192 p(x) a CQ in q(x) C p )(x).", "formula_coordinates": [4.0, 315.0, 275.49, 191.09, 15.2]}, {"formula_id": "formula_7", "formula_text": "Proposition 6. Let L \u2208 {ALC, ALCI, ALC u , ALCI u }. If a UCQ q(x) is L-IQ-rewritable, then so is any OMQ (T , \u03a3, q(x)) from (LH, UCQ).", "formula_coordinates": [5.0, 54.0, 590.42, 243.0, 32.96]}, {"formula_id": "formula_8", "formula_text": "(P i \u2192 \u2203r.P i )).1\u2264i\u22643", "formula_coordinates": [6.0, 197.36, 627.44, 85.04, 14.6]}], "doi": ""}