{"title": "Efficient Algorithms for Genome-Wide Association Study", "authors": "Xiang Zhang; Fei Zou; Wei Wang", "pub_date": "", "abstract": "Studying the association between quantitative phenotype (such as height or weight) and single nucleotide polymorphisms (SNPs) is an important problem in biology. To understand underlying mechanisms of complex phenotypes, it is often necessary to consider joint genetic effects across multiple SNPs. ANOVA (analysis of variance) test is routinely used in association study. Important findings from studying gene-gene (SNP-pair) interactions are appearing in the literature. However, the number of SNPs can be up to millions. Evaluating joint effects of SNPs is a challenging task even for SNP-pairs. Moreover, with large number of SNPs correlated, permutation procedure is preferred over simple Bonferroni correction for properly controlling family-wise error rate and retaining mapping power, which dramatically increases the computational cost of association study. In this article, we study the problem of finding SNP-pairs that have significant associations with a given quantitative phenotype. We propose an efficient algorithm, FastANOVA, for performing ANOVA tests on SNP-pairs in a batch mode, which also supports large permutation test. We derive an upper bound of SNP-pair ANOVA test, which can be expressed as the sum of two terms. The first term is based on single-SNP ANOVA test. The second term is based on the SNPs and independent of any phenotype permutation. Furthermore, SNP-pairs can be organized into groups, each of which shares a common upper bound. This allows for maximum reuse of intermediate computation, efficient upper bound estimation, and effective SNP-pair pruning. Consequently, FastANOVA only needs to perform the ANOVA test on a small number of candidate SNP-pairs without the risk of missing any significant ones. Extensive experiments demonstrate that FastANOVA is orders of magnitude faster than the brute-force implementation of ANOVA tests on all SNP pairs. The principles used in FastANOVA can be applied to categorical phenotypes and other statistics such as Chi-square test.", "sections": [{"heading": "INTRODUCTION", "text": "Quantitative phenotype association study analyzes genetic variation across a population in order to find the genetic factors underlying continuous phenotypes (such as height or weight). These phenotypes are often complex in the sense that they are likely due to the effects of multiple genes [Carlson et al. 2004;Segr et al. 2005]. The most abundant source of genetic variation is represented by single nucleotide polymorphisms (SNPs). A SNP is a DNA sequence variation occurring when a single nucleotide (A, T, G, or C) in the genome differs between individuals of a species. For inbred species, a SNP usually shows variation between only two of the four possible nucleotide types [Ideraabdullah et al. 2004], which allows us to represent it by a binary variable. The binary representation of a SNP is also referred to as the genotype of the SNP. Table I shows an example dataset consisting of 1000 SNPs {X 1 , X 2 , . . . , X 1000 } and a quantitative phenotype Y for 12 individuals.\nVarious statistics can be applied to measure the association between SNPs and the phenotypes of interest, among which ANOVA (analysis of variance) test is one of the standard statistic methods and has been routinely used in quantitative phenotype association study [Pagano and Gauvreau 2000]. The goal of ANOVA test is to determine whether the group means are significantly different after accounting for the variances within groups. It accomplishes the comparison by decomposing the total variance in the data into within-group variance and between-group variance. If the between-group variance is sufficiently larger than the within-group variance, then the test concludes that there is significant (phenotypic) difference between the groups.\nIn the application of phenotype-SNP association study, the individuals' phenotype values are grouped by the genotype of a SNP or a subset of SNPs. Using the dataset showing in Table I, Figure 1(a) shows an example of strong association between the phenotype and SNP X 1 . 0 and 1 on the x-axis represent the binary SNP genotype and the y-axis represents the phenotype. Each point in the figure represents an individual. It is clear from the figure that the phenotype values are partitioned into two groups with distinct means, hence indicating a strong association between the phenotype and the SNP. On the other hand, if the genotype of a SNP partitions the phenotype values into groups as shown in Figure 1(b), the phenotype and the SNP are not associated with each other.\nRecent advances in high-throughput techniques enable genotyping SNPs in genome-wide scale, resulting in large datasets containing thousands to millions of SNPs, for example, the genotype datasets available in the Broad Institute (http://www.broad.mit.edu/) and the Jackson Laboratory (http://www.jax.org/). The vast number of SNPs has posed great computational challenge to genomewide association study. In order to understand the underlying biological mechanisms of complex phenotype, one needs to consider the joint effect of multiple  SNPs simultaneously. Although the idea of studying the association between phenotype and multiple SNPs is straightforward, the implementation is nontrivial. For a study with total N SNPs, in order to find the association between n SNPs and the phenotype, a brute-force approach is to exhaustively enumerate all N n possible SNP combinations and evaluate their associations with the phenotype. The computational burden imposed by this enormous search space often makes the complete genome-wide association study intractable.\nX 2 X 3 X 4 X 5 \u2022 \u2022 \u2022 X 1000 Y 0 0 0 1 0 1 8 0 0 0 0 0 0 7 0 1 1 0 0 \u2022 \u2022 \u2022 1 12 0 1 0 0 1 0 11 0 1 0 1 0 1 9 0 1 0 0 0 \u2022 \u2022 \u2022 0 13 1 0 1 1 1 1 6 1 0 0 0 1 0 4 1 1 1 1 1 \u2022 \u2022 \u2022 1 2 1 0 0 1 0 0 5 1 0 0 1 0 1 0 1 0 1 1 0 \u2022 \u2022 \u2022 0 3 0 1 phenotype\nThe computational challenge of genome-wide association study is further compounded by another well-known statistical problem -the multiple testing problem [Miller 1981]. The multiple testing problem can be described as the potential increase in Type I error (false positive, the error of rejecting a null hypothesis when it is true) when statistical tests are performed multiple times. Let \u03b1 be the Type I error for each independent test. If n independent comparisons are performed, the experimental-wise error \u03b1 is given by\n\u03b1 = 1 \u2212 (1 \u2212 \u03b1) n .\nFor example, when \u03b1 = 0.05 and n = 20, \u03b1 = 1 \u2212 0.95 20 = 0.64. We have 64% probability to get at least one spurious result. Determining the statistical 19:4 \u2022 X. Zhang et al. significance of the association between the phenotype and SNPs is crucial. Bonferroni correction based on the assumption that all n tests are independent is too conservative for the genome-wise association studies since SNPs are often correlated. Alternatively, permutation procedure can be used and much preferred in association studies which automatically takes the correlation structure of SNPs into consideration.\nThe null hypothesis is that there is no association between the genotype and the phenotype. Permutation test is used to estimate the null distribution. The idea is to randomly permute the phenotype K times, where K can be hundreds to thousands. The association analysis will be repeated in order to find the maximum test value for each permutated phenotype. Then the distribution of the K maximum test values is used as the approximated null distribution to assess the statistical significance of the findings from the original phenotype. Permutation test is usually very time-consuming since the test procedure needs to be performed in all permutations in order to find the maximum values.\nAlgorithm development to support these large scale analysis is still in its infancy stage. Most existing work focuses on studying associations between the phenotype and SNP-pairs and can only handle a small number of SNPs. Given a pair of SNPs, the phenotype values can be partitioned into at most four groups by the genotype of the SNP-pair, that is, 00, 01, 10, and 11. Since each SNP has a distinct location on the genome, the association study of a phenotype and SNPpairs is also called two-locus association mapping. Important findings are appearing in the literature from studying the association between phenotypes and SNP-pairs [Saxena et al. 2007;Scuteri et al. 2007;Weedon et al. 2007].\nAlthough the standard ANOVA test has been a valuable tool to find association between SNP-pairs and phenotype, it is usually not performed in genomewide scale. This is due to the fact that the search space of two-locus association mapping in genome-wide scale prohibits an exhaustive search. Suppose that the dataset consists of N SNPs and the number of permutations is K . The total number of ANOVA tests is KN(N \u2212 1)/2. Given a moderate number of SNPs N = 10, 000 and number of permutations K = 1, 000, the number of ANOVA tests is around 5 \u00d7 10 10 . Therefore, ANOVA test is often reserved for validating a small set of candidates identified by other methods [Ohno et al. 2000;Shimomura et al. 2001].\nIn this article, we examine the computational aspect of ANOVA test. We present an efficient algorithm, FastANOVA, and show that the standard ANOVA test can be applied in genome-wide scale for two-locus association mapping even when the permutation procedure is needed. Unlike algorithms applying heuristics, FastANOVA is a complete algorithm, that is, it guarantees to find the optimal solution, though it does not explicitly examine all possible SNP-pairs. In fact, a large portion of the SNP-pairs are pruned without the need of performing the tests. FastANOVA establishes an upper bound on the two-locus ANOVA test. The upper bound is the sum of two terms: one based on the ANOVA test between phenotype and a single SNP, and the other based on the pair-wise SNP genotype and the ordered phenotype values. This formulation of the upper bound allows the algorithm to calculate the bound for a large number of SNPs together, which enables fast candidate retrieval. Moreover, the intermediate results for calculating the second term of the upper bound is independent of phenotype permutations. Hence, they only need to be computed once and can be reused in all permutations. Applying this bound, Fas-tANOVA is able to identify SNP-pairs with significant ANOVA test values using only a small fraction of the time required by performing ANOVA test on all SNP-pairs. In Section 7, we discuss further extensions of the FastANOVA algorithm to case-control study whose phenotypes can be represented as binary variables. We first show that the principle of FastANOVA can be applied to Chi-square test [Zhang et al. 2009b]. Then we briefly describe a more general approach that can be applied to a variety of statistics used in case-control study [Zhang et al. 2009a].", "publication_ref": ["b4", "b27", "b13", "b21", "b15", "b24", "b25", "b30", "b20", "b29", "b34", "b33"], "figure_ref": ["fig_0", "fig_0"], "table_ref": []}, {"heading": "RELATED WORK", "text": "The problem of phenotype-SNP association study has attracted extensive research interests and is an ongoing research area in biology and statistic communities. In this section, we review the related work from a computational point of view. Please refer to Doerge [2002], Hoh and Ott [2003], and Balding [2006] for excellent surveys of existing work.\nDifferent machine learning models have been adopted in multilocus association study. In Curtis et al. [2001] and Sherriff and Ott [2001], the authors investigate using neural networks to study the relationship between complex traits and multilocus genotypes. These models are theoretically well suited for analyzing high-order interactions. However, the results of these methods are usually expressed as weights associated with SNPs. They are difficult to interpret and do not clearly identify the interacting SNPs. Recursive partitioning methods [Zhang and Bonney 2000;Province et al. 2001] utilize classification and regression tree (CART) [Breiman et al. 1984] to pick the SNP that minimizes some pre-specified measure of impurity in each iteration. These methods are not effective in detecting SNP combinations if there is little or no marginal effect.\nUnder the assumption that the number of SNPs is limited, for example, from tens to hundreds, exhaustive algorithms that explicitly enumerate all possible SNP combinations have been developed. Combinatorial partitioning method (CPM) [Nelson et al. 2001] is designed to identify multilocus genotypic partitions that predict quantitative trait variation. Given a small set of SNPs, CPM searches for the partitions of multilocus genotypes that are the most predictive in terms of phenotypic variability. Motivated by CPM, multifactorial dimension reduction (MDR) [Ritchie et al. 2001;Moore et al. 2006] is designed for case/control studies. By pooling genotypes of multilocus into two groups at high disease risk and low disease risk, MDR reduces the genotype of multiple SNPs into one dimension. Among all possible combinations, MDR selects the one that maximizes the case/control ratio of the high risk group. Since these methods explicitly enumerate all possible SNP combinations, they are not well adapted to genome-wide association studies.\nTo avoid exhaustively enumerating the search space, a common approach is to break the problem into two steps [Hoh et al. 2000;Evans et al. 2006]. First, a subset of important SNPs are selected. Second, within the selected subset, the association between SNPs and the phenotypes are searched. These methods are not complete since the SNPs with weak marginal effects may not be selected in the first step. Genetic algorithm [Carlborg et al. 2000;Nakamichi et al. 2001] has been applied in finding SNP-pairs for quantitative phenotypes. These methods cannot guarantee to find the optimal solution.\nFeature selection methods [Liu and Motoda 1998] have been proposed to address the problem of finding important SNPs. In feature selection, the selected feature subset usually contains features that have low correlation with each other but have strong correlation with the target feature. In the application of selecting SNPs, the goal is to select a subset of SNPs that can be used as proxies for all SNPs in the genome [Sebastiani et al. 2003;Chi et al. 2006;Halperin et al. 2005]. The selected SNPs can then be used as the input SNPs in the association study. These methods are also not complete since some important SNPs may not be tagged.", "publication_ref": ["b7", "b11", "b0", "b6", "b28", "b32", "b21", "b2", "b18", "b22", "b16", "b12", "b9", "b3", "b17", "b14", "b26", "b5", "b10"], "figure_ref": [], "table_ref": []}, {"heading": "TWO-LOCUS ANOVA TEST", "text": "In this section, we formalize the problem of two-locus ANOVA test with permutation procedure. Let {X 1 , X 2 , . . . , X N } be the set of SNPs of M individuals. Each SNP\nX i (1 \u2264 i \u2264 N ) is a binary variable coded by {0, 1}. Let Y = { y 1 , y 2 , . . . , y M } be the quantitative phenotype of interest, where y m (1 \u2264 m \u2264 M ) is the phenotype value of individual m. For any SNP X i (1 \u2264 i \u2264 N )\n, we represent the F-statistic from the ANOVA test of X i and Y as F (X i , Y ). For any SNP-pair (X i X j ), we represent the F-statistic from the ANOVA test of (X i X j ) and Y as F (X i X j , Y ).\nThe basic idea of ANOVA test is to partition the total sum of squared deviations SS T into between-group sum of squared deviations SS B and within-group sum of squared deviations SS W SS T = SS B + SS W .\nSuppose that phenotype values are partitioned into k groups, with m i individuals in group i (1 \u2264 i \u2264 k). Let y i j be the j th observation in group i. Let\u0233 be the mean of all the observed phenotype values, and\u0233 i be the mean of the observed phenotype values in group i. The terms used in an ANOVA test are defined as follows.\nSS B = k i=1 m i (\u0233 i \u2212\u0233) 2 ; SS W = k i=1 m i j =1 ( y i j \u2212\u0233 i ) 2 ; SS T = k i=1 m i j =1 ( y i j \u2212\u0233) 2 .\nIn the application of two-locus association study, Table II(a) and Table II(b) show the possible groupings of phenotype values by the genotypes of X i and (X i X j ) respectively. Let A, B, a 1 , a 2 , b 1 , b 2 represent the groups as indicated in Table II(a) and Table II (b). We use SS B (X i , Y ) and SS B (X i X j , Y ) to distinguish the one locus (i.e., single-SNP) and two locus (i.e., SNP-pair) analysis.\n\u2022", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "19:7", "text": "Table II. Possible Groupings of Phenotype Values by the Genotypes of X i and (X i X j ) (a) Grouping of Y by X i\nX i = 1 X i = 0 group A group B (b) Grouping of Y by X i X j X i = 1 X i = 0 X j = 1 group a 1 group b 1 X j = 0 group a 2 group b 2\nSpecifically, we have\nSS T (X i , Y ) = SS B (X i , Y ) + SS W (X i , Y ), SS T (X i X j , Y ) = SS B (X i X j , Y ) + SS W (X i X j , Y ).\nThe F-statistics for ANOVA tests on X i and (X i X j ) are:\nF (X i , Y ) = M \u2212 2 2 \u2212 1 \u00d7 SS B (X i , Y ) SS T (X i , Y ) \u2212 SS B (X i , Y ) ,(1)\nF (X i X j , Y ) = M \u2212 g g \u2212 1 \u00d7 SS B (X i X j , Y ) SS T (X i X j , Y ) \u2212 SS B (X i X j , Y ) ,(2)\nwhere g in Eq. ( 2) is the number of groups that the genotype of (X i X j ) partitions the individuals into. Possible values of g are 3 or 4, assuming all SNPs are distinct: If none of groups A, B, a 1 , a 2 , b 1 , b 2 is empty, then g = 4. If one of them is empty, then g = 3.\nLet T = y m \u2208Y y m be the sum of all phenotype values. The total sum of squared deviations does not depend on the groupings of individuals:\nSS T (X i , Y ) = SS T (X i X j , Y ) = y m \u2208Y y 2 m \u2212 T 2 M .\nLet T group = y m \u2208group y m be the sum of phenotype values in a specific group, and n group be the number of individuals in that group. SS B (X i , Y ) and SS B (X i X j , Y ) can be calculated as follows:\nSS B (X i , Y ) = T 2 A n A + T 2 B n B \u2212 T 2 M , SS B (X i X j , Y ) = T 2 a 1 n a 1 + T 2 a 2 n a 2 + T 2 b 1 n b 1 + T 2 b 2 n b 2 \u2212 T 2 M .\nNote that for any group of A, B, a 1 , a 2 , b 1 , b 2 , if n group = 0, then T 2 group /n group is defined to be 0.\nThe two-locus association mapping with permutation test is typically conducted in the following way [Westfall and Young 1993;Dudoit and van der Laan 2008]  First, for every SNP-pair (\nX i X j ) (1 \u2264 i < j \u2264 N ), the ANOVA test is performed and F (X i X j , Y ) is recorded.\nSecond, a permutation test is performed to get a reference distribution in order to assess the statistical significance of previous findings. More specifically, a permutation Y k of Y is generated by sampling the phenotype Y without replacement. In other words, phenotype values are randomly assigned to individuals in the dataset with no single phenotype value being assigned to more than one individual. Let Y = {Y 1 , Y 2 , . . . , Y K } be the set of K permutations of Y . For each permutation Y k \u2208 Y , let F Y k represent the maximum F-statistic value of all SNP-pairs, that is,\nF Y k = max{F (X i X j , Y k )|1 \u2264 i < j \u2264 N }.\nThe distribution of {F Y k |Y k \u2208 Y } is then used as the reference distribution for assessing the statistical significance of F (X i X j , Y ) values found using the original phenotype Y : Given a Type I error threshold \u03b1, the critical value\nF \u03b1 is the \u03b1 K -th largest value in {F Y k |Y k \u2208 Y }. The SNP-pair (X i X j ) whose F-statistic value F (X i X j , Y ) \u2265 F \u03b1 is considered as significant at \u03b1.\nFor example, Figure 2 shows the cumulative distribution of the maximum values for K = 100 permutations. Suppose that \u03b1 = 0.3, then F \u03b1 is the 30th largest value among the 100 maximum test values, which is 32 as shown in this example.\nTwo computational problems need to be solved in this procedure. The first one is to find the critical value F \u03b1 for a given Type I error threshold \u03b1. The second one is to find all SNP-pairs (X i X j ) whose F-statistics are greater than F \u03b1 . We formalize these two problems as follows:\nProblem (1). Given the Type I error threshold \u03b1, find the critical value F \u03b1 , which is the \u03b1 K -th largest value in\n{F Y k |Y k \u2208 Y }. Problem (2). Given the threshold F \u03b1 , find all significant SNP-pairs (X i X j ) such that F (X i X j , Y ) \u2265 F \u03b1 .\nA brute force approach to these two problems is to enumerate all SNP-pairs and find their F-statistics. In Problem (1), for each permutation Y k \u2208 Y , all SNP-pairs need to be enumerated in order to find the maximum value F Y k . In Problem (2), all SNP-pairs need to be enumerated to see if their test values are above the threshold F \u03b1 . Computationally, Problem (1) is more challenging, since the permutation number K can range form hundreds to thousands, which means the running time of finding the critical value F \u03b1 can be hundreds to thousands times longer than the running time of finding the significant SNPpairs in Problem (2) using a brute-force search.\nIn the reminder of this article, we first derive an upper bound on twolocus ANOVA test value and discuss how this upper bound enables an efficient ANOVA testing for a single phenotype. Then, we show how this approach can be easily extended to handle the permutation procedure.", "publication_ref": ["b31", "b8"], "figure_ref": ["fig_3"], "table_ref": []}, {"heading": "THE UPPER BOUND", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Updating F-Statistic", "text": "Since the total sum of squared deviations does not change, from the calculation of F (X i , Y ) and F (X i X j , Y ) (Eqs. ( 1) and ( 2)), we know that the relationship between these two tests only depends on the relationship between SS B (X i , Y ) and SS B (X i X j , Y ). Next, we show that SS B (X i X j , Y ) can be updated from SS B (X i , Y ).\nFor groups A, a 1 and a 2 , let\nA = T 2 a 1 n a 1 + T 2 a 2 n a 2 \u2212 T 2 A n A = n a 2 T 2 a 1 + n a 1 T 2 a 2 n a 1 n a 2 \u2212 (T a 1 + T a 2 ) 2 n a 1 + n a 2 = (n a 2 T a 1 \u2212 n a 1 T a 2 ) 2 n a 1 n a 2 n A = (n A T a 1 \u2212 n a 1 T A ) 2 n a 1 (n A \u2212 n a 1 )n A .\nSimilarly, we have\nB = T 2 b 1 n b 1 + T 2 b 2 n b 2 \u2212 T 2 B n B = (n B T b 1 \u2212 n b 1 T B ) 2 n b 1 (n B \u2212 n b 1 )n B .\nThus, SS B (X i X j , Y ) can be updated using SS B (X i , Y ):\nSS B (X i X j , Y ) = SS B (X i , Y ) + A + B. (3\n)\nNote that if any one of {n a 1 , n a 2 , n A } is 0, then\nA = 0. Similarly, if any one of {n b 1 , n b 2 , n B } is 0, then B = 0.\nNext, we develop an upper bound of SS B (X i X j , Y ). We first show the derivation of an upper bound of A . A similar idea can be applied to find an upper bound of B . ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Bounds of A and B", "text": "Let { y m | y m \u2208 A} = { y A 1 , y A 2 , . . . , y A n A } be the phenotype values in group A. Without loss of generality, assume that these phenotype values are arranged in ascending order, that is,\ny A 1 \u2264 y A 2 \u2264 \u2022 \u2022 \u2022 \u2264 y A n A .\nThe derivative of A with respect to T a 1 is:\nd A d T a 1 = 2n A (n A T a 1 \u2212 n a 1 T A ) n a 1 (n A \u2212 n a 1 )n A .\nThus we have\nA monotonically increases if T a 1 \u2265 n a 1 T A n A ; decreases if T a 1 \u2264 n a 1 T A n A .\nWe have the range of T a 1 :\nT a 1 \u2208 [l a 1 , u a 1 ] = \u23a1 \u23a3 n a 1 i=1 y A i , n A i=n A \u2212n a 1 +1 y A i \u23a4 \u23a6 . The maximum value of A is attained when T a 1 = l a 1 or T a 1 = u a 1 , i.e., A \u2264 max{(n A l a 1 \u2212 n a 1 T A ) 2 , (n A u a 1 \u2212 n a 1 T A ) 2 } n a 1 (n A \u2212 n a 1 )n A . (4\n)\nWe use R 1 (X i X j Y ) to denote this upper bound. Let { y m | y m \u2208 B} = { y B 1 , y B 2 , . . . , y B n B } be the phenotype values in group B. Without loss of generality, assume that these phenotype values are arranged in ascending order, that is,\ny B 1 \u2264 y B 2 \u2264 \u2022 \u2022 \u2022 \u2264 y B n B .\nSimilarly, we can derive the bound on B:\nB \u2264 max{(n B l b 1 \u2212 n b 1 T B ) 2 , (n B u b 1 \u2212 n b 1 T B ) 2 } n b 1 (n B \u2212 n b 1 )n B . (5\n)\nWe use R 2 (X i X j Y ) to denote this upper bound. The symbols used in Inequalities (4) and ( 5) are summarized in Table III.\nFrom Eq. (3), Inequalities (4) and ( 5), we have the overall upper bound on SS B (X i X j , Y ): The tightness of the bound is obvious from the derivation of the upper bound, since there exists some genotype of SNP-pair (X i X j ) that makes the equality hold. For the same reason, we have the following property. \nTHEOREM 4.1 (UPPER BOUND OF SS B (X i X j , Y )). SS B (X i X j , Y ) \u2264 SS B (X i , Y ) + R 1 (X i X j Y ) + R 2 (X i X j Y ).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "19:11", "text": "Table III. Notations for the Bounds on A and B", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Symbols", "text": "Formulas\nl a 1 na 1 i=1 y A i u a 1 n A i=n A \u2212na 1 +1 y A i R 1 (X i X j Y ) max{(n A la 1 \u2212na 1 T A ) 2 , (n A ua 1 \u2212na 1 T A ) 2 } na 1 (n A \u2212na 1 )n A l b 1 n b 1 i=1 y B i u b 1 n B i=n B \u2212n b 1 +1 y B i R 2 (X i X j Y ) max{(n B l b 1 \u2212n b 1 T B ) 2 , (n B u b 1 \u2212n b 1 T B ) 2 } n b 1 (n B \u2212n b 1 )n B\nPROPERTY 4.3. The upper bound in Theorem 4.1 does not exceed the total sum of squared deviations, that is,\nSS B (X i , Y ) + R 1 (X i X j Y ) + R 2 (X i X j Y ) \u2264 SS T (X i X j , Y ).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "THE FASTANOVA ALGORITHM", "text": "In this section, we show how our algorithm FastANOVA utilizes the upper bound in Theorem 4.1 to achieve efficient two-locus ANOVA testing. In Section 5.1, we describe the method for Problem (2) discussed in Section 3; that is, given a threshold F \u03b1 , we want to find all SNP-pairs whose F-statistics are greater than F \u03b1 . Then, in Section 5.2, we discuss how FastANOVA performs in permutation procedure, that is, the scenario of Problem (1) in Section 3.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "A Single Phenotype", "text": "Given the threshold F \u03b1 , to find all SNP-pairs whose F-statistics are greater than F \u03b1 , a brute-force approach is to enumerate all SNP-pairs. To expedite this process, we employ the inequality in Theorem 4.1 to prune SNP pairs that will have no chance to pass the significance threshold F \u03b1 . From Eq. (2), we know that finding SNP-pairs (X i X j ) whose F-statistics F (\nX i X j , Y ) \u2265 F \u03b1 is equivalent to finding SNP-pairs satisfying SS B (X i X j , Y ) \u2265 SS T (X i , Y ) M \u2212 g ( g \u22121)F \u03b1 + 1 = \u03b8.\nTheorem 4.1 suggests that we only need to compute the F-statistics for the SNP-pairs that satisfy:\nSS B (X i , Y ) + R 1 (X i X j Y ) + R 2 (X i X j Y ) \u2265 \u03b8.\nWe refer to these SNP-pairs as candidate SNP-pairs. We now discuss how to apply the upper bound in Theorem 4.1 in detail. The set of all SNP-pairs is partitioned into nonoverlapping groups such that each group has a common upper bound. For every (3,3) Fig. 3. The index array Array(X 1 ) for efficient retrieval of the candidate SNP-pairs. For all SNP-pairs in AP(X i ), n A , T A , n B , T B and SS B (X i , Y ) are constants. Moreover, l a 1 , u a 1 are determined by n a 1 , and l b 1 , u b 1 are determined by n b 1 . Therefore, in the upper bound, n a 1 and n b 1 are the only variables that depend on X j and may vary for different SNP-pairs (X i X j ) in AP(X i ).\nX i (1 \u2264 i \u2264 N ), let AP(X i ) be the set of SNP-pairs AP(X i ) = {(X i X j )|i + 1 \u2264 j \u2264 N }.\nNote that n a 1 is the number of 1's in X j when X i takes value 1, and n b 1 is the number of 1's in X j when X i takes value 0. In Section 4.2, we have shown the upper bound of A ( B) using the phenotype values in group a 1 (b 1 ). We can also develop a similar bound based on group a 2 (b 1 ). Therefore, without loss of generality, we always assume that n a 1 is the smaller one between the number of 1's and number of 0's in X j when X i takes value 1, and n b 1 is the smaller one between the number of 1's and number of 0's in X j when X i takes value 0.\nFor example, using the dataset showing in Table I, for SNP-pair (X i X 2 ), n a = 1 since the minimum of number of 1's and 0's in X 2 when X 1 = 1 is 1 (the number of 1's), and n b = 2 since the minimum of number of 1's and 0's in X 2 when X 1 = 0 is 2 (the number of 0's).\nThe following property specifies the values that n a 1 and n b 1 can take. The proof is straightforward and omitted here. PROPERTY 5.1. If there are m 1's and (M \u2212m) 0's in X i , then for any\n(X i X j ) \u2208 AP(X i ), the possible values that n a 1 can take are {0, 1, 2, . . . , m/2 }. The possible values that n b 1 can take are {0, 1, 2, . . . , (M \u2212 m)/2 }.\nTo efficiently retrieve the candidates, the SNP-pairs (X i X j ) in AP(X i ) are grouped by their (n a 1 , n b 1 ) values and indexed in a 2D array, referred to as Array(X i ).\nExample 5.2. Using the example dataset shown in Table I, we consider the SNP-pairs in AP(X 1 ), that is, {(X 1 X 2 ), (X 1 X 3 ), (X 1 X 4 ), (X 1 X 5 ), . . . , (X 1 X 1000 )}. There are 12 individuals in the dataset, and the genotype of X 1 contains 6 0's and 6 1's. Therefore, the possible values of n a 1 and n b 1 are {0, 1, 2, 3}. Figure 3 shows the 4 \u00d7 4 array, Array(X 1 ), whose entries represent the possible values of (n a 1 , n b 1 ) for the SNP-pairs in AP(X i ). The entries in the same column have the same n a 1 value. The entries in the same row have the same n b 1 value. The n a 1 value of each column is noted beneath each column. The n b 1 value of each row is noted left to each row. Each entry of the array is a pointer to the SNP-pairs having the corresponding (n a 1 , n b 1 ) values. For example, for SNP-pair (X 1 X 3 ), its (n a 1 , n b 1 ) = (3, 1). Thus, it is indexed by entry (3,1).\nNote that for a SNP-pair (X i X j ) \u2208 AP(X i ), n a 1 and n a 2 can be calculated faster than performing the two-locus ANOVA test. To obtain n a 1 and n a 2 , we only need to count the numbers of 0's and 1's of X j when X i is equal to 0 and 1 respectively, which can be done by a linear scan of the M \u00d7 2 binary matrix consisting of the genotypes of X i and X j . In contrast, to calculate the F-statistic, we first need to scan the M \u00d7 3 binary matrix consisting of X i , X j and Y in order to find out how the phenotype values are grouped by the genotype of (X i X j ). Then a constant time O(t) is required to compute the F-statistic.\nPROPERTY 5.3. For any SNP X i , the maximum number of the entries in Array(\nX i ) is M 4 + 1 2 .\nThe proof of Property 5.3 is straightforward and omitted here. In order to find candidate SNP-pairs, we scan all entries in Array(X i ) to calculate their upper bounds. Since the SNP-pairs indexed by the same entry share the same (n a 1 , n b 1 ) value, they have the same upper bound. PROPERTY 5.4. Given phenotype Y , for any SNP X i , the SNP-pairs indexed by the same entry in AP(X i ) have the same upper bound value.\nFor typical genome-wide association studies, the number of individuals M is much smaller than the number of SNPs N . From Property 5.3, there must be a group of SNP-pairs indexed by the same entry of AP(X i ). In Example 5.2, there are in total 16 entries in Array(X 1 ), and 999 SNP-pairs in AP(X 1 ). Thus many SNP-pairs share the same (n a 1 , n b 1 ) value and hence indexed by the same entry in Array(X 1 ). Moreover, from Property 5.4, we can calculate the upper bound for the group of SNP-pairs indexed by the same entry together. It is these two key properties of the index structure that help to reduce the complexity of the algorithm. The additional cost for accessing Array(X i ) is minimal compared to performing ANOVA tests for all pairs (X i X j ) \u2208 AP(X i ) since M N . Algorithm 1 describes the FastANOVA algorithm for finding the SNP-pairs whose F-statistics are greater than the threshold F \u03b1 . The inputs of FastANOVA include the N SNPs, the phenotype Y and the critical value F \u03b1 . For each X i , FastANOVA first indexes (X i X j ) \u2208 AP(X i ) using Array(X i ). Then it retrieves the candidate SNP-pairs by accessing Array(X i ) and records them in Cand(X i , Y ). The candidates in Cand(X i , Y ) are then evaluated for their F-statistics. The candidates whose F-statistics are greater than or equal to F \u03b1 are reported by the algorithm. Input: SNPs X = {X 1 , X 2 , . . . , X N }, phenotype Y , and threshold F \u03b1 Output: find the set of SNP-pairs\nResult(Y ) = {(X i X j )|F (X i X j , Y ) \u2265 F \u03b1 , 1 \u2264 i < j \u2264 N } 1 for every X i \u2208 X , do 2 index (X i X j ) \u2208 AP(X i ) by Array(X i ); 3\naccess Array(X i ) to find the candidate SNP-pairs and store them in Cand(X i , Y ); 4 for every\n(X i X j ) \u2208 Cand(X i , Y ) do 5 if F (X i X j , Y ) \u2265 F \u03b1 then 6\nResult(Y ) \u2190 (X i X j ); 7 end 8 end 9 end 10 return Result(Y ).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Permutation Procedure", "text": "For multiple tests, permutation procedure is often used in genetic analysis for controlling family-wise error rate. For genome-wide association study, permutation is less commonly used because it often entails prohibitively long computation time. Our FastANOVA algorithm makes permutation procedure feasible in genome-wide association study.\nLet Y = {Y 1 , Y 2 , . . . , Y K } be K permutations of the phenotype Y . Following the idea discussed in Section 5.1, the upper bound in Theorem 4.1 can be easily incorporated in the algorithm to handle the permutations. PROPERTY 5.5. For every SNP X i , the indexing structure Array(X i ) is independent of the permuted phenotypes in Y .\nThe correctness of this property relies on the fact that, for any (X i X j ) \u2208 AP(X i ), n a 1 and n b 1 only depend on the genotype of the SNP-pair and thus remain constant for different phenotype permutations. Therefore, for each X i , once we build Array(X i ), it can be reused in all permutations.\nThe FastANOVA algorithm for permutation test is described in Algorithm 2. The inputs include the N SNPs, K phenotype permutations, and the Type I error threshold \u03b1. The goal is to find the critical value F \u03b1 , which is the \u03b1 K -th largest value in {F Y k |Y k \u2208 Y }. Recall that F Y k is the maximum F-statistic value for phenotype Y k . We use Tlist to keep the \u03b1 K phenotype permutations having the largest F-statistics found by the algorithm so far. Initially, Tlist contains \u03b1 K dummy phenotype permutations with test values 0. The smallest F-statistic value in Tlist, initially 0, is used as the threshold to prune the SNP-pairs. For each X i , FastANOVA first indexes (X i X j ) \u2208 AP(X i ) using Array(X i ). Then it finds the set of candidate SNP-pairs Cand(X i , Y k ) by accessing Array(X i ) for every phenotype permutation Y k . The candidates in Cand(X i , Y k ) are then evaluated for their F-statistics. If a candidate's F-statistic value is greater than the current threshold, then Tlist is updated accordingly: If the candidate's phenotype Y k is not in the Tlist, then the phenotype in Tlist having the smallest ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "19:15", "text": "Algorigthm 2: FastANOVA (for permutation test) Input: SNPs X = {X 1 , X 2 , . . . , X N }, phenotype permutations Y = {Y 1 , Y 2 , . . . , Y K }, and the Type I error \u03b1 Output: find the critical value F \u03b1 1 Tlist \u2190 \u03b1 K dummy phenotype permutations with F-statistics 0; 2 F \u03b1 = 0; 3 for every X i \u2208 X , do 4 index (X i X j ) \u2208 AP(X i ) by Array(X i ); 5 for every Y k \u2208 Y , do 6 access Array(X i ) to find the candidate SNP-pairs and store them in F-statistic value is replaced by Y k . If the candidate's phenotype Y k is already in Tlist, we only need to update its corresponding F-statistic value to be the maximum value found for the phenotype so far. The threshold is also updated to be the smallest F-statistic value in Tlist.\nCand(X i , Y k ); 7 for every (X i X j ) \u2208 Cand(X i , Y k ) do 8 if F (X i X j , Y k ) \u2265 F", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Complexity Analysis", "text": "In this section, we study the time and space complexities of the FastANOVA algorithm for permutation test. The complexity for a single phenotype can be analyzed in a similar way. Time Complexity. For each X i , FastANOVA needs to index (X i X j ) in AP(X i ). The complexity to build the indexing structure for all SNPs is O(N (N \u2212 1)M/2). The worst case for accessing all Array(\nX i ) for all permutations is O(N \u00d7 K \u00d7 ( M 4 + 1) 2 ) = O(NKM 2 ). Let C = i,k |Cand(X i , Y k )| represent the total number of candidates. The overall time complexity of FastANOVA is thus O(N (N \u2212 1)M/2) + O(N K \u00d7 ( M 4 + 1) 2 ) + O( i,k |Cand(X i , Y k )|M ) = O(N 2 M + NKM 2 + CM).\nThe experimental results show that the overhead of building the indexing structures and accessing them for candidate retrieval are negligible when large permutation tests are needed. The time complexity of the brute-force approach is\nO(K N(N \u2212 1)M/2) = O(K N 2 M ).\nNote that in a typical genotype-phenotype association study, the number of SNPs N is much lager than the number of individuals M . Therefore, when the number of permutations K is large, e.g. thousands, the complexity of FastANOVA is much less than the complexity of the brute force approach.\nSpace Complexity. The total number of variables in the dataset, including the SNPs and the phenotype permutations, is N + K . The maximum space of  the indexing structure Array(X i ) is O(( M 4 + 1) 2 + N ). Note that for each SNP X i , FastANOVA only needs to access one indexing structure, Array(X i ), for all permutations. Once the evaluation process for X i is done for all permutations, Array(X i ) can be cleared from the memory. Therefore, the space complexity of FastANOVA is O(\n(N + K )M ) + O(( M 4 + 1) 2 + N ) = O((N + K )M ) since M N .\nThe space complexity is linear to the dataset size.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "EXPERIMENTAL RESULTS", "text": "In this section, we present extensive experimental results on evaluating the performance of the FastANOVA algorithm. We show (1) the runtime comparison between FastANOVA and the brute-force approach under various experimental settings, (2) the punning effect of the upper bound, and (3) the relative computational cost of each component of FastANOVA. FastANOVA is implemented in C++. The experiments are performed on a 2.4 GHz PC with 1G memory running WindowsXP system. Dataset. The SNP dataset used for the experiments is extracted from a set of combined SNPs from the 140k Broad/MIT mouse dataset (http://www. broad.mit.edu/) and 10k GNF mouse dataset (http://www.gnf.org/). This merged dataset has 156,525 SNPs for 71 individuals. The missing values in the dataset are imputed using NPUTE [Roberts et al. 2007]. We use both real phenotypes and synthetic phenotypes in our experiments. The real phenotype data is available from the Jackson Laboratory (http://www.jax.org/).", "publication_ref": ["b23"], "figure_ref": [], "table_ref": []}, {"heading": "Real Phenotypes", "text": "We use three real phenotypes in our experiments: cardiovascular (blood pressure), metabolism (water intake), and neurosensory (acoustic startle response). Table IV shows the statistics of the genotype datasets corresponding to the three phenotypes. The number of SNPs in the table indicates the number of unique SNPs in each genotype dataset.\nWe first show the results on finding the critical value F \u03b1 , which is more timeconsuming than finding the significance SNP-pairs given the critical value F \u03b1 for a single phenotype. 6.1.1 Finding Critical Value F \u03b1 6.1.1.1 FastANOVA vs. the Brute-Force Approach. We compare FastANOVA with the brute-force approach under various experimental settings. Since the brute-force approach is very time-consuming, we use a moderate number of SNPs and permutations in the default setting in order to show the performance comparisons. The default setting is as follows: The Type I error threshold \u03b1 = 0.01. The number of permutations is 100. The number of SNP is 10,000 for the two larger datasets of metabolism and neurosensory, and 2,900 for the  cardiovascular SNP dataset. These experimental settings are chosen to demonstrate the performance gain and enhanced scalability offered by FastANOVA over the brute-force implementation. FastANOVA can handle much larger SNP panels and larger number of permutation tests. The performance of FastANOVA is expected to follow the same trends presented in the remainder of this section.\nFigures 4, 5, and 6 show the running time comparison of FastANOVA and the brute-force approach on the three genotype phenotype datasets using different settings. The y-axis is in logarithm scale. The numbers above the runtime line of FastANOVA indicate the ratio of the runtimes of the brute-force approach over FastANOVA. We terminate the programs that have run over 72 hours without completion.\nFigure 4 shows the runtime comparison when varying the Type I error thresholds. For each dataset, the runtime of the brute-force approach does not change over different Type I error thresholds. The runtime of FastANOVA decreases as the threshold decreases. FastANOVA offers 218-fold speedup when \u03b1 = 0.05 and 293 fold speedup when \u03b1 = 0.01 on cardiovascular dataset. We can also observe a similar two-orders-of-magnitude speedup in the metabolism and neurosensory datasets. This is consistent with the pruning effect of the upper bound, which will be presented later in this section. In general, the lower the Type I error threshold, the more powerful the pruning effect, hence the faster the algorithm.\nFigure 5 depicts the comparison of these two approaches when the number of SNPs changes. From these figures, it is clear that FastANOVA is about two orders of magnitude faster than the brute-force approach. The brute-force approach cannot finish in 72 hours when the number of unique SNPs is greater than 26k in the metabolism dataset and greater than 24k in the neurosensory  dataset. We observe that the runtime ratio tends to increase (approaching three-orders-of-magnitude speedup) as the number of SNPs increases. This indicates that the performance gain of FastANOVA is even higher for larger SNP datasets.\nFigure 6 shows the runtime comparison when the number of phenotype permutations changes. The runtime of the brute-force approach is linear with respect to the number of permutations. FastANOVA is consistently two orders of magnitude faster than the brute-force approach. The performance gap increases as the number of permutations increases. V shows the percentage of SNP-pairs pruned under different experimental settings. Since the three datasets have different numbers of SNPs, the 1st to 5th rows in the column of \"# SNPs\" correspond to the settings from left to right on x-axis in each plot in Figure 5. Most SNP-pairs are pruned under all settings. Moreover, as the Type I error threshold \u03b1 decreases, the pruning ratio increases, which is consistent with runtime comparison shown in Figure 4. As the number of SNPs increases, the pruning ratio also increases. This is because, with more SNPs, the dynamic threshold used to prune the search space becomes higher. Hence, a larger portion of SNPs are pruned. This is consistent with results shown in Figure 5. Note that from Table V, we observe that the pruning ratio tends to remain steady when the number of permutations changes. However, we observe that the runtime ratio increases as the number of permutations increases. The reason for these two different trends will become clear after we show the results on the computational cost of each component of FastANOVA in the next subsection. 6.1.2 Finding Significant SNP-Pairs. In this section, we study the comparison between FastANOVA and the brute-force approach in finding significant SNP-pairs given a critical value F \u03b1 . Only the original phenotype (without permutations) is used in this procedure. We examine the detailed computation cost of each component of the FastANOVA algorithm. FastANOVA has three major components: building the indexing structure Array(X i ) for every SNP X i , accessing Array(X i ) to find the candidate SNP-pairs, and performing ANOVA tests on these candidates.", "publication_ref": [], "figure_ref": ["fig_9", "fig_9", "fig_10", "fig_12", "fig_10", "fig_9", "fig_10"], "table_ref": ["tab_4", "tab_5"]}, {"heading": "Pruning Effect of the Upper Bound. Table", "text": "Figures 7 to 9 show the performance comparison on the three datasets. The default experimental setting is the same as before. We examine the performance on metabolism dataset in detail. Similar behaviors can be observed on the other   two datasets. Figure 8(a) and Figure 8(b) show the runtime of these three components when varying the Type I error threshold and number of SNPs in the metabolism dataset respectively. Since F \u03b1 is a function of \u03b1, in Figure 8(a), we plot the runtime with respect to \u03b1. In both figures, the three lines from the bottom show the runtime of these three components. The runtime of the bruteforce approach is the top line. As we can see from these two figures, performing two-locus ANOVA tests on candidate SNP pairs is two to three orders of magnitude faster than performing such tests on all SNP-pairs. This is the benefit of the upper bound pruning since most SNP-pairs have been pruned and only a very small portion of candidates need to be evaluated for their F-statistics. The cost for accessing the indexing structures is also small, which demonstrates the efficiency of the method introduced in Section 5.1 for candidate retrieval. Among the three components of FastANOVA, the most time-consuming one is  building the index structures. Yet, its runtime is only a small fraction of the runtime of performing the two-locus ANOVA tests on all SNP pairs. Note that, in permutation test, building the index structures is a one time cost. Once the index structures are built, they can be reused in all permutations. Therefore, the amortized overhead per permutation decreases when the number of permutations increases. This is why the pruning ratio remains steady in Table V while the runtime ratio increases in Figure 6 when the number of permutations increases.\nFigure 10 shows the histogram of the sizes of the indexing structures for the three datasets. From Property 5.3, the maximum sizes of the indexing structures are 36 for the cardiovascular dataset, 64 for the metabolism dataset, and 100 for the neurosensory dataset. It is clear from the figure that the actual sizes of the indexing structures are much smaller than the maximum sizes. 6.1.3 Finding F Y k for All Permutations. Sometimes the users may be interested in finding F Y k values of all phenotype permutations. In this way, the  users can get the critical value F \u03b1 for any Type I error threshold \u03b1 ranging from 0 to 1, without re-running the permutation tests for different thresholds. Recall that, given a set of phenotype permutations Y = {Y 1 , Y 2 , . . . , Y K },\nF Y k = max{F (X i X j , Y k )|1 \u2264 i < j \u2264 N } is the maximum F-statistic value for permutation Y k . F \u03b1 is the \u03b1 K th largest value in {F Y k |Y k \u2208 Y }.\nIn this section, we show the pruning effect of the upper bound when it is applied to determine\nF Y k for every Y k (1 \u2264 k \u2264 K ).\nNote that in this case, for each permutation Y k , the dynamic threshold used to prune the search space is the largest F-statistic value of Y k identified by the algorithm so far.\nTable VI shows the pruning ratio of applying the upper bound to the three real phenotype datasets. The experimental setting is the same as the default setting before. As expected, the pruning ratios are slightly lower than those in Table V, where smaller Type I error thresholds are used to prune the search space. However, the pruning ratios on all three datasets are still above 97%. Moreover, finding all F Y k provides the advantage that we can get the F \u03b1 values for all possible \u03b1 values instead of just for a specific one.", "publication_ref": [], "figure_ref": ["fig_14", "fig_16", "fig_16", "fig_16", "fig_12", "fig_0"], "table_ref": ["tab_5", "tab_5", "tab_5"]}, {"heading": "Synthetic Phenotypes", "text": "To further study the performance of FastANOVA, we generate three synthetic phenotypes whose values follow three different distributions: uniform, standard normal (with mean 0 and variance 1), and standard exponential distribution (with the probability density function f (x) = e \u2212x ). Our purpose is to study the pruning effect of the upper bound under different phenotype distributions. The default setting of the experiments in this subsection is as follows:  #individuals = 32, #SNPs = 10,000, #permutations = 100, \u03b1 = 0.01. There are 60,970 unique SNPs for these 32 individuals.\nTable VII shows the pruning ratio of FastANOVA under different settings using permutation test. In this table, we also include the pruning ratio when the number of individuals varies. We observe that the pruning effects are similar to that of real phenotypes, which indicates that the upper bound pruning is effective and insensitive to different phenotype distributions.", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_5"]}, {"heading": "DISCUSSION", "text": "The large number of available SNPs poses great computational challenge to the genome-wide association study. To assess the significance of the findings, permutation test is usually required. These factors make the association study a very time-consuming process. Thus tools that can improve the efficiency of the association study are in demand.\nIn this article, we present an efficient algorithm, FastANOVA, for genomewide two-locus ANOVA test. FastANOVA is a complete algorithm which guarantees to find the optimal solution. Experimental results demonstrate that FastANOVA is two to three orders of magnitude faster than the brute-force alternative. The efficiency of FastANOVA is gained from two sources. First, it utilizes an upper bound of the two-locus ANOVA test value to prune a majority of the SNP-pairs. Second, it identifies and reuses computation units that are independent of the phenotype and hence are invariant in permutation test. By eliminating redundant computation of these invariant units, FastANOVA is much more efficient than the brute-force method. \nT 1 M 2 (O A +O B )(O A +O C )(O C +O D ) S 1 max O 2 A , O 2 C R 1 min O X j =1 O X j =0 |X i = 0 , O X j =0 O X j =1 |X i = 0 T 2 M 2 (O A +O B )(O B +O D )(O C +O D ) S 2 max O 2 B , O 2 D R 2 min O X j =1 O X j =0 |X i = 1 , O X j =0 O X j =1 |X i = 1", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Extension to Chi-Square Test", "text": "As our initial attempt to develop scalable algorithms for genome-wide association study, FastANOVA is specifically designed for the ANOVA test on quantitative phenotypes. Another category of phenotypes is generated in case-control study, where the phenotypes are binary variables representing disease/nondisease individuals. Chi-square test is one of the most commonly used statistics in binary phenotype association study. We can extend the principles in Fas-tANOVA for efficient two-locus chi-square test [Zhang et al. 2009b]. The general idea of FastChi is similar to that of FastANOVA, that is, re-formulating the chisquare test statistic to establish an upper bound of two-locus chi-square test, and indexing the SNP-pairs according to their genotypes in order to effectively prune the search space and reuse redundant computations. Here we briefly introduce the FastChi algorithm.\nFor SNP X i , we represent the chi-square test value of X i and the binary phenotype Y as \u03c7 2 (X i , Y ). For any SNP-pair X i and X j , we use \u03c7 2 (X i X j , Y ) to represent the chi-square test value for the combined effect of (X i X j ) with Y . Let A, B, C, D represent the following events respectively:\nY = 0 \u2227 X i = 0; Y = 0 \u2227 X i = 1; Y = 1 \u2227 X i = 0; Y = 1 \u2227 X i = 1.\nLet O event denote the observed value of an event. T 1 , T 2 , S 1 , S 2 , R 1 , and R 2 represent the formulas shown in Table VIII. We have the upper bound of \u03c7 2 (X i X j , Y ) stated in Theorem 7.1.\nTHEOREM 7.1 (UPPER BOUND OF \u03c7 2 (X i X j , Y )). \u03c7 2 (X i X j , Y ) \u2264 \u03c7 2 (X i , Y ) + T 1 S 1 R 1 + T 2 S 2 R 2 .\nFor given phenotype Y and SNPX i , \u03c7 2 (X i , Y ), T 1 , S 1 , T 2 , and S 2 are constants. R 1 and R 2 are the only variables that depend on X j and may vary for different SNP-pairs (X i X j ) \u2208 AP(X i ). (Recall that AP(X i ) = {(X i X j )|i + 1 \u2264 j \u2264 N }.) Thus, for a given X i , we can treat equation \u03c7 2 (X i , Y ) + T 1 S 1 R 1 + T 2 S 2 R 2 = \u03b8 as a straight line in the 2-D space of R 1 and R 2 . The ones whose (R 1 (X i X j ), R 2 (X i X j )) values fall below the line can be pruned without any further test.\nSuppose that there are 32 individuals, X i contains half 0's, and half 1's. For the SNP-pairs in AP(X i ), the possible values of R 1 (and R 2 ) are     \nX i = 0 X i = 1 Total Y = 0 event A event B Y = 1 event C event D Total M X i = 0 X i = 1 Total X j = 0 event S event T X j = 1 event P event Q Total M (c) X i X j and Y X i = 0 X i = 1 Total X j = 0 X j = 1 X j = 0 X j = 1 Y = 0 event a 1 event a 2 event b 1 event b 2 Y = 1 event c 1 event c 2 event d 1 event d 2 Total M G-test (\nE 0 = {a 1 , a 2 , b 1 , b 2 , c 1 , c 2 , d 1 , d 2 }, E 1 = {a 1 , a 2 , c 1 , c 2 }, and E 2 = {b 1 , b 2 , d 1 , d 2 }.\nThe two-locus chi-square tests can be calculated as follows:\n\u03c7 2 (X i X j , Y ) = event\u2208E 1 (O event \u2212 E event ) 2 E event \u03c7 2 1 (X i X j Y ) + event\u2208E 2 (O event \u2212 E event ) 2 E event \u03c7 2 2 (X i X j Y ) . (6\n)\nNote that we intentionally break the calculation into two components: one for the events in E 1 , denoted as \u03c7 2 1 (X i X j Y ), and one for the events in E 2 , denoted as \u03c7 2 2 (X i X j Y ). The reason for separating these two components is that each of these two components is a convex function (See Lemma 7.2).\nThe G-test, also known as a likelihood ratio test for goodness of fit, is an alternative to the chi-square test. The formula for two-locus G-test is\nG(X i X j , Y ) = 2 event\u2208E 1 O event \u2022 ln O event E event + 2 event\u2208E 2 O event \u2022 ln O event E event . (7)\nInformation-theoretic measurements have been proposed for association study. We examine the mutual information measure, which is the basic form of many other measurements. The mutual information between SNP-pair (X i X j ) and phenotype Y is I (Y ; X i X j ) = H(Y ) + H(X i X j ) \u2212 H(X i X j Y ), in which the joint entropy \u2212H(\nX i X j Y ) is calculated as \u2212H(X i X j Y ) = event\u2208E 1 O event M \u2022 log O event M + event\u2208E 2 O event M \u2022 log O event M . (8)\nLet T (X i X j , Y ) represent any one of \u03c7 2 (X i X j , Y ), G(X i X j , Y ), and \u2212H(X i X j Y ). Let T 1 (X i X j Y ) denote the component for events in E 1 , and T 2 (X i X j Y ) denote the component for events in E 2 . The following lemma shows the convexity of T 1 (X i X j Y ) and T 2 (X i X j Y ). Experimental results show that the developed upper bound is much tighter than that of the FastChi algorithm. In addition, this approach only requires the test statistic to be a convex function, which is true for a variety of tests. Please refer to Zhang et al. [2009a] for further details about COE.", "publication_ref": ["b34", "b33"], "figure_ref": [], "table_ref": ["tab_5"]}, {"heading": "LIMITATIONS AND FUTURE WORK", "text": "In general, genome-wide association study is not restricted to two-locus tests. Ideally, one should be able to examine the interactions among any number of SNPs. This dramatically increases the computational burden. For example, suppose that number of SNPs N = 10, 000 and number of permutations K = 1, 000, the number of tests needed for two-locus association study is in the order of 10 10 , and number of tests needed for three-locus association study is in the order of 10 14 . In practice, this means that if two-locus association testing takes 1 second, the three-locus testing will take about 10 4 seconds. The computational burden increases exponentially when the number of SNPs considered for interaction increases. In our future work, we will investigate scalable algorithms for multi-locus association study involving more than two-locus.\nOur work in this article is motivated by the association study for inbred mice, whose genotypes are usually binary. For other subjects, such as human, the genotype are heterozygous, where SNPs are encoded as {0, 1, 2}. The formulation in this article is for binary SNPs. In the future work, we plan to extend the principles used in this article to the heterozygous case. Another difference between human subjects and inbred mice is that the number of samples of human subjects are usually much larger than that of the mice. This could potentially impair the applicability of the indexing structure which is the key component of FastANOVA. The size of the indexing structure depends on the number of individuals in the dataset: the maximum size of the indexing structure increases quadratically with respect to the number of individuals. The associated problem is that he number of SNP-pairs indexed by the same entry will decrease and the accessing time of the indexing structure will increase. In the worst case, if the number of entries is larger than the number of SNPs, then there is no advantage to build the indexing structure. We will investigate algorithms for large sample datasets in our future work.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "", "text": "{ 0 16 , 1 15 , 2 14 , 3 13 , 4 12 , 5 11 , 6 10 , 7 9 , 8 8 }. Figure 11 shows the 2-D space of R 1 and R 2 . The blue stars represent the values that (R 1 , R 2 ) can take. The line \u03c7\nOnly the SNP-pairs whose (R 1 , R 2 ) values are in the shaded region are subject to two-locus Chi-square test.\nSimilar to FastANOVA, in FastChi, we can index the SNP-pairs in AP(X i ) according to their genotype relationships, i.e., by the values of (R 1 , R 2 ). Experimental results demonstrate that FastChi is an order of magnitude faster than the brute force alternative. For further details of FastChi, please refer to Zhang et al. [2009b].", "publication_ref": ["b34"], "figure_ref": [], "table_ref": []}, {"heading": "A General Approach for Binary Phenotypes", "text": "The common drawback of FastANOVA and FastChi is that they are specifically designed for ANOVA and chi-square tests, and cannot be applied to other statistics. In Zhang et al. [2009a], a generalized approach, COE, for case-control study is proposed. The major contribution is that COE can be applied to a wide range of statistics. One key observation is that many commonly used statistics are convex functions. This property allows to use convex optimization techniques to find tight upper bound for tow-locus statistical tests.\nWe use T to denote the statistical test that will be used for two-locus association study. Specifically, we represent the test value of SNP X i and phenotype Y as T (X i , Y ), and represent the test value of SNP-pair (X i X j ) and Y as T (X i X j , Y ). A contingency table, which records the observed values of all events, is the basis for many statistical tests. Table IX shows contingency tables for the single-locus test T (X i , Y ), genotype relationship between SNPs X i and X j , and two-locus test T (X i X j , Y ). Next, we use chi-square test,", "publication_ref": ["b33"], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "A tutorial on statistical methods for population association studies", "journal": "Nature Reviews Genetics", "year": "2006", "authors": "D J Balding"}, {"ref_id": "b1", "title": "Convex Optimization", "journal": "Cambridge University Press", "year": "2004", "authors": "S Boyd; L Vandenberghe"}, {"ref_id": "b2", "title": "Classification and Regression Trees", "journal": "Wadsworth, Inc", "year": "1984", "authors": "L Breiman; J H Friedman; R A Olshen; C J Stone"}, {"ref_id": "b3", "title": "The use of a genetic algorithm for simultaneous mapping of multiple interacting quantitative trait loci", "journal": "Genetics", "year": "2000", "authors": "O Carlborg; L Andersson; B Kinghorn"}, {"ref_id": "b4", "title": "Mapping complex disease loci in whole-genome association studies", "journal": "Nature", "year": "2004", "authors": "C S Carlson; M A Eberle; L Kruglyak; D A Nickerson"}, {"ref_id": "b5", "title": "Comparison of SNP tagging methods using empirical data: Association study of 713 SNPs on chromosome 12q14.3-12q24.21 for asthma and total serum IgE in an African Caribbean population", "journal": "Genet. Epidemiol", "year": "2006", "authors": "P Chi; P Duggal; W Kao; R A Mathias; A V Grant; M L Stockton; J G N Garcia; R G Ingergoll; A F Scott; T H Benty; K C Barnes; M D Fallin"}, {"ref_id": "b6", "title": "Use of an artificial neural network to detect association between a disease and multiple marker genotypes", "journal": "Ann. Hum. Genet", "year": "2001", "authors": "D Curtis; B V North; P C Sham"}, {"ref_id": "b7", "title": "Multifactorial genetics: Mapping and analysis of quantitative trait loci in experimental populations", "journal": "Nat. Rev. Genet", "year": "2002", "authors": "R W Doerge"}, {"ref_id": "b8", "title": "Multiple Testing Procedures with Applications to Genomics", "journal": "Springer-Verlag", "year": "2008", "authors": "S Dudoit;  Van Der; M J Laan"}, {"ref_id": "b9", "title": "Two-stage two-locus models in genome-wide association", "journal": "PLoS Genet", "year": "2006", "authors": "D M Evans; J Marchini; A P Morris; L R Cardon"}, {"ref_id": "b10", "title": "Tag SNP selection in genotype data for maximizing SNP prediction accuracy", "journal": "Oxford University Press", "year": "2005", "authors": "E Halperin; G Kimmel; R Shamir"}, {"ref_id": "b11", "title": "Mathematical multi-locus approaches to localizing complex human trait genes", "journal": "Nat. Rev. Genet", "year": "2003", "authors": "J Hoh; J Ott"}, {"ref_id": "b12", "title": "Selecting SNPs in two-stage analysis of disease association data: A model-free approach", "journal": "Ann. Hum. Genet", "year": "2000", "authors": "J Hoh; A Wille; R Zee; S Cheng; R Reynolds; K Lindpaintner; J Ott"}, {"ref_id": "b13", "title": "Genetic and haplotype diversity among wild-derived mouse inbred strains", "journal": "Gen. Res", "year": "2004", "authors": "F Ideraabdullah; E Dela Casa-Esper\u00f3n; T A Bell; D A Petwiler; T Magnuson; C Sapienza;  Pardo-Manuel De; F Villena"}, {"ref_id": "b14", "title": "Feature selection for knowledge discovery and data mining", "journal": "Kluwer Academic", "year": "1998", "authors": "H Liu; H Motoda"}, {"ref_id": "b15", "title": "Simultaneous Statistical Inference", "journal": "Springer-Verlag", "year": "1981", "authors": "R G Miller"}, {"ref_id": "b16", "title": "A flexible computational framework for detecting, characterizing, and interpreting statistical patterns of epistasis in genetic studies of human disease susceptibility", "journal": "J. Theoret. Biol", "year": "2006", "authors": "J H Moore; J C Gilbert; C.-T Tsai; F.-T Chiang; T Holden; N Barney; B C White"}, {"ref_id": "b17", "title": "Detection of closely linked multiple quantitative trait loci using a genetic algorithm", "journal": "Genetics", "year": "2001", "authors": "R Nakamichi; Y Ukai; H Kishino"}, {"ref_id": "b18", "title": "A combinatorial partitioning method to identify multilocus genotypic partitions that predict quantitative trait variation", "journal": "Gen. Res", "year": "2001", "authors": "M R Nelson; S L Kardia; R E Ferrell; C F Sing"}, {"ref_id": "b19", "title": "", "journal": "", "year": "", "authors": "X Zhang"}, {"ref_id": "b20", "title": "Selective genotyping with epistasis can be utilized for a major quantitative trait locus mapping in hypertension in rats", "journal": "Genetics", "year": "2000", "authors": "Y Ohno; H Tanase; T Nabika; K Otsuka; T Sasaki; T Suzawa; T Morii; Y Yamori; T Saruta"}, {"ref_id": "b21", "title": "Classification methods for confronting heterogeneity", "journal": "Duxbury Press", "year": "2000", "authors": "M Pagano; K ; Gauvreau; M A Province; W D Shannon; D C Rao"}, {"ref_id": "b22", "title": "Multifactor-dimensionality reduction reveals high-order interactions among estrogenmetabolism genes in sporadic breast cancer", "journal": "Amer. J. Hum. Gen", "year": "2001", "authors": "M D Ritchie; L W Hahn; N Roodi; L R Bailey; W D Dupont; F F Parl; J H Moore"}, {"ref_id": "b23", "title": "Inferring missing genotypes in large SNP panels using fast nearest-neighbor searches over sliding windows", "journal": "Oxford University Press", "year": "2007", "authors": "A Roberts; L Mcmillan; W Wang; J Parker; I Rusyn; D Threadgill"}, {"ref_id": "b24", "title": "", "journal": "Science", "year": "2007", "authors": "R Saxena; B F Voight; V Lyssenko; N P Burtt; P I W De Bakker; H Chen; J J Roix; S Kathire-San; J N Hirschhorn; M J Daly; T E Hughes; L Groop; D Altshuler; P Almgren; J C Florez; J Meyer; K Ardle; K Bengtsson Bostr\u00f6m; B Isomaa; G Lettre; U Lindblad; H N Lyon; O Melander; C Newton-Cheh; P Nilsson; M Orho-Melander; L R\u00e1stam; E K Speliotes; M.-R Taskinen; T Tuomi; C Guiducci; A Berglund; J Carlson; L Gianniny; R Hackett; L Hall; J Holmkvist; E Laurita; M Sj\u00f6gren; M Sterner; A Surti; M Svensson; M Svens-Son; R Tewhey; B Blumenstiel; M Parkin; M Defelice; R Barry; W Brodeur; J Camarata; N Chia;  M Fava; J Gibbons; B Handsaker; C Healy; K Nguyen; C Gates; C Sougnez; D Gage; M Nizzari; S B Gabriel; G.-W Chim; Q Ma; H Parikh; D Richardson; D Ricke; S Purcell"}, {"ref_id": "b25", "title": "Genome-wide association scan shows genetic variants in the FTO gene are associated with obesity-related traits", "journal": "", "year": "2007", "authors": "A Scuteri; S Sanna; W M Chan; M Uda; G Albai; J Strait; S Najjar; R Nagaraja; M Orr\u00fa; G Usala; M Dei; S Lai; A Maschio; F Busonero; A Mulas; G B Ehret; A A Fink; A B Weder; R S Cooper; P Galan; A Chakravarti; D Schlessinger; A Cao; E Lakatta; G R Abecasis"}, {"ref_id": "b26", "title": "Minimal haplotype tagging. Proc. Natl. Acad. Sci. USA", "journal": "", "year": "2003", "authors": "P Sebastiani; R Lazarus; S T Weiss; L M Kunkel; I S Kohane; M F Ramoni"}, {"ref_id": "b27", "title": "Modular epistasis in yeast metabolism", "journal": "Nat. Genet", "year": "2005", "authors": "D Segr; A Deluna; G M Church; R Kishony"}, {"ref_id": "b28", "title": "Applications of neural networks for gene finding", "journal": "Adv. Genet", "year": "2001", "authors": "A Sherriff; J Ott"}, {"ref_id": "b29", "title": "Genome-wide epistatic interaction analysis reveals complex genetic determinants of circadian behavior in mice", "journal": "Gen. Res", "year": "2001", "authors": "K Shimomura; S S Low-Zeddies; D P King; T D Steeves; A Whiteley; J Kushla; P D Zemenides; A Lin; M H Vitaterna; G A Churchill; J S Takahashi"}, {"ref_id": "b30", "title": "A common variant of HMGA2 is associated with adult and childhood height in the general population", "journal": "Nat. Genet", "year": "2007", "authors": "M N Weedon; G Lettre; R M Freathy; C M Lindgren; B F Voight; J R Perry; K S Elliott; R Hackett; C Guiducci; B Shields; E Zeggini; H Lango; V Lyssenko; N J Timpson; N P Burtt; N W Rayner; R Saxena; K Ardlie; J H Tobias; A R Ness; S M Ring; C N Palmer; A D Morris; L Peltonen; V Salomaa;  Diabetes;  Initiative;  Case Control; Davey Consortium; G Smith; L C Groop; A T Hattersley; M I Mccarthy; J N Hirschhorn; T M Frayling"}, {"ref_id": "b31", "title": "Resampling-Based Multiple Testing", "journal": "Wiley", "year": "1993", "authors": "P H Westfall; S S Young"}, {"ref_id": "b32", "title": "Use of classification trees for association studies", "journal": "Genet. Epidemiol", "year": "2000", "authors": "H Zhang; G Bonney"}, {"ref_id": "b33", "title": "COE: A general approach for efficient genome-wide two-locus epistatic test in disease association study", "journal": "Springer-Verlag", "year": "2009", "authors": "X Zhang; F Pan; Y Xie; F Zow; W Wang"}, {"ref_id": "b34", "title": "FastChi: An efficient algorithm for analyzing gene-gene interactions", "journal": "World Scientific", "year": "2009", "authors": "X Zhang; F Zou; W Wang"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Fig. 1 .1Fig. 1. Examples of associations between a phenotype and two different SNPs.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": ":", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Fig. 2 .2Fig.2. An example of determining the critical value using permutation test.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "PROPERTY 4.2. The upper bound in Theorem 4.1 is tight.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_5", "figure_caption": "\u2022", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_7", "figure_caption": "\u2022", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_9", "figure_caption": "Fig. 4 .4Fig. 4. Performance comparison between FastANOVA and the brute-force approach when varying Type I error thresholds.", "figure_data": ""}, {"figure_label": "5", "figure_type": "figure", "figure_id": "fig_10", "figure_caption": "Fig. 5 .5Fig. 5. Performance comparison between FastANOVA and the brute-force approach when varying the number of SNPs.", "figure_data": ""}, {"figure_label": "6", "figure_type": "figure", "figure_id": "fig_12", "figure_caption": "Fig. 6 .6Fig.6. Performance comparison between FastANOVA and the brute-force approach when varying the number of permutations.", "figure_data": ""}, {"figure_label": "7", "figure_type": "figure", "figure_id": "fig_14", "figure_caption": "Fig. 7 .7Fig. 7. Finding significant SNP-pairs (cardiovascular dataset).", "figure_data": ""}, {"figure_label": "8", "figure_type": "figure", "figure_id": "fig_16", "figure_caption": "Fig. 8 .8Fig. 8. Finding significant SNP-pairs (metabolism dataset).", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_17", "figure_caption": "Fig. 10. Histogram of the sizes of the indexing structures.", "figure_data": ""}, {"figure_label": "11", "figure_type": "figure", "figure_id": "fig_20", "figure_caption": "Fig. 11 .11Fig. 11. Pruning SNP-Pairs in AP(X i ) using the Upper Bound.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_22", "figure_caption": "Given the values of OA , O B , O C , O D , O P , O Q , T 1 (X i X j Y ) is a convex function of O c 2 , and T 2 (X i X j Y ) is a convex function of O d 2 .Suppose that the range of O c 2 is [l c 2 , u c 2 ], and the range ofO d 2 is [l d 2 , u d 2 ].For any convex function, its maximum value is attained at one of the vertices of it convex domain[Boyd and Vandenberghe 2004]. Thus, we have the following theorem.THEOREM 7.3. Given the values of O A , O B , O C , O D , O P , O Q , for chi-square test, G-test, and entropy-based test, the maximum value ofT 1 (X i X j Y ) is attained when O c 2 = l c 2 or O c 2 = u c 2 . The maximum value of T 2 (X i X j Y ) is attained when O d 2 = l d 2 or O d 2 = u d 2 .By further studying the relationships between the observed values shown in TableIX,we can derive the ranges of O c 2 and O d 2 . THEOREM 7.4. Given the values of O A , O B , O C , O D , O P , O Q , the ranges of O c 2 and O d 2 are max{0, O P \u2212 O A } \u2264 O c 2 \u2264 min{O P , O C }; max{0, O Q \u2212 O B } \u2264 O d 2 \u2264 min{O Q , O D }.", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "Table I. An Example Dataset for Phenotype-SNP Association Study", "figure_data": "\u202219:3SNPsPhenotypeX 1"}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_2", "figure_caption": "ACM Transactions on Knowledge Discovery from Data, Vol. 3, No. 4, Article 19, Publication date: November 2009. Zhang et al.", "figure_data": "19:12(X 1 . ) .... (X 1 . ) (X 1 X 4 ) (X 1 X 2 )2 3(1,2)(X 1 X 1000 ). . (X 1 . )n b10 1(3,1)(X 1 X 3 ) . (X 1 . ) (X 1 X 5 )0123. .n a1(X 1 . )"}, {"figure_label": "IV", "figure_type": "table", "figure_id": "tab_4", "figure_caption": "Statistics of the Genotype Datasets", "figure_data": "Cardiovascular MetabolismNeurosensory# individuals192634# SNPs14,51343,85666,006"}, {"figure_label": "V", "figure_type": "table", "figure_id": "tab_5", "figure_caption": "Pruning Effects on Cardiovascular, Metabolism and Neurosensory Datasets when Finding Critical Value F \u03b1", "figure_data": "CardiovascularMetabolismNeurosensory0.0599.881%99.724%99.701%0.0499.907%99.758%99.751%\u03b10.0399.928%99.797%99.792%0.0299.949%99.877%99.853%0.0199.974%99.929%99.911%1st99.974%99.929%99.911%2nd99.991%99.985%99.979%# SNPs3rd99.996%99.996%99.997%4th99.998%99.996%99.997%5th99.998%99.993%99.998%10099.974%99.929%99.911%20099.966%99.935%99.917%# Perm.30099.977%99.962%99.919%40099.977%99.961%99.914%50099.974%99.953%99.907%(a) Varying threshold values(b) Varying number of SNPs"}, {"figure_label": "VI", "figure_type": "table", "figure_id": "tab_6", "figure_caption": "", "figure_data": "Pruning Effect on Cardiovascular,Metabolism and Neurosensory Datasets whenFinding F Y k for all PermutationsCardiovascularMetabolismNeurosensory97.865%97.844%98.061%"}, {"figure_label": "VII", "figure_type": "table", "figure_id": "tab_7", "figure_caption": "Pruning Effect when Finding Critical Value F \u03b1 using three Synthetic Phenotypes", "figure_data": "UniformNormalExponential0.0596.469%97.793%99.335%0.0496.888%98.222%99.401%\u03b10.0397.695%98.631%99.502%0.0298.712%99.072%99.617%0.0199.605%99.506%99.737%10k99.605%99.506%99.737%22k99.864%99.814%99.924%# SNPs34k99.907%99.905%99.967%46k99.928%99.889%99.965%58k99.941%99.942%99.963%10099.605%99.506%99.737%20098.891%99.398%99.726%# Perm.30098.897%99.072%99.780%40098.623%99.315%99.762%50098.709%99.199%99.759%2899.756%99.695%99.893%3099.422%99.577%99.880%# indiv.3299.605%99.506%99.737%3499.073%99.289%99.773%3698.736%98.832%99.745%"}, {"figure_label": "VIII", "figure_type": "table", "figure_id": "tab_8", "figure_caption": "Notations Used in the Derivation of the Upper Bound for Two-Locus Chi-Square Test Symbols Formulas", "figure_data": ""}, {"figure_label": "IX", "figure_type": "table", "figure_id": "tab_9", "figure_caption": "", "figure_data": "Contingency Tables(a) X i and Y(b) X i and X j"}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_10", "figure_caption": ", a 2 , b 1 , b 2 , c 1 , c 2 , d 1 , d 2 representthe events as shown in Table IX. Let E event and O event denote the expected value and observed value of an event. Suppose that", "figure_data": "likely ratio test), and entropy based test as concrete examples to showthat they are convex statistics.Let A, B, C, D, S, T, P, Q, a 1"}], "formulas": [{"formula_id": "formula_0", "formula_text": "X 2 X 3 X 4 X 5 \u2022 \u2022 \u2022 X 1000 Y 0 0 0 1 0 1 8 0 0 0 0 0 0 7 0 1 1 0 0 \u2022 \u2022 \u2022 1 12 0 1 0 0 1 0 11 0 1 0 1 0 1 9 0 1 0 0 0 \u2022 \u2022 \u2022 0 13 1 0 1 1 1 1 6 1 0 0 0 1 0 4 1 1 1 1 1 \u2022 \u2022 \u2022 1 2 1 0 0 1 0 0 5 1 0 0 1 0 1 0 1 0 1 1 0 \u2022 \u2022 \u2022 0 3 0 1 phenotype", "formula_coordinates": [3.0, 209.08, 152.93, 192.42, 254.21]}, {"formula_id": "formula_1", "formula_text": "\u03b1 = 1 \u2212 (1 \u2212 \u03b1) n .", "formula_coordinates": [3.0, 272.42, 635.9, 77.36, 11.58]}, {"formula_id": "formula_2", "formula_text": "X i (1 \u2264 i \u2264 N ) is a binary variable coded by {0, 1}. Let Y = { y 1 , y 2 , . . . , y M } be the quantitative phenotype of interest, where y m (1 \u2264 m \u2264 M ) is the phenotype value of individual m. For any SNP X i (1 \u2264 i \u2264 N )", "formula_coordinates": [6.0, 127.61, 351.76, 358.65, 45.83]}, {"formula_id": "formula_3", "formula_text": "SS B = k i=1 m i (\u0233 i \u2212\u0233) 2 ; SS W = k i=1 m i j =1 ( y i j \u2212\u0233 i ) 2 ; SS T = k i=1 m i j =1 ( y i j \u2212\u0233) 2 .", "formula_coordinates": [6.0, 191.7, 548.94, 230.49, 63.61]}, {"formula_id": "formula_4", "formula_text": "X i = 1 X i = 0 group A group B (b) Grouping of Y by X i X j X i = 1 X i = 0 X j = 1 group a 1 group b 1 X j = 0 group a 2 group b 2", "formula_coordinates": [7.0, 242.91, 153.7, 136.5, 70.96]}, {"formula_id": "formula_5", "formula_text": "SS T (X i , Y ) = SS B (X i , Y ) + SS W (X i , Y ), SS T (X i X j , Y ) = SS B (X i X j , Y ) + SS W (X i X j , Y ).", "formula_coordinates": [7.0, 196.06, 261.35, 230.1, 35.45]}, {"formula_id": "formula_6", "formula_text": "F (X i , Y ) = M \u2212 2 2 \u2212 1 \u00d7 SS B (X i , Y ) SS T (X i , Y ) \u2212 SS B (X i , Y ) ,(1)", "formula_coordinates": [7.0, 200.36, 322.76, 290.07, 24.43]}, {"formula_id": "formula_7", "formula_text": "F (X i X j , Y ) = M \u2212 g g \u2212 1 \u00d7 SS B (X i X j , Y ) SS T (X i X j , Y ) \u2212 SS B (X i X j , Y ) ,(2)", "formula_coordinates": [7.0, 177.93, 359.9, 312.5, 24.43]}, {"formula_id": "formula_8", "formula_text": "SS T (X i , Y ) = SS T (X i X j , Y ) = y m \u2208Y y 2 m \u2212 T 2 M .", "formula_coordinates": [7.0, 205.41, 468.78, 211.39, 28.54]}, {"formula_id": "formula_9", "formula_text": "SS B (X i , Y ) = T 2 A n A + T 2 B n B \u2212 T 2 M , SS B (X i X j , Y ) = T 2 a 1 n a 1 + T 2 a 2 n a 2 + T 2 b 1 n b 1 + T 2 b 2 n b 2 \u2212 T 2 M .", "formula_coordinates": [7.0, 205.46, 547.37, 211.29, 65.87]}, {"formula_id": "formula_10", "formula_text": "X i X j ) (1 \u2264 i < j \u2264 N ), the ANOVA test is performed and F (X i X j , Y ) is recorded.", "formula_coordinates": [8.0, 127.61, 300.34, 358.65, 22.32]}, {"formula_id": "formula_11", "formula_text": "F Y k = max{F (X i X j , Y k )|1 \u2264 i < j \u2264 N }.", "formula_coordinates": [8.0, 214.32, 423.83, 185.94, 11.01]}, {"formula_id": "formula_12", "formula_text": "F \u03b1 is the \u03b1 K -th largest value in {F Y k |Y k \u2208 Y }. The SNP-pair (X i X j ) whose F-statistic value F (X i X j , Y ) \u2265 F \u03b1 is considered as significant at \u03b1.", "formula_coordinates": [8.0, 127.61, 477.58, 358.65, 22.66]}, {"formula_id": "formula_13", "formula_text": "{F Y k |Y k \u2208 Y }. Problem (2). Given the threshold F \u03b1 , find all significant SNP-pairs (X i X j ) such that F (X i X j , Y ) \u2265 F \u03b1 .", "formula_coordinates": [8.0, 127.61, 613.07, 358.66, 38.6]}, {"formula_id": "formula_14", "formula_text": "A = T 2 a 1 n a 1 + T 2 a 2 n a 2 \u2212 T 2 A n A = n a 2 T 2 a 1 + n a 1 T 2 a 2 n a 1 n a 2 \u2212 (T a 1 + T a 2 ) 2 n a 1 + n a 2 = (n a 2 T a 1 \u2212 n a 1 T a 2 ) 2 n a 1 n a 2 n A = (n A T a 1 \u2212 n a 1 T A ) 2 n a 1 (n A \u2212 n a 1 )n A .", "formula_coordinates": [9.0, 235.66, 388.29, 158.18, 116.26]}, {"formula_id": "formula_15", "formula_text": "B = T 2 b 1 n b 1 + T 2 b 2 n b 2 \u2212 T 2 B n B = (n B T b 1 \u2212 n b 1 T B ) 2 n b 1 (n B \u2212 n b 1 )n B .", "formula_coordinates": [9.0, 222.8, 542.34, 185.38, 27.38]}, {"formula_id": "formula_16", "formula_text": "SS B (X i X j , Y ) = SS B (X i , Y ) + A + B. (3", "formula_coordinates": [9.0, 215.46, 599.89, 270.91, 10.37]}, {"formula_id": "formula_17", "formula_text": ")", "formula_coordinates": [9.0, 486.37, 600.26, 4.06, 9.18]}, {"formula_id": "formula_18", "formula_text": "A = 0. Similarly, if any one of {n b 1 , n b 2 , n B } is 0, then B = 0.", "formula_coordinates": [9.0, 131.78, 621.04, 358.65, 23.06]}, {"formula_id": "formula_19", "formula_text": "y A 1 \u2264 y A 2 \u2264 \u2022 \u2022 \u2022 \u2264 y A n A .", "formula_coordinates": [10.0, 255.26, 176.81, 104.99, 12.52]}, {"formula_id": "formula_20", "formula_text": "d A d T a 1 = 2n A (n A T a 1 \u2212 n a 1 T A ) n a 1 (n A \u2212 n a 1 )n A .", "formula_coordinates": [10.0, 242.26, 221.48, 130.56, 25.16]}, {"formula_id": "formula_21", "formula_text": "A monotonically increases if T a 1 \u2265 n a 1 T A n A ; decreases if T a 1 \u2264 n a 1 T A n A .", "formula_coordinates": [10.0, 211.93, 267.05, 195.32, 31.93]}, {"formula_id": "formula_22", "formula_text": "T a 1 \u2208 [l a 1 , u a 1 ] = \u23a1 \u23a3 n a 1 i=1 y A i , n A i=n A \u2212n a 1 +1 y A i \u23a4 \u23a6 . The maximum value of A is attained when T a 1 = l a 1 or T a 1 = u a 1 , i.e., A \u2264 max{(n A l a 1 \u2212 n a 1 T A ) 2 , (n A u a 1 \u2212 n a 1 T A ) 2 } n a 1 (n A \u2212 n a 1 )n A . (4", "formula_coordinates": [10.0, 139.57, 315.32, 342.64, 93.68]}, {"formula_id": "formula_23", "formula_text": ")", "formula_coordinates": [10.0, 482.21, 391.19, 4.06, 9.18]}, {"formula_id": "formula_24", "formula_text": "y B 1 \u2264 y B 2 \u2264 \u2022 \u2022 \u2022 \u2264 y B n B .", "formula_coordinates": [10.0, 255.48, 469.07, 104.56, 12.52]}, {"formula_id": "formula_25", "formula_text": "B \u2264 max{(n B l b 1 \u2212 n b 1 T B ) 2 , (n B u b 1 \u2212 n b 1 T B ) 2 } n b 1 (n B \u2212 n b 1 )n B . (5", "formula_coordinates": [10.0, 209.23, 504.11, 272.98, 26.28]}, {"formula_id": "formula_26", "formula_text": ")", "formula_coordinates": [10.0, 482.21, 512.58, 4.06, 9.18]}, {"formula_id": "formula_27", "formula_text": "THEOREM 4.1 (UPPER BOUND OF SS B (X i X j , Y )). SS B (X i X j , Y ) \u2264 SS B (X i , Y ) + R 1 (X i X j Y ) + R 2 (X i X j Y ).", "formula_coordinates": [10.0, 139.57, 590.83, 302.0, 28.21]}, {"formula_id": "formula_28", "formula_text": "l a 1 na 1 i=1 y A i u a 1 n A i=n A \u2212na 1 +1 y A i R 1 (X i X j Y ) max{(n A la 1 \u2212na 1 T A ) 2 , (n A ua 1 \u2212na 1 T A ) 2 } na 1 (n A \u2212na 1 )n A l b 1 n b 1 i=1 y B i u b 1 n B i=n B \u2212n b 1 +1 y B i R 2 (X i X j Y ) max{(n B l b 1 \u2212n b 1 T B ) 2 , (n B u b 1 \u2212n b 1 T B ) 2 } n b 1 (n B \u2212n b 1 )n B", "formula_coordinates": [11.0, 223.31, 144.42, 175.03, 117.67]}, {"formula_id": "formula_29", "formula_text": "SS B (X i , Y ) + R 1 (X i X j Y ) + R 2 (X i X j Y ) \u2264 SS T (X i X j , Y ).", "formula_coordinates": [11.0, 176.44, 308.96, 269.33, 10.42]}, {"formula_id": "formula_30", "formula_text": "X i X j , Y ) \u2265 F \u03b1 is equivalent to finding SNP-pairs satisfying SS B (X i X j , Y ) \u2265 SS T (X i , Y ) M \u2212 g ( g \u22121)F \u03b1 + 1 = \u03b8.", "formula_coordinates": [11.0, 131.78, 494.8, 358.65, 56.48]}, {"formula_id": "formula_31", "formula_text": "SS B (X i , Y ) + R 1 (X i X j Y ) + R 2 (X i X j Y ) \u2265 \u03b8.", "formula_coordinates": [11.0, 207.17, 586.15, 207.86, 10.42]}, {"formula_id": "formula_32", "formula_text": "X i (1 \u2264 i \u2264 N ), let AP(X i ) be the set of SNP-pairs AP(X i ) = {(X i X j )|i + 1 \u2264 j \u2264 N }.", "formula_coordinates": [11.0, 131.78, 639.46, 358.65, 39.77]}, {"formula_id": "formula_33", "formula_text": "(X i X j ) \u2208 AP(X i ), the possible values that n a 1 can take are {0, 1, 2, . . . , m/2 }. The possible values that n b 1 can take are {0, 1, 2, . . . , (M \u2212 m)/2 }.", "formula_coordinates": [12.0, 127.61, 534.0, 358.65, 35.02]}, {"formula_id": "formula_34", "formula_text": "X i ) is M 4 + 1 2 .", "formula_coordinates": [13.0, 164.05, 322.5, 179.98, 41.24]}, {"formula_id": "formula_35", "formula_text": "Result(Y ) = {(X i X j )|F (X i X j , Y ) \u2265 F \u03b1 , 1 \u2264 i < j \u2264 N } 1 for every X i \u2208 X , do 2 index (X i X j ) \u2208 AP(X i ) by Array(X i ); 3", "formula_coordinates": [14.0, 132.59, 165.3, 274.86, 48.44]}, {"formula_id": "formula_36", "formula_text": "(X i X j ) \u2208 Cand(X i , Y ) do 5 if F (X i X j , Y ) \u2265 F \u03b1 then 6", "formula_coordinates": [14.0, 132.59, 215.11, 172.52, 28.52]}, {"formula_id": "formula_37", "formula_text": "Cand(X i , Y k ); 7 for every (X i X j ) \u2208 Cand(X i , Y k ) do 8 if F (X i X j , Y k ) \u2265 F", "formula_coordinates": [15.0, 136.76, 245.33, 190.51, 28.87]}, {"formula_id": "formula_38", "formula_text": "X i ) for all permutations is O(N \u00d7 K \u00d7 ( M 4 + 1) 2 ) = O(NKM 2 ). Let C = i,k |Cand(X i , Y k )| represent the total number of candidates. The overall time complexity of FastANOVA is thus O(N (N \u2212 1)M/2) + O(N K \u00d7 ( M 4 + 1) 2 ) + O( i,k |Cand(X i , Y k )|M ) = O(N 2 M + NKM 2 + CM).", "formula_coordinates": [15.0, 131.78, 507.17, 358.65, 60.08]}, {"formula_id": "formula_39", "formula_text": "O(K N(N \u2212 1)M/2) = O(K N 2 M ).", "formula_coordinates": [15.0, 268.4, 592.03, 156.09, 11.08]}, {"formula_id": "formula_40", "formula_text": "(N + K )M ) + O(( M 4 + 1) 2 + N ) = O((N + K )M ) since M N .", "formula_coordinates": [16.0, 128.27, 227.73, 358.0, 23.02]}, {"formula_id": "formula_41", "formula_text": "F Y k = max{F (X i X j , Y k )|1 \u2264 i < j \u2264 N } is the maximum F-statistic value for permutation Y k . F \u03b1 is the \u03b1 K th largest value in {F Y k |Y k \u2208 Y }.", "formula_coordinates": [21.0, 131.78, 422.29, 358.65, 22.97]}, {"formula_id": "formula_42", "formula_text": "F Y k for every Y k (1 \u2264 k \u2264 K ).", "formula_coordinates": [21.0, 132.47, 458.16, 135.11, 11.01]}, {"formula_id": "formula_43", "formula_text": "T 1 M 2 (O A +O B )(O A +O C )(O C +O D ) S 1 max O 2 A , O 2 C R 1 min O X j =1 O X j =0 |X i = 0 , O X j =0 O X j =1 |X i = 0 T 2 M 2 (O A +O B )(O B +O D )(O C +O D ) S 2 max O 2 B , O 2 D R 2 min O X j =1 O X j =0 |X i = 1 , O X j =0 O X j =1 |X i = 1", "formula_coordinates": [23.0, 224.42, 156.04, 173.47, 106.91]}, {"formula_id": "formula_44", "formula_text": "Y = 0 \u2227 X i = 0; Y = 0 \u2227 X i = 1; Y = 1 \u2227 X i = 0; Y = 1 \u2227 X i = 1.", "formula_coordinates": [23.0, 131.79, 480.61, 358.64, 22.32]}, {"formula_id": "formula_45", "formula_text": "THEOREM 7.1 (UPPER BOUND OF \u03c7 2 (X i X j , Y )). \u03c7 2 (X i X j , Y ) \u2264 \u03c7 2 (X i , Y ) + T 1 S 1 R 1 + T 2 S 2 R 2 .", "formula_coordinates": [23.0, 143.73, 533.88, 275.74, 31.32]}, {"formula_id": "formula_46", "formula_text": "X i = 0 X i = 1 Total Y = 0 event A event B Y = 1 event C event D Total M X i = 0 X i = 1 Total X j = 0 event S event T X j = 1 event P event Q Total M (c) X i X j and Y X i = 0 X i = 1 Total X j = 0 X j = 1 X j = 0 X j = 1 Y = 0 event a 1 event a 2 event b 1 event b 2 Y = 1 event c 1 event c 2 event d 1 event d 2 Total M G-test (", "formula_coordinates": [25.0, 131.78, 142.97, 329.31, 144.13]}, {"formula_id": "formula_47", "formula_text": "E 0 = {a 1 , a 2 , b 1 , b 2 , c 1 , c 2 , d 1 , d 2 }, E 1 = {a 1 , a 2 , c 1 , c 2 }, and E 2 = {b 1 , b 2 , d 1 , d 2 }.", "formula_coordinates": [25.0, 131.78, 325.38, 358.65, 22.37]}, {"formula_id": "formula_48", "formula_text": "\u03c7 2 (X i X j , Y ) = event\u2208E 1 (O event \u2212 E event ) 2 E event \u03c7 2 1 (X i X j Y ) + event\u2208E 2 (O event \u2212 E event ) 2 E event \u03c7 2 2 (X i X j Y ) . (6", "formula_coordinates": [25.0, 160.82, 358.95, 325.55, 47.27]}, {"formula_id": "formula_49", "formula_text": ")", "formula_coordinates": [25.0, 486.37, 367.42, 4.06, 9.18]}, {"formula_id": "formula_50", "formula_text": "G(X i X j , Y ) = 2 event\u2208E 1 O event \u2022 ln O event E event + 2 event\u2208E 2 O event \u2022 ln O event E event . (7)", "formula_coordinates": [25.0, 139.98, 492.35, 350.45, 27.29]}, {"formula_id": "formula_51", "formula_text": "X i X j Y ) is calculated as \u2212H(X i X j Y ) = event\u2208E 1 O event M \u2022 log O event M + event\u2208E 2 O event M \u2022 log O event M . (8)", "formula_coordinates": [25.0, 158.66, 575.09, 331.77, 39.25]}], "doi": "10.1145/1631162.1631167"}