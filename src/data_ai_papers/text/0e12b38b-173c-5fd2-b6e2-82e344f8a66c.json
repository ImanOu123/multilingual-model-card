{"title": "Fast Semidifferential-based Submodular Function Optimization *", "authors": "Rishabh Iyer; Stefanie Jegelka; Jeff Bilmes", "pub_date": "2013-08-14", "abstract": "We present a practical and powerful new framework for both unconstrained and constrained submodular function optimization based on discrete semidifferentials (sub-and super-differentials). The resulting algorithms, which repeatedly compute and then efficiently optimize submodular semigradients, offer new and generalize many old methods for submodular optimization. Our approach, moreover, takes steps towards providing a unifying paradigm applicable to both submodular minimization and maximization, problems that historically have been treated quite distinctly. The practicality of our algorithms is important since interest in submodularity, owing to its natural and wide applicability, has recently been in ascendance within machine learning. We analyze theoretical properties of our algorithms for minimization and maximization, and show that many state-of-the-art maximization algorithms are special cases. Lastly, we complement our theoretical analyses with supporting empirical experiments.", "sections": [{"heading": "Introduction", "text": "In this paper, we address minimization and maximization problems of the following form: where f : 2 V \u2192 R is a discrete set function on subsets of a ground set V = {1, 2, \u2022 \u2022 \u2022 , n}, and C \u2286 2 V is a family of feasible solution sets. The set C could express, for example, that solutions must be an independent set in a matroid, a limited budget knapsack, or a cut (or spanning tree, path, or matching) in a graph. Without making any further assumptions about f , the above problems are trivially worst-case exponential time and moreover inapproximable.\nIf we assume that f is submodular, however, then in many cases the above problems can be approximated and in some cases solved exactly in polynomial time. A function f : 2 V \u2192 R is said to be submodular [9] if for all subsets S, T \u2286 V , it holds that f (S) + f (T ) \u2265 f (S \u222a T ) + f (S \u2229 T ). Defining f (j|S) f (S \u222a j) \u2212 f (S) as the gain of j \u2208 V with respect to S \u2286 V , then f is submodular if and only if f (j|S) \u2265 f (j|T ) for all S \u2286 T and j / \u2208 T . Traditionally, submodularity has been a key structural property for problems in combinatorial optimization, and for applications in econometrics, circuit and game theory, and operations research. More recently, submodularity's popularity in machine learning has been on the rise.\nOn the other hand, a potential stumbling block is that machine learning problems are often large (e.g., \"big data\") and are getting larger. For general unconstrained submodular minimization, the computational complexity often scales as a high-order polynomial. These algorithms are designed to solve the most general case and the worst-case instances are often contrived and unrealistic. Typical-case instances are much more benign, so simpler algorithms (e.g., graph-cut) might suffice. In the constrained case, however, the problems often become NP-complete. Algorithms for submodular maximization are very different in nature from their submodular minimization cohorts, and their complexity too varies depending on the problem. In any case, there is an urgent need for efficient, practical, and scalable algorithms for the aforementioned problems if submodularity is to have a lasting impact on the field of machine learning.\nIn this paper, we address the issue of scalability and simultaneously draw connections across the apparent gap between minimization and maximization problems. We demonstrate that many algorithms for submodular maximization may be viewed as special cases of a generic minorize-maximize framework that relies on discrete semidifferentials. This framework encompasses state-of-the-art greedy and local search techniques, and provides a rich class of very practical algorithms. In addition, we show that any approximate submodular maximization algorithm can be seen as an instance of our framework.\nWe also present a complementary majorize-minimize framework for submodular minimization that makes two contributions. For unconstrained minimization, we obtain new nontrivial bounds on the lattice of minimizers, thereby reducing the possible space of candidate minimizers. This method easily integrates into any other exact minimization algorithm as a preprocessing step to reduce running time. In the constrained case, we obtain practical algorithms with bounded approximation factors. We observe these algorithms to be empirically competitive to more complicated ones.\nAs a whole, the semidifferential framework offers a new unifying perspective and basis for treating submodular minimization and maximization problems in both the constrained and unconstrained case. While it has long been known [9] that submodular functions have tight subdifferentials, our results rely on a recently discovered property [18,22] showing that submodular functions also have superdifferentials. Furthermore, our approach is entirely combinatorial, thus complementing (and sometimes obviating) related relaxation methods.", "publication_ref": ["b8", "b8", "b17", "b21"], "figure_ref": [], "table_ref": []}, {"heading": "Motivation and Background", "text": "Submodularity's escalating popularity in machine learning is due to its natural applicability. Indeed, instances of Problems 1 and 2 are seen in many forms, to wit: MAP inference/Image segmentation: Markov Random Fields with pairwise attractive potentials are important in computer vision, where MAP inference is identical to unconstrained submodular minimization solved via minimum cut [3]. A richer higher-order model can be induced for which MAP inference corresponds to Problem 1 where V is a set of edges in a graph, and C is a set of cuts in this graph -this was shown to significantly improve many image segmentation results [22]. Moreover, [6] efficiently solve MAP inference in a sparse higher-order graphical model by restating the problem as a submodular vertex cover, i.e., Problem 1 where C is the set of all vertex covers in a graph.\nClustering: Variants of submodular minimization have been successfully applied to clustering problems [38,36].\nLimited Vocabulary Speech Corpora: The problem of finding a maximum size speech corpus with bounded vocabulary [32] can be posed as submodular function minimization subject to a size constraint. Alternatively, cardinality can be treated as a penalty, reducing the problem to unconstrained submodular minimization [23].", "publication_ref": ["b2", "b21", "b5", "b37", "b35", "b31", "b22"], "figure_ref": [], "table_ref": []}, {"heading": "Size constraints:", "text": "The densest k-subgraph and size-constrained graph cut problems correspond to submodular minimization with cardinality constraints, problems that are very hard [44]. Specialized algorithms for cardinality and related constraints were proposed e.g. in [44,35].", "publication_ref": ["b43", "b43", "b34"], "figure_ref": [], "table_ref": []}, {"heading": "Minimum Power Assignment:", "text": "In wireless networks, one seeks a connectivity structure that maintains connectivity at a minimum energy consumption. This problem is equivalent to finding a suitable structure (e.g., a spanning tree) minimizing a submodular cost function [45].\nTransportation: Costs in real-world transportation problems are often non-additive. For example, it may be cheaper to take a longer route owned by one carrier rather than a shorter route that switches carriers. Such economies of scale, or \"right of usage\" properties are captured in the \"Categorized Bottleneck Path Problem\" -a shortest path problem with submodular costs [1]. Similar costs have been considered for spanning tree and matching problems.\nSummarization/Sensor placement: Submodular maximization also arises in many subset extraction problems. Sensor placement [25], document summarization [31] and speech data subset selection [29], for example, are instances of submodular maximization.", "publication_ref": ["b44", "b0", "b24", "b30", "b28"], "figure_ref": [], "table_ref": []}, {"heading": "Determinantal Point Processes:", "text": "The Determinantal Point Processes (DPPs) which have found numerous applications in machine learning [26] are known to be log-submodular distributions. In particular, the MAP inference problem is a form of non-monotone submodular maximization. Indeed, there is strong motivation for solving Problems 1 and 2 but, as mentioned above, these problems come not without computational difficulties. Much work has therefore been devoted to developing optimal or near optimal algorithms. Among the several algorithms [33] for the unconstrained variant of Problem 1, where C = 2 V , the best complexity to date is O(n 5 \u03b3 + n 6 ) [40] (\u03b3 is the cost of evaluating f ). This has motivated studies on faster, possibly special case or approximate, methods [42,23]. Constrained minimization problems, even for simple constraints such as a cardinality lower bound, are mostly NP-hard, and not approximable to within better than a polynomial factor. Approximation algorithms for these problems with various techniques have been studied in [44,16,12,21]. Unlike submodular minimization, all forms of submodular maximization are NP-hard. Most such problems, however, admit constant-factor approximations, which are attained via very simple combinatorial algorithms [39,4].\nMajorization-minimization (MM) 1 algorithms are known to be useful in machine learning [15]. Notable examples include the EM algorithm [34] and the convex-concave procedure [46]. Discrete instances have been used to minimize the difference between submodular functions [37,17], but these algorithms generally lack theoretical guarantees. This paper shows, by contrast, that for submodular optimization, MM algorithms have strong theoretical properties and empirically work very well.", "publication_ref": ["b25", "b32", "b39", "b41", "b22", "b43", "b15", "b11", "b20", "b38", "b3", "b14", "b33", "b45", "b36", "b16"], "figure_ref": [], "table_ref": []}, {"heading": "Submodular semi-differentials", "text": "We first briefly introduce submodular semidifferentials. Throughout this paper, we assume normalized submodular functions (i.e., f (\u2205) = 0). The subdifferential \u2202 f (Y ) of a submodular set function f : 2 V \u2192 R for a set Y \u2286 V is defined [9] analogously to the subdifferential of a continuous convex function:\n\u2202 f (Y ) = {y \u2208 R n : (1) f (X) \u2212 y(X) \u2265 f (Y ) \u2212 y(Y ) for all X \u2286 V }\nFor a vector x \u2208 R V and X \u2286 V , we write x(X) = j\u2208X x(j) -in such case, we say that x is a normalized modular function. We shall denote a subgradient at Y by h Y \u2208 \u2202 f (Y ). The extreme points of \u2202 f (Y ) may be computed via a greedy algorithm: Let \u03c3 be a permutation of V that assigns the elements in Y to the first |Y | positions (\u03c3(i) \u2208 Y if and only if i \u2264 |Y |). Each such permutation defines a chain with elements S \u03c3 0 = \u2205, \nh \u03c3 Y (\u03c3(i)) = f (S \u03c3 i ) \u2212 f (S \u03c3 i\u22121 ).(2)\nSurprisingly, we can also define superdifferentials \u2202 f (Y ) of a submodular function [22,18] at Y :\n\u2202 f (Y ) = {y \u2208 R n : (3) f (X) \u2212 y(X) \u2264 f (Y ) \u2212 y(Y ); for all X \u2286 V }\nWe denote a generic supergradient at Y by g Y . It is easy to show that the polyhedron \u2202 f is non-empty. We define three special supergradients\u011d Y (\"grow\"),\u01e7 Y (\"shrink\") and\u1e21 Y as follows [18]:\ng Y (j) = f (j | V \\ {j})\u011d Y (j) = f (j | Y ) g Y (j) = f (j | Y \\ {j})\u01e7 Y (j) = f (j | \u2205) g Y (j) = f (j | V \\ {j}) \u1e21 Y (j) = f (j | \u2205) for j \u2208 Y for j / \u2208 Y.\nFor a monotone submodular function, i.e., a function satisfying f (A) \u2264 f (B) for all A \u2286 B \u2286 V , the suband supergradients defined here are nonnegative.", "publication_ref": ["b8", "b21", "b17", "b17"], "figure_ref": [], "table_ref": []}, {"heading": "The discrete MM framework", "text": "With the above semigradients, we can define a generic MM algorithm. In each iteration, the algorithm optimizes a modular approximation formed via the current solution Y . For minimization, we use an upper bound\nm g Y (X) = f (Y ) + g Y (X) \u2212 g Y (Y ) \u2265 f (X),(4)\nand for maximization a lower bound\nm h Y (X) = f (Y ) + h Y (X) \u2212 h Y (Y ) \u2264 f (X).(5)\nBoth these bounds are tight at the current solution, satisfying\nm g Y (Y ) = m h Y (Y ) = f (Y ).\nIn almost all cases, optimizing the modular approximation is much faster than optimizing the original cost function f . Algorithm 1 shows our discrete MM scheme for maximization (MMax) [and minimization (MMin)] , and for both constrained and unconstrained settings. Since we are minimizing a tight upper bound, or maximizing a tight lower bound, the algorithm must make progress.  Pick a semigradient h X t [ g X t ] at X t 4:\nX t+1 := argmax X\u2208C m h X t (X) [ X t+1 := argmin X\u2208C m g X t (X)] 5: t \u2190 t + 1 6: until we have converged (X i\u22121 = X i ) Proof. By definition, it holds that f (X t+1 ) \u2264 m g X t (X t+1 ). Since X t+1 minimizes m g X t , it follows that f (X t+1 ) \u2264 m g X t (X t+1 ) \u2264 m g X t (X t ) = f (X t ). (6\n)\nThe observation that Algorithm 1 monotonically increases the objective of maximization problems follows analogously.\nContrary to standard continuous subgradient descent schemes, Algorithm 1 produces a feasible solution at each iteration, thereby circumventing any rounding or projection steps that might be challenging under certain types of constraints. In addition, it is known that for relaxed instances of our problems, subgradient descent methods can suffer from slow convergence [2]. Nevertheless, Algorithm 1 still relies on the choice of the semigradients defining the bounds. Therefore, we next analyze the effect of certain choices of semigradients.", "publication_ref": ["b1"], "figure_ref": [], "table_ref": []}, {"heading": "Submodular function minimization", "text": "For minimization problems, we use MMin with the supergradients\u011d X ,\u01e7 X and\u1e21 X . In both the unconstrained and constrained settings, this yields a number of new approaches to submodular minimization.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Unconstrained Submodular Minimization", "text": "We begin with unconstrained minimization, where C = 2 V in Problem 1. Each of the three supergradients yields a different variant of Algorithm 1, and we will call the resulting algorithms MMin-I, II and III, respectively. We make one more assumption: of the minimizing arguments in Step 4 of Algorithm 1, we always choose a set of minimum cardinality.\nMMin-I is very similar to the algorithms proposed in [23]. Those authors, however, decompose f and explicitly represent graph-representable parts of the function f . We do not require or consider such a restriction here.\nLet us define the sets A = {j : f (j|\u2205) < 0} and B = {j : f (j|V \\ {j}) \u2264 0}. Submodularity implies that A \u2286 B, and this allows us to define a lattice 2 L = [A, B] whose least element is the set A and whose greatest element is the set is B. This sublattice L of [\u2205, V ] retains all minimizers X * (i.e., A \u2286 X * \u2286 B for all X * ):\nLemma 5.1. [9] Let L * be the lattice of the global minimizers of a submodular function f . Then L * \u2286 L, where we use \u2286 to denote a sublattice. Lemma 5.1 has been used to prune down the search space of the minimum norm point algorithm from the power set of V to a smaller lattice [2,10]. Indeed, A and B may be obtained by using MMin-III: Lemma 5.2. With X 0 = \u2205 and X 0 = V , MMin-III returns the sets A and B, respectively. Initialized by an arbitrary X 0 , MMin-III converges to (X\n0 \u2229 B) \u222a A. V B B+ A+ A X* Figure 2:\nVenn diagram for the lattices obtained by MMin-I, II and III. We are searching for the optimal set X * \u2286 V . The lattice L contains all sets S \"between\" A and B, i.e., A \u2286 S \u2286 B. The lattice L + uses the sets A + and B + instead (it contains all sets T with A + \u2286 T \u2286 B + ) and therefore provides a tighter bound and smaller search space around the optimal solution X * .\nProof. When using X 0 = \u2205, we obtain X 1 = argmin X f (\u2205) + j\u2208X f (j) = A. Since A \u2286 B, the algorithm will converge to X 1 = A. At this point, no more elements will be added, since for all i / \u2208 A we hav\u0113 g X 1 (i) = f (i | \u2205) > 0. Moreover, the algorithm will not remove any elements: for all i \u2208 A, it holds that\ng X 1 (i) = f (i | V \\ i) \u2264 f (i) \u2264 0.\nBy a similar argumentation, the initialization X 0 = V will lead to X 1 = B, where the algorithm terminates. If we start with any arbitrary X 0 , MMin-III will remove the elements j with f (j|V \\ j) > 0 and add the element j with f (j|\u2205) < 0. Hence it will add the elements in A that are not in X 0 and remove those element from X 0 that are not in B. Let the resulting set be X 1 . As before, for all i \u2208 A, it holds that\u1e21\nX 1 (i) = f (i | V \\ i) \u2264 f (i) \u2264 0,\nso these elements will not be removed in any possible subsequent iteration. The elements i \u2208 X 1 \\ A were not removed, so f (i | V \\ i) \u2264 0. Hence, no more elements will be removed after the first iteration. Similarly, no elements will be added since for all i /\n\u2208 X 1 , it holds that f (i | \u2205) \u2265 f (i | V \\ i) > 0.\nLemma 5.2 implies that MMin-III effectively provides a contraction of the initial lattice to L, and, if X 0 is not in L, it returns a set in L. Henceforth, we therefore assume that we start with a set X 0 \u2208 L.\nWhile the known lattice L has proven useful for warm-starts, MMin-I and II enable us to prune L even further. Let A + be the set obtained by starting MMin-I at X 0 = \u2205, and B + be the set obtained by starting MMin-II at X 0 = V . This yields a new, smaller sublattice L + = [A + , B + ] that retains all minimizers: Theorem 5.3. For any minimizer X * \u2208 L, it holds that A \u2286 A + \u2286 X * \u2286 B + \u2286 B. Hence L * \u2286 L + \u2286 L. Furthermore, when initialized with X 0 = \u2205 and X 0 = V , respectively, both MMin-I and II converge in O(n) iterations to a local minimum of f . By a local minimum, we mean a set X that satisfies f (X) \u2264 f (Y ) for any set Y that differs from X by a single element. We point out that Theorem 5.3 generalizes part of Lemma 3 in [23]. For the proof, we build on the following Lemma: Lemma 5.4. Every iteration of MMin-I can be written as X t+1 = X t \u222a {j : f (j|X t ) < 0}. Similarly, every iteration of MMin-II can be expressed as X t+1 = X t \\{j : f (j|X t \\ j) > 0}.\nProof. (Lemma 5.4) Throughout this paper, we assume that we select only the minimal minimizer of the modular function at every step. In other words, we do not choose the elements that have zero marginal cost. We observe that in iteration t + 1 of MMin-I, we add the elements i with\u011d X t (i) < 0, i.e., X t+1 = X t \u222a {j : f (j|X t ) < 0}. No element will ever be removed, since\u011d\nX t (i) = f (i | V \\ i) \u2264 f (i | X t\u22121 ) \u2264 0.\nIf we start with X 0 = \u2205, then after the first iteration, it holds that X 1 = argmin X f (\u2205) + j\u2208X f (j). Hence X 1 = A. MMin-I terminates when reaching a set A + , where f (j|A + ) \u2265 0, for all j / \u2208 A + . The analysis of MMin-II is analogous. In iteration t + 1, we remove the elements i with\u01e7 X t (i) > 0, i.e., X t+1 = X t \\{j : f (j|X t \u2212 j) > 0}. Similarly to the argumentation above, MMin-II never adds any elements. If we begin with X 0 = V , then X 1 = arg min X f (V ) + j\u2208V \\X f (j|V \u2212 {j}), and therefore X 1 = B. MMin-II terminates with a set B + . Now we can prove Theorem 5.3.\nProof. (Thm. 5.3) Since, by Lemma 5.4, MMin-I only adds elements and MMin-II only removes elements, at least one in each iteration, both algorithms terminate after O(n) iterations.\nLet us now turn to the relation of X * to A and B. Since f (i) < 0 for all i \u2208 A, the set X 1 = A found in the first iteration of MMin-I must be a subset of X * . Consider any subset X t \u2286 X * . Any element j for which f (j | X t ) < 0 must be in X * as well, because by submodularity, f (j | X * ) \u2264 f (j | X t ) < 0. This means f (X * \u222a j) < f (X * ), which would otherwise contradict the optimality of X * . The set of such j is exactly X t+1 , and therefore X t+1 \u2286 X * . This induction shows that MMin-I, whose first solution is A \u2286 X * , always returns a subset of X * . Analogously, B \u2287 X * , and MMin-II only removes elements j / \u2208 X * . Finally, we argue that A + is a local minimum; the proof for B + is analogous. Algorithm MMin-I generates a chain \u2205 = X 0 \u2286 X 1 \u2286 X 2 \u2022 \u2022 \u2022 \u2286 A + = X T . For any t \u2264 T , consider j \u2208 X t \\ X t\u22121 . Submodularity implies that f (j|A + \\ j) \u2264 f (j|X t\u22121 ) < 0. The last inequality follows from the fact that j was added in iteration t. Therefore, removing any j \u2208 A + will increase the cost. Regarding the elements i / \u2208 A + , we observe that MMin-I has terminated, which implies that f (i | A + ) \u2265 0. Hence, adding i to A + will not improve the solution, and A + is a local minimum. Theorem 5.3 has a number of nice implications. First, it provides a tighter bound on the lattice of minimizers of the submodular function f that, to the best of our knowledge, has not been used or mentioned before. The sets A + and B + obtained above are guaranteed to be supersets and subsets of A and B, respectively, as illustrated in Figure 2. This means we can start any algorithm for submodular minimization from the lattice L + instead of the initial lattice 2 V or L. When using an algorithm whose running time is a high-order polynomial of |V |, any reduction of the ground set V is beneficial. Second, each iteration of MMin takes linear time. Therefore, its total running time is O(n 2 ). Third, Theorem 5.3 states that both MMin-I and II converge to a local minimum. This may be counter-intuitive if one considers that each algorithm either only adds or only removes elements. In consequence, a local minimum of a submodular function can be obtained in O(n 2 ), a fact that is of independent interest and that does not hold for local maximizers [8].\nThe following example illustrates that L + can be a strict subset of L and therefore provides non-trivial pruning. Let w 1 , w 2 \u2208 R V , w 1 \u2265 0 be two vectors, each defining a linear (modular) function. Then the function f (X) = w 1 (X) + w 2 (X) is submodular. Specifically, let w As a refinement to Theorem 5.3, we can show that MMin-I and MMin-II converge to the local minima of lowest and highest cardinality, respectively.\nLemma 5.5. The set A + is the smallest local minimum of f (by cardinality), and B + is the largest. Moreover, every local minimum Z is in L + : Z \u2208 L + for every local minimum Z.\nProof. The proof proceeds analogously to the proof of Theorem 5.3. Let Y s be the local minimum of smallest-cardinality, and Y the largest one. First, we note that X 0 = \u2205 \u2286 Y s . For induction, assume that X t \u2286 Y s . For contradiction, assume there is an element\nj \u2208 X t+1 that is not in Y s . Since j \u2208 X t+1 \\ X t , it holds by construction that f (j | Y s ) \u2264 f (j | X t ) < 0, implying that f (Y s \u222a j) < f (Y s )\n. This contradicts the local optimality of Y s , and therefore it must hold that X t+1 \u2286 Y s . Consequently, A + \u2286 Y s . But A + is itself a local minimum, and hence equality holds. The result for B + follows analogously.\nBy the same argumentation as above for Y s and Y , we conclude that each local minimum Z satisfies A + \u2286 Z \u2286 B + , and therefore Z \u2208 L + \u2286 L.\nAs a corollary, Lemma 5.5 implies that if a submodular function has a unique local minimum, MMin-I and II must find this minimum, which is a global one.\nIn the following we consider two extensions of MMin-I and II. First, we analyze an algorithm that alternates between MMin-I and MMin-II. While such an algorithm does not provide much benefit when started at X 0 = \u2205 or X 0 = V , we see that with a random initialization X 0 = R, the alternation ensures convergence to a local minimum. Second, we address the question of which supergradients to select in general.\nIn particular, we show that the supergradients\u011d and\u01e7 subsume alternativee supergradients and provide the tightest results with MMin. Hence, our results are the tight.\nAlternating MMin-I and II and arbitrary initializations. Instead of running only one of MMin-I and II, we can run one until it stops and then switch to the other. Assume we initialize both algorithms with a random set X 0 = R \u2208 L + . By Theorem 5.3, we know that MMin-I will return a subset R 1 \u2283 R (no element will be removed because all removable elements are not in B, and R \u2282 B by assumption). When MMin-I terminates, it holds that\u011d R 1 (j) = f (j|R 1 ) \u2265 0 for all j / \u2208 R 1 , and therefore R 1 cannot be increased usin\u011d g R1 . We will call such a set an I-minimum. Similarly, MMin-II returns a set R 1 \u2286 R from which, considering that\u01e7 R1 (j) = f (j|R 1 \\ j) \u2264 0 for all j \u2208 R 1 , no elements can be removed. We call such a non-decreasable set a D-minimum. Every local minimum is both an I-minimum and a D-minimum.\nWe can apply MMin-II to the I-minimum R 1 returned by MMin-I. Let us call the resulting set R 2 . Analogously, applying MMin-I to R 1 yields R 2 \u2287 R 1 .\nLemma 5.6. The sets R 2 and R 2 are local optima. Furthermore,\nR 1 \u2286 R 2 \u2286 R 2 \u2286 R 1 .\nProof. It is easy to see that A \u2286 R 1 \u2286 B, and A \u2286 R 1 \u2286 B. By Lemma 5.4, MMin-I applied to R 1 will only add elements, and MMin-II on R 1 will only remove elements. Since R 1 is an I-minimum, adding an element j \u2208 V \\ R 1 to any set X \u2282 R 1 never helps, and therefore R 1 contains all of R 1 , R 2 and R 2 . Similarly, R 1 is contained in R 2 , R 2 and R 1 . In consequence, it suffices to look at the contracted lattice [R 1 , R 1 ], and any local minimum in this sublattice is a local minimum on [\u2205, V ]. Theorem 5.3 applied to the sublattice [R 1 , R 1 ] (and the submodular function restricted to the sublattice) yields the inclusion R 2 \u2286 R 2 , so R 1 \u2286 R 2 \u2286 R 2 \u2286 R 1 , and both R 2 and R 2 are local minima.\nThe following lemma provides a more general view. The above lemmas have a number of implications for minimization algorithms. First, many of the properties for initializing with V or the empty set can be transferred to arbitrary initializations. In particular, the succession of MMin-I and II will terminate in O(n 2 ) iterations, regardless of what X 0 is. Second, Lemmas 5.6 and 5.7 provide useful pruning opportunities: we can prune down the initial lattice to [R\n2 , R 2 ] or [S 2 , S 2 ], respectively. In particular, if any global optimizer of f is contained in [S 1 , S 1 ], it will also be contained in [S 2 , S 2 ].\nChoice of supergradients. We close this section with a remark about the choice of supergradients. The following Lemma states how\u011d X and\u01e7 X subsume alternative choices of supergradients and MMin-I and II lead to the tightest results possible.\nLemma 5.8. Initialized with X 0 = \u2205, Algorithm 1 will converge to a subset of A + with any choice of supergradients. Initialized with X 0 = V , the algorithm will converge to a superset of B + with any choice of supergradients. If X 0 is a local minimum, then the algorithm will not move with any supergradient.\nThe proof of Lemma 5.8 is very similar to the proof of Theorem 5.3.", "publication_ref": ["b22", "b8", "b1", "b9", "b22", "b7"], "figure_ref": [], "table_ref": []}, {"heading": "Constrained submodular minimization", "text": "MMin straightforwardly generalizes to constraints more complex than C = 2 V , and Theorem 5.3 still holds for more general lattices or ring family constraints.\nBeyond lattices, MMin applies to any set of constraints C as long as we have an efficient algorithm at hand that minimizes a nonnegative modular cost function over C. This subroutine can even be approximate. Such algorithms are available for cardinality bounds, independent sets of a matroid and many other combinatorial constraints such as trees, paths or cuts.\nAs opposed to unconstrained submodular minimization, almost all cases of constrained submodular minimization are very hard [44,21,12], and admit at most approximate solutions in polynomial time. The next theorem states an upper bound on the approximation factor achieved by MMin-I for nonnegative, nondecreasing cost functions. An important ingredient in the bound is the curvature [5] of a monotone submodular function f , defined as\n\u03ba f = 1 \u2212 min j\u2208V f (j | V \\j) / f (j)(8)\nTheorem 5.9. Let X * \u2208 argmin X\u2208C f (X). The solution X returned by MMin-I satisfies\nf ( X) \u2264 |X * | 1 + (|X * | \u2212 1)(1 \u2212 \u03ba f ) f (X * ) \u2264 1 1 \u2212 \u03ba f f (X * )\nIf the minimization in Step 4 is done with approximation factor \u03b2, then f\n( X) \u2264 \u03b2/(1 \u2212 \u03ba f )f (X * ).\nBefore proving this result, we remark that a similar, slightly looser bound was shown for cuts in [22], by using a weaker notion of curvature. Note that the bound in Theorem 5.9 is at most n 1+(n\u22121)(1\u2212\u03ba f ) , where n = |V | is the dimension of the problem.\nProof. We will use the shorthand g \u011d \u2205 . To prove Theorem 5.9, we use the following result shown in [20]:\nf ( X) \u2264 g(X * )/f (i) 1 + (1 \u2212 \u03ba f )(g(X * )/f (i) \u2212 1) f (X * ) (9)\nfor any i \u2208 V . We now transfer this result to curvature. To do so, we use i \u2208 arg max i\u2208V f (i), so that g(X * ) = j\u2208X * f (j) \u2264 |X * |f (i ). Observing that the function p(x) =\nx\n1+(1\u2212\u03ba f )(x\u22121) is increasing in x yields that f ( X) \u2264 |X * | 1 + (1 \u2212 \u03ba f )(|X * | \u2212 1) f (X * ).(10)\nFor problems where \u03ba f < 1, Theorem 5.9 yields a constant approximation factor and refines bounds for constrained minimization that are given in [12,44]. To our knowledge, this is the first curvature dependent bound for this general class of minimization problems.\nA class of functions with \u03ba f = 1 are matroid rank functions, implying that these functions are difficult instances the MMin algorithms. But several classes of functions occurring in applications have more benign curvature. For example, concave over modular functions were used in [31,22]. These comprise, for instance, functions of the form f (X) = (w(X)) a , for some a \u2208 [0, 1] and a nonnegative weight vector w, whose curvature is\n\u03ba f \u2248 1 \u2212 a( minj w(j) w(V ) ) 1\u2212a > 0. A special case is f (X) = |X| a , with curvature \u03ba f = 1 \u2212 an a\u22121 , or f (X) = log(1 + w(X)) satisfying \u03ba f \u2248 1 \u2212 minj w(j) w(V ) .\nThe bounds of Theorem 5.9 hold after the first iteration. Nevertheless, empirically we often found that for problem instances that are not worst-case, subsequent iterations can improve the solution substantially. Using Theorem 5.9, we can bound the number of iterations the algorithm will take. To do so, we assume an \u03b7-approximate version, where we proceed only if f (X t+1 ) \u2264 (1 \u2212 \u03b7)f (X t ) for some \u03b7 > 0. In practice, the algorithm usually terminates after 5 to 10 iterations for an arbitrarily small \u03b7.  \nO( 1 \u03b7 T log n 1+(n\u22121)(1\u2212\u03ba f ) ) time,\nwhere T is the time for minimizing a modular function subject to X \u2208 C.\nProof. At the end of the first iteration, we obtain a set X 1 such that f\n(X 1 ) \u2264 n 1+(n\u22121)(1\u2212\u03ba f ) f (X * ). The \u03b7-approximate assumption implies that f (X t+1 ) \u2264 (1 \u2212 \u03b7)f (X t ) \u2264 (1 \u2212 \u03b7) t f (X 1\n). Using that log(1 \u2212 \u03b7) \u2264 \u03b7 \u22121 and Theorem 5.9, we see that the algorithm terminates after at most O( 1 \u03b7 log n 1+(n\u22121)(1\u2212\u03ba f ) ) iterations.", "publication_ref": ["b43", "b20", "b11", "b4", "b21", "b19", "b11", "b43", "b30", "b21"], "figure_ref": [], "table_ref": []}, {"heading": "Experiments", "text": "We will next see that, apart from its theoretical properties, MMin is in practice competitive to more complex algorithms. We implement and compare algorithms using Matlab and the SFO toolbox [24].\nUnconstrained minimization We first study the results in Section 5.1 for contracting the lattice of possible minimizers. We measure the size of the new lattices relative to the ground set. Applying MMin-I and II (lattice L + ) to Iwata's test function [10], we observe an average reduction of 99.5% in the lattice. MMin-III (lattice L) obtains only about 60% reduction. Averages are taken for n between 20 and 120.\nIn addition, we use concave over modular functions w 1 (X) + \u03bbw 2 (V \\X) with randomly chosen vectors w 1 , w 2 in [0, 1] n and n = 50. We also consider the application of selecting limited vocabulary speech corpora. [32,23] use functions of the form w 1 (\u0393(X)) + w 2 (V \\X), where \u0393(X) is the neighborhood function of a bipartite graph. Here, we choose n = 100 and random vectors w 1 and w 2 . For both function classes, we vary \u03bb such that the optimal solution X * moves from X * = \u2205 to X * = V . The results are shown in Figure 3. In both cases, we observe a significant reduction of the search space. When used as a preprocessing step for the minimum norm point algorithm (MN) [10], this pruned lattice speeds up the MN algorithm accordingly, in particular for the speech data. The dotted lines represent the relative time of MN including the respective preprocessing, taken with respect to MN without preprocessing. Figure 3 also shows the average results over 10 random choices of weights in both cases. In order to obtain accurate estimates of the timings, we run each experiment 5 times and take the minimum of these timing valuess.\nConstrained minimization. For constrained minimization, we compare MMin-I to two methods: a simple algorithm (MU) that minimizes the upper bound g(X) = i\u2208X f (i) [12] (this is identical to the first iteration of MMin-I), and a more complex algorithm (EA) that computes an approximation to the submodular polyhedron [13] and in many cases yields a theoretically optimal approximation. MU has the theoretical bounds of Theorem 5.9, while EA achieves a worst-case approximation factor of O( \u221a n log n). We show two experiments: the theoretical worst-case and average-case instances. Figure 4 illustrates the results.\nWorst case. We use a very hard cost function [13] f (X) = min{|X|, |X \u2229R| + \u03b2, \u03b1},  where \u03b1 = n 1/2+ and \u03b2 = n 2 , and R is a random set such that |R| = \u03b1. This function is the theoretical worst case. Figure 4 shows results for cardinality lower bound constraints; the results for other, more complex constraints are similar. As shrinks, the problem becomes harder. In this case, EA and MMin-I achieve about the same empirical approximation factors, which matches the theoretical guarantee of n 1/2\u2212 . Average case. We next compare the algorithms on more realistic functions that occur in applications. Figure 4 shows the empirical approximation factors for minimum submodular-cost spanning tree, bipartite matching, and shortest path. We use four classes of randomized test functions: (1) concave (square root or log) over modular (CM), (2) clustered CM (CCM) of the form f\n(X) = k i=1 w(X \u2229 C k ) for clusters C 1 , \u2022 \u2022 \u2022 , C k , (3) Best Set (BS)\nfunctions where the optimal feasible set R is chosen randomly (f (X) = I(|X \u2229 R| \u2265 1) + j\u2208R\\X w j ) and ( 4) worst case-like functions (WC) similar to equation (11). Functions of type ( 1) and ( 2) have been used in speech and computer vision [31,22,17] and have reduced curvature (\u03ba f < 1). Functions of type ( 3) and ( 4) have \u03ba f = 1. In all four cases, we consider both sparse and dense graphs, with random weight vectors w. The plots show averages over 20 instances of these graphs. For sparse graphs, we consider grid like graphs in the form of square grids, grids with diagonals and cubic grids. For dense graphs, we sparsely connect a few dense cluster subgraphs. For matchings, we restrict ourselves to bipartite graphs, and consider both sparse and dense variants of these.\nFirst, we observe that in many cases, MMin clearly outperforms MU. This suggests the practical utility of more than one iteration. Second, despite its simplicity, MMin performs comparably to EA, and sometimes even better. In summary, the experiments suggest that the complex EA only gains on a few worst-case instances, whereas in many (average) cases, MMin yields near-optimal results (factor 1-2). In terms of running time, MMin is definitely preferable: on small instances (for example n = 40), our Matlab implementation of MMin takes 0.2 seconds, while EA needs about 58 seconds. On larger instances (n = 500), the running times differ on the order of seconds versus hours.", "publication_ref": ["b23", "b9", "b31", "b22", "b9", "b11", "b12", "b12", "b10", "b30", "b21", "b16"], "figure_ref": ["fig_7", "fig_7", "fig_9", "fig_9", "fig_9"], "table_ref": []}, {"heading": "Submodular maximization", "text": "Just like for minimization, for submodular maximization too we obtain a family of algorithms where each member is specified by a distinct schedule of subgradients. We will only select subgradients that are vertices of the subdifferential, i.e., each subgradient corresponds to a permutation of V . For any of those choices, MMax converges quickly. To bound the running time, we assume that we proceed only if we make sufficient progress, i.e., if f (X t+1 ) \u2265 (1 + \u03b7)f (X t ). Lemma 6.1. MMax with X 0 = argmax j f (j) runs in time O(T log 1+\u03b7 n), where T is the time for maximizing a modular function subject to X \u2208 C. Proof. Let X * be the optimal solution, then\nf (X * ) \u2264 i\u2208X * f (j) \u2264 n max j\u2208V f (j) = nf (X 0 ).(12)\nFurthermore, we know that f (X t ) \u2265 (1 + \u03b7) t f (X 0 ). Therefore, we have reached the maximum function value after at most (log n)/ log(1 + \u03b7) iterations.\nIn practice, we observe that MMax terminates within 3-10 iterations. We next consider specific subgradients and their theoretical implications. For unconstrained problems, we assume the submodular function to be non-monotone (the results trivially hold for monotone functions too); for constrained problems, we assume the function f to be monotone nondecreasing. Our results rely on the observation that many maximization algorithms actually compute a specific subgradient and run MMax with this subgradient. To our knowledge, this observation is new.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Unconstrained Maximization", "text": "Random Permutation (RA/RP). In iteration t, we randomly pick a permutation \u03c3 that defines a subgradient at X t\u22121 , i.e., X t\u22121 is assigned to the first |X t\u22121 | positions. At X 0 = \u2205, this can be any permutation. Stopping after the first iteration (RP) achieves an approximation factor of 1/4 in expectation, and 1/2 for symmetric functions. Making further iterations (RA) only improves the solution. Lemma 6.2. When running Algorithm RP with X 0 = \u2205, it holds after one iteration that E(f (X 1 )) \u2265 1 4 f (X * ) if f is a general non-negative submodular function, and E(f (X 1 )) \u2265 1 2 f (X * ) if f is symmetric. Proof. Each permutation has the same probability 1/n! of being chosen. Therefore, it holds that\nE(f (X 1 )) = E \u03c3 (max X\u2286V h \u03c3 \u2205 (X)) (13) = 1 n! \u03c3 max X\u2286V h \u03c3 \u2205 (X) (14) Let \u2205 \u2286 S \u03c3 1 \u2286 S \u03c3 2 \u2022 \u2022 \u2022 S \u03c3 n = V\nbe the chain corresponding to a given permutation \u03c3. We can bound\nmax X\u2286V h \u03c3 \u2205 (X) \u2265 n k=0 n k 2 n f (S \u03c3 k )(15)\nbecause max X\u2286V h \u03c3 \u2205 (X) \u2265 f (S \u03c3 k ), \u2200k and n k=0\n( n k ) 2 n = 1. Together, Equations ( 14) and (15) imply that\nE(f (X 1 )) \u2265 E \u03c3 (max X\u2286V h \u03c3 \u2205 (X)) (16) = \u03c3 n k=0 n k 2 n f (S \u03c3 k ) 1 n! (17) = n k=0 n k n!2 n \u03c3 f (S \u03c3 k ) (18) = n k=0 n k n!2 n k!(n \u2212 k)! S:|S|=k f (S)(19)\n= S f (S) 2 n (20) = E S (f (S))(21)\nBy E S (f (S)), we denote the expected function value when the set S is sampled uniformly at random, i.e., each element is included with probability 1/2. [8] shows that E S (f (S)) \u2265 1 4 f (X * ). For symmetric submodular functions, the factor is 1 2 .\nRandomized local search (RLS). Instead of using a completely random subgradient as in RA, we fix the positions of two elements: the permutation must satisfy that \u03c3 t (|X t | + 1) \u2208 argmax j f (j|X t ) and \u03c3 t (|X t | \u2212 1) \u2208 argmin j f (j|X t \\j). The remaining positions are assigned randomly. An \u03b7-approximate version of MMax with such subgradients returns an \u03b7-approximate local maximum that achieves an improved approximation factor of 1/3 \u2212 \u03b7 in O( n 2 log n \u03b7 ) iterations.\nLemma 6.3. Algorithm RLS returns a local maximum X that satisfies max{f (X), f\n(V \\X)} \u2265 ( 1 3 \u2212 \u03b7)f (X * ) in O( n 2 log n \u03b7 ) iterations.\nProof. At termination (t = T ), it holds that max j f (j|X T ) \u2264 0 and min j f (j|X T \\ j) \u2265 0; this implies that the set X t is local optimum.\nTo show local optimality, recall that the subgradient h \u03c3 T X T satisfies h \u03c3 T X T (X T ) = f (X T ), and h \u03c3 T X T (Y ) \u2265 h \u03c3 T X T (X T ) for all Y \u2286 V . Therefore, it must hold that max j / \u2208X T f (j|X T ) = max j / \u2208X T h \u03c3 T X T (j) \u2264 0, and min j\u2208X T f (j|X T \\j) = h \u03c3 T X T (j) \u2265 0, which implies that the set X T is a local maximum. We now use a result by [8] showing that if a set X is a local optimum, then f (X) \u2265 1 3 f (X * ) if f is a general non-negative submodular set function and f (X) \u2265 1 2 f (X * ) if f is a symmetric submodular function. If the set is an \u03b7-approximate local optimum, we obtain a 1 3 \u2212 \u03b7 approximation [8]. A complexity analysis similar to Theorem 6.1 reveals that the worst case complexity of this algorithm is O( n 2 log n \u03b7 ).\nNote that even finding an exact local maximum is hard for submodular functions [8], and therefore it is necessary to resort to an \u03b7-approximate version, which converges to an \u03b7-approximate local maximum.", "publication_ref": ["b14", "b7", "b7", "b0", "b0", "b7", "b7"], "figure_ref": [], "table_ref": []}, {"heading": "Deterministic local search (DLS).", "text": "A completely deterministic variant of RLS defines the permutation by an entirely greedy ordering. We define permutation \u03c3 t used in iteration t via the chain \u2205 = S \u03c3 t 0 \u2282 S \u03c3 t 1 \u2282 . . . \u2282 S \u03c3 t n it will generate. The initial permutation is \u03c3 0 (j) = argmax k / \u2208S \u03c3 0 j\u22121 f (k|S \u03c3 0 j\u22121 ) for j = 1, 2, . . .. In subsequent iterations t, the permutation \u03c3 t is\n\u03c3 t (j) = \uf8f1 \uf8f4 \uf8f4 \uf8f4 \uf8f2 \uf8f4 \uf8f4 \uf8f4 \uf8f3 \u03c3 t\u22121 (j) if t even, j \u2208 X t\u22121 argmax k f (k|S \u03c3 t j\u22121 ) if t even, j / \u2208 X t\u22121 argmin k f (k|S \u03c3 t j+1 \\k) if t odd, j \u2208 X t\u22121 \u03c3 t\u22121 (j) if t odd, j / \u2208 X t\u22121 .\nThis schedule is equivalent to the deterministic local search (DLS) algorithm by [8], and therefore achieves an approximation factor of 1/3 \u2212 \u03b7.\nBi-directional greedy (BG). The procedures above indicate that greedy and local search algorithms implicitly define specific chains and thereby subgradients. Likewise, the deterministic bi-directional greedy algorithm by [4] induces a distinct permutation of the ground set. It is therefore equivalent to MMax with the corresponding subgradients and achieves an approximation factor of 1/3. This factor improves that of the local search techniques by removing \u03b7. Moreover, unlike for local search, the 1/3 approximation holds already after the first iteration.\nLemma 6.4. The set X 1 obtained by Algorithm 1 with the subgradient equivalent to BG satisfies that f (X) \u2265 1 3 f (X * ). Proof. Given an initial ordering \u03c4 , the bi-directional greedy algorithm by [4] generates a chain of sets. Let \u03c3 \u03c4 denote the permutation defined by this chain, obtainable by mimicking the algorithm. We run MMax with the corresponding subgradient. By construction, the set S \u03c4 returned by the bi-directional greedy algorithm is contained in the chain. Therefore, it holds that\nf (X 1 ) \u2265 max X\u2286V h \u03c3 \u03c4 \u2205 (X)(22)\n\u2265 max k f (S \u03c3 \u03c4 k ) (23) \u2265 f (S \u03c4 ) (24) \u2265 1 3 f (X * ). (25\n)\nThe first inequality follows since the subgradient is tight for all sets in the chain. For the second inequality, we used that S \u03c4 belongs to the chain, and hence S \u03c4 = S \u03c3 \u03c4 j for some j. The last inequality follows from the approximation factor satisfied by S \u03c4 [4]. We can continue the algorithm, using any one of the adaptive schedules above to get a locally optimal solution. This can only improve the solution.\nRandomized bi-directional greedy (RG). Like its deterministic variant, the randomized bi-directional greedy algorithm by [4] can be shown to run MMax with a specific subgradient. Starting from \u2205 and V , it implicitly defines a random chain of subsets and thereby (random) subgradients. A simple analysis shows that this subgradient leads to the best possible approximation factor of 1/2 in expectation.\nLike its deterministic counterpart, the Randomized bi-directional Greedy algorithm (RG) by [4] induces a (random) permutation \u03c3 \u03c4 based on an initial ordering \u03c4 . Lemma 6.5. If the subgradient in MMax is determined by \u03c3 \u03c4 , then the set X 1 after the first iteration satisfies E(f (X 1 )) \u2265 1 2 f (X * ), where the expectation is taken over the randomness in \u03c3 \u03c4 . Proof. The permutation \u03c3 \u03c4 is obtained by a randomized algorithm, but once \u03c3 \u03c4 is fixed, the remainder of Lemma 6.7. Using \u03c3 g in MMax under the budget constraints yields:\nmax{ max i:c(i)\u2264B f (i), f (X 1 )} \u2265 (1 \u2212 1/ \u221a e)f (X * ).(36)\nLet \u03c3 ijk be a permutation with i, j, k in the first three positions, and the remaining arrangement greedy.\nRunning O(n 3 ) restarts of MM yields sets X ijk (after one iteration) with\nmax i,j,k\u2208V f (X ijk ) \u2265 (1 \u2212 1/e)f (X * ). (37\n)\nThe proof is analogous to that of Lemma 6.6. Table 1 lists results for monotone submodular maximization under different constraints.\nIt would be interesting if some of the constrained variants of non-monotone submodular maximization could be naturally subsumed in our framework too. In particular, some recent algorithms [27,28] propose local search based techniques to obtain constant factor approximations for non-monotone submodular maximization under knapsack and matroid constraints. Unfortunately, these algorithms require swap operations along with inserting and deleting elements. We do not currently know how to phrase these swap operations via our framework and leave this relation as an open problem.\nWhile a number of algorithms cannot be naturally seen as an instance of our framework, we show in the following section that any polynomial time approximation algorithm for unconstrained or constrained variants of submodular optimization can be ultimately seen as an instance of our algorithm, via a polynomial-time computable subgradient.", "publication_ref": ["b7", "b3", "b3", "b3", "b3", "b3", "b26", "b27"], "figure_ref": [], "table_ref": ["tab_0"]}, {"heading": "Generality", "text": "The correspondences between MMax and maximization algorithms hold even more generally: Theorem 6.8. For any polynomial-time unconstrained submodular maximization algorithm that achieves an approximation factor \u03b1, there exists a schedule of subgradients (obtainable in polynomial time) that, if used within MMax, leads to a solution with the same approximation factor \u03b1.\nThe proof relies on the following observation. Lemma 6.9. Any submodular function f satisfies\nmax X\u2208C f (X) = max X\u2208C,h\u2208P f h(X) = max X\u2208C,\u03c3\u2208\u03a3 h \u03c3 \u2205 (X). (38\n)\nLemma 6.9 implies that there exists a permutation (and equivalent subgradient) with which MMax finds the optimal solution in the first iteration. Known hardness results [7] imply that this permutation may not be obtainable in polynomial time.\nProof. (Lemma 6.9) The first equality in Lemma 6.9 follows from the fact that any submodular function f can be written as\nf (X) = max h\u2208P f h(X).(39)\nFor the second equality, we use the fact that a linear program over a polytope has a solution at one of the extreme points of the corresponding polytope.\nWe can now prove Theorem 6.8\nProof. (Thm. 6.8) Let Y be the set returned by the approximation algorithm; this set is polynomial-time computable by definition. Let \u03c4 be an arbitrary permutation that places the elements in Y in the first |Y | positions. The subgradient h \u03c4 defined by \u03c4 is a subgradient both for \u2205 and for Y . Therefore, using X 0 = \u2205 and h \u03c4 in the first iteration, we obtain a set X 1 with\nf (X 1 ) \u2265 h \u03c4 \u2205 (X 1 ) \u2265 h \u03c4 \u2205 (Y ) = f (Y ) \u2265 \u03b1f (X * ). (40\n)\nThe equality follows from the fact that Y belongs to the chain of \u03c4 .\nWhile the above theorem shows the optimality of MMax in the unconstrained setting, a similar result holds for the constrained case: Corollary 6.10. Let C be any constraint such that a linear function can be exactly maximized over C. For any polynomial-time algorithm for submodular maximization over C that achieves an approximation factor \u03b1, there exists a schedule of subgradients (obtainable in polynomial time) that, if used within MMax, leads to a solution with the same approximation factor \u03b1.\nThe proof of Corollary 6.10 follows directly from the Theorem 6.8.\nLastly, we pose the question of selecting the optimal subgradient in each iteration. An optimal subgradient h would lead to a function m h whose maximization yields the largest improvement. Unfortunately, obtaining such an \"optimal\" subgradient is impossible: Theorem 6.11. The problem of finding the optimal subgradient \u03c3 OP T = argmax \u03c3,X\u2286V h \u03c3 X t (X) in Step 4 of Algorithm 1 is NP-hard even when C = 2 V . Given such an oracle, however, MMax using subgradient \u03c3 OP T returns a global optimizer.\nProof. Lemma 6.9 implies that an optimal subgradient at X 0 = \u2205 or X 0 = V is a subgradient at an optimal solution. An argumentation as in Equation (40) shows that using this subgradient in MM leads to an optimal solution. Since this would solve submodular maximization (which is NP-hard), it must be NP-hard to find such a subgradient.\nTo show that this holds for arbitrary X t (and correspondingly at every iteration), we use that the submodular subdifferential can be expressed as a direct product between a submodular polyhedron and an anti-submodular polyhedron [9]. Any problem involving an optimization over the sub-differential, can then be expressed as an optimization over a submodular polyhedron (which is a subdifferential at the empty set) and an anti-submodular polyhedron (which is a subdifferential at V ) [9]. Correspondingly, Equation ( 38) can be expressed as the sum of two submodular maximization problems.", "publication_ref": ["b6", "b39", "b8", "b8"], "figure_ref": [], "table_ref": []}, {"heading": "Experiments", "text": "We now empirically compare variants of MMax with different subgradients. As a test function, we use the objective of [29], f (X) = i\u2208V j\u2208X s ij \u2212 \u03bb i,j\u2208X s ij , where \u03bb is a redundancy parameter. This non-monotone function was used to find the most diverse yet relevant subset of objects in a large corpus. We use the objective with both synthetic and real data. We generate 10 instances of random similarity matrices {s ij } ij and vary \u03bb from 0.5 to 1. Our real-world data is the Speech Training data subset selection problem [29] on the TIMIT corpus [11], using the string kernel metric [41] for similarity. We use 20 \u2264 n \u2264 30 so that the exact solution can still be computed with the algorithm of [14].\nWe compare the algorithms DLS, BG, RG, RLS, RA and RP, and a baseline RS that picks a set uniformly at random. RS achieves a 1/4 approximation in expectation [8]. For random algorithms, we select the best solution out of 5 repetitions. Figure 5 shows that DLS, BG, RG and RLS dominate. Even though RG has the best theoretical worst-case bounds, it performs slightly poorer than the local search ones and BG. Moreover, MMax with random subgradients (RP) is much better than choosing a set uniformly at random (RS). In general, the empirical approximation factors are much better than the theoretical worst-case bounds. Importantly, the MMax variants are extremely fast, about 200-500 times faster than the exact branch and bound technique of [14].", "publication_ref": ["b28", "b28", "b10", "b40", "b13", "b7", "b13"], "figure_ref": ["fig_10"], "table_ref": []}, {"heading": "Discussion and Conclusions", "text": "In this paper, we introduced a general MM framework for submodular optimization algorithms. This framework is akin to the class of algorithms for minimizing the difference between submodular functions [37,17]. In addition, it may be viewed as a special case of a proximal minimization algorithm that uses Bregman divergences derived from submodular functions [19]. To our knowledge this is the first generic and unifying framework of combinatorial algorithms for submodular optimization.\nAn alternative framework relies on relaxing the discrete optimization problem by using a continuous extension (the Lov\u00e1sz extension for minimization and multilinear extension for maximization). Relaxations have been applied to some constrained [16] and unconstrained [2] minimization problems as well as maximization problems [4]. Such relaxations, however, rely on a final rounding step that can be challenging -the combinatorial framework obviates this step. Moreover, our results show that in many cases, it yields good results very efficiently.", "publication_ref": ["b36", "b16", "b18", "b15", "b1", "b3"], "figure_ref": [], "table_ref": []}, {"heading": "", "text": "MMax is deterministic. By an argumentation similar to that in the proof of Lemma 6.4, it holds that 27)\nThe last inequality follows from a result in [4].", "publication_ref": ["b3"], "figure_ref": [], "table_ref": []}, {"heading": "Constrained Maximization", "text": "In this final section, we analyze subgradients for maximization subject to the constraint X \u2208 C. Here we assume that f is monotone. An important subgradient results from the greedy permutation \u03c3 g , defined as\nThis definition might be partial; we arrange any remaining elements arbitrarily. When using the corresponding subgradient h \u03c3 g , we recover a number of approximation results already after one iteration: Lemma 6.6. Using h \u03c3 g in iteration 1 of MMax yields the following approximation bounds for X 1 :\n), for any down-monotone constraint C, where K and k are the maximum and minimum cardinality of the maximal feasible sets in C.\nProof. We prove the first result for cardinality constraints. The proofs for the matroid and general downmonotone constraints are analogous. By the construction of \u03c3 g , the set S \u03c3 g k is exactly the set returned by the greedy algorithm. This implies that f (X 1 ) \u2265 argmax\nThe last inequality follows from [39,5].\nA very similar construction of a greedy permutation provides bounds for budget constraints, i.e., c(S) i\u2208S c(i) \u2264 B for some given nonnegative costs c. In particular, define a permutation as:\nThe following result then follows from [30,43].", "publication_ref": ["b38", "b4", "b29", "b42"], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Categorized bottleneck-minisum path problems on networks", "journal": "Operations Research Letters", "year": "1994", "authors": "I Averbakh; O Berman"}, {"ref_id": "b1", "title": "Learning with Submodular functions: A convex Optimization Perspective", "journal": "Arxiv", "year": "2011", "authors": "F Bach"}, {"ref_id": "b2", "title": "Interactive graph cuts for optimal boundary and region segmentation of objects in n-d images", "journal": "", "year": "2001", "authors": "Y Boykov; M P Jolly"}, {"ref_id": "b3", "title": "A tight (1/2) linear-time approximation to unconstrained submodular maximization", "journal": "", "year": "2012", "authors": "N Buchbinder; M Feldman; J Naor; R Schwartz"}, {"ref_id": "b4", "title": "Submodular set functions, matroids and the greedy algorithm: tight worstcase bounds and some generalizations of the Rado-Edmonds theorem", "journal": "Discrete Applied Mathematics", "year": "1984", "authors": "M Conforti; G Cornuejols"}, {"ref_id": "b5", "title": "Minimizing sparse high-order energies by submodular vertex-cover", "journal": "", "year": "2012", "authors": "A Delong; O Veksler; A Osokin; Y Boykov"}, {"ref_id": "b6", "title": "A threshold of ln n for approximating set cover", "journal": "Journal of the ACM (JACM)", "year": "1998", "authors": "U Feige"}, {"ref_id": "b7", "title": "Maximizing non-monotone submodular functions", "journal": "SIAM J. COMPUT", "year": "2007", "authors": "U Feige; V Mirrokni; J Vondr\u00e1k"}, {"ref_id": "b8", "title": "Submodular functions and optimization", "journal": "Elsevier Science", "year": "2005", "authors": "S Fujishige"}, {"ref_id": "b9", "title": "A submodular function minimization algorithm based on the minimum-norm base", "journal": "Pacific Journal of Optimization", "year": "2011", "authors": "S Fujishige; S Isotani"}, {"ref_id": "b10", "title": "Timit, acoustic-phonetic continuous speech corpus", "journal": "", "year": "1993", "authors": "J Garofolo; L Fisher Lamel; J W Fiscus; D Pallet; N Dahlgren"}, {"ref_id": "b11", "title": "Approximability of combinatorial problems with multi-agent submodular cost functions", "journal": "", "year": "2009", "authors": "G Goel; C Karande; P Tripathi; L Wang"}, {"ref_id": "b12", "title": "Approximating submodular functions everywhere", "journal": "", "year": "2009", "authors": "M X Goemans; N J A Harvey; S Iwata; V Mirrokni"}, {"ref_id": "b13", "title": "The maximization of submodular functions: Old and new proofs for the correctness of the dichotomy algorithm", "journal": "", "year": "1999", "authors": "B Goldengorin; G A Tijssen; M Tso"}, {"ref_id": "b14", "title": "A tutorial on MM algorithms", "journal": "The American Statistician", "year": "2004", "authors": "D R Hunter; K Lange"}, {"ref_id": "b15", "title": "Submodular function minimization under covering constraints", "journal": "IEEE", "year": "2009", "authors": "S Iwata; K Nagano"}, {"ref_id": "b16", "title": "Algorithms for approximate minimization of the difference between submodular functions, with applications", "journal": "", "year": "2012", "authors": "R Iyer; J Bilmes"}, {"ref_id": "b17", "title": "The submodular Bregman and Lov\u00e1sz-Bregman divergences with applications", "journal": "", "year": "2012", "authors": "R Iyer; J Bilmes"}, {"ref_id": "b18", "title": "Mirror descent like algorithms for submodular optimization", "journal": "", "year": "2012", "authors": "R Iyer; S Jegelka; J Bilmes"}, {"ref_id": "b19", "title": "Combinatorial Problems with submodular coupling in machine learning and computer vision", "journal": "", "year": "2012", "authors": "S Jegelka"}, {"ref_id": "b20", "title": "Approximation bounds for inference using cooperative cuts", "journal": "", "year": "2011", "authors": "S Jegelka; J A Bilmes"}, {"ref_id": "b21", "title": "Submodularity beyond submodular energies: coupling edges in graph cuts", "journal": "", "year": "2011", "authors": "S Jegelka; J A Bilmes"}, {"ref_id": "b22", "title": "On fast approximate submodular minimization", "journal": "", "year": "2011", "authors": "S Jegelka; H Lin; J Bilmes"}, {"ref_id": "b23", "title": "SFO: A toolbox for submodular function optimization", "journal": "JMLR", "year": "2010", "authors": "A Krause"}, {"ref_id": "b24", "title": "Near-optimal sensor placements in Gaussian processes: Theory, efficient algorithms and empirical studies", "journal": "JMLR", "year": "2008", "authors": "A Krause; A Singh; C Guestrin"}, {"ref_id": "b25", "title": "Determinantal point processes for machine learning", "journal": "", "year": "2012", "authors": "A Kulesza; B Taskar"}, {"ref_id": "b26", "title": "Non-monotone submodular maximization under matroid and knapsack constraints", "journal": "ACM", "year": "2009", "authors": "J Lee; V S Mirrokni; V Nagarajan; M Sviridenko"}, {"ref_id": "b27", "title": "Submodular maximization over multiple matroids via generalized exchange properties", "journal": "", "year": "2009", "authors": "Jon Lee; Maxim Sviridenko; Jan Vondr\u00e1k"}, {"ref_id": "b28", "title": "How to select a good training-data subset for transcription: Submodular active selection for sequences", "journal": "", "year": "2009", "authors": "H Lin; J Bilmes"}, {"ref_id": "b29", "title": "Multi-document summarization via budgeted maximization of submodular functions", "journal": "", "year": "2010", "authors": "H Lin; J Bilmes"}, {"ref_id": "b30", "title": "A class of submodular functions for document summarization", "journal": "", "year": "2011", "authors": "H Lin; J Bilmes"}, {"ref_id": "b31", "title": "Optimal selection of limited vocabulary speech corpora", "journal": "", "year": "2011", "authors": "H Lin; J Bilmes"}, {"ref_id": "b32", "title": "Submodular function minimization", "journal": "Discrete Optimization", "year": "2005", "authors": "Thomas Mccormick"}, {"ref_id": "b33", "title": "The EM algorithm and extensions", "journal": "", "year": "1997", "authors": "G J Mclachlan; T Krishnan"}, {"ref_id": "b34", "title": "Size-constrained submodular minimization through minimum norm base", "journal": "", "year": "2011", "authors": "K Nagano; Y Kawahara; K Aihara"}, {"ref_id": "b35", "title": "Minimum average cost clustering", "journal": "", "year": "2010", "authors": "K Nagano; Y Kawahara; S Iwata"}, {"ref_id": "b36", "title": "A submodular-supermodular procedure with applications to discriminative structure learning", "journal": "", "year": "2005", "authors": "M Narasimhan; J Bilmes"}, {"ref_id": "b37", "title": "", "journal": "Q-clustering. NIPS", "year": "2006", "authors": "M Narasimhan; N Jojic; J Bilmes"}, {"ref_id": "b38", "title": "An analysis of approximations for maximizing submodular set functions-i", "journal": "Mathematical Programming", "year": "1978", "authors": "G L Nemhauser; L A Wolsey; M L Fisher"}, {"ref_id": "b39", "title": "A faster strongly polynomial time algorithm for submodular function minimization", "journal": "Mathematical Programming", "year": "2009", "authors": "J B Orlin"}, {"ref_id": "b40", "title": "Efficient computation of gapped substring kernels on large alphabets", "journal": "Journal of Machine Learning Research", "year": "2006", "authors": "J Rousu; J Shawe-Taylor"}, {"ref_id": "b41", "title": "Efficient minimization of decomposable submodular functions", "journal": "", "year": "2010", "authors": "P Stobbe; A Krause"}, {"ref_id": "b42", "title": "A note on maximizing a submodular set function subject to a knapsack constraint", "journal": "Operations Research Letters", "year": "2004", "authors": "M Sviridenko"}, {"ref_id": "b43", "title": "Submodular approximation: Sampling-based algorithms and lower bounds", "journal": "", "year": "2008", "authors": "Z Svitkina; L Fleischer"}, {"ref_id": "b44", "title": "Minimum-energy broadcasting in static ad hoc wireless networks", "journal": "Wireless Networks", "year": "2002", "authors": "P.-J Wan; G Calinescu; X.-Y. Li; O Frieder"}, {"ref_id": "b45", "title": "The concave-convex procedure (CCCP)", "journal": "", "year": "2002", "authors": "A L Yuille; A Rangarajan"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 1 :1Figure 1: Illustration of the chain of sets and permutation \u03c3", "figure_data": ""}, {"figure_label": "41", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Lemma 4 . 1 .41Algorithm 1 monotonically improves the objective function value for Problems 1 and 2 at every iteration, as long as a linear function can be exactly optimized over C.", "figure_data": ""}, {"figure_label": "11", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Algorithm 1 : 1 :11Semigradient Descent Algorithm Start with an arbitrary X 0 . 2: repeat 3:", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "1 = [3, 9, 17, 14, 14, 10, 16, 4, 13, 2] and w 2 = [\u22129, 4, 6, \u22121, 10, \u22124, \u22126, \u22121, 2, \u22128]. Then we obtain L defined by A = [1, 6, 7, 10] and B = [1, 4, 6, 7, 8, 10]. The tightened sublattice contains exactly the minimizer: A + = B + = X * = [1, 6, 7, 8, 10].", "figure_data": ""}, {"figure_label": "577", "figure_type": "figure", "figure_id": "fig_5", "figure_caption": "Lemma 5 . 7 . 7 )577Let S 1 \u2286 S 1 be such that S 1 is an I-minimum and S 1 is a D-minimum. Then there exist local minimaS 2 \u2286 S 2 in [S 1 , S 1 ] such that initializing with any X 0 \u2208 [S 1 , S 1 ],an alternation of MMin-I and II converges to a local minimum in [S 2 , S 2 ], and min X\u2208[S1,S 1 ] f (X) = min X\u2208[S2,S 2 ] f (X). (Proof. Let S 2 , S 2 be the smallest and largest local minima within [S 1 , S 1 ]. By the same argumentation as for Lemma 5.6, using X 0 \u2208 [S 1 , S 1 ] leads to a local minimum within [S 2 , S 2 ]. Since by definition all local optima in [S 1 , S 1 ] are within [S 2 , S 2 ], the global minimum within [S 1 , S 1 ] will also be in [S 2 , S 2 ].", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_7", "figure_caption": "Figure 3 :3Figure 3: Lattice reduction (solid line), and runtime (%) of MMin+min-norm relative to unadorned min-norm (dotted).", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_9", "figure_caption": "Figure 4 :4Figure 4: Constrained minimization for worst-case (a) and average-case (b-d) instances. In (a), Dashed lines: MMin, dotted lines: EA, solid lines: theoretical bound. In (b -d), bars are average approximation factors and crosses worst observed results. CM -Concave over Mod., CCM -Clust. Concave Mod., BS -Best Set and WC -Worst Case", "figure_data": ""}, {"figure_label": "5", "figure_type": "figure", "figure_id": "fig_10", "figure_caption": "Figure 5 :5Figure 5: Empirical approximation factors for variants of MMax. See Section 6.1 for legend details.", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "Approximation factors obtained through specific subgradients for submodular maximization (see text for details).", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "\u2202 f (Y ) = {y \u2208 R n : (1) f (X) \u2212 y(X) \u2265 f (Y ) \u2212 y(Y ) for all X \u2286 V }", "formula_coordinates": [3.0, 191.79, 558.83, 348.21, 25.75]}, {"formula_id": "formula_1", "formula_text": "h \u03c3 Y (\u03c3(i)) = f (S \u03c3 i ) \u2212 f (S \u03c3 i\u22121 ).(2)", "formula_coordinates": [4.0, 243.54, 231.79, 296.46, 12.69]}, {"formula_id": "formula_2", "formula_text": "\u2202 f (Y ) = {y \u2208 R n : (3) f (X) \u2212 y(X) \u2264 f (Y ) \u2212 y(Y ); for all X \u2286 V }", "formula_coordinates": [4.0, 190.68, 276.71, 349.32, 25.75]}, {"formula_id": "formula_3", "formula_text": "g Y (j) = f (j | V \\ {j})\u011d Y (j) = f (j | Y ) g Y (j) = f (j | Y \\ {j})\u01e7 Y (j) = f (j | \u2205) g Y (j) = f (j | V \\ {j}) \u1e21 Y (j) = f (j | \u2205) for j \u2208 Y for j / \u2208 Y.", "formula_coordinates": [4.0, 171.41, 350.6, 525.31, 60.64]}, {"formula_id": "formula_4", "formula_text": "m g Y (X) = f (Y ) + g Y (X) \u2212 g Y (Y ) \u2265 f (X),(4)", "formula_coordinates": [4.0, 209.69, 524.94, 330.31, 11.72]}, {"formula_id": "formula_5", "formula_text": "m h Y (X) = f (Y ) + h Y (X) \u2212 h Y (Y ) \u2264 f (X).(5)", "formula_coordinates": [4.0, 208.31, 566.86, 331.69, 10.27]}, {"formula_id": "formula_6", "formula_text": "m g Y (Y ) = m h Y (Y ) = f (Y ).", "formula_coordinates": [4.0, 354.02, 588.78, 124.14, 10.27]}, {"formula_id": "formula_7", "formula_text": "X t+1 := argmax X\u2208C m h X t (X) [ X t+1 := argmin X\u2208C m g X t (X)] 5: t \u2190 t + 1 6: until we have converged (X i\u22121 = X i ) Proof. By definition, it holds that f (X t+1 ) \u2264 m g X t (X t+1 ). Since X t+1 minimizes m g X t , it follows that f (X t+1 ) \u2264 m g X t (X t+1 ) \u2264 m g X t (X t ) = f (X t ). (6", "formula_coordinates": [5.0, 72.0, 127.01, 463.76, 108.24]}, {"formula_id": "formula_8", "formula_text": ")", "formula_coordinates": [5.0, 535.76, 226.52, 4.24, 8.74]}, {"formula_id": "formula_9", "formula_text": "0 \u2229 B) \u222a A. V B B+ A+ A X* Figure 2:", "formula_coordinates": [5.0, 248.23, 642.8, 49.07, 10.31]}, {"formula_id": "formula_10", "formula_text": "g X 1 (i) = f (i | V \\ i) \u2264 f (i) \u2264 0.", "formula_coordinates": [6.0, 72.0, 289.36, 138.09, 9.93]}, {"formula_id": "formula_11", "formula_text": "X 1 (i) = f (i | V \\ i) \u2264 f (i) \u2264 0,", "formula_coordinates": [6.0, 196.89, 337.18, 138.75, 9.93]}, {"formula_id": "formula_12", "formula_text": "\u2208 X 1 , it holds that f (i | \u2205) \u2265 f (i | V \\ i) > 0.", "formula_coordinates": [6.0, 72.0, 359.52, 468.27, 22.27]}, {"formula_id": "formula_13", "formula_text": "X t (i) = f (i | V \\ i) \u2264 f (i | X t\u22121 ) \u2264 0.", "formula_coordinates": [6.0, 319.95, 603.89, 168.83, 11.36]}, {"formula_id": "formula_14", "formula_text": "j \u2208 X t+1 that is not in Y s . Since j \u2208 X t+1 \\ X t , it holds by construction that f (j | Y s ) \u2264 f (j | X t ) < 0, implying that f (Y s \u222a j) < f (Y s )", "formula_coordinates": [7.0, 72.0, 535.85, 468.27, 23.18]}, {"formula_id": "formula_15", "formula_text": "R 1 \u2286 R 2 \u2286 R 2 \u2286 R 1 .", "formula_coordinates": [8.0, 363.39, 238.96, 91.19, 11.23]}, {"formula_id": "formula_16", "formula_text": "2 , R 2 ] or [S 2 , S 2 ], respectively. In particular, if any global optimizer of f is contained in [S 1 , S 1 ], it will also be contained in [S 2 , S 2 ].", "formula_coordinates": [8.0, 72.0, 524.69, 468.0, 35.14]}, {"formula_id": "formula_17", "formula_text": "\u03ba f = 1 \u2212 min j\u2208V f (j | V \\j) / f (j)(8)", "formula_coordinates": [9.0, 232.69, 232.54, 307.31, 9.65]}, {"formula_id": "formula_18", "formula_text": "f ( X) \u2264 |X * | 1 + (|X * | \u2212 1)(1 \u2212 \u03ba f ) f (X * ) \u2264 1 1 \u2212 \u03ba f f (X * )", "formula_coordinates": [9.0, 189.1, 271.67, 233.8, 24.8]}, {"formula_id": "formula_19", "formula_text": "( X) \u2264 \u03b2/(1 \u2212 \u03ba f )f (X * ).", "formula_coordinates": [9.0, 394.34, 306.29, 107.39, 11.23]}, {"formula_id": "formula_20", "formula_text": "f ( X) \u2264 g(X * )/f (i) 1 + (1 \u2212 \u03ba f )(g(X * )/f (i) \u2212 1) f (X * ) (9)", "formula_coordinates": [9.0, 209.91, 388.0, 330.09, 24.8]}, {"formula_id": "formula_21", "formula_text": "1+(1\u2212\u03ba f )(x\u22121) is increasing in x yields that f ( X) \u2264 |X * | 1 + (1 \u2212 \u03ba f )(|X * | \u2212 1) f (X * ).(10)", "formula_coordinates": [9.0, 72.0, 433.92, 468.0, 52.56]}, {"formula_id": "formula_22", "formula_text": "\u03ba f \u2248 1 \u2212 a( minj w(j) w(V ) ) 1\u2212a > 0. A special case is f (X) = |X| a , with curvature \u03ba f = 1 \u2212 an a\u22121 , or f (X) = log(1 + w(X)) satisfying \u03ba f \u2248 1 \u2212 minj w(j) w(V ) .", "formula_coordinates": [9.0, 72.0, 596.81, 468.2, 31.06]}, {"formula_id": "formula_23", "formula_text": "O( 1 \u03b7 T log n 1+(n\u22121)(1\u2212\u03ba f ) ) time,", "formula_coordinates": [10.0, 211.28, 217.57, 130.07, 14.14]}, {"formula_id": "formula_24", "formula_text": "(X 1 ) \u2264 n 1+(n\u22121)(1\u2212\u03ba f ) f (X * ). The \u03b7-approximate assumption implies that f (X t+1 ) \u2264 (1 \u2212 \u03b7)f (X t ) \u2264 (1 \u2212 \u03b7) t f (X 1", "formula_coordinates": [10.0, 72.0, 250.87, 468.0, 25.19]}, {"formula_id": "formula_26", "formula_text": "(X) = k i=1 w(X \u2229 C k ) for clusters C 1 , \u2022 \u2022 \u2022 , C k , (3) Best Set (BS)", "formula_coordinates": [11.0, 72.0, 329.78, 468.2, 24.57]}, {"formula_id": "formula_27", "formula_text": "f (X * ) \u2264 i\u2208X * f (j) \u2264 n max j\u2208V f (j) = nf (X 0 ).(12)", "formula_coordinates": [12.0, 211.61, 274.24, 328.4, 22.13]}, {"formula_id": "formula_28", "formula_text": "E(f (X 1 )) = E \u03c3 (max X\u2286V h \u03c3 \u2205 (X)) (13) = 1 n! \u03c3 max X\u2286V h \u03c3 \u2205 (X) (14) Let \u2205 \u2286 S \u03c3 1 \u2286 S \u03c3 2 \u2022 \u2022 \u2022 S \u03c3 n = V", "formula_coordinates": [12.0, 72.0, 554.26, 468.0, 69.46]}, {"formula_id": "formula_29", "formula_text": "max X\u2286V h \u03c3 \u2205 (X) \u2265 n k=0 n k 2 n f (S \u03c3 k )(15)", "formula_coordinates": [12.0, 246.38, 632.56, 293.62, 30.55]}, {"formula_id": "formula_30", "formula_text": "E(f (X 1 )) \u2265 E \u03c3 (max X\u2286V h \u03c3 \u2205 (X)) (16) = \u03c3 n k=0 n k 2 n f (S \u03c3 k ) 1 n! (17) = n k=0 n k n!2 n \u03c3 f (S \u03c3 k ) (18) = n k=0 n k n!2 n k!(n \u2212 k)! S:|S|=k f (S)(19)", "formula_coordinates": [13.0, 212.17, 99.34, 327.83, 118.6]}, {"formula_id": "formula_31", "formula_text": "= S f (S) 2 n (20) = E S (f (S))(21)", "formula_coordinates": [13.0, 257.42, 223.98, 282.58, 41.65]}, {"formula_id": "formula_32", "formula_text": "(V \\X)} \u2265 ( 1 3 \u2212 \u03b7)f (X * ) in O( n 2 log n \u03b7 ) iterations.", "formula_coordinates": [13.0, 72.0, 397.45, 469.17, 28.57]}, {"formula_id": "formula_33", "formula_text": "\u03c3 t (j) = \uf8f1 \uf8f4 \uf8f4 \uf8f4 \uf8f2 \uf8f4 \uf8f4 \uf8f4 \uf8f3 \u03c3 t\u22121 (j) if t even, j \u2208 X t\u22121 argmax k f (k|S \u03c3 t j\u22121 ) if t even, j / \u2208 X t\u22121 argmin k f (k|S \u03c3 t j+1 \\k) if t odd, j \u2208 X t\u22121 \u03c3 t\u22121 (j) if t odd, j / \u2208 X t\u22121 .", "formula_coordinates": [14.0, 191.21, 96.25, 228.1, 53.62]}, {"formula_id": "formula_34", "formula_text": "f (X 1 ) \u2265 max X\u2286V h \u03c3 \u03c4 \u2205 (X)(22)", "formula_coordinates": [14.0, 258.89, 367.37, 281.12, 18.32]}, {"formula_id": "formula_35", "formula_text": "\u2265 max k f (S \u03c3 \u03c4 k ) (23) \u2265 f (S \u03c4 ) (24) \u2265 1 3 f (X * ). (25", "formula_coordinates": [14.0, 288.86, 389.35, 251.15, 59.87]}, {"formula_id": "formula_36", "formula_text": ")", "formula_coordinates": [14.0, 535.57, 433.65, 4.43, 8.74]}, {"formula_id": "formula_37", "formula_text": "max{ max i:c(i)\u2264B f (i), f (X 1 )} \u2265 (1 \u2212 1/ \u221a e)f (X * ).(36)", "formula_coordinates": [16.0, 206.65, 85.71, 333.35, 22.71]}, {"formula_id": "formula_38", "formula_text": "max i,j,k\u2208V f (X ijk ) \u2265 (1 \u2212 1/e)f (X * ). (37", "formula_coordinates": [16.0, 233.54, 146.83, 302.03, 16.73]}, {"formula_id": "formula_39", "formula_text": ")", "formula_coordinates": [16.0, 535.57, 148.9, 4.43, 8.74]}, {"formula_id": "formula_40", "formula_text": "max X\u2208C f (X) = max X\u2208C,h\u2208P f h(X) = max X\u2208C,\u03c3\u2208\u03a3 h \u03c3 \u2205 (X). (38", "formula_coordinates": [16.0, 206.3, 440.03, 329.27, 17.4]}, {"formula_id": "formula_41", "formula_text": ")", "formula_coordinates": [16.0, 535.57, 442.1, 4.43, 8.74]}, {"formula_id": "formula_42", "formula_text": "f (X) = max h\u2208P f h(X).(39)", "formula_coordinates": [16.0, 264.72, 533.37, 275.28, 15.33]}, {"formula_id": "formula_43", "formula_text": "f (X 1 ) \u2265 h \u03c4 \u2205 (X 1 ) \u2265 h \u03c4 \u2205 (Y ) = f (Y ) \u2265 \u03b1f (X * ). (40", "formula_coordinates": [16.0, 207.52, 656.9, 328.05, 12.94]}, {"formula_id": "formula_44", "formula_text": ")", "formula_coordinates": [16.0, 535.57, 658.98, 4.43, 8.74]}], "doi": ""}