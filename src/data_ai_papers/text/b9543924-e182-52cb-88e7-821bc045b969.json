{"title": "Object Class Recognition by Unsupervised Scale-Invariant Learning", "authors": "R Fergus; P Perona; A Zisserman", "pub_date": "", "abstract": "We present a method to learn and recognize object class models from unlabeled and unsegmented cluttered scenes in a scale invariant manner. Objects are modeled as flexible constellations of parts. A probabilistic representation is used for all aspects of the object: shape, appearance, occlusion and relative scale. An entropy-based feature detector is used to select regions and their scale within the image. In learning the parameters of the scale-invariant object model are estimated. This is done using expectation-maximization in a maximum-likelihood setting. In recognition, this model is used in a Bayesian manner to classify images. The flexible nature of the model is demonstrated by excellent results over a range of datasets including geometrically constrained classes (e.g. faces, cars) and flexible objects (such as animals).", "sections": [{"heading": "Introduction", "text": "Representation, detection and learning are the main issues that need to be tackled in designing a visual system for recognizing object categories. The first challenge is coming up with models that can capture the 'essence' of a category, i.e. what is common to the objects that belong to it, and yet are flexible enough to accommodate object variability (e.g. presence/absence of distinctive parts such as mustache and glasses, variability in overall shape, changing appearance due to lighting conditions, viewpoint etc). The challenge of detection is defining metrics and inventing algorithms that are suitable for matching models to images efficiently in the presence of occlusion and clutter. Learning is the ultimate challenge. If we wish to be able to design visual systems that can recognize, say, 10,000 object categories, then effortless learning is a crucial step. This means that the training sets should be small and that the operatorassisted steps that are required (e.g. elimination of clutter in the background of the object, scale normalization of the training sample) should be reduced to a minimum or eliminated.\nThe problem of describing and recognizing categories, as opposed to specific objects (e.g. [6,9,11]), has recently gained some attention in the machine vision literature [1,2,3,4,13,14,19] with an emphasis on the detection of faces [12,15,16]. There is broad agreement on the issue of representation: object categories are represented as collection of features, or parts, each part has a distinctive appearance and spatial position. Different authors vary widely on the details: the number of parts they envision (from a few to thousands of parts), how these parts are detected and represented, how their position is represented, whether the variability in part appearance and position is represented explicitly or is implicit in the details of the matching algorithm. The issue of learning is perhaps the least well understood. Most authors rely on manual steps to eliminate background clutter and normalize the pose of the training examples. Recognition often proceeds by an exhaustive search over image position and scale.\nWe focus our attention on the probabilistic approach proposed by Burl et al. [4] which models objects as random constellations of parts. This approach presents several advantages: the model explicitly accounts for shape variations and for the randomness in the presence/absence of features due to occlusion and detector errors. It accounts explicitly for image clutter. It yields principled and efficient detection methods. Weber et al. [18,19] proposed a maximum likelihood unsupervised learning algorithm for the constellation model which successfully learns object categories from cluttered data with minimal human intervention. We propose here a number of substantial improvement to the constellation model and to its maximum likelihood learning algorithm. First: while Burl et al. and Weber et al. model explicitly shape variability, they do not model the variability of appearance. We extend their model to take this aspect into account. Second, appearance here is learnt simultaneously with shape, whereas in their work the appearance of a part is fixed before shape learning. Third: they use correlation to detect their parts. We substitute their front end with an interest operator, which detects regions and their scale in the manner of [8,10]. Fourthly, Weber et al. did not experiment extensively with scale-invariant learning, most of their training sets are collected in such a way that the scale is approximately normalized. We extend their learning algorithm so that new object categories may be learnt efficiently, without supervision, from training sets where the object examples have large variability in scale. A final contribution is experimenting with a number of new image datasets to validate the overall approach over several object categories. Examples images from these datasets are shown in figure 1.", "publication_ref": ["b5", "b8", "b10", "b0", "b1", "b2", "b3", "b12", "b13", "b18", "b11", "b14", "b15", "b3", "b17", "b18", "b7", "b9"], "figure_ref": ["fig_2"], "table_ref": []}, {"heading": "Approach", "text": "Our approach to modeling object classes follows on from the work of Weber et al. [17,18,19]. An object model consists of a number of parts. Each part has an appearance, relative scale and can be be occluded or not. Shape is represented by the mutual position of the parts. The entire model is generative and probabilistic, so appearance, scale, shape and occlusion are all modeled by probability density functions, which here are Gaussians. The process of learning an object category is one of first detecting regions and their scales, and then estimating the parameters of the above densities from these regions, such that the model gives a maximum-likelihood description of the training data. Recognition is performed on a query image by again first detecting regions and their scales, and then evaluating the regions in a Bayesian manner, using the model parameters estimated in the learning.\nThe model, region detector, and representation of appearance are described in detail in the following subsections.", "publication_ref": ["b16", "b17", "b18"], "figure_ref": [], "table_ref": []}, {"heading": "Model structure", "text": "The model is best explained by first considering recognition. We have learnt a generative object class model, with P parts and parameters \u03b8. We are then presented with a new image and we must decide if it contains an instance of our object class or not. In this query image we have identified N interesting features with locations X, scales S, and appearances A. We now make a Bayesian decision, R: The last line is an approximation since we will only use a single value for \u03b8 (the maximum-likelihood value) rather than integrating over p(\u03b8) as we strictly should. Likewise, we assume that all non-object images can also be modeled by a background with a single set of parameters \u03b8 bg . The ratio of the priors may be estimated from the training set or set by hand (usually to 1). Our decision requires the calculation of the ratio of the two likelihood functions. In order to do this, the likelihoods may be factored as follows: ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "p(h|\u03b8)", "text": "Other Since our model only has P (typically 3-7) parts but there are N (up to 30) features in the image, we introduce an indexing variable h which we call a hypothesis. h is a vector of length P , where each entry is between 0 and N which allocates a particular feature to a model part. The unallocated features are assumed to be part of the background, with 0 indicating the part is unavailable (e.g. because of occlusion). The set H is all valid allocations of features to the parts; consequently |H| is O(N P ).\nIn the following we sketch the form for likelihood ratios of each of the above factored terms. Space prevents a full derivation being included, but the full expressions follow from the methods of [17]. It will be helpful to define the following notation: d = sign(h) (which is a binary vector giving the state of occlusion for each part), n = N \u2212 sum(d) (the number of background features under the current hypothesis), and f = sum(d) which is the number of foreground features.\nAppearance. Each feature's appearance is represented as a point in some appearance space, defined below. Each part p has a Gaussian density within this space, with mean and covariance parameters \u03b8 app p = {c p , V p } which is independent of other parts' densities. The background model has parameters \u03b8 app bg = {c bg , V bg }. Both V p and V bg are assumed to be diagonal. Each feature selected by the hypothesis is evaluated under the appropriate part density. All features not selected by the hypothesis are evaluated under the background density. The ratio reduces to:\np(A|X, S, h, \u03b8) p(A|X, S, h, \u03b8 bg ) = P p=1 G(A(h p )|c p , V p ) G(A(h p )|c bg , V bg ) dp\nwhere G is the Gaussian distribution, and d p is the p th entry of the vector d, i.e. d p = d(p). So the appearance of each feature in the hypothesis is evaluated under foreground and background densities and the ratio taken. If the part is occluded, the ratio is 1 (d p = 0). ", "publication_ref": ["b16"], "figure_ref": [], "table_ref": []}, {"heading": "Shape.", "text": "The shape is represented by a joint Gaussian density of the locations of features within a hypothesis, once they have been transformed into a scale-invariant space. This is done using the scale information from the features in the hypothesis, so avoiding an exhaustive search over scale that other methods use. The density has parameters \u03b8 shape = {\u00b5, \u03a3}. Note that, unlike appearance whose covariance matrices V p , V bg are diagonal, \u03a3 is a full matrix.\nAll features not included in the hypothesis are considered as arising from the background. The model for the background assumes features to be spread uniformly over the image (which has area \u03b1), with locations independent of the foreground locations. If a part is occluded it is integrated out of the joint foreground density.\np(X|S, h, \u03b8) p(X|S, h, \u03b8 bg ) = G(X(h)|\u00b5, \u03a3) \u03b1 f\nRelative scale. \n1 n C r (N, f ) p(d|\u03b8)\nThe first term models the number of features detected using a Poisson distribution, which has a mean M . The second is a book-keeping term for the hypothesis variable and the last is a probability table (of size 2 P ) for all possible occlusion patterns and is a parameter of the model. The model of Weber et al. contains the shape and occlusion terms to which we have added the appearance and relative scale terms. Since the model encompasses many of the properties of an object, all in a probabilistic way, this model can represent both geometrically constrained objects (where the shape density would have a small covariance) and objects with distinctive appearance but lacking geometric form (the appearance densities would be tight, but the shape density would now be looser). From the equations above we can now calculate the overall likelihood ratio from a given set of X, S, A. The intuition is that the majority of the hypotheses will be low scoring as they will be picking up features from background junk on the image but hopefully a few features will genuinely be part of the object and hypotheses using these will score highly. However, we must be able to locate features over many different instances of the object and over a range of scales in order for this approach to work.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Feature detection", "text": "Features are found using the detector of Kadir and Brady [7]. This method finds regions that are salient over both location and scale. For each point on the image a histogram P (I) is made of the intensities in a circular region of radius (scale) s. The entropy H(s) of this histogram is then calculated and the local maxima of H(s) are candidate scales for the region. The saliency of each of these candidates is measured by H dP ds (with appropriate normalization for scale [7,8]). The N regions with highest saliency over the image provide the features for learning and recognition. Each feature is defined by its centre and radius (the scale).\nA good example illustrating the saliency principle is that of a bright circle on a dark background. If the scale is too small then only the white circle is seen, and there is no extrema in entropy. There is an entropy extrema when the scale is slightly larger than the radius of the bright circle, and thereafter the entropy decreases as the scale increases.\nIn practice this method gives stable identification of features over a variety of sizes and copes well with intra-class variability. The saliency measure is designed to be invariant to scaling, although experimental tests show that this is not entirely the case due to aliasing and other effects. Note, only monochrome information is used to detect and represent features.", "publication_ref": ["b6", "b6", "b7"], "figure_ref": [], "table_ref": []}, {"heading": "Feature representation", "text": "The feature detector identifies regions of interest on each image. The coordinates of the centre give us X and the size of the region gives S. Figure 2 illustrates this on two typical images from the motorbike dataset. Once the regions are identified, they are cropped from the image and rescaled to the size of a small (typically 11\u00d711) pixel patch. Thus, each patch exists in a 121 dimensional space. Since the appearance densities of the model must also exist in this space, we must somehow reduce the dimensionality of each patch whilst retaining its distinctiveness, since a 121-dimensional Gaussian is unmanageable from a numerical point of view and also the number of parameters involved (242 per model part) are too many to be estimated. This is done by using principal component analysis (PCA). In the learning stage, we collect the patches from all images and perform PCA on them. Each patch's appearance is then a vector of the coordinates within the first k (typically 10-15) principal components, so giving us A. This gives a good reconstruction of the original patch whilst using a moderate number of parameters per part (20-30). ICA and Fisher's linear discriminant were also tried, but in experiments they were shown to be inferior.\nWe have now computed X, S, and A for use in learning or recognition. For a typical image, this takes 10-15 seconds (all timings given are for a 2 Ghz machine), mainly due to the unoptimized feature detector. Optimization should reduce this to a few seconds.", "publication_ref": [], "figure_ref": ["fig_3"], "table_ref": []}, {"heading": "Learning", "text": "The task of learning is to estimate the parameters \u03b8 = {\u00b5, \u03a3, c, V, M, p(d|\u03b8), t, U} of the model discussed above. The goal is to find the parameters\u03b8 ML which best explain the data X, S, A from all the training images, that is maximize the likelihood:\u03b8 ML = arg max \u03b8 p(X, S, A| \u03b8).\nLearning is carried out using the expectationmaximization (EM) algorithm [5] which iteratively converges, from some random initial value of \u03b8 to a maximum (which might be a local one). It works in two stages; the E-step in which, given the current value of \u03b8, some statistics are computed and the M-step in which the current value of \u03b8 is updated using the statistics from the E-step. The process is then repeated until convergence. The scale information from each feature allows us to learn the model shape in a scale-invariant space. Since the E-step involves evaluating the likelihood for each hypothesis and there being O(N P ) of them per image, efficient search methods are needed. A * and space-search methods are used, giving a considerable performance improvement. Despite these methods, a P = 6-7 part model with N = 20-30 features per image (a practical maximum), using 400 training images, takes around 24-36 hours to run. Learning complex models such as these has certain difficulties. Table 1 illustrates how the number of parameters in the model grows with the number of parts, (assuming k = 15). To  avoid over-fitting data, large datasets are used (up to 400 images in size). Surprisingly, given the complexity of the search space, the algorithm is remarkable consistent in it's convergence, so much so that validation sets were not necessary. Initial conditions were chosen randomly within a sensible range and convergence usually occurred within 50-100 EM iterations. Using a typical 6 part model on a typical dataset (Motorbikes), 10 runs from different initial conditions gave the same classification performance for 9 of them, with the other showing a difference of under 1%. Since the model is a generative one, the background images are not used in learning except for one instance: the appearance model has a distribution in appearance space modeling background features. Estimating this from foreground data proved inaccurate so the parameters were estimated from a set of background images and not updated within the EM iteration.", "publication_ref": ["b4"], "figure_ref": [], "table_ref": ["tab_1"]}, {"heading": "Recognition", "text": "Recognition proceeds by first detecting features, and then evaluating these features using the learnt model, as described in section 2.1. By calculating the likelihood ratio, R, and comparing it to a threshold; the presence or absence of the object within the image may be determined. In recognition, as in learning, efficient search techniques are used since large N and P mean around 2-3 seconds are taken per image. It is also possible to search reliably for more than one instance in an image, as needed for the Cars (Side) dataset.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Results", "text": "Experiments were carried out as follows: each dataset was split randomly into two separate sets of equal size.\nThe model was then trained on the first and tested on the second. In recognition, the decision was (as described above) a simple object present/absent one, except for the cars (side) dataset where multiple instances of the object were to be found. The performance figures quoted are the receiver-operating characteristic (ROC) equal error rates (i.e. p(True positive)=1-p(False positive)) testing against the background dataset. For example a figure of 91% means that 91% of the foreground images were correctly classified but 9% of the background images were incorrectly classified (i.e. thought to be foreground). A limited amount of preprocessing was performed on some of the datasets. For the motorbikes and airplanes the images were flipped to ensure the object was facing the same way. The spotted cat dataset was only 100 images originally, so another 100 were added by reflecting the original images, making 200 in total. Amongst the datasets, only the motorbikes, airplanes and cars (rear) contained any meaningful scale variation. There were two phases of experiments. In the first those datasets with scale variability were normalized so that the objects were of uniform size. The algorithm was then evaluated on the datasets and compared to other approaches. In the second phase the algorithm was run on the datasets containing scale variation and the performance compared to the scale-normalized case.\nIn all the experiments, the following parameters were used: k = 15, P = 6 and on average N = 20. The only parameter that was adjusted at all in all the following experiments was the scale over which features were found. The standard setting was 4 \u2212 60 pixels but for the scaleinvariant experiments, this was changed to account for the wider scale variation in features.\nFigures 5-8 show models and test images for four of the datasets. Notice how each model captures the essence, be it in appearance or shape or both, of the object. The face and motorbike datasets have tight shape models, but some of the parts have a highly variable appearance. For these parts any feature in that location will do regardless of what it looks like. Conversely, the spotted cat dataset has a loose shape model, but a highly distinctive appearance for each patch. In this instance, the model is just looking for patches of spotty fur, regardless of their location. The differing nature of these examples illustrate the flexible nature of the model.\nThe majority of errors are a result of the object receiving insufficient coverage from the feature detector. This happens for a number of reasons. One possibility is that, when a threshold is imposed on N (for the sake of speed), many features on the object are removed. Alternatively, the feature detector seems to perform badly when the object is much darker than the background (see examples in figure 5). Finally, the clustering of salient points into features, within the feature detector, is somewhat temperamental and can result in parts of the object being missed.\nFigure 3 shows a recall-precision curve 1 (RPC) and a table comparing the algorithm to previous approaches to object class recognition [1,17,19]. In all cases the performance of the algorithm is superior to the earlier methods, despite not being tuned for a particular dataset.\nFigure 4(a) illustrates the algorithm performs well even when the signal-to-noise ratio is degraded by introducing background images into the training set and Fig. 4(b) shows how variation in the number of parts affects performance.   [1,17,19]. The diagram on the right shows the RPC for [1] and our algorithm on the cars (side) dataset. On the left the table gives ROC equal error rates (except for the car (side) dataset where it is a recall-precision equal error) on a number of datasets. The errors for our algorithm are at least half those of the other methods, except for the face dataset. 1 Recall is defined as the number of true positives over total positives in the data set, and precision is the number of true positives over the sum of false positives and true positives.          Table 2 shows the performance of the algorithm across the four datasets, with the learnt models illustrated in figures 5-8. Exactly the same algorithm settings are used for all models. Note that the performance is above 90% for all four datasets. In addition, the table shows the confusion between models which is usually at the level of chance.\nTable 3 compares the performance of the scale-invariant models on unscaled images to that of the scale-variant models on the pre-scaled data. It can be seen that the drop in performance is marginal despite a wide range of object scales. In the case of the cars (rear) dataset, there is a significant improvement in performance with the scale-invariant model. This is due to the feature detector performing badly on small images (< 150 pixels) and in the pre-scaled case, all were scaled down to 100 pixels. Figure 9 shows the scale-invariant model for this dataset. This dataset was tested against background road scenes (rather than the background images, examples of which are in Fig. 1) to make a more realistic experiment.     ", "publication_ref": ["b0", "b16", "b18", "b0", "b16", "b18", "b0", "b0"], "figure_ref": ["fig_7", "fig_7", "fig_5", "fig_12", "fig_2"], "table_ref": ["tab_7", "tab_9"]}, {"heading": "Conclusions and Further work", "text": "The recognition results presented here convincingly demonstrate the power of the constellation model and the associated learning algorithm: the same piece of code performs well (less than 10% error rate) on six diverse object categories presenting a challenging mixture of visual characteristics. Learning is achieved without any supervision on datasets that contain a wide range of scales as well as clutter.\nCurrently, the framework is heavily dependent on the feature detector picking up useful features on the object. We are addressing this by extending the model to incorporate several classes of feature, e.g. edgels. Other than this there are two areas where improvements will be very beneficial.\nThe first is in a further generalization of the model structure to have a multi-modal appearance density with a single shape distribution. This will allow more complex appearances to be represented, for example faces with and without sunglasses. Second, we have built in scale-invariance, but full affine-invariance should also be possible. This would enable learning and recognition from images with much larger viewpoint variation.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgements", "text": "Timor Kadir for advice on the feature detector. D. Roth for providing the Cars (Side) dataset. Funding was provided by CNSE, the UK EPSRC, and EC Project CogViSys.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Learning a sparse representation for object detection", "journal": "", "year": "2002", "authors": "S Agarwal; D Roth"}, {"ref_id": "b1", "title": "A computational model for visual selection", "journal": "Neural Computation", "year": "1999", "authors": "Y Amit; D Geman"}, {"ref_id": "b2", "title": "Class-specific, top-down segmentation", "journal": "", "year": "2002", "authors": "E Borenstein; S Ullman"}, {"ref_id": "b3", "title": "A probabilistic approach to object recognition using local photometry and global geometry", "journal": "", "year": "1998", "authors": "M Burl; M Weber; P Perona"}, {"ref_id": "b4", "title": "Maximum likelihood from incomplete data via the em algorithm", "journal": "JRSS B", "year": "1976", "authors": "A Dempster; N Laird; D Rubin"}, {"ref_id": "b5", "title": "Object Recognition by Computer, The Role of Geometric Constraints", "journal": "MIT Press", "year": "1990", "authors": "W E L Grimson"}, {"ref_id": "b6", "title": "Scale, saliency and image description", "journal": "IJCV", "year": "2001", "authors": "T Kadir; M Brady"}, {"ref_id": "b7", "title": "Feature detection with automatic scale selection", "journal": "IJCV", "year": "1998", "authors": "T Lindeberg"}, {"ref_id": "b8", "title": "Perceptual Organization and Visual Recognition", "journal": "Kluwer Academic Publishers", "year": "1985", "authors": "D G Lowe"}, {"ref_id": "b9", "title": "Indexing based on scale invariant interest points", "journal": "", "year": "2001", "authors": "K Mikolajczyk; C Schmid"}, {"ref_id": "b10", "title": "Planar object recognition using projective shape representation", "journal": "IJCV", "year": "1995", "authors": "C Rothwell; A Zisserman; D Forsyth; J Mundy"}, {"ref_id": "b11", "title": "Neural network-based face detection", "journal": "IEEE PAMI", "year": "1998-01", "authors": "H Rowley; S Baluja; T Kanade"}, {"ref_id": "b12", "title": "Constructing models for content-based image retrieval", "journal": "", "year": "2001", "authors": "C Schmid"}, {"ref_id": "b13", "title": "A statistical method for 3d object detection applied to faces and cars", "journal": "", "year": "2000", "authors": "H Schneiderman; T Kanade"}, {"ref_id": "b14", "title": "Example-based learning for view-based human face detection", "journal": "IEEE PAMI", "year": "1998-01", "authors": "K Sung; T Poggio"}, {"ref_id": "b15", "title": "Rapid object detection using a boosted cascade of simple features", "journal": "", "year": "2001", "authors": "P Viola; M Jones"}, {"ref_id": "b16", "title": "Unsupervised Learning of Models for Object Recognition", "journal": "", "year": "2000", "authors": "M Weber"}, {"ref_id": "b17", "title": "Towards automatic discovery of object categories", "journal": "", "year": "2000-06", "authors": "M Weber; M Welling; P Perona"}, {"ref_id": "b18", "title": "Unsupervised learning of models for recognition", "journal": "", "year": "2000", "authors": "M Weber; M Welling; P Perona"}], "figures": [{"figure_label": "", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "object|X, S, A) = p(X, S, A|Object) p(Object) p(X, S, A|No object) p(No object) \u2248 p(X, S, A| \u03b8) p(Object) p(X, S, A|\u03b8 bg ) p(No object)", "figure_data": ""}, {"figure_label": "1", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Figure 1 :1Figure1: Some sample images from the datasets. Note the large variation in scale in, for example, the cars (rear) database. These datasets are from http://www.robots.ox.ac.uk/\u223cvgg/data/, except for the Cars (Side) from (http://l2r.cs.uiuc.edu/\u223ccogcomp/index research.html) and Spotted Cats from the Corel Image library. A Powerpoint presentation of the figures in this paper can be found at http://www.robots.ox.ac.uk/\u223cvgg/presentations.html", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Figure 2 :2Figure 2: Output of the feature detector", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_5", "figure_caption": "Figure 3 :3Figure 3: Comparison to other methods[1,17,19]. The diagram on the right shows the RPC for[1] and our algorithm on the cars (side) dataset. On the left the table gives ROC equal error rates (except for the car (side) dataset where it is a recall-precision equal error) on a number of datasets. The errors for our algorithm are at least half those of the other methods, except for the face dataset.", "figure_data": ""}, {"figure_label": "42", "figure_type": "figure", "figure_id": "fig_6", "figure_caption": "Figure 4 :Part 2 \u221242Figure 4: (a)  shows the effect of mixing background images into the training data (in this case, the face dataset). Even with a 50-50 mix of images with/without objects, the resulting model error is a tolerable 13%. In (b), we see how the performance drops off as the number of parts in the model is reduced.", "figure_data": ""}, {"figure_label": "5", "figure_type": "figure", "figure_id": "fig_7", "figure_caption": "Figure 5 :5Figure 5: A typical face model with 6 parts. The top left figure shows the shape model. The ellipses represent the variance of each part (the covariance terms cannot easily be shown) and the probability of each part being present is shown just to the right of the mean. The top right figure shows 10 patches closest to the mean of the appearance density for each part and the background density, along with the determinant of the variance matrix, so as to give an idea as to the relative tightness of each distribution. Below these two are some sample test images, with a mix of correct and incorrect classifications. The pink dots are features found on each image and the coloured circles indicate the features of the best hypothesis in the image. The size of the circles indicates the score of the hypothesis (the bigger the better).", "figure_data": ""}, {"figure_label": "6", "figure_type": "figure", "figure_id": "fig_9", "figure_caption": "Figure 6 :6Figure 6: A typical motorbike model with 6 parts. Note the clear identification of the front and rear wheels, along with other parts such as the fuel tank.", "figure_data": ""}, {"figure_label": "7", "figure_type": "figure", "figure_id": "fig_10", "figure_caption": "Figure 7 :7Figure 7: A typical spotted cat model with 6 parts. Note the loose shape model but distinctive \"spotted fur\" appearance.", "figure_data": ""}, {"figure_label": "183", "figure_type": "figure", "figure_id": "fig_11", "figure_caption": "18 Part 3 \u2212183Det:2e\u221220 Part 4 \u2212 Det:2e\u221222 Part 5 \u2212 Det:3e\u221218 Part 6 \u2212 Det:2e\u221218 Background \u2212 Det:4e\u221220", "figure_data": ""}, {"figure_label": "9", "figure_type": "figure", "figure_id": "fig_12", "figure_caption": "Figure 9 :9Figure 9: A scale-invariant car model with 6 parts.", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "Relationship between number of parameters and number of parts in model", "figure_data": ""}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_7", "figure_caption": "A confusion table for a number of datasets. The diagonal shows the ROC equal error rates on test data across four categories, where the algorithm's parameters were kept exactly the same, despite a range of image sizes and object types. The performance above can be improved dramatically (motorbikes increase to 95.0%, airplanes to 94.0% and faces to 96.8%) if feature scale is adjusted on a per-dataset basis. The off-diagonal elements demonstrate how good, for example, a motorbike model is at distinguishing between spotted cats and background images: 48%at the level of chance. So despite the models being inherently generative, they perform well in a distinctive setting.", "figure_data": ""}, {"figure_label": "3", "figure_type": "table", "figure_id": "tab_9", "figure_caption": "Results for scale-invariant learning/recognition.", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "p(A|X, S, h, \u03b8) p(A|X, S, h, \u03b8 bg ) = P p=1 G(A(h p )|c p , V p ) G(A(h p )|c bg , V bg ) dp", "formula_coordinates": [2.0, 334.5, 602.18, 201.95, 30.44]}, {"formula_id": "formula_1", "formula_text": "p(X|S, h, \u03b8) p(X|S, h, \u03b8 bg ) = G(X(h)|\u00b5, \u03a3) \u03b1 f", "formula_coordinates": [4.0, 104.18, 249.77, 144.79, 23.53]}, {"formula_id": "formula_2", "formula_text": "1 n C r (N, f ) p(d|\u03b8)", "formula_coordinates": [4.0, 195.92, 408.38, 73.87, 23.98]}], "doi": ""}