{"title": "A Unified Architecture for Natural Language Processing: Deep Neural Networks with Multitask Learning", "authors": "Ronan Collobert; Jason Weston", "pub_date": "", "abstract": "We describe a single convolutional neural network architecture that, given a sentence, outputs a host of language processing predictions: part-of-speech tags, chunks, named entity tags, semantic roles, semantically similar words and the likelihood that the sentence makes sense (grammatically and semantically) using a language model. The entire network is trained jointly on all these tasks using weight-sharing, an instance of multitask learning. All the tasks use labeled data except the language model which is learnt from unlabeled text and represents a novel form of semi-supervised learning for the shared tasks. We show how both multitask learning and semi-supervised learning improve the generalization of the shared tasks, resulting in stateof-the-art performance.", "sections": [{"heading": "Introduction", "text": "The field of Natural Language Processing (NLP) aims to convert human language into a formal representation that is easy for computers to manipulate. Current end applications include information extraction, machine translation, summarization, search and humancomputer interfaces.\nWhile complete semantic understanding is still a fardistant goal, researchers have taken a divide and conquer approach and identified several sub-tasks useful for application development and analysis. These range from the syntactic, such as part-of-speech tagging, chunking and parsing, to the semantic, such as wordsense disambiguation, semantic-role labeling, named entity extraction and anaphora resolution.\nCurrently, most research analyzes those tasks separately. Many systems possess few characteristics that would help develop a unified architecture which would presumably be necessary for deeper semantic tasks. In particular, many systems possess three failings in this regard: (i) they are shallow in the sense that the classifier is often linear, (ii) for good performance with a linear classifier they must incorporate many handengineered features specific for the task; and (iii) they cascade features learnt separately from other tasks, thus propagating errors.\nIn this work we attempt to define a unified architecture for Natural Language Processing that learns features that are relevant to the tasks at hand given very limited prior knowledge. This is achieved by training a deep neural network, building upon work by (Bengio & Ducharme, 2001) and (Collobert & Weston, 2007). We define a rather general convolutional network architecture and describe its application to many well known NLP tasks including part-of-speech tagging, chunking, named-entity recognition, learning a language model and the task of semantic role-labeling.\nAll of these tasks are integrated into a single system which is trained jointly. All the tasks except the language model are supervised tasks with labeled training data. The language model is trained in an unsupervised fashion on the entire Wikipedia website. Training this task jointly with the other tasks comprises a novel form of semi-supervised learning.\nWe focus on, in our opinion, the most difficult of these tasks: the semantic role-labeling problem. We show that both (i) multitask learning and (ii) semisupervised learning significantly improve performance on this task in the absence of hand-engineered features.\nWe also show how the combined tasks, and in particular the unsupervised task, learn powerful features with clear semantic information given no human supervision other than the (labeled) data from the tasks (see Table 1).\nThe article is structured as follows. In Section 2 we describe each of the NLP tasks we consider, and in Section 3 we define the general architecture that we use to solve all the tasks. Section 4 describes how this architecture is employed for multitask learning on all the labeled tasks we consider, and Section 5 describes the unlabeled task of building a language model in some detail. Section 6 gives experimental results of our system, and Section 7 concludes with a discussion of our results and possible directions for future research.", "publication_ref": ["b1", "b5"], "figure_ref": [], "table_ref": []}, {"heading": "NLP Tasks", "text": "We consider six standard NLP tasks in this paper.\nPart-Of-Speech Tagging (POS) aims at labeling each word with a unique tag that indicates its syntactic role, e.g. plural noun, adverb, . . . Chunking, also called shallow parsing, aims at labeling segments of a sentence with syntactic constituents such as noun or verb phrase (NP or VP). Each word is assigned only one unique tag, often encoded as a begin-chunk (e.g. B-NP) or inside-chunk tag (e.g. I-NP).\nNamed Entity Recognition (NER) labels atomic elements in the sentence into categories such as \"PER-SON\", \"COMPANY\", or \"LOCATION\".\nSemantic Role Labeling (SRL) aims at giving a semantic role to a syntactic constituent of a sentence. In the PropBank (Palmer et al., 2005) formalism one assigns roles ARG0-5 to words that are arguments of a predicate in the sentence, e.g. the following sentence might be tagged \"[John] ARG0 [ate] REL [the apple] ARG1 \", where \"ate\" is the predicate. The precise arguments depend on a verb's frame and if there are multiple verbs in a sentence some words might have multiple tags. In addition to the ARG0-5 tags, there there are 13 modifier tags such as ARGM-LOC (locational) and ARGM-TMP (temporal) that operate in a similar way for all verbs.\nLanguage Models A language model traditionally estimates the probability of the next word being w in a sequence. We consider a different setting: predict whether the given sequence exists in nature, or not, following the methodology of (Okanohara & Tsujii, 2007). This is achieved by labeling real texts as positive examples, and generating \"fake\" negative text.\nSemantically Related Words (\"Synonyms\") This is the task of predicting whether two words are semantically related (synonyms, holonyms, hypernyms...) which is measured using the WordNet database (http://wordnet.princeton.edu) as ground truth.\nOur main interest is SRL, as it is, in our opinion, the most complex of these tasks. We use all these tasks to: (i) show the generality of our proposed architecture; and (ii) improve SRL through multitask learning.", "publication_ref": ["b13", "b12"], "figure_ref": [], "table_ref": []}, {"heading": "General Deep Architecture for NLP", "text": "All the NLP tasks above can be seen as tasks assigning labels to words. The traditional NLP approach is: extract from the sentence a rich set of hand-designed features which are then fed to a classical shallow classification algorithm, e.g. a Support Vector Machine (SVM), often with a linear kernel. The choice of features is a completely empirical process, mainly based on trial and error, and the feature selection is task dependent, implying additional research for each new NLP task. Complex tasks like SRL then require a large number of possibly complex features (e.g., extracted from a parse tree) which makes such systems slow and intractable for large-scale applications.\nInstead we advocate a deep neural network (NN) architecture, trained in an end-to-end fashion. The input sentence is processed by several layers of feature extraction. The features in deep layers of the network are automatically trained by backpropagation to be relevant to the task. We describe in this section a general deep architecture suitable for all our NLP tasks, and easily generalizable to other NLP tasks.\nOur architecture is summarized in Figure 1. The first layer extracts features for each word. The second layer extracts features from the sentence treating it as a sequence with local and global structure (i.e., it is not treated like a bag of words). The following layers are classical NN layers.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Transforming Indices into Vectors", "text": "As our architecture deals with raw words and not engineered features, the first layer has to map words into real-valued vectors for processing by subsequent layers of the NN. For simplicity (and efficiency) we consider words as indices in a finite dictionary of words D \u2282 N.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Lookup-Table Layer", "text": "Each word i \u2208 D is embed- ded into a d-dimensional space using a lookup table LT W (\u2022): LT W (i) = W i ,\nwhere W \u2208 R d\u00d7|D| is a matrix of parameters to be learnt, W i \u2208 R d is the i th column of W and d is the word vector size (wsz ) to be chosen by the user. In the first layer of our architecture an input sentence {s 1 , s 2 , . . . s n } of n words in D is thus transformed into a series of vectors {W s1 , W s2 , . . . W sn } by apply-ing the lookup-table to each of its words.\nIt is important to note that the parameters W of the layer are automatically trained during the learning process using backpropagation.\nVariations on Word Representations In practice, one may want to introduce some basic pre-processing, such as word-stemming or dealing with upper and lower case. In our experiments, we limited ourselves to converting all words to lower case, and represent the capitalization as a separate feature (yes or no).\nWhen a word is decomposed into K elements (features), it can be represented as\na tuple i = {i 1 , i 2 , . . . i K } \u2208 D 1 \u00d7 \u2022 \u2022 \u2022 \u00d7 D K\n, where D k is the dictionary for the k th -element. We associate to each element a lookup-table\nLT W k (\u2022), with parameters W k \u2208 R d k \u00d7|D k | where d k \u2208 N is a user-specified vector size. A word i is then embedded in a d = k d k dimensional\nspace by concatenating all lookup-table outputs:\nLT W 1 ,...,W K (i) T = (LT W 1 (i 1 ) T , . . . , LT W K (i K ) T )\nClassifying with Respect to a Predicate In a complex task like SRL, the class label of each word in a sentence depends on a given predicate. It is thus necessary to encode in the NN architecture which predicate we are considering in the sentence.\nWe propose to add a feature for each word that encodes its relative distance to the chosen predicate. For the i th word in the sentence, if the predicate is at position pos p we use an additional lookup table LT distp (i \u2212 pos p ).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Variable Sentence Length", "text": "The lookup table layer maps the original sentence into a sequence x(\u2022) of n identically sized vectors:\n(x 1 , x 2 , . . . , x n ), \u2200t x t \u2208 R d .(1)\nObviously the size n of the sequence varies depending on the sentence. Unfortunately normal NNs are not able to handle sequences of variable length.\nThe simplest solution is to use a window approach: consider a window of fixed size ksz around each word we want to label. While this approach works with great success on simple tasks like POS, it fails on more complex tasks like SRL. In the latter case it is common for the role of a word to depend on words far away in the sentence, and hence outside of the considered window.\nWhen modeling long-distance dependencies is important, Time-Delay Neural Networks (TDNNs) (Waibel et al., 1989)  to the idea that a sequence has a notion of order. A TDNN \"reads\" the sequence in an online fashion: at time t \u2265 1, one sees x t , the t th word in the sentence.\nA classical TDNN layer performs a convolution on a given sequence x(\u2022), outputting another sequence o(\u2022) whose value at time t is:\no(t) = n\u2212t j=1\u2212t L j \u2022 x t+j ,(2)\nwhere L j \u2208 R n hu \u00d7d (\u2212n \u2264 j \u2264 n) are the parameters of the layer (with n hu hidden units) trained by backpropagation. One usually constrains this convolution by defining a kernel width, ksz, which enforces\n\u2200 |j| > (ksz \u2212 1)/2, L j = 0 .(3)\nA classical window approach only considers words in a window of size ksz around the word to be labeled. Instead, if we use (2) and (3), a TDNN considers at the same time all windows of ksz words in the sentence.\nTDNN layers can also be stacked so that one can extract local features in lower layers, and more global features in subsequent ones. This is an approach typically used in convolutional networks for vision tasks, such as the LeNet architecture (LeCun et al., 1998).\nWe then add to our architecture a layer which captures the most relevant features over the sentence by feeding the TDNN layer(s) into a \"Max\" Layer, which takes the maximum over time (over the sentence) in ( 2) for each of the n hu output features.\nAs the layer's output is of fixed dimension (independent of sentence size) subsequent layers can be classical NN layers. Provided we have a way to indicate to our architecture the word to be labeled, it is then able to use features extracted from all windows of ksz words in the sentence to compute the label of one word of interest.\nWe indicate the word to be labeled to the NN with an additional lookup-table, as suggested in Section 3.1.\nConsidering the word at position pos w we encode the relative distance between the i th word in the sentence and this word using a lookup-table LT distw (i \u2212 pos w ).", "publication_ref": ["b21", "b8"], "figure_ref": [], "table_ref": []}, {"heading": "Deep Architecture", "text": "A TDNN (or window) layer performs a linear operation over the input words. While linear approaches work fairly well for POS or NER, more complex tasks like SRL require nonlinear models. One can add to the NN one or more classical NN layers. The output of the l th layer containing n hu l hidden units is computed with o l = tanh(L l \u2022 o l\u22121 ), where the matrix of parameters L l \u2208 R n hu l \u00d7n hu l\u22121 is trained by backpropagation.\nThe size of the last (parametric) layer's output o last is the number of classes considered in the NLP task. This layer is followed by a softmax layer (Bridle, 1990) which makes sure the outputs are positive and sum to 1, allowing us to interpret the outputs of the NN as probabilities for each class. The i th output is given by\ne o last i / j e o last j\n. The whole network is trained with the cross-entropy criterion (Bridle, 1990).", "publication_ref": ["b2", "b2"], "figure_ref": [], "table_ref": []}, {"heading": "Related Architectures", "text": "In (Collobert & Weston, 2007) we described a NN suited for SRL. This work also used a lookup-table to generate word features (see also (Bengio & Ducharme, 2001)). The issue of labeling with respect to a predicate was handled with a special hidden layer: its output, given input sequence (1), predicate position pos p , and the word of interest pos w was defined as:\no(t) = C(t \u2212 pos w , t \u2212 pos p ) \u2022 x t .\nThe function C(\u2022) is shared through time t: one could say that this is a variant of a TDNN layer with a kernel width ksz = 1 but where the parameters are conditioned with other variables (distances with respect to the verb and word of interest).\nThe fact that C(\u2022) does not combine several words in the same neighborhood as in our TDNN approach lim-its the dependencies between words it can model. Also C(\u2022) is itself a NN inside a NN. Not only does one have to carefully design this additional architecture, but it also makes the approach more complicated to train and implement. Integrating all the desired features in x() (including the predicate position) via lookuptables makes our approach simpler, more general and easier to tune.", "publication_ref": ["b5", "b1"], "figure_ref": [], "table_ref": []}, {"heading": "Multitasking with Deep NN", "text": "Multitask learning (MTL) is the procedure of learning several tasks at the same time with the aim of mutual benefit. This an old idea in machine learning; a good overview, especially focusing on NNs, can be found in (Caruana, 1997).", "publication_ref": ["b3"], "figure_ref": [], "table_ref": []}, {"heading": "Deep Joint Training", "text": "If one considers related tasks, it makes sense that features useful for one task might be useful for other ones. In NLP for example, POS predictions are often used as features for SRL and NER. Improving generalization on the POS task might therefore improve both SRL and NER.\nA NN automatically learns features for the desired tasks in the deep layers of its architecture. In the case of our general architecture for NLP presented in Section 3, the deepest layer (consisting of lookup-tables) implicitly learns relevant features for each word in the dictionary. It is thus reasonable to expect that when training NNs on related tasks, sharing deep layers in these NNs would improve features produced by these deep layers, and thus improve generalization performance. The last layers of the network can then be task specific.\nIn this paper we show this procedure performs very well for NLP tasks when sharing the lookup-tables of each considered task, as depicted in Figure 2. Training is achieved in a stochastic manner by looping over the tasks:\n1. Select the next task. 2. Select a random training example for this task. 3. Update the NN for this task by taking a gradient step with respect to this example. 4. Go to 1.\nIt is worth noticing that labeled data for training each task can come from completely different datasets.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Previous Work in MTL for NLP", "text": "The NLP field contains many related tasks. This makes it a natural field for applying MTL, and sev-", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Lookup Tables", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Convolution", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Task 1", "text": "Max Classical NN Layer(s)", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Softmax", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "LT w 2 LT w 3", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Lookup Tables", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Convolution", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Task 2", "text": "Max Classical NN Layer(s)", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Softmax", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "LT w 1", "text": "LT w 2 '\nFigure 2. Example of deep multitasking with NN. Task 1 and Task 2 are two tasks trained with the architecture presented in Figure 1. One lookup-table (in black) is shared (the other lookup-tables and layers are task specific). The principle is the same with more than two tasks.\neral techniques have already been explored.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Cascading Features", "text": "The most obvious way to achieve MTL is to train one task, and then use this task as a feature for another task. This is a very common approach in NLP. For example, in the case of SRL, several methods (e.g., (Pradhan et al., 2004)) train a POS classifier and use the output as features for training a parser, which is then used for building features for SRL itself. Unfortunately, tasks (features) are learnt separately in such a cascade, thus propagating errors from one classifier to the next.", "publication_ref": ["b14"], "figure_ref": [], "table_ref": []}, {"heading": "Shallow Joint Training", "text": "If one possesses a dataset labeled for several tasks, it is then possible to train these tasks jointly in a shallow manner: one unique model can predict all task labels at the same time. Using this scheme, the authors of (Sutton et al., 2007) proposed a conditional random field approach where they showed improvements from joint training on POS tagging and noun-phrase chunking tasks. However the requirement of jointly annotated data is a limitation, as this is often not the case. Similarly, in (Miller et al., 2000) NER, parsing and relation extraction were jointly trained in a statistical parsing model achieving improved performance on all tasks. This work has the same joint labeling requirement problem, which the authors avoided by using a predictor to fill in the missing annotations.\nIn (Sutton & McCallum, 2005a) the authors showed that one could learn the tasks independently, hence using different training sets, by only leveraging predictions jointly in a test time decoding step, and still obtain improved results. The problem is, however, that this will not make use of the shared tasks at training time. The NN approach used here seems more flexible in these regards.\nFinally, the authors of (Musillo & Merlo, 2006) made an attempt at improving the semantic role labeling task by joint inference with syntactic parsing, but their results are not state-of-the-art. The authors of (Sutton & McCallum, 2005b) also describe a negative result at the same joint task.", "publication_ref": ["b19", "b10", "b17", "b11", "b18"], "figure_ref": [], "table_ref": []}, {"heading": "Leveraging Unlabeled Data", "text": "Labeling a dataset can be an expensive task, especially in NLP where labeling often requires skilled linguists.\nOn the other hand, unlabeled data is abundant and freely available on the web. Leveraging unlabeled data in NLP tasks seems to be a very attractive, and challenging, goal.\nIn our MTL framework presented in Figure 2, there is nothing stopping us from jointly training supervised tasks on labeled data and unsupervised tasks on unlabeled data. We now present an unsupervised task suitable for NLP.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Language Model", "text": "We consider a language model based on a simple fixed window of text of size ksz using our NN architecture, given in Figure 2. We trained our language model to discriminate a two-class classification task: if the word in the middle of the input window is related to its context or not. We construct a dataset for this task by considering all possible ksz windows of text from the entire of English Wikipedia (http://en.wikipedia.org). Positive examples are windows from Wikipedia, negative examples are the same windows but where the middle word has been replaced by a random word.\nWe train this problem with a ranking-type cost:\nX s\u2208S X w\u2208D max (0, 1 \u2212 f (s) + f (s w )) ,(4)\nwhere S is the set of sentence windows of text, D is the dictionary of words, and f (\u2022) represents our NN architecture without the softmax layer and s w is a sentence window where the middle word has been replaced by the word w. We sample this cost online w.r.t. (s, w).\nWe will see in our experiments that the features (embedding) learnt by the lookup-table layer of this NN clusters semantically similar words. These discovered features will prove very useful for our shared tasks. (Bengio & Ducharme, 2001) and (Schwenk & Gauvain, 2002) already presented very similar language models. However, their goal was to give a probability of a word given previous ones in a sentence. Here, we only want to have a good representation of words: we take advantage of the complete context of a word (before and af-ter) to predict its relevance. Perhaps this is the reason the authors were never able to obtain a good embedding of their words. Also, using probabilities imposes using a cross-entropy type criterion and can require many tricks to speed-up the training, due to normalization issues. Our criterion ( 4) is much simpler in that respect.", "publication_ref": ["b1", "b16"], "figure_ref": [], "table_ref": []}, {"heading": "Previous Work on Language Models", "text": "The authors of (Okanohara & Tsujii, 2007), like us, also take a two-class approach (true/fake sentences). They use a shallow (kernel) classifier.", "publication_ref": ["b12"], "figure_ref": [], "table_ref": []}, {"heading": "Previous Work in Semi-Supervised Learning", "text": "For an overview of semi-supervised learning, see (Chapelle et al., 2006). There have been several uses of semi-supervised learning in NLP before, for example in NER (Rosenfeld & Feldman, 2007), machine translation (Ueffing et al., 2007), parsing (McClosky et al., 2006) and text classification (Joachims, 1999). The first work is a highly problem-specific approach whereas the last three all use a self-training type approach (Transductive SVMs in the case of text classification, which is a kind of self-training method). These methods augment the training set with labeled examples from the unlabeled set which are predicted by the model itself. This can give large improvements in a model, but care must be taken as the predictions are of course prone to noise.\nThe authors of (Ando & Zhang, 2005) propose a setup more similar to ours: they learn from unlabeled data as an auxiliary task in a MTL framework. The main difference is that they use shallow classifiers; however they report positive results on POS and NER tasks.\nSemantically Related Words Task We found it interesting to compare the embedding obtained with a language model on unlabeled data with an embedding obtained with labeled data. WordNet is a database which contains semantic relations (synonyms, holonyms, hypernyms, ...) between around 150, 000 words. We used it to train a NN similar to the language model one. We considered the problem as a two-class classification task: positive examples are pairs with a relation in Wordnet, and negative examples are random pairs.", "publication_ref": ["b4", "b15", "b20", "b9", "b7", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "Experiments", "text": "We used Sections 02-21 of the PropBank dataset version 1 (about 1 million words) for training and Section 23 for testing as standard in all SRL experiments. POS and chunking tasks use the same data split via the Penn TreeBank. NER labeled data was obtained by running the Stanford Named Entity Recognizer (a Table 1. Language model performance for learning an embedding in wsz = 50 dimensions (dictionary size: 30, 000).\nFor each column the queried word is followed by its index in the dictionary (higher means more rare) and its 10 nearest neighbors (arbitrary using the Euclidean metric). Language models were trained on Wikipedia. In all cases, any numeric number was converted as \"NUM-BER\". Accentuated characters were transformed to their non-accentuated versions. All paragraphs containing other non-ASCII characters were discarded.\nFor Wikipedia, we obtain a database of 631M words. We used WordNet to train the \"synonyms\" (semantically related words) task.\nAll tasks use the same dictionary of the 30, 000 most common words from Wikipedia, converted to lower case. Other words were considered as unknown and mapped to a special word.\nArchitectures All tasks were trained using the NN shown in Figure 1. POS, NER, and chunking tasks were trained with the window version with ksz = 5. We chose linear models for POS and NER. For chunking we chose a hidden layer of 200 units. The language model task had a window size ksz = 11, and a hidden layer of 100 units. All these tasks used two lookuptables: one of dimension wsz for the word in lower case, and one of dimension 2 specifying if the first letter of the word is a capital letter or not.\nFor SRL, the network had a convolution layer with ksz = 3 and 100 hidden units, followed by another hidden layer of 100 hidden units. It had three lookuptables in the first layer: one for the word (in lower case), and two that encode relative distances (to the word of interest and the verb). The last two lookuptables embed in 5 dimensional spaces. Verb positions are obtained with our POS classifier.\nThe language model network had only one lookuptable (the word in lower case) and 100 hidden units. It used a window of size ksz = 11.\nWe show results for different encoding sizes of the word in lower case: wsz = 15, 50 and 100.  Results: Language Model Because the language model was trained on a huge database we first trained it alone. It takes about a week to train on one computer. The embedding obtained in the word lookuptable was extremely good, even for uncommon words, as shown in Table 1. The embedding obtained by training on labeled data from WordNet \"synonyms\" is also good (results not shown) however the coverage is not as good as using unlabeled data, e.g. \"Dreamcast\" is not in the database.\nThe resulting word lookup-table from the language model was used as an initializer of the lookup-table used in MTL experiments with a language model. Results: SRL Our main interest was improving SRL performance, the most complex of our tasks. In Table 2, we show results comparing the SRL task alone with the SRL task jointly trained with different combinations of the other tasks. For all our experiments, training was achieved in a few epochs (about a day) over the PropBank dataset as shown in Figure 3. Testing takes 0.015s to label a complete sentence (given one verb).\nAll MTL experiments performed better than SRL alone. With larger wsz (and thus large capacity) the relative improvement becomes larger from using MTL compared to the task alone, which shows MTL is a good way of regularizing: in fact with MTL results are fairly stable with capacity changes.\nThe semi-supervised training of SRL using the language model performs better than other combinations. Our best model performed as low as 14.30% in perword error rate, which is to be compared to previously published results of 16.36% with an NN architecture (Collobert & Weston, 2007) and 16.54% for a state-of-the-art method based on parse trees (Pradhan et al., 2004) 1 . Further, our system is the only one not to use POS tags or parse tree features.\nResults: POS and Chunking Training takes about 30 min for these tasks alone. Testing time for labeling a complete sentence is about 0.003s. We obtained modest improvements to POS and chunking results us-ing MTL. Without MTL (for wsz = 50) we obtain 2.95% test error for POS and 4.5% (91.1 F-measure) for chunking. With MTL we obtain 2.91% for POS and 3.8% (92.71 F-measure) for chunking. POS error rates in the 3% range are state-of-the-art. For chunking, although we use a different train/test setup to the CoNLL-2000 shared task (http://www.cnts.ua.ac. be/conll2000/chunking) our system seems competitive with existing systems (better than 9 of the 11 submitted systems). However, our system is the only one that does not use POS tags as input features.\nNote, we did not evaluate NER error rates because we used non-gold standard annotations in our setup. Future work will more thoroughly evaluate these tasks.", "publication_ref": ["b5", "b14"], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "Conclusion", "text": "We proposed a general deep NN architecture for NLP. Our architecture is extremely fast enabling us to take advantage of huge databases (e.g. 631 million words from Wikipedia). We showed our deep NN could be applied to various tasks such as SRL, NER, POS, chunking and language modeling. We demonstrated that learning tasks simultaneously can improve generalization performance. In particular, when training the SRL task jointly with our language model our architecture achieved state-of-the-art performance in SRL without any explicit syntactic features. This is an important result, given that the NLP community considers syntax as a mandatory feature for semantic extraction (Gildea & Palmer, 2001).", "publication_ref": ["b6"], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "A Framework for Learning Predictive Structures from Multiple Tasks and Unlabeled Data", "journal": "JMLR", "year": "2005", "authors": "R Ando; T Zhang"}, {"ref_id": "b1", "title": "A neural probabilistic language model", "journal": "NIPS", "year": "2001", "authors": "Y Bengio; R Ducharme"}, {"ref_id": "b2", "title": "Probabilistic interpretation of feedforward classification network outputs, with relationships to statistical pattern recognition", "journal": "", "year": "1990", "authors": "J Bridle"}, {"ref_id": "b3", "title": "Multitask Learning. Machine Learning", "journal": "", "year": "1997", "authors": "R Caruana"}, {"ref_id": "b4", "title": "Semisupervised learning. Adaptive computation and machine learning", "journal": "MIT Press", "year": "2006", "authors": "O Chapelle; B Schlkopf; A Zien"}, {"ref_id": "b5", "title": "Fast semantic extraction using a novel neural network architecture", "journal": "", "year": "2007", "authors": "R Collobert; J Weston"}, {"ref_id": "b6", "title": "The necessity of parsing for predicate argument recognition", "journal": "", "year": "2001", "authors": "D Gildea; M Palmer"}, {"ref_id": "b7", "title": "Transductive inference for text classification using support vector machines", "journal": "", "year": "1999", "authors": "T Joachims"}, {"ref_id": "b8", "title": "Gradient-Based Learning Applied to Document Recognition", "journal": "", "year": "1998", "authors": "Y Lecun; L Bottou; Y Bengio; P Haffner"}, {"ref_id": "b9", "title": "Effective self-training for parsing", "journal": "", "year": "2006", "authors": "D Mcclosky; E Charniak; M Johnson"}, {"ref_id": "b10", "title": "A novel use of statistical parsing to extract information from text", "journal": "", "year": "2000", "authors": "S Miller; H Fox; L Ramshaw; R Weischedel"}, {"ref_id": "b11", "title": "Robust Parsing of the Proposition Bank", "journal": "", "year": "2006", "authors": "G Musillo; P Merlo"}, {"ref_id": "b12", "title": "A discriminative language model with pseudo-negative samples", "journal": "", "year": "2007", "authors": "D Okanohara; J Tsujii"}, {"ref_id": "b13", "title": "The proposition bank: An annotated corpus of semantic roles", "journal": "Comput. Linguist", "year": "2005", "authors": "M Palmer; D Gildea; P Kingsbury"}, {"ref_id": "b14", "title": "Shallow semantic parsing using support vector machines", "journal": "", "year": "2004", "authors": "S Pradhan; W Ward; K Hacioglu; J Martin; D Jurafsky"}, {"ref_id": "b15", "title": "Using Corpus Statistics on Entities to Improve Semi-supervised Relation Extraction from the Web", "journal": "", "year": "2007", "authors": "B Rosenfeld; R Feldman"}, {"ref_id": "b16", "title": "Connectionist language modeling for large vocabulary continuous speech recognition", "journal": "", "year": "2002", "authors": "H Schwenk; J Gauvain"}, {"ref_id": "b17", "title": "Composition of conditional random fields for transfer learning", "journal": "", "year": "2005", "authors": "C Sutton; A Mccallum"}, {"ref_id": "b18", "title": "Joint parsing and semantic role labeling", "journal": "", "year": "2005", "authors": "C Sutton; A Mccallum"}, {"ref_id": "b19", "title": "Dynamic Conditional Random Fields: Factorized Probabilistic Models for Labeling and Segmenting Sequence Data", "journal": "JMLR", "year": "2007", "authors": "C Sutton; A Mccallum; K Rohanimanesh"}, {"ref_id": "b20", "title": "Transductive learning for statistical machine translation", "journal": "", "year": "2007", "authors": "N Ueffing; G Haffari; A Sarkar"}, {"ref_id": "b21", "title": "Phoneme recognition using time-delay neural networks", "journal": "IEEE Transactions on Acoustics, Speech, and Signal Processing", "year": "1989", "authors": "A Waibel; G Hinton; T H Shikano; K Lang; K "}], "figures": [{"figure_label": "3", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 3 .3Figure 3. Test error versus number of training epochs over PropBank, for the SRL task alone and SRL jointly trained with various other NLP tasks, using deep NNs.", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "Figure1. A general deep NN architecture for NLP. Given an input sentence, the NN outputs class probabilities for one chosen word. A classical window approach is a special case where the input has a fixed size ksz, and the TDNN kernel size is ksz; in that case the TDNN layer outputs only one vector and the Max layer performs an identity.", "figure_data": "Input Sentencen words, K featuresfeature 1 (text)the cat sat on the matfeature 2s1(1) s1(2) s1(3) s1(4) s1(5) s1(6)...feature KsK(1) sK(2) sK(3) sK(4) sK(5) sK(6)Lookup Tables(d1+d2+...dK)*nLT w 1.....................LT w KConvolution Layer#hidden units * (n-2)...Max Over Time...#hidden unitsOptional Classical NN Layer(s)Softmax#classes"}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_2", "figure_caption": "A Deep Architecture for SRL improves by learning auxiliary tasks that share the first layer that represents words as wsz-dimensional vectors. We give word error rates for wsz=15, 50 and 100 and various shared tasks.", "figure_data": "wsz=15 wsz=50 wsz=100"}], "formulas": [{"formula_id": "formula_0", "formula_text": "Each word i \u2208 D is embed- ded into a d-dimensional space using a lookup table LT W (\u2022): LT W (i) = W i ,", "formula_coordinates": [2.0, 307.44, 593.81, 234.01, 44.96]}, {"formula_id": "formula_1", "formula_text": "a tuple i = {i 1 , i 2 , . . . i K } \u2208 D 1 \u00d7 \u2022 \u2022 \u2022 \u00d7 D K", "formula_coordinates": [3.0, 55.44, 219.63, 234.0, 20.72]}, {"formula_id": "formula_2", "formula_text": "LT W k (\u2022), with parameters W k \u2208 R d k \u00d7|D k | where d k \u2208 N is a user-specified vector size. A word i is then embedded in a d = k d k dimensional", "formula_coordinates": [3.0, 55.44, 253.95, 234.01, 38.24]}, {"formula_id": "formula_3", "formula_text": "LT W 1 ,...,W K (i) T = (LT W 1 (i 1 ) T , . . . , LT W K (i K ) T )", "formula_coordinates": [3.0, 66.71, 312.07, 211.47, 12.19]}, {"formula_id": "formula_4", "formula_text": "(x 1 , x 2 , . . . , x n ), \u2200t x t \u2208 R d .(1)", "formula_coordinates": [3.0, 106.4, 517.68, 183.04, 11.72]}, {"formula_id": "formula_5", "formula_text": "o(t) = n\u2212t j=1\u2212t L j \u2022 x t+j ,(2)", "formula_coordinates": [3.0, 375.25, 447.09, 166.19, 30.32]}, {"formula_id": "formula_6", "formula_text": "\u2200 |j| > (ksz \u2212 1)/2, L j = 0 .(3)", "formula_coordinates": [3.0, 360.09, 548.81, 181.35, 9.68]}, {"formula_id": "formula_7", "formula_text": "e o last i / j e o last j", "formula_coordinates": [4.0, 55.44, 464.52, 65.95, 14.78]}, {"formula_id": "formula_8", "formula_text": "o(t) = C(t \u2212 pos w , t \u2212 pos p ) \u2022 x t .", "formula_coordinates": [4.0, 101.55, 613.06, 141.78, 9.68]}, {"formula_id": "formula_9", "formula_text": "X s\u2208S X w\u2208D max (0, 1 \u2212 f (s) + f (s w )) ,(4)", "formula_coordinates": [5.0, 353.63, 468.42, 187.82, 40.16]}], "doi": ""}