{"title": "What Game Are We Playing? End-to-end Learning in Normal and Extensive Form Games", "authors": "Chun Kai Ling; Fei Fang; J Zico Kolter", "pub_date": "2018-06-27", "abstract": "Although recent work in AI has made great progress in solving large, zero-sum, extensive-form games, the underlying assumption in most past work is that the parameters of the game itself are known to the agents. This paper deals with the relatively under-explored but equally important \"inverse\" setting, where the parameters of the underlying game are not known to all agents, but must be learned through observations. We propose a differentiable, end-to-end learning framework for addressing this task. In particular, we consider a regularized version of the game, equivalent to a particular form of quantal response equilibrium, and develop 1) a primal-dual Newton method for finding such equilibrium points in both normal and extensive form games; and 2) a backpropagation method that lets us analytically compute gradients of all relevant game parameters through the solution itself. This ultimately lets us learn the game by training in an end-to-end fashion, effectively by integrating a \"differentiable game solver\" into the loop of larger deep network architectures. We demonstrate the effectiveness of the learning method in several settings including poker and security game tasks.", "sections": [{"heading": "Introduction", "text": "Recent work in artificial intelligence has led to huge advances in methods for solving large-scale, zero-sum, extensive form games, both from methodological and applied standpoints. From the algorithmic approach, methods based on Counterfactual Regret Minimization [Zinkevich et al., 2008] and firstorder methods for game solving [Kroer et al., 2017], have enabled solutions to larger and larger games. In terms of applications, there have been a number of recent breakthroughs, including exceeding human performance in no-limit poker [Brown and Sandholm, 2017;Morav\u010d\u00edk et al., 2017], essentially weakly solving limit poker [Bowling et al., 2015], work in security games with applications to infrastructure security [Pita et al., 2009], and many others. However, virtually all this progress in game theoretic approaches to large games has operated under the assumption that the parameters of the game are known to the solvers, and that the main challenge is simply finding the optimal strategy. In contrast, in many real world scenarios, certain elements of the game (e.g., payoff matrices, chance node probabilities, etc), are unknown to some of the agents prior to the game. For example, in security games, we may want to understand the underlying payoffs of an adversary, rather than just their observed strategy, to better understand how aspects of the game can be manipulated or changed to get a desirable outcome.\nIn this paper, we propose an end-to-end framework for learning the parameters of uncertain games (both for normalform and extensive-form games), purely by observing the actions of the agents. Although there has been a great deal of work at the intersection of game theory and reinforcement learning [Busoniu et al., 2008;Bowling and Veloso, 2000], most game-theoretic analysis either assumes that the payoffs underlying the game are known (this is the standard game theory setting), or forgoes trying to learn an explicit and complete representation of the game and instead looks for merely learning agent strategies that will perform well [Letchford et al., 2009;Vorobeychik et al., 2007;Fearnley et al., 2015]. However, in many cases when the true underlying payoffs of the agents are not known, our primary goal is precisely to recover or understand the payoffs. The few exceptions that focus on learning the payoffs often rely on special structures of the game (e.g., symmetry in multiplayer setting [Vorobeychik et al., 2007]), or querying the best response of the agent with unknown payoffs by asking other agents to play carefully designed strategies [Blum et al., 2014;Letchford et al., 2009]. However, the general problem of learning game parameters by observing actions is still underexplored. One of the most closely-related works to our own is the Computational Rationalization framework [Waugh et al., 2011], though 1) our approach differs in how the utilities/payoffs are modeled; and 2) we crucially focus heavily on the extensive form settings, whereas this past work considered only normal form games.\nThe crux of our approach is to consider the quantal response equilibrium (QRE), a generalization of Nash equilibrium (NE) that includes some possibility of agents acting suboptimally. We show that the solution of the QRE is a differentiable function of the game payoff matrix, and backpropagation can be computed analytically via implicit differentiation. We develop a solver that jointly solves the QRE for two-player zero-sum games using a primal-dual Newton Method, and allows us to compute the derivatives of agent actions with respect to the underlying payoff matrix. This enables us to develop end-to-end learning approaches that can infer the payoff matrix or other parameters underlying a game merely from samples of the agents acting according to their QREs. 1 More generally, the method allows for (both normal form and extensive form) game-solving to be integrated as a module in deep learning systems, a strategy that can find use in multiple application areas.\nWe demonstrate the effectiveness of our approach on several domains: a toy normal-form game where payoffs depend on external context; a one-card poker game (with a small representation in strategic form, but which would already be too large to solved in normal form); and a security resource allocation game, which is an extensive-form generalization of defender-attacker game in security domain. In all settings, we show that our approach is able to learn, solely from observed actions, the relevant underlying parameters of the game, such as the payoff matrices or (agent belief over) chance node probabilities. We believe this represents a substantial step forward in understanding how game theoretic methods can be applied to uncertain settings, where the \"true\" parameters of the game are unknown to an agent. Due to space constraints, supplementary material and appendices are available at arXiv. 2 2 Learning and Quantal Response in Normal Form Games\nOur game-solving module provides all the elements required to perform differentiable learning through the game solution.\nThe resulting learning approach learns a mapping from contextual features x to payoff matrices P and computes equilibrium strategies (u * , v * ) under a new set of contextual features. An example architecture is presented in Figure 1. Here, P is parameterized by a domain-dependent low-dimensional vector \u03c6, which is dependent on a differentiable function M 1 (x). Similarly, the loss function is taken after applying any differentiable M 2 (u * , v * ). For the remainder of the paper, we focus on zero-sum games, which capture a wide class of adversarial environments. We begin by considering normal form games. Although normal form games have limited real-world utility due to the fact that they can only handle relatively small-scale settings, 1 Naturally, there are some questions here about when games are identifiable or not; in general, the answer is no, because e.g. many payoff matrices can lead to identical strategies or policies for the agent, so we do not expect to always be able to recover a true underlying payoff matrix. However, we show that for various classes of parametrized games, our approach is able to recover the true underlying payoffs of different agents.\n2 https://arxiv.org/abs/1805.02777 the game solver and learning approach in this restricted setting captures much of the intuition and basic methodology of our approach.", "publication_ref": ["b7", "b1", "b7", "b3", "b1", "b7", "b4", "b1", "b7", "b10"], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "Zero-Sum Normal Form Games", "text": "In two-player zero-sum game with payoff matrix P , a classic min-max formulation to compute the NE is as follows\nmin u max v u T P v (1) subject to 1 T u = 1, u \u2265 0 (2) 1 T v = 1, v \u2265 0,(3)\nu and v denote the (mixed) strategies employed by the min and max player respectively. The solution (u * , v 0 ) to this optimization problem and the solution (u 0 , v * ) of the corresponding problem with inversed player order (i.e., min v max u u T P v) forms the Nash equilibrium (u * , v * ).\nHere we present an introduction to our approach considering the case where the payoff matrix P is not known a priori. P could represent either a single fixed but unknown payoff matrix, or, in a more complex setting, depend on some external context x. For example, in anti-poaching games [Fang et al., 2016], P depends on temperature and precipitation. In general, however, we consider the case where we observe samples of actions a (i) , i = 1, . . . , N , consisting of observed actions, from one or both players, sampled from the equilibrium strategies (u * , v * ). The goal is to recover the true underlying payoff matrix P , or a function form P (x) depending on the current context.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Quantal Response Equilibria", "text": "While extremely powerful both theoretically and as a modeling tool, the NE is poorly-suited for our purposes because: 1. NEs are overly strict. In practice, many payoff matrices result in actions never being played. This tends to be overly restrictive and does not adequately describe realworld scenarios where players are boundedly rational.\n2. NEs in zero-sum games may not be unique. This leads to difficulties when resolving which NE to select.\n3. NEs are discontinuous with respect to P -a small change in P can lead to jumps in u * , v * . This precludes integrating the technique into differentiable learning procedures.\nTo address these issues, in our learning setting we propose to model the player's action with the quantal response equilibria [McKelvey and Palfrey, 1995] instead. In general, QRE models situations where payoff matrices are injected with some noise. Specifically, we consider the logit equilibrium, where payoffs are perturbed by samples from a Gumbel distribution. The smoothness of QRE makes gradient-based approaches feasible [Amin et al., 2016]. It is known that for zero-sum games, the logit equilibrium obeys the fixed point 3\nu * i = exp(\u2212P v) i q\u2208[n] exp(\u2212P v) q , v * j = exp(P T u) j q\u2208[m] exp(P T u) q .\n(4) It is further known that for a fixed opponent strategy, the logit equilibrium corresponds to a strategy regularized by the Gibbs entropy [Mertikopoulos and Sandholm, 2016]. Since the Gibbs entropy is strictly convex, the regularized best response is unique.", "publication_ref": ["b7", "b0", "b7"], "figure_ref": [], "table_ref": []}, {"heading": "End-to-End Learning", "text": "In order to integrate zero-sum game solvers into an end-toend learning framework, we need a method for \"differentiating through\" the game solution itself; that is, we need to compute the Jacobian (or more precisely, compute the Jacobianvector products needed for backpropagation) of the quantal equilibrium solution with respect to the payoff matrix. Our method for doing so relies on techniques from differential calculus, and is a relatively straightforward extension of similar approaches to differentiating through optimization problems. However, as a prelude to the more involved extensive form solution that we will discuss shortly, we describe our method in some detail, which involves both a particular approach to solving the QRE and to differentiating through its solution.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "QRE Solver", "text": "We observe that finding the fixed point in ( 4) is equivalent to solving the regularized min-max game\nmin u\u2208R n max v\u2208R m u T P v \u2212 H(v) + H(u) subject to 1 T u = 1, 1 T v = 1,(5)\nwhere H(y) is the Gibbs entropy i y i log y i . Notice that the non-negative constraints are implicit from the entropy term, and that the entropy regularization renders the equilibrium continuous with respect to P . Intuitively, entropy regularization encourages players to play more randomly, and no action has probability 0. Furthermore, since the objective is strictly a convex-concave problem, it has a unique saddle point which corresponds to (u * , v * ).\nThis formulation leads to a solver for the QRE for twoplayer zero-sum games, using a primal-dual Newton Method. To begin, the KKT conditions for the above problem are\nP v + log(u) + 1 + \u00b51 = 0 P T u \u2212 log(v) \u2212 1 + \u03bd1 = 0 1 T u = 1, 1 T v = 1,(6)\nwhere \u00b5, \u03bd are Lagrange multipliers for the equality constraints on u, v respectively. Following Newton's method, we get the following update rule, which provides a convergent method for computing the QRE for 2 player zero-sum games\nQ \uf8ee \uf8ef \uf8f0 \u2206u \u2206v \u2206\u00b5 \u2206\u03bd \uf8f9 \uf8fa \uf8fb = \u2212 \uf8ee \uf8ef \uf8f0 P v + log u + 1 + \u00b51 P T u \u2212 log v \u2212 1 + \u03bd1 1 T u \u2212 1 1 v \u2212 1 \uf8f9 \uf8fa \uf8fb , (7\n)\nwhere Q is the Hessian of the Lagrangian, given by\nQ = \uf8ee \uf8ef \uf8ef \uf8f0 diag( 1 u ) P 1 0 P T \u2212diag( 1 v ) 0 1 1 T 0 0 0 0 1 T 0 0 \uf8f9 \uf8fa \uf8fa \uf8fb .(8)\nDifferentiating Through QRE Solutions The QRE solver also provides a method for computing the necessary Jacobian-vector products. The derivation follows in a similar manner to recent work in differentiating equalityconstrained optimization problems [Gould et al., 2016;Johnson et al., 2016;Amos and Kolter, 2017] (the only difference being the min-max objective instead of a pure minimization objective, but since we compute differentials via the KKT conditions, the differences are minor). Specifically, given the solution (u * , v * ) to the QRE, and considering some loss function L(u * , v * ) (for example, the log-likelihood of some observed data given this equilibrium probabilities), we show here how to compute the gradient of the loss with respect to the payoff P . In particular, taking differentials of the KKT conditions and rearranging leads to the following expression\nQ [du dv d\u00b5 d\u03bd] T = \u2212dP v \u2212 dP T u 0 0 T .(9)\nFor small changes denoted by du, dv, we have\ndL = [\u2207 u L \u2207 v L 0 0] [du dv d\u00b5 d\u03bd] T = [\u2207 u L \u2207 v L 0 0] Q \u22121 \u2212dP v \u2212 dP T u 0 0 T = v T dP T u T dP 0 0 Q \u22121 [\u2212\u2207 u L \u2212 \u2207 v L 0 0] T ,\nwhere the last step is from symmetry of Q. This expression governs how small changes in dP affect L. For example, we may obtain the change in L after perturbing a single entry in P . Applying this procedure to all entries in P , simplifying and taking limits as dP is small yields\n\u2207 P L = y u v T + uy T v , (10\n) where [y u y v y \u00b5 y \u03bd ] T = Q \u22121 [\u2212\u2207 u L \u2212 \u2207 v L 0 0] T .\nHence, the forward and backward passes with our module are respectively given by: 1) Using the expression in (7), solve for the logit equilibrium given P , and 2) Using \u2207 u L and \u2207 v L, obtain \u2207 P L using (10). It is stressed that the module is sufficiently general to be included in any existing architecture where having a zero-sum game module is appropriate.", "publication_ref": ["b5", "b5", "b1"], "figure_ref": [], "table_ref": []}, {"heading": "A Note on Identifiability", "text": "As mentioned in Section 1, it is natural to ask if the games are identifiable -that is, is there a unique P which under the logit QRE, generates u * , v * ? The answer is no, in general. Assuming u * , v * are fixed, we can rewrite the KKT conditions in (6) as a system of linear equations in P . This system has O(nm) unknowns but only O(n + m) constraints. This implies that without a sufficiently compact parametrization, there will be infinitely many payoff matrices leading to identical equilibria. For example, one can add a constant to all entries in P without changing the QRE. When under-constrained, one cannot expect to recover P . However, as we show below, there are also many settings where it is possible to recover underlying parameters reliably.\n3 Learning Extensive Form Games (EFG)", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Sequence Form Representation", "text": "In practice, many games are more naturally and compactly represented in extensive form. Unfortunately, learning payoff matrices of their equivalent normal form representation is computationally unfeasible even for small games. For example, one-card poker has 2 26 pure strategies per player. In order to facilitate learning of EFGs, we turn to the sequence form representation [Von Stengel, 1996], which is sufficiently rich to represent all strategic behaviors given perfect recall.\nThe sequence form replaces pure strategies by partial description of sequences specifying the player's moves over the game tree. Instead of probability vectors, we are interested in realization plans u \u2208 R n , v \u2208 R m , each a vector of size equal to possible actions throughout the game (thus, n and m are equal to the size of the game tree's action nodes for each player). Realization plans represent probabilities of performing a sequence of actions, in isolation from chance and other player's moves. Mathematically, this is represented by the linear constraints Eu = e, F v = f . Here, E, F are matrices with entries in {\u22121, 0, 1}, while e, f are vectors containing {0, 1}. Together, they specify 'flow' constraints and implicitly encode parent-child relationships and information sets. These constraints may be seen as a generalization of the requirement that u, v lie in probability simplexes. The likelihood of arriving at a given node of the game tree is the product of probabilities of each sequence, multiplied by the probabilities needed by the chance player.", "publication_ref": ["b9"], "figure_ref": [], "table_ref": []}, {"heading": "Dilated Entropy Regularization", "text": "Denote I u and I v to be all information sets for the min and max player. For an information set i \u2208 I u \u222a I v , A i denotes the possible actions at information set i, while p i is the action (from the same player) preceding i. Similarly, define \u03c1 a to be the information set immediately preceding the action a ,i.e. i where a \u2208 A i . As with the normal form representation, we solve the regularized min-max problem\nmin u max v u T P v + i\u2208Iu a\u2208Ai u a log u a u pi \u2212 i\u2208Iv a\u2208Ai v a log v a v pi .(11)\nThis form of regularization is known as dilated entropy [Kroer et al., 2017] or normalized entropy [Boyd and Vandenberghe, 2004], and is known to be strictly convex/concave in u and v respectively. Observe that this formulation operates in O(m + n) dimensions. The number of sequences is bounded by the size of the game tree and is normally much smaller than the number of pure strategies. One of our first primary results in this paper is the fact that this particular form of regularization, applied to the sequence form, recovers the QRE as applied to the equivalent reduced normal form game (that is, the normal form representation of the extensive form, but with unattainable strategies omitted). Theorem 1. The solution to (11) is realization equivalent to the QRE of the game in reduced normal form.\nProof. (Sketch) Consider the max player in isolation and his game tree, represented by alternating actions and information states. Choose any action a 0 with parallel information sets, near the bottom of the tree (i.e. all child information sets are leaves). In sequence form, this action and its subtree may be coalesced into a set of strategies, corresponding to the Cartesian product {i|pi=a0} A i . This essentially converts a part of the sequence form into normal form. It can be shown that the solutions to (11) before and after this replacement are realization equivalent. The proof follows by repeated bottomup application of this operation, eventually collapsing the tree to its reduced normal form, all while maintaining realization equivalence. The full proof is in the Appendix.\nTheorem 1 shows dilated entropy regularization leads to a well-accepted solution concept, even if it differs slightly from the more traditional definition of the QRE for extensive form games [McKelvey and Palfrey, 1998]. A side consequence is that under certain regimes, the excessive gap technique [Kroer et al., 2017;Hoda et al., 2010] used to quickly solve zero-sum EFGs converges to the NE specified by QRE in reduced normal form, as the rationality-parameter tends to \u221e.", "publication_ref": ["b7", "b2", "b7", "b7", "b5"], "figure_ref": [], "table_ref": []}, {"heading": "Differentiable Learning in Sequence Form", "text": "Here we derive a differentiable formulation of the sequence form QRE, mirroring our derivation for the normal form case, but admittedly with significantly more complex notation due to the more involved entropy term. The KKT conditions of our optimization problem are,\n(P v) a + 1 + log(u a ) \u2212 log(u pi ) \u2212 J a + c\u2208Ca \u00b5 c \u2212 \u00b5 i = 0, \u2200i \u2208 U, a \u2208 A i (P T u) a \u2212 1 \u2212 log(v a ) + log(v p i ) + J a + c\u2208C a \u03bd c \u2212 \u03bd i = 0, \u2200i \u2208 V, a \u2208 A i\nEu \u2212 e = 0, F v \u2212 f = 0, u \u2265 0, v \u2265 0 where C a , C a are sets of possible information sets immediately following a or a . J a , J a are their sizes, i.e. |C a |, |C a |.\nWe write the terms on the left hand side as a vector g (u, v, \u00b5, \u03bd). Taking derivatives again yields the updates for Newton's method.\n\uf8ee \uf8ef \uf8f0 \u2212\u039e(u) P E T 0 P T \u039e(v) 0 F T E 0 0 0 0 F 0 0 \uf8f9 \uf8fa \uf8fb \uf8ee \uf8ef \uf8f0 \u2206u \u2206v \u2206\u00b5 \u2206\u03bd \uf8f9 \uf8fa \uf8fb = \u2212g(u, v, \u00b5, \u03bd) \u039e(u) ab = \uf8f1 \uf8f4 \uf8f2 \uf8f4 \uf8f3 \u2212 1+Ja ua , a = b 1 u b , p \u03c1a = b 1 ua , p \u03c1 b = a \u039e(v) a b = \uf8f1 \uf8f4 \uf8f2 \uf8f4 \uf8f3 \u2212 1+J a v a , a = b 1 v b , p \u03c1 a = b 1 v a , p \u03c1 b = a\nThe updates are done in exactly the same manner as (10) \n\u2207 P L = y u v T + uy T v ,(12) where \uf8ee\n\uf8ef \uf8f0 y u y v y \u00b5 y \u03bd \uf8f9 \uf8fa \uf8fb = \uf8ee \uf8ef \uf8f0 \u2212\u039e(u) P E T 0 P T \u039e(v) 0 F T E 0 0 0 0 F 0 0 \uf8f9 \uf8fa \uf8fb \u22121 \uf8ee \uf8ef \uf8f0 \u2212\u2207 u L \u2212\u2207 v L 0 0 \uf8f9 \uf8fa \uf8fb . R P S R 0 \u2212b 1 b 2 P b 1 0 \u2212b 3 S \u2212b 2 b 3 0", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Implementation Notes", "text": "We can use this differentiable game solver within an automatic differentiation framework to easily obtain gradients of virtually any loss with respect to any of the game parameters.\nIn particular, we used the PyTorch automatic differentiation library [Paszke et al., 2017], and will release the full code for our solver as open source along with the release of this paper.", "publication_ref": ["b7"], "figure_ref": [], "table_ref": []}, {"heading": "Experiments", "text": "We empirically demonstrate our module's novel aspectslearning extensive form games in the presence of side information, with partial observations. In the first experiment, we learn a non-symmetric variant of rock, paper, scissors with side information. We illustrate the learning of extensive form games with one-card poker, and learning with partial information with a security resource allocation game. In all cases, we minimize the log-loss of the observed sequence -that is, maximizing the likelihood of realizing observed sequence from the player, assuming he acts in accordance to the QRE. Due to space constraints, hyper-parameters and details of train/test environment are deferred to the Appendix. Generally, our module works well with a medium or large batch size (e.g. 128), RMSProp [Tieleman and Hinton, 2012] or Adam [Kingma and Ba, 2014] optimizers with learning rates between [0.0001, 0.01].", "publication_ref": ["b8", "b6"], "figure_ref": [], "table_ref": []}, {"heading": "Rock, Paper, Scissors", "text": "Rock Paper Scissors (RPS) is among the most well-studied 2-player zero-sum game. It is well known that playing uniformly is an NE and QRE for RPS. In this experiment, we consider the following variant (Figure 2), which breaks symmetry between the 3 actions. Notice that the traditional RPS is recovered when b 1 , b 2 , b 3 are all 1.\nWe assume that each of the b's is a linear function of some features x \u2208 R 2 , i.e., b y = x T w y , y \u2208 {1, 2, 3}, where w y are to be learned. Features in the dataset and ground-truth weights are drawn uniformly from [0, 1], and [0, 10] respectively. Experiments were evaluated with a fixed test set of size 2000. The results presented in Figure 3 illustrate 2 key points. The first plot shows that dramatically improves with larger datasets, both in terms of parameters learned and predicted strategies. The second plot shows that with a reasonably sized dataset, convergence is stable and is fairly quick. However, it was observed that when the dataset is small (e.g. 200), the model may diverge from the ground truth.", "publication_ref": [], "figure_ref": ["fig_1", "fig_2"], "table_ref": []}, {"heading": "One-Card Poker", "text": "We consider a simple poker game where players are dealt a single card, with ante/bets of 10, and two stages of betting for the first player. Specifically, suppose n cards labeled 1  through n are dealt uniformly. Both players begin with an ante of 10. Player 1 decides whether to bet an additional 10, followed by Player 2 (who folds if he does not call). Lastly, Player 1 may choose to bet if Player 2 raises. Both players are obliged to reveal their card at the end of each game.\nWhile relatively simple, the game contains the key elements in extensive-form games and the strategic concepts in poker such as slow playing (e.g. not betting even if Player 1 holds the high card) and bluffing (e.g. betting even if the player holds a low card). Despite its simple structure, the game with n cards has 2 2n normal form pure strategies for each player. This exponential explosion of strategies is not improved by using the reduced normal form. However, in sequence form, we only need to work with realization plans of size 4n.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Experimental Setup", "text": "We assume that the deck is stacked non-uniformly. Our goal is to learn this distribution of cards after observing many rounds of play. Let d \u2208 R n , d \u2265 0, i d i = 1 be the weights of cards. The probability that the players are dealt cards (i, j)\n(i = j) is d i \u00d7 dj 1\u2212di .\nNote that this distribution is asymmetric between players. Matrices P, E, F for the case n = 4 are presented in the Appendix.\nRemark. While counting cards seems to be a straightforward way to learn the card distribution when d does not change over time, our method is suited to learn the player's perceived or believed distribution of cards, which may be different from the distribution of cards dealt. This may even be a function of contextual features such as demographics of players.\nA total of three experiments were run with n = 4. For each experiment, d \u223c Dir(1, 1, 1, 1). Each experiment comprises 5 runs of training, with same weights but different training sets. Training was for 2500 epochs, which was observed to be after convergence. The mean squared error of learned parameters are averaged over all runs and are presented in Figure 4.  \n{#D 1 , #D 2 } {0, 3} {1, 2} {2, 1} {3, 0} T 1 \u2212R 1 \u2212 1 2 R 1 \u2212 1 4 R 1 \u2212 1 8 R 1 T 2 \u2212 1 8 R 2 \u2212 1 4 R 2 \u2212 1 2 R 2 \u2212R 2", "publication_ref": [], "figure_ref": ["fig_3"], "table_ref": []}, {"heading": "Security Resource Allocation Game", "text": "In this set of experiments, we demonstrate the ability to learn from incomplete observations in a setting that abstracts attacks in cybersecurity domain. The defender possesses k indistinguishable and indivisible defensive resources, e.g., cyber analysts, which he splits among n targets, {T 1 , ..., T n }.\nIn an attacking attempt, the attacker (row player) chooses one target. In the event an attack on T i succeeds, the attacker obtains a reward of R i (and the defender \u2212R i ), otherwise, the payoffs to both parties are 0. Each defensive resource independently prevents an intrusion with probability 0.5. For example, if there are two defenders guarding T 1 , the chance of a successful attack on T 1 is 1 2 2 . This creates a scenario where the marginal benefit of each defensive resources decreases, thus requiring the defender to strike a balance. The matrix of expected payoffs when n = 2, k = 3 is shown in Figure 5.\nIn addition to considering the case where the attacker launches a single attack, we also consider a multi-stage game where the attacker can launch t attacks, one in each stage while the defender chooses his allocation of resources in stage 1 and cannot change it in later stages. On the other hand, the attacker has the option of changing his target between stages. This describes a setting where analysts are deployed to specific network assets on a daily basis, while attackers are sufficiently nimble to make multiple attacks in a single day. To understand why the attacker may change target, consider that target T i is attacked in stage 1 and the attack is unsuccessful. It may be inferred that it is more likely that T i is better guarded, prompting the attacker to switch targets.\nThree experiments are run with n = 2, k = 5 for games with single attack and double attack, i.e, t = 1 and t = 2. Crucially, in this set of experiments, we learn R i only based on observations of the defender's actions. This setting yields a 10 \u00d7 6 sequence form payoff matrix. For each experiment, R 1 and R 2 are drawn uniformly in [0, 2]. Each experiment is run 10 times for at least 2000 epochs per run. The mean and standard error over each run is presented in Figure 6. The results show that our algorithm can still recover the game setting by only observing defender's actions.", "publication_ref": [], "figure_ref": ["fig_4", "fig_5"], "table_ref": []}, {"heading": "Discussion", "text": "As expected, the quality of learned parameters improves as the number of data points increases. Notable exceptions occur in (i) the green plot for the security game when t = 2 and (ii) RPS, when comparing between training sizes of 2000 and 5000. These outliers are no longer observed when comparing MSE of u, v. For example, Figure 3 shows that predicted strategies improve significantly when going from 2000 to 5000 samples, showing that despite not converging to better parameters, the network still demonstrates a marked improvement in predicting player strategies.", "publication_ref": [], "figure_ref": ["fig_2"], "table_ref": []}, {"heading": "Conclusion", "text": "In this paper, we present a fully differentiable module capable of learning payoff and other parameters in zero-sum games, given side information and partial observability. The proposed module's unique capabilities are demonstrated over a broad range of problems. Future work entails faster solvers by exploiting structure in the KKT matrix and extensions to learning general-sum games.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "A Proofs and derivations", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "A.1 Equivalence to reduced normal form", "text": "In this section we present the proof of one of the main technical results of this paper, that the dilated entropy regularization of a extensive form game is equivalent to the standard entropy-regularized QRE of the equivalent reduced normalform game.\nConsider the max player in isolation. His game in sequence form may be represented by a tree with alternating actions and information sets. Consider the game shown in Figure 7. Red nodes are vertices and black nodes are information sets. White squares represent sibling actions of A, which may in turn, contain other parts of the game tree. The information states associated with I 1 , I 2 are parallel information states, i.e. both of which may be reached from A with non-zero probability (assuming suitable opponent/chance actions).\nWe show that the optimal solution using dilated entropy regularization on the game in Figure 7 is realization equivalent to the optimum of the reduced game in Figure 8. Essentially, this operation converts part of the sequences to the normal form, by replacing parts of the tree with all possibly contingencies. Repeated application of this operation eventually translates the sequence-form representation to the reduced normal form. This is performed on the tree in a bottomup manner, all while maintaining realization equivalence. ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Part 1", "text": "Let A be the an action such that all immediate child actions are leaves (e.g. Figure 7) and I be its parent. We condition on having taken the action A, that is, assume that the player reaches A with probability 1 (barring chance or the other player's actions). We will first show that after conditioning, the resultant reduced normal form is equivalent to its sequence form. Notation. Recall C A = {I k } denotes the children information sets of A. The action set at I k is denoted by  this derivation, the opponent's strategy is fixed, and his strategy profile is combined to give P T u = x.\nIn normal form, all contingencies are accounted for, and the set of pure strategies are given by the Cartesian product of action sets\u00c2 A = k A k . We denote the normal form mixed strategy profile, payoff matrix, and normal form payoff vector asv,P andx =P T\u00fb . Note that the sizes of these vectors/matrices are not equivalent to their counterparts in sequence form. For convenience, we define f (v) to be a function mappingv to v by performing the appropriate marginalization. Let g(v, j) be the distribution of actions extracted from v supposing an information state of I j . For simplicity let H now define the Shannon entropy, H(y) = \u2212 y i log(y i ).\nDerivation. The resultant QRE in the reduced normal form is, max\nThe first line is by definition. The second line holds from the fact that joint entropy is maximized by independent random variables (induced by the marginals g(f (v), j)). That is, if this independence relationship does not hold, then we could construct a strictly better candidate solution. The third line follows from the fact that the joint entropy of mutually independent random variables is equal to the sum of their entropies. The last line is true since every sequence form strategy is induced by at least one normal form strategy (i.e. the image of f is equal to the domain of v) and vice versa.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Part 2", "text": "In Part 1, we showed realization equivalence when the white square is non-existent, i.e. there are no other children of I.\nIn this section, we relax that assumption. For this part of the proof, I may possibly not be the root.\nConsider the full sequence form formulation, starting from our objective function. We split v (the full realization plan in sequence form) into two portions,\u1e7d for actions which are children of A (i.e. all a where p \u03c1a = A), andv, for the rest of the actions (at other portions of the tree). We split x int\u00f5 x andx similarly. The objective function may be written as two nested optimization problems,\nObserve that the flow constraints dictate that for any information set under A, the corresponding children actions in\u1e7d sums to v A . Hence, we may write the optimization problem in terms of normalized (conditional) probabilities,v, which do indeed sum to 1.\nAfter normalization, we may plug in the result in Part 1 into the inner maximization term, replacing it by its normal form involvingv andx.\nThe first line follows from the result in Part 1. The second line splits the entropy regularization terms from I into the terms involving A and those which do not. The last line follows from 'reintroducing' the flow constraints into the inner maximization. Observe that thev A logv A terms cancel out, allowing for the following simplifications,\nObserve thatx A is zero, since it must be a non-leaf node (all rewards are deferred to leaves). This allows us to recombinev andv into a long vector in sequence form, which we denotev -which is the sequence form of the condensed version (e.g. Figure 8. The flow constraints in the inner maximization is 'compatible' with the form required by the outer maximization.\nwhere the\u00c0 and\u00cc v are the action sets in the condensed game (i.e all the information sets originally children of A are gone, and the actions in the normal form are now actions in \u03c1 A ).x refers to the reward vector obtained by mergingx,x together, and removing the term associated withx A (which was 0 to begin with).\nThe final part of the proof follows by repeatedly applying the transform described. Note that it is always possible to find a suitable I and A for this process, if not, then we have already arrived at the reduced normal form. The number of non-leaf actions must drop monotonically, hence the process will terminate at some point. Lastly, observe that our assumption that non-leaf actions have 0 payoffs is remains true after every iteration.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "B Experimental setup B.1 E, F, P matrices for one-card poker", "text": "Here we provide a complete example of how to encode and parameterize one-card poker in sequence form, as required by our approach. We begin with the linear constraints in sequence form. Recall E and F matrices define the structure of the game state transitions, Eu \u2212 e = 0, F v \u2212 f = 0. For a game with 4 cards, there are 8 information sets and 16 actions per player. The constraint matrices are given by\nwhere each I has a size of 4.\nWe now turn to parameterization of the payoff matrix in terms of the card distribution d. Suppose for the time being that the deck is uniformly stacked, i.e. d = (0.25, 0.25, 0.25, 0.25). Define the showdown matrix\nand the forfeit matrix.\nwhere by our convention, the row player is the minimizing player. Each block is of size 4 \u00d7 4, and gives possible outcomes for each of the 4 2 possible ways of dealing cards. The 4 blocks for the row player correspond to the actions 'do not raise on first move', 'raise on first move', 'fold on second move', 'raise on second move'. For the column player, the actions are 'fold after first player did not raise', 'raise after first player did not raise', 'fold after first player raised', 'raise after first player raised'.\nWhen d is not uniform, define the 4 \u00d7 4 distribution matrix\nThe payoff matrix is then\ni.e. every 4 \u00d7 4 block is pointwise weighted by the chance of being dealt the relevant cards. It may be seen that the forfeit matrix X is really just the all-ones matrix multiplied pointwise by D.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "B.2 Experimental setup", "text": "All of the experiments are run using CPU cycles.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Rock, paper, scissors", "text": "Experiments were run on a 3.1 GHz Intel Core i5 with 16 GB of RAM. The learning rate is 0.0005, with a batch size of 128. We utilized the Adam optimizer. The maximum number of epochs before termination is 10000. Parameters were initialized to the 0-matrix for each experiment.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "One card poker", "text": "Experiments are run on a 4.2GHz Intel Core i7 with 128GB of RAM . The learning rate is 0.002, batch size of 128, using the RMSProp optimizer. Weights are initialized to be uniform, i.e. (0.25, 0.25, 0.25, 0.25). In order to ensure that d is valid probability distribution, the features are passed through softmax layer which then outputs d. The maximum number of epochs is 2500, although convergence occurs significantly faster. Since there is no context, experiments may be run much faster by computing the forward pass just once for each minibatch. Similarly, the inverse matrix required in the backward pass may be cached and reused between each member in the same minibatch.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Security resource allocation game", "text": "The experiments were run on an Amazon c4.2xlarge EC2 instance. The learning rate is 0.002 using the RMSProp optimizer (all other hyperparameters are left as the defaults in Pytorch). Each run was 2000 epochs. The weights are passed through f (x) = (tanh(x) + 1) to clip rewards to between [0, 2] for the payoff matrix.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Gradient methods for stackelberg security games", "journal": "", "year": "2016", "authors": " Amin"}, {"ref_id": "b1", "title": "An analysis of stochastic game theory for multiagent reinforcement learning", "journal": "", "year": "2000", "authors": "Amos ; Kolter ; Brandon Amos; J Zico Kolter ; Blum"}, {"ref_id": "b2", "title": "Superhuman ai for heads-up no-limit poker: Libratus beats top professionals", "journal": "", "year": "2004", "authors": "Vandenberghe ; Stephen Boyd; Lieven Vandenberghe"}, {"ref_id": "b3", "title": "Deploying paws: Field optimization of the protection assistant for wildlife security", "journal": "IEEE Transactions on Systems, Man, And Cybernetics-Part C: Applications and Reviews", "year": "2008", "authors": "[ Busoniu"}, {"ref_id": "b4", "title": "Learning equilibria of games via payoff queries", "journal": "Journal of Machine Learning Research", "year": "2015", "authors": " Fearnley"}, {"ref_id": "b5", "title": "On differentiating parameterized argmin and argmax problems with application to bi-level optimization", "journal": "", "year": "2010", "authors": "[ Gould"}, {"ref_id": "b6", "title": "Adam: A method for stochastic optimization", "journal": "", "year": "2014", "authors": "Ba Kingma; P Diederik; Jimmy Kingma;  Ba"}, {"ref_id": "b7", "title": "Deepstack: Expert-level artificial intelligence in heads-up no-limit poker", "journal": "Springer", "year": "1995", "authors": "[ Kroer"}, {"ref_id": "b8", "title": "Lecture 6.5-RmsProp: Divide the gradient by a running average of its recent magnitude", "journal": "", "year": "2012", "authors": "T Tieleman; G Hinton"}, {"ref_id": "b9", "title": "Bernhard Von Stengel. Efficient computation of behavior strategies. Games and Economic Behavior", "journal": "", "year": "1996", "authors": "Von Stengel"}, {"ref_id": "b10", "title": "Computational rationalization: the inverse equilibrium problem", "journal": "Omnipress", "year": "2007", "authors": "Satinder Michael P Wellman; ; Singh;  Waugh"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 1 :1Figure 1: An example architecture utilizing our proposed module.", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 2 :2Figure 2: Payoff matrix of modified Rock-Paper-Scissors. Values shown are for the row player.", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Figure 3 :3Figure 3: Left: MSE of parameters and predicted mixed strategies. Right: Convergence over 2000 epochs, using a dataset of size 2000.", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Figure 4 :4Figure 4: MSE of card weights (left) and realization plans (right).", "figure_data": ""}, {"figure_label": "5", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "Figure 5 :5Figure 5: Security resource allocation game. n = 2, k = 3.", "figure_data": ""}, {"figure_label": "6", "figure_type": "figure", "figure_id": "fig_5", "figure_caption": "Figure 6 :6Figure 6: MSE of target values. Left: t=1, Right: t=2", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "min u max v u T P v (1) subject to 1 T u = 1, u \u2265 0 (2) 1 T v = 1, v \u2265 0,(3)", "formula_coordinates": [2.0, 379.61, 147.47, 178.39, 47.02]}, {"formula_id": "formula_1", "formula_text": "u * i = exp(\u2212P v) i q\u2208[n] exp(\u2212P v) q , v * j = exp(P T u) j q\u2208[m] exp(P T u) q .", "formula_coordinates": [3.0, 57.01, 72.85, 228.68, 26.29]}, {"formula_id": "formula_2", "formula_text": "min u\u2208R n max v\u2208R m u T P v \u2212 H(v) + H(u) subject to 1 T u = 1, 1 T v = 1,(5)", "formula_coordinates": [3.0, 102.96, 383.42, 194.04, 31.88]}, {"formula_id": "formula_3", "formula_text": "P v + log(u) + 1 + \u00b51 = 0 P T u \u2212 log(v) \u2212 1 + \u03bd1 = 0 1 T u = 1, 1 T v = 1,(6)", "formula_coordinates": [3.0, 117.01, 554.75, 179.99, 41.04]}, {"formula_id": "formula_4", "formula_text": "Q \uf8ee \uf8ef \uf8f0 \u2206u \u2206v \u2206\u00b5 \u2206\u03bd \uf8f9 \uf8fa \uf8fb = \u2212 \uf8ee \uf8ef \uf8f0 P v + log u + 1 + \u00b51 P T u \u2212 log v \u2212 1 + \u03bd1 1 T u \u2212 1 1 v \u2212 1 \uf8f9 \uf8fa \uf8fb , (7", "formula_coordinates": [3.0, 90.97, 657.61, 202.15, 43.03]}, {"formula_id": "formula_5", "formula_text": ")", "formula_coordinates": [3.0, 293.13, 675.38, 3.87, 8.64]}, {"formula_id": "formula_6", "formula_text": "Q = \uf8ee \uf8ef \uf8ef \uf8f0 diag( 1 u ) P 1 0 P T \u2212diag( 1 v ) 0 1 1 T 0 0 0 0 1 T 0 0 \uf8f9 \uf8fa \uf8fa \uf8fb .(8)", "formula_coordinates": [3.0, 371.02, 73.56, 186.98, 46.08]}, {"formula_id": "formula_7", "formula_text": "Q [du dv d\u00b5 d\u03bd] T = \u2212dP v \u2212 dP T u 0 0 T .(9)", "formula_coordinates": [3.0, 330.96, 293.03, 227.04, 12.92]}, {"formula_id": "formula_8", "formula_text": "dL = [\u2207 u L \u2207 v L 0 0] [du dv d\u00b5 d\u03bd] T = [\u2207 u L \u2207 v L 0 0] Q \u22121 \u2212dP v \u2212 dP T u 0 0 T = v T dP T u T dP 0 0 Q \u22121 [\u2212\u2207 u L \u2212 \u2207 v L 0 0] T ,", "formula_coordinates": [3.0, 318.8, 324.83, 237.06, 48.61]}, {"formula_id": "formula_9", "formula_text": "\u2207 P L = y u v T + uy T v , (10", "formula_coordinates": [3.0, 392.14, 436.09, 161.72, 12.69]}, {"formula_id": "formula_10", "formula_text": ") where [y u y v y \u00b5 y \u03bd ] T = Q \u22121 [\u2212\u2207 u L \u2212 \u2207 v L 0 0] T .", "formula_coordinates": [3.0, 315.0, 438.48, 243.0, 37.87]}, {"formula_id": "formula_11", "formula_text": "min u max v u T P v + i\u2208Iu a\u2208Ai u a log u a u pi \u2212 i\u2208Iv a\u2208Ai v a log v a v pi .(11)", "formula_coordinates": [4.0, 54.0, 473.6, 254.54, 38.26]}, {"formula_id": "formula_12", "formula_text": "(P v) a + 1 + log(u a ) \u2212 log(u pi ) \u2212 J a + c\u2208Ca \u00b5 c \u2212 \u00b5 i = 0, \u2200i \u2208 U, a \u2208 A i (P T u) a \u2212 1 \u2212 log(v a ) + log(v p i ) + J a + c\u2208C a \u03bd c \u2212 \u03bd i = 0, \u2200i \u2208 V, a \u2208 A i", "formula_coordinates": [4.0, 329.74, 363.6, 210.33, 83.34]}, {"formula_id": "formula_13", "formula_text": "\uf8ee \uf8ef \uf8f0 \u2212\u039e(u) P E T 0 P T \u039e(v) 0 F T E 0 0 0 0 F 0 0 \uf8f9 \uf8fa \uf8fb \uf8ee \uf8ef \uf8f0 \u2206u \u2206v \u2206\u00b5 \u2206\u03bd \uf8f9 \uf8fa \uf8fb = \u2212g(u, v, \u00b5, \u03bd) \u039e(u) ab = \uf8f1 \uf8f4 \uf8f2 \uf8f4 \uf8f3 \u2212 1+Ja ua , a = b 1 u b , p \u03c1a = b 1 ua , p \u03c1 b = a \u039e(v) a b = \uf8f1 \uf8f4 \uf8f2 \uf8f4 \uf8f3 \u2212 1+J a v a , a = b 1 v b , p \u03c1 a = b 1 v a , p \u03c1 b = a", "formula_coordinates": [4.0, 315.0, 520.75, 231.98, 94.1]}, {"formula_id": "formula_14", "formula_text": "\u2207 P L = y u v T + uy T v ,(12) where \uf8ee", "formula_coordinates": [4.0, 315.0, 631.78, 243.0, 38.03]}, {"formula_id": "formula_15", "formula_text": "\uf8ef \uf8f0 y u y v y \u00b5 y \u03bd \uf8f9 \uf8fa \uf8fb = \uf8ee \uf8ef \uf8f0 \u2212\u039e(u) P E T 0 P T \u039e(v) 0 F T E 0 0 0 0 F 0 0 \uf8f9 \uf8fa \uf8fb \u22121 \uf8ee \uf8ef \uf8f0 \u2212\u2207 u L \u2212\u2207 v L 0 0 \uf8f9 \uf8fa \uf8fb . R P S R 0 \u2212b 1 b 2 P b 1 0 \u2212b 3 S \u2212b 2 b 3 0", "formula_coordinates": [4.0, 329.62, 659.43, 213.76, 46.41]}, {"formula_id": "formula_16", "formula_text": "(i = j) is d i \u00d7 dj 1\u2212di .", "formula_coordinates": [5.0, 315.0, 523.93, 80.9, 14.61]}, {"formula_id": "formula_17", "formula_text": "{#D 1 , #D 2 } {0, 3} {1, 2} {2, 1} {3, 0} T 1 \u2212R 1 \u2212 1 2 R 1 \u2212 1 4 R 1 \u2212 1 8 R 1 T 2 \u2212 1 8 R 2 \u2212 1 4 R 2 \u2212 1 2 R 2 \u2212R 2", "formula_coordinates": [6.0, 70.29, 55.27, 209.93, 35.95]}], "doi": ""}