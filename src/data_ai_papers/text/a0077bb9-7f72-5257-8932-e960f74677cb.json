{"title": "Support Vector Machine Classification with Indefinite Kernels", "authors": "Ronny Luss", "pub_date": "", "abstract": "In this paper, we propose a method for support vector machine classification using indefinite kernels. Instead of directly minimizing or stabilizing a nonconvex loss function, our method simultaneously finds the support vectors and a proxy kernel matrix used in computing the loss. This can be interpreted as a robust classification problem where the indefinite kernel matrix is treated as a noisy observation of the true positive semidefinite kernel. Our formulation keeps the problem convex and relatively large problems can be solved efficiently using the analytic center cutting plane method. We compare the performance of our technique with other methods on several data sets.", "sections": [{"heading": "Introduction", "text": "Here, we present an algorithm for support vector machine (SVM) classification using indefinite kernels. Our interest in indefinite kernels is motivated by several observations. First, certain similarity measures take advantage of application-specific structure in the data and often display excellent empirical classification performance. Unlike popular kernels used in support vector machine classification, these similarity matrices are often indefinite and so do not necessarily correspond to a reproducing kernel Hilbert space (see [1] for a discussion).\nAn application of classification with indefinite kernels to image classification using Earth Mover's Distance was discussed in [2]. Similarity measures for protein sequences such as the Smith-Waterman and BLAST scores are indefinite yet have provided hints for constructing useful positive semidefinite kernels such as those decribed in [3] or have been transformed into positive semidefinite kernels (see [4] for example). Here instead, our objective is to directly use these indefinite similarity measures for classification.\nOur work also closely follows recent results on kernel learning (see [5] or [6]), where the kernel matrix is learned as a linear combination of given kernels, and the resulting kernel is explicitly constrained to be positive semidefinite (the authors of [7] have adapted the SMO algorithm to solve the case where the kernel is written as a positively weighted combination of other kernels). In our case however, we never explicitly optimize the kernel matrix because this part of the problem can be solved explicitly, which means that the complexity of our method is substantially lower than that of classical kernel learning methods and closer in spirit to the algorithm used in [8], who formulate the multiple kernel learning problem of [7] as a semi-infinite linear program and solve it with a column generation technique similar to the analytic center cutting plane method we use here.\nFinally, it is sometimes impossible to prove that some kernels satisfy Mercer's condition or the numerical complexity of evaluating the exact positive semidefinite kernel is too high and a proxy (and not necessarily positive semidefinite) kernel has to be used instead (see [9] for example). In both cases, our method allows us to bypass these limitations.", "publication_ref": ["b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b6", "b8"], "figure_ref": [], "table_ref": []}, {"heading": "Current results", "text": "Several methods have been proposed for dealing with indefinite kernels in SVMs. A first direction embeds data in a pseudo-Euclidean (pE) space: [10] for example, formulates the classification problem with an indefinite kernel as that of minimizing the distance between convex hulls formed from the two categories of data embedded in the pE space. The nonseparable case is handled in the same manner using reduced convex hulls (see [11] for a discussion of SVM geometric interpretations).\nAnother direction applies direct spectral transformations to indefinite kernels: flipping the negative eigenvalues or shifting the kernel's eigenvalues and reconstructing the kernel with the original eigenvectors in order to produce a positive semidefinite kernel (see [12] and [2]).\nYet another option is to reformulate either the maximum margin problem or its dual in order to use the indefinite kernel in a convex optimization problem (see [13]). An equivalent formulation of SVM with the same objective but where the kernel appears in the constraints can be modified to a convex problem by eliminating the kernel from the objective. Directly solving the nonconvex problem sometimes gives good results as well (see [14] and [10]).", "publication_ref": ["b9", "b10", "b11", "b1", "b12", "b13", "b9"], "figure_ref": [], "table_ref": []}, {"heading": "Contribution", "text": "Here, instead of directly transforming the indefinite kernel, we simultaneously learn the support vector weights and a proxy positive semidefinite kernel matrix, while penalizing the distance between this proxy kernel and the original, indefinite one. Our main result is that the kernel learning part of that problem can be solved explicitly, meaning that the classification problem with indefinite kernels can simply be formulated as a perturbation of the positive semidefinite case.\nOur formulation can also be interpreted as a worst-case robust classification problem with uncertainty on the kernel matrix. In that sense, indefinite similarity matrices are seen as noisy observations of an unknown positive semidefinite kernel. From a complexity standpoint, while the original SVM classification problem with indefinite kernel is nonconvex, the robustification we detail here is a convex problem, and hence can be solved efficiently with guaranteed complexity bounds.\nThe paper is organized as follows. In Section 2 we formulate our main classification problem and detail its interpretation as a robust SVM. In Section 3 we describe an algorithm for solving this problem. Finally, in Section 4, we test the numerical performance of these methods on various applications.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "SVM with indefinite kernels", "text": "Here, we introduce our robustification of the SVM classification problem with indefinite kernels.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Robust classification", "text": "Let K \u2208 S n be a given kernel matrix and y \u2208 R n be the vector of labels, with Y = diag(y) the matrix with diagonal y, where S n is the set of symmetric matrices of size n and R n is the set of n-vectors of real numbers. We can write the dual of the SVM classification problem with hinge loss and quadratic penalty as:\nmaximize \u03b1 T e \u2212 Tr(K(Y \u03b1)(Y \u03b1) T )/2 subject to \u03b1 T y = 0 0 \u2264 \u03b1 \u2264 C (1)\nin the variable \u03b1 \u2208 R n and where e is an n-vector of ones. When K is positive semidefinite, this problem is a convex quadratic program. Suppose now that we are given an indefinite kernel matrix K 0 \u2208 S n . We formulate a robust version of problem (1) by restricting K to be a positive semidefinite kernel matrix in some given neighborhood of the original (indefinite) kernel matrix K 0 :\nmax {\u03b1 T y=0, 0\u2264\u03b1\u2264C} min {K 0, K\u2212K0 2 F \u2264\u03b2} \u03b1 T e \u2212 1 2 Tr(K(Y \u03b1)(Y \u03b1) T )(2)\nin the variables K \u2208 S n and \u03b1 \u2208 R n , where the parameter \u03b2 > 0 controls the distance between the original matrix K 0 and the proxy kernel K. This can be interpreted as a worst-case robust classification problem with bounded uncertainty on the kernel matrix K. The above problem is infeasible for some values of \u03b2 so we replace here the hard constraint on K by a penalty on the distance between the proxy positive semidefinite kernel and the given indefinite matrix. The problem we solve is now:\nmax {\u03b1 T y=0,0\u2264\u03b1\u2264C} min {K 0} \u03b1 T e \u2212 1 2 Tr(K(Y \u03b1)(Y \u03b1) T ) + \u03c1 K \u2212 K 0 2 F (3)\nin the variables K \u2208 S n and \u03b1 \u2208 R n , where the parameter \u03c1 > 0 controls the magnitude of the penalty on the distance between K and K 0 . The inner minimization problem is a convex conic program on K. Also, as the pointwise minimum of a family of concave quadratic functions of \u03b1, the solution to the inner problem is a concave function of \u03b1, and hence the outer optimization problem is also convex (see [15] for further details). Thus, ( 3) is a concave maximization problem subject to linear constraints and is therefore a convex problem in \u03b1.\nOur key result here is that the inner kernel learning optimization problem can be solved in closed form. For a fixed \u03b1, the inner minimization problem is equivalent to the following problem:\nminimize K \u2212 (K 0 + 1 4\u03c1 (Y \u03b1)(Y \u03b1) T ) 2 F subject to K 0 in the variable K \u2208 S n\n. This is the projection of the\nK 0 + (1/4\u03c1)(Y \u03b1)(Y \u03b1)\nT on the cone of positive semidefinite matrices. The optimal solution to this problem is then given by:\nK * = (K 0 + (1/4\u03c1)(Y \u03b1)(Y \u03b1) T ) + (4)\nwhere X + is the positive part of the matrix X, i.e. X + = i max(0, \u03bb i )x i x T i where \u03bb i and x i are the i th eigenvalue and eigenvector of the matrix X. Plugging this solution into (3), we get:\nmax {\u03b1 T y=0, 0\u2264\u03b1\u2264C} \u03b1 T e \u2212 1 2 Tr(K * (Y \u03b1)(Y \u03b1) T ) + \u03c1 K * \u2212 K 0 2 F in the variable \u03b1 \u2208 R n , where (Y \u03b1)(Y \u03b1)\nT is the rank one matrix with coefficients y i \u03b1 i \u03b1 j y j , i, j = 1, . . . , n. We can rewrite this as an eigenvalue optimization problem by using the eigenvalue representation of X + . Letting the eigenvalue decomposition of\nK 0 +(1/4\u03c1)(Y \u03b1)(Y \u03b1) T be V DV T ,\nwe get K * = V D + V T and, with v i the i th column of V , we can write:\nTr(K * (Y \u03b1)(Y \u03b1) T ) = (Y \u03b1) T V D + V T (Y \u03b1) = n i=1 max 0, \u03bb i K 0 + 1 4\u03c1 (Y \u03b1)(Y \u03b1) T (\u03b1 T Y v i ) 2\nwhere \u03bb i (X) is the i th eigenvalue of the quantity X. Using the same technique, we can also rewrite the term K * \u2212 K 0 | 2 F using this eigenvalue decomposition. Our original optimization problem (3) finally becomes:\nmaximize \u03b1 T e \u2212 1 2 i max(0, \u03bb i (K 0 + (Y \u03b1)(Y \u03b1) T /4\u03c1))(\u03b1 T Y v i ) 2 +\u03c1 i (max(0, \u03bb i (K 0 + (Y \u03b1)(Y \u03b1) T /4\u03c1))) 2 \u22122\u03c1 i Tr((v i v T i )K 0 )max(0, \u03bb i (K 0 + (Y \u03b1)(Y \u03b1) T /4\u03c1)) + \u03c1 Tr(K 0 K 0 ) subject to \u03b1 T y = 0, 0 \u2264 \u03b1 \u2264 C (5) in the variable \u03b1 \u2208 R n .", "publication_ref": ["b14"], "figure_ref": [], "table_ref": []}, {"heading": "Dual problem", "text": "Because problem (3) is convex with at least one compact feasible set, we can formulate the dual problem to (5) by simply switching the max and the min. The inner maximization is a quadratic program in \u03b1, and hence has a quadratic program as its dual. We then get the dual by plugging this inner dual quadratic program into the outer minimization, to get the following problem:\nminimize Tr(K \u22121 (Y (e \u2212 \u03bb + \u00b5 + y\u03bd))(Y (e \u2212 \u03bb + \u00b5 + y\u03bd)) T )/2 + C\u00b5 T e + \u03c1 K \u2212 K 0 2 F subject to K 0, \u03bb, \u00b5 \u2265 0 (6)\nin the variables K \u2208 S n , \u03bb, \u00b5 \u2208 R n and \u03bd \u2208 R. This dual problem is a quadratic program in the variables \u03bb and \u00b5 which correspond to the primal constraints 0 \u2264 \u03b1 \u2264 C and \u03bd which is the dual variable for the constraint \u03b1 T y = 0. As we have seen earlier, any feasible solution to the primal problem produces a corresponding kernel in (4), and plugging this kernel into the dual problem in (6) allows us to calculate a dual feasible point by solving a quadratic program which gives a dual objective value, i.e. an upper bound on the optimum of (5). This bound can then be used to compute a duality gap and track convergence.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Interpretation", "text": "We noted that our problem can be viewed as a worst-case robust classification problem with uncertainty on the kernel matrix. Our explicit solution of the optimal worst-case kernel given in ( 4) is the projection of a penalized rank-one update to the indefinite kernel on the cone of positive semidefinite matrices. As \u03c1 tends to infinity, the rank-one update has less effect and in the limit, the optimal kernel is the kernel given by zeroing out the negative eigenvalues of the indefinite kernel. This means that if the indefinite kernel contains a very small amount of noise, the best positive semidefinite kernel to use with SVM in our framework is the positive part of the indefinite kernel.\nThis limit as \u03c1 tends to infinity also motivates a heuristic for the transformation of the kernel on the testing set. Since the negative eigenvalues of the training kernel are thresholded to zero in the limit, the same transformation should occur for the test kernel. Hence, we update the entries of the full kernel corresponding to training instances by the rank-one update resulting from the optimal solution to (3) and threshold the negative eigenvalues of the full kernel matrix to zero. We then use the test kernel values from the resulting positive semidefinite matrix.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Algorithms", "text": "We now detail two algorithms that can be used to solve Problem (5). The optimization problem is the maximization of a nondifferentiable concave function subject to convex constraints. An optimal point always exists since the feasibility set is bounded and nonempty. For numerical stability, in both algorithms, we quadratically smooth our objective to calculate a gradient instead. We first describe a simple projected gradient method which has numerically cheap iterations but has no convergence bound. We then show how to apply the much more efficient analytic center cutting plane method whose iterations are slightly more complex but which converges linearly.\nSmoothing Our objective contains terms of the form max{0, f (x)} for some function f (x), which are not differentiable (described in the section below). These functions are easily smoothed out by a regularization technique (see [16] for example). We replace them by a continuously differentiable \u01eb 2 -approximation as follows:\n\u03d5 \u01eb (f (x)) = max 0\u2264u\u22641 (uf (x) \u2212 \u01eb 2 u 2 ).\nand the gradient is given by \u2207\u03d5 \u01eb (f (x)) = u * (x)\u2207f (x) where u * (x) = argmax \u03d5 \u01eb (f (x)).\nGradient Calculating the gradient of our objective requires a full eigenvalue decomposition to compute the gradient of each eigenvalue. Given a matrix X(\u03b1), the derivative of the i th eigenvalue with respect to \u03b1 is given by:\n\u2202\u03bb i (X(\u03b1)) \u2202\u03b1 = v T i \u2202X(\u03b1) \u2202\u03b1 v i (7)\nwhere v i is the i th eigenvector of X(\u03b1). We can then combine this expression with the smooth approximation above to get the gradient.\nWe note that eigenvalues of symmetric matrices are not differentiable when some of them have multiplicities greater than one (see [17] for a discussion). In practice however, most tested kernels were of full rank with distinct eigenvalues so we ignore this issue here. One may also consider projected subgradient methods, which are much slower, or use subgradients for analytic center cutting plane methods (which does not affect complexity).", "publication_ref": ["b4", "b15", "b16"], "figure_ref": [], "table_ref": []}, {"heading": "Projected gradient method", "text": "The projected gradient method takes a steepest descent, then projects the new point back onto the feasible region (see [18] for example). In order to use these methods the objective function must be differentiable and the method is only efficient if the projection step is numerically cheap. We choose an initial point \u03b1 0 \u2208 R n and the algorithm proceeds as follows:\nProjected gradient method\n1. Compute \u03b1 i+1 = \u03b1 i + t\u2207f (\u03b1 i ).\n2. Set \u03b1 i+1 = p A (\u03b1 i+1 ).\n3. If gap \u2264 \u01eb stop, otherwise go back to step 1.\nThe complexity of each iteration breaks down as follows.\nStep 1. This requires an eigenvalue decomposition and costs O(n 3 ). We note that a line search would be costly because it would require multiple eigenvalue decompositions to recalculate the objective multiple times.\nStep 2. This is a projection onto the region A = {\u03b1 T y = 0, 0 \u2264 \u03b1 \u2264 C} and can be solved explicitly by sorting the vector of entries, with cost O(n log n).\nStopping Criterion. We can compute a duality gap using the results of \u00a72.2:\nlet K i = (K 0 + (Y \u03b1 i )(Y \u03b1 i ) T /4\u03c1\n) + (the kernel at iteration i), then solving problem (1) which is just an SVM with a convex kernel K i produces an upper bound on (5), and hence a bound on the suboptimality of the current solution.\nComplexity. The number of iterations required by this method to reach a target precision of \u01eb is typically in O(1/\u01eb 2 ).", "publication_ref": ["b17"], "figure_ref": [], "table_ref": []}, {"heading": "Analytic center cutting plane method", "text": "The analytic center cutting plane method (ACCPM) reduces the feasible region on each iteration using a new cut of the feasible region computed by evaluating a subgradient of the objective function at the analytic center of the current set, until the volume of the reduced region converges to the target precision. This method does not require differentiability. We set A 0 = {\u03b1 T y = 0, 0 \u2264 \u03b1 \u2264 C} which we can write as {A 0 \u2264 b 0 } to be our first localization set for the optimal solution. The method then works as follows (see [18] for a more complete reference on cutting plane methods):\nAnalytic center cutting plane method 1. Compute \u03b1 i as the analytic center of A i by solving:\n\u03b1 i+1 = argmin y\u2208R n \u2212 m i=1 log(b i \u2212 a T i y)\nwhere a T i represents the i th row of coefficients from the left-hand side of {A 0 \u2264 b 0 }. 2. Compute \u2207f (x) at the center \u03b1 i+1 and update the (polyhedral) localization set:\nA i+1 = A i \u222a {\u2207f (\u03b1 i+1 )(\u03b1 \u2212 \u03b1 i+1 ) \u2265 0} 3. If gap \u2264 \u01eb stop, otherwise go back to step 1.\nThe complexity of each iteration breaks down as follows.\nStep 1. This step computes the analytic center of a polyhedron and can be solved in O(n 3 ) operations using interior point methods for example.\nStep 2. This simply updates the polyhedral description.\nStopping Criterion. An upper bound is computed by maximizing a first order Taylor approximation of f (\u03b1) at \u03b1 i over all points in an ellipsoid that covers A i , which can be done explicitly.\nComplexity. ACCPM is provably convergent in O(n log(1/\u01eb) 2 ) iterations when using cut elimination which keeps the complexity of the localization set bounded. Other schemes are available with slightly different complexities: an O(n 2 /\u01eb 2 ) is achieved in [19] using (cheaper) approximate centers for example.", "publication_ref": ["b17", "b18"], "figure_ref": [], "table_ref": []}, {"heading": "Experiments", "text": "In this section we compare the generalization performance of our technique to other methods of applying SVM classification given an indefinite similarity measure. We also test SVM classification performance on positive semidefinite kernels using the LIBSVM library. We finish with experiments showing convergence of our algorithms. Our algorithms were implemented in Matlab.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Generalization", "text": "We compare our method for SVM classification with indefinite kernels to several of the kernel preprocessing techniques discussed earlier. The first three techniques perform spectral transformations on the indefinite kernel. The first, denoted denoise, thresholds the negative eigenvalues to zero. The second transformation, called flip, takes the absolute value of all eigenvalues. The last transformation, shift, adds a constant to each eigenvalue making them all positive. See [12] for further details. We finally also compare with using SVM on the original indefinite kernel (SVM converges but the solution is only a stationary point and is not guaranteed to be optimal).\nWe experiment on data from the USPS handwritten digits database (described in [20]) using the indefinite Simpson score (SS) to compare two digits and on two data sets from the UCI repository (see [21]) using the indefinite Epanechnikov (EP) kernel. The data is randomly divided into training and testing data. We apply 5-fold cross validation and use an accuracy measure (described below) to determine the optimal parameters C and \u03c1. We then train a model with the full training set and optimal parameters and test on the independent test set. Table 1 provides statistics including the minimum and maximum eigenvalues of the training kernels.\nThe main observation is that the USPS data uses highly indefinite kernels while the UCI data use kernels that are nearly positive semidefinite. Table 2 displays performance by comparing accuracy and recall. Accuracy is defined as the percentage of total instances predicted correctly. Recall is the percentage of true positives that were correctly predicted positive.\nOur method is referred to as Indefinite SVM. We see that our method performs favorably among the USPS data. Both measures of performance are quite high for all methods. Our method does not perform as well on the UCI data sets but is still favorable on one of the measures in each experiment. Notice though that recall is not good in the liver data set overall which could be the result of overfitting one of the classification categories. The liver data set uses a kernel that is almost positive semidefinite -this is an example where the input is almost a true kernel and Indefinite SVM finds one slightly better. We postulate that our method will perform better in situations where the similarity measure is highly indefinite as in the USPS dataset, while measures that are almost positive semidefinite maybe be seen as having a small amount of noise. ", "publication_ref": ["b11", "b19", "b20"], "figure_ref": [], "table_ref": ["tab_0", "tab_1"]}, {"heading": "Algorithm Convergence", "text": "We ran our two algorithms on data sets created by randomly perturbing the four USPS data sets used above. The average results with one standard deviation above and below the mean are displayed in Figure 1 with the duality gap in log scale (note that the codes were not stopped here and that the target gap improvement is usually much smaller than 10 \u22128 ). As expected, ACCPM converges much faster (in fact linearly) to a higher precision while each iteration requires solving a linear program of size n. The gradient projection method converges faster in the beginning but stalls at a higher precision, however each iteration only requires sorting the current point. ", "publication_ref": [], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "Conclusion", "text": "We have proposed a technique for incorporating indefinite kernels into the SVM framework without any explicit transformations. We have shown that if we view the indefinite kernel as a noisy instance of a true kernel, we can learn an explicit solution for the optimal kernel with a tractable convex optimization problem. We give two convergent algorithms for solving this problem on relatively large data sets. Our initial experiments show that our method can at least fare comparably with other methods handling indefinite kernels in the SVM framework but provides a much clearer interpretation for these heuristics.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Learning with non-positive kernels", "journal": "", "year": "2004", "authors": "C S Ong; X Mary; S Canu; A J Smola"}, {"ref_id": "b1", "title": "An assessment of alternative strategies for constructing emd-based kernel functions for use in an svm for image classification", "journal": "", "year": "2004", "authors": "A Zamolotskikh; P Cunningham"}, {"ref_id": "b2", "title": "Protein homology detection using string alignment kernels", "journal": "Bioinformatics", "year": "2004", "authors": "H Saigo; J P Vert; N Ueda; T Akutsu"}, {"ref_id": "b3", "title": "Kernel-based integration of genomic data using semidefinite programming", "journal": "", "year": "2003", "authors": "G R G Lanckriet; N Cristianini; M I Jordan; W S Noble"}, {"ref_id": "b4", "title": "Learning the kernel matrix with semidefinite programming", "journal": "Journal of Machine Learning Research", "year": "2004", "authors": "G R G Lanckriet; N Cristianini; P Bartlett; L El Ghaoui; M I Jordan"}, {"ref_id": "b5", "title": "Learning the kernel with hyperkernels", "journal": "Journal of Machine Learning Research", "year": "2005", "authors": "C S Ong; A J Smola; R C Williamson"}, {"ref_id": "b6", "title": "Multiple kernel learning, conic duality, and the smo algorithm", "journal": "", "year": "2004", "authors": "F R Bach; G R G Lanckriet; M I Jordan"}, {"ref_id": "b7", "title": "Large scale multiple kernel learning", "journal": "Journal of Machine Learning Research", "year": "2006", "authors": "S Sonnenberg; G R\u00e4tsch; C Sch\u00e4fer; B Sch\u00f6lkopf"}, {"ref_id": "b8", "title": "Permanents, transport polytopes and positive definite kernels on histograms. Proceedings of the Twentieth International Joint Conference on Artificial Intelligence", "journal": "", "year": "2007", "authors": "Marco Cuturi"}, {"ref_id": "b9", "title": "Feature space interpretation of svms with indefinite kernels", "journal": "IEEE Transactions on Pattern Analysis and Machine Intelligence", "year": "2005", "authors": "B Haasdonk"}, {"ref_id": "b10", "title": "Duality and geometry in svm classifiers", "journal": "", "year": "2000", "authors": "K P Bennet; E J Bredensteiner"}, {"ref_id": "b11", "title": "An analysis of transformation on non-positive semidefinite similarity matrix for kernel machines", "journal": "", "year": "2005", "authors": "G Wu; E Y Chang; Z Zhang"}, {"ref_id": "b12", "title": "A study on sigmoid kernel for svm and the training of non-psd kernels by smo-type methods", "journal": "", "year": "2003", "authors": "H.-T Lin; C.-J Lin"}, {"ref_id": "b13", "title": "Distances and (indefinite) kernels for set of objects", "journal": "", "year": "2006", "authors": "A Wo\u017anica; A Kalousis; M Hilario"}, {"ref_id": "b14", "title": "Convex Optimization", "journal": "Cambridge University Press", "year": "2004", "authors": "S Boyd; L Vandenberghe"}, {"ref_id": "b15", "title": "A regularization method for solving the finite convex min-max problem", "journal": "SIAM Journal on Numerical Analysis", "year": "1990", "authors": "C Gigola; S Gomez"}, {"ref_id": "b16", "title": "Large-scale optimization of eigenvalues", "journal": "SIAM Journal on Optimization", "year": "1992", "authors": "M Overton"}, {"ref_id": "b17", "title": "Nonlinear Programming", "journal": "", "year": "1999", "authors": "D Bertsekas"}, {"ref_id": "b18", "title": "Convex nondifferentiable optimization: A survey focused on the analytic center cutting plane method", "journal": "Optimization Methods and Software", "year": "2002", "authors": "J.-L Goffin; J.-P Vial"}, {"ref_id": "b19", "title": "A database for handwritten text recognition research", "journal": "IEEE Transactions on Pattern Analysis and Machine Intelligence", "year": "1994", "authors": "J J Hull"}, {"ref_id": "b20", "title": "UCI Machine Learning Repository", "journal": "", "year": "2007", "authors": "A Asuncion; D J Newman"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 1 :1Figure 1: Convergence plots for ACCPM (left) & projected gradient method (right) on randomly perturbed USPS data sets (average gap versus iteration number, dashed lines at plus and minus one standard deviation).", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "Statistics for various data sets.", "figure_data": "Data Set# Train # Test\u03bbmin\u03bbmaxUSPS-3-5-SS767773-34.76453.58USPS-4-6-SS829857-37.30413.17Diabetes-EP614154-0.2718.17Liver-EP27669-1.38e-153.74"}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "Performance Measures for various data sets.", "figure_data": "Data SetMeasureDenoiseFlipShiftSVM Indefinite SVMUSPS-3-5-SSAccuracy95.4795.73 90.43 74.9096.25Recall94.5095.45 92.11 72.7396.65USPS-4-6-SSAccuracy97.7897.90 94.28 90.0897.90Recall98.4298.65 93.68 88.4998.87Diabetes-EPAccuracy75.3274.68 68.83 75.3268.83Recall90.0090.00 92.00 90.0095.00Liver-EPAccuracy63.7763.77 57.97 63.7765.22Recall22.5822.58 25.81 22.5822.58"}], "formulas": [{"formula_id": "formula_0", "formula_text": "maximize \u03b1 T e \u2212 Tr(K(Y \u03b1)(Y \u03b1) T )/2 subject to \u03b1 T y = 0 0 \u2264 \u03b1 \u2264 C (1)", "formula_coordinates": [2.0, 222.0, 553.51, 282.08, 33.62]}, {"formula_id": "formula_1", "formula_text": "max {\u03b1 T y=0, 0\u2264\u03b1\u2264C} min {K 0, K\u2212K0 2 F \u2264\u03b2} \u03b1 T e \u2212 1 2 Tr(K(Y \u03b1)(Y \u03b1) T )(2)", "formula_coordinates": [2.0, 169.56, 640.89, 334.52, 24.21]}, {"formula_id": "formula_2", "formula_text": "max {\u03b1 T y=0,0\u2264\u03b1\u2264C} min {K 0} \u03b1 T e \u2212 1 2 Tr(K(Y \u03b1)(Y \u03b1) T ) + \u03c1 K \u2212 K 0 2 F (3)", "formula_coordinates": [3.0, 163.56, 90.33, 340.52, 23.52]}, {"formula_id": "formula_3", "formula_text": "minimize K \u2212 (K 0 + 1 4\u03c1 (Y \u03b1)(Y \u03b1) T ) 2 F subject to K 0 in the variable K \u2208 S n", "formula_coordinates": [3.0, 108.0, 218.47, 286.58, 41.3]}, {"formula_id": "formula_4", "formula_text": "K 0 + (1/4\u03c1)(Y \u03b1)(Y \u03b1)", "formula_coordinates": [3.0, 335.16, 249.81, 98.8, 9.96]}, {"formula_id": "formula_5", "formula_text": "K * = (K 0 + (1/4\u03c1)(Y \u03b1)(Y \u03b1) T ) + (4)", "formula_coordinates": [3.0, 233.52, 276.05, 270.56, 11.8]}, {"formula_id": "formula_6", "formula_text": "max {\u03b1 T y=0, 0\u2264\u03b1\u2264C} \u03b1 T e \u2212 1 2 Tr(K * (Y \u03b1)(Y \u03b1) T ) + \u03c1 K * \u2212 K 0 2 F in the variable \u03b1 \u2208 R n , where (Y \u03b1)(Y \u03b1)", "formula_coordinates": [3.0, 108.0, 321.09, 329.06, 40.92]}, {"formula_id": "formula_7", "formula_text": "K 0 +(1/4\u03c1)(Y \u03b1)(Y \u03b1) T be V DV T ,", "formula_coordinates": [3.0, 357.36, 372.91, 146.61, 11.06]}, {"formula_id": "formula_8", "formula_text": "Tr(K * (Y \u03b1)(Y \u03b1) T ) = (Y \u03b1) T V D + V T (Y \u03b1) = n i=1 max 0, \u03bb i K 0 + 1 4\u03c1 (Y \u03b1)(Y \u03b1) T (\u03b1 T Y v i ) 2", "formula_coordinates": [3.0, 141.84, 400.37, 327.73, 45.48]}, {"formula_id": "formula_9", "formula_text": "maximize \u03b1 T e \u2212 1 2 i max(0, \u03bb i (K 0 + (Y \u03b1)(Y \u03b1) T /4\u03c1))(\u03b1 T Y v i ) 2 +\u03c1 i (max(0, \u03bb i (K 0 + (Y \u03b1)(Y \u03b1) T /4\u03c1))) 2 \u22122\u03c1 i Tr((v i v T i )K 0 )max(0, \u03bb i (K 0 + (Y \u03b1)(Y \u03b1) T /4\u03c1)) + \u03c1 Tr(K 0 K 0 ) subject to \u03b1 T y = 0, 0 \u2264 \u03b1 \u2264 C (5) in the variable \u03b1 \u2208 R n .", "formula_coordinates": [3.0, 108.0, 493.54, 396.08, 74.27]}, {"formula_id": "formula_10", "formula_text": "minimize Tr(K \u22121 (Y (e \u2212 \u03bb + \u00b5 + y\u03bd))(Y (e \u2212 \u03bb + \u00b5 + y\u03bd)) T )/2 + C\u00b5 T e + \u03c1 K \u2212 K 0 2 F subject to K 0, \u03bb, \u00b5 \u2265 0 (6)", "formula_coordinates": [3.0, 114.12, 654.89, 389.96, 37.51]}, {"formula_id": "formula_11", "formula_text": "\u03d5 \u01eb (f (x)) = max 0\u2264u\u22641 (uf (x) \u2212 \u01eb 2 u 2 ).", "formula_coordinates": [4.0, 235.44, 490.77, 141.13, 23.52]}, {"formula_id": "formula_12", "formula_text": "\u2202\u03bb i (X(\u03b1)) \u2202\u03b1 = v T i \u2202X(\u03b1) \u2202\u03b1 v i (7)", "formula_coordinates": [4.0, 250.92, 582.21, 253.16, 23.52]}, {"formula_id": "formula_13", "formula_text": "1. Compute \u03b1 i+1 = \u03b1 i + t\u2207f (\u03b1 i ).", "formula_coordinates": [5.0, 131.4, 146.97, 144.21, 10.4]}, {"formula_id": "formula_14", "formula_text": "let K i = (K 0 + (Y \u03b1 i )(Y \u03b1 i ) T /4\u03c1", "formula_coordinates": [5.0, 108.0, 298.41, 395.95, 21.44]}, {"formula_id": "formula_15", "formula_text": "\u03b1 i+1 = argmin y\u2208R n \u2212 m i=1 log(b i \u2212 a T i y)", "formula_coordinates": [5.0, 247.44, 525.07, 153.04, 30.58]}, {"formula_id": "formula_16", "formula_text": "A i+1 = A i \u222a {\u2207f (\u03b1 i+1 )(\u03b1 \u2212 \u03b1 i+1 ) \u2265 0} 3. If gap \u2264 \u01eb stop, otherwise go back to step 1.", "formula_coordinates": [5.0, 131.4, 597.09, 279.18, 29.88]}], "doi": ""}