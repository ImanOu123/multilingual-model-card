{"title": "Value Iteration Networks", "authors": "Aviv Tamar; Yi Wu; Garrett Thomas; Sergey Levine; Pieter Abbeel", "pub_date": "2017-03-20", "abstract": "We introduce the value iteration network (VIN): a fully differentiable neural network with a 'planning module' embedded within. VINs can learn to plan, and are suitable for predicting outcomes that involve planning-based reasoning, such as policies for reinforcement learning. Key to our approach is a novel differentiable approximation of the value-iteration algorithm, which can be represented as a convolutional neural network, and trained end-to-end using standard backpropagation. We evaluate VIN based policies on discrete and continuous path-planning domains, and on a natural-language based search task. We show that by learning an explicit planning computation, VIN policies generalize better to new, unseen domains. 1 In principle, with enough training data that covers all possible task configurations, and a rich enough policy representation, a reactive policy can learn to map each task to its optimal policy. In practice, this is often too expensive, and we offer a more data-efficient approach by exploiting a flexible prior about the planning computation underlying the behavior.", "sections": [{"heading": "Introduction", "text": "Over the last decade, deep convolutional neural networks (CNNs) have revolutionized supervised learning for tasks such as object recognition, action recognition, and semantic segmentation [3,15,6,19]. Recently, CNNs have been applied to reinforcement learning (RL) tasks with visual observations such as Atari games [21], robotic manipulation [18], and imitation learning (IL) [9]. In these tasks, a neural network (NN) is trained to represent a policy -a mapping from an observation of the system's state to an action, with the goal of representing a control strategy that has good long-term behavior, typically quantified as the minimization of a sequence of time-dependent costs.\nThe sequential nature of decision making in RL is inherently different than the one-step decisions in supervised learning, and in general requires some form of planning [2]. However, most recent deep RL works [21,18,9] employed NN architectures that are very similar to the standard networks used in supervised learning tasks, which typically consist of CNNs for feature extraction, and fully connected layers that map the features to a probability distribution over actions. Such networks are inherently reactive, and in particular, lack explicit planning computation. The success of reactive policies in sequential problems is due to the learning algorithm, which essentially trains a reactive policy to select actions that have good long-term consequences in its training domain.\nTo understand why planning can nevertheless be an important ingredient in a policy, consider the grid-world navigation task depicted in Figure 1 (left), in which the agent can observe a map of its domain, and is required to navigate between some obstacles to a target position. One hopes that after training a policy to solve several instances of this problem with different obstacle configurations, the policy would generalize to solve a different, unseen domain, as in Figure 1 (right). However, as we show in our experiments, while standard CNN-based networks can be easily trained to solve a set of such maps, they do not generalize well to new tasks outside this set, because they do not understand the goal-directed nature of the behavior. This observation suggests that the computation learned by reactive policies is different from planning, which is required to solve a new task 1 . Figure 1: Two instances of a grid-world domain. Task is to move to the goal between the obstacles.\nIn this work, we propose a NN-based policy that can effectively learn to plan. Our model, termed a value-iteration network (VIN), has a differentiable 'planning program' embedded within the NN structure.\nThe key to our approach is an observation that the classic value-iteration (VI) planning algorithm [1,2] may be represented by a specific type of CNN. By embedding such a VI network module inside a standard feed-forward classification network, we obtain a NN model that can learn the parameters of a planning computation that yields useful predictions. The VI block is differentiable, and the whole network can be trained using standard backpropagation. This makes our policy simple to train using standard RL and IL algorithms, and straightforward to integrate with NNs for perception and control.\nConnections between planning algorithms and recurrent NNs were previously explored by Ilin et al. [12]. Our work builds on related ideas, but results in a more broadly applicable policy representation. Our approach is different from model-based RL [25,4], which requires system identification to map the observations to a dynamics model, which is then solved for a policy. In many applications, including robotic manipulation and locomotion, accurate system identification is difficult, and modelling errors can severely degrade the policy performance. In such domains, a model-free approach is often preferred [18]. Since a VIN is just a NN policy, it can be trained model free, without requiring explicit system identification. In addition, the effects of modelling errors in VINs can be mitigated by training the network end-to-end, similarly to the methods in [13,11].\nWe demonstrate the effectiveness of VINs within standard RL and IL algorithms in various problems, among which require visual perception, continuous control, and also natural language based decision making in the WebNav challenge [23]. After training, the policy learns to map an observation to a planning computation relevant for the task, and generate action predictions based on the resulting plan. As we demonstrate, this leads to policies that generalize better to new, unseen, task instances.", "publication_ref": ["b2", "b14", "b5", "b18", "b20", "b17", "b8", "b1", "b20", "b17", "b8", "b0", "b0", "b1", "b11", "b24", "b3", "b17", "b12", "b10", "b22"], "figure_ref": [], "table_ref": []}, {"heading": "Background", "text": "In this section we provide background on planning, value iteration, CNNs, and policy representations for RL and IL. In the sequel, we shall show that CNNs can implement a particular form of planning computation similar to the value iteration algorithm, which can then be used as a policy for RL or IL.\nValue Iteration: A standard model for sequential decision making and planning is the Markov decision process (MDP) [1,2]. An MDP M consists of states s \u2208 S, actions a \u2208 A, a reward function R(s, a), and a transition kernel P (s |s, a) that encodes the probability of the next state given the current state and action. A policy \u03c0(a|s) prescribes an action distribution for each state. The goal in an MDP is to find a policy that obtains high rewards in the long term. Formally, the value V \u03c0 (s) of a state under policy \u03c0 is the expected discounted sum of rewards when starting from that state and executing policy \u03c0, V \u03c0 (s)\n.\n= E \u03c0 [ \u221e t=0 \u03b3 t r(s t , a t )| s 0 = s],\nwhere \u03b3 \u2208 (0, 1) is a discount factor, and E \u03c0 denotes an expectation over trajectories of states and actions (s 0 , a 0 , s 1 , a 1 . . . ), in which actions are selected according to \u03c0, and states evolve according to the transition kernel P (s |s, a). The optimal value function V * (s)\n.\n= max \u03c0 V \u03c0 (s) is the maximal long-term return possible from a state. A policy \u03c0 * is said to be optimal if V \u03c0 * (s) = V * (s) \u2200s. A popular algorithm for calculating V * and \u03c0 * is value iteration (VI):\nV n+1 (s) = max a Q n (s, a) \u2200s, where Q n (s, a) = R(s, a) + \u03b3 s P (s |s, a)V n (s ).\n(1) It is well known that the value function V n in VI converges as n \u2192 \u221e to V * , from which an optimal policy may be derived as \u03c0 * (s) = arg max a Q \u221e (s, a).\nConvolutional Neural Networks (CNNs) are NNs with a particular architecture that has proved useful for computer vision, among other domains [8,16,3,15]. A CNN is comprised of stacked convolution and max-pooling layers. The input to each convolution layer is a 3dimensional signal X, typically, an image with l channels, m horizontal pixels, and n vertical pixels, and its output h is a l -channel convolution of the image with kernels W 1 , . . . , W l , h l ,i ,j = \u03c3 l,i,j W l l,i,j X l,i \u2212i,j \u2212j , where \u03c3 is some scalar activation function. A max-pooling layer selects, for each channel l and pixel i, j in h, the maximum value among its neighbors N (i, j), h maxpool l,i,j = max i ,j \u2208N (i,j) h l,i ,j . Typically, the neighbors N (i, j) are chosen as a k \u00d7 k image patch around pixel i, j. After max-pooling, the image is down-sampled by a constant factor d, commonly 2 or 4, resulting in an output signal with l channels, m/d horizontal pixels, and n/d vertical pixels. CNNs are typically trained using stochastic gradient descent (SGD), with backpropagation for computing gradients. Reinforcement Learning and Imitation Learning: In MDPs where the state space is very large or continuous, or when the MDP transitions or rewards are not known in advance, planning algorithms cannot be applied. In these cases, a policy can be learned from either expert supervision -IL, or by trial and error -RL. While the learning algorithms in both cases are different, the policy representations -which are the focus of this work -are similar. Additionally, most state-of-the-art algorithms such as [24,21,26,18] are agnostic to the policy representation, and only require it to be differentiable, for performing gradient descent on some algorithm-specific loss function. Therefore, in this paper we do not commit to a specific learning algorithm, and only consider the policy. Let \u03c6(s) denote an observation for state s. The policy is specified as a parametrized function \u03c0 \u03b8 (a|\u03c6(s)) mapping observations to a probability over actions, where \u03b8 are the policy parameters. For example, the policy could be represented as a neural network, with \u03b8 denoting the network weights. The goal is to tune the parameters such that the policy behaves well in the sense that \u03c0 \u03b8 (a|\u03c6(s)) \u2248 \u03c0 * (a|\u03c6(s)), where \u03c0 * is the optimal policy for the MDP, as defined in Section 2. In IL, a dataset of N state observations and corresponding optimal actions \u03c6(s i ), a i \u223c \u03c0 * (\u03c6(s i )) i=1,...,N is generated by an expert. Learning a policy then becomes an instance of supervised learning [24,9]. In RL, the optimal action is not available, but instead, the agent can act in the world and observe the rewards and state transitions its actions effect. RL algorithms such as in [27,21,26,18] use these observations to improve the value of the policy.", "publication_ref": ["b0", "b1", "b7", "b15", "b2", "b14", "b23", "b20", "b25", "b17", "b23", "b8", "b26", "b20", "b25", "b17"], "figure_ref": [], "table_ref": []}, {"heading": "The Value Iteration Network Model", "text": "In this section we introduce a general policy representation that embeds an explicit planning module. As stated earlier, the motivation for such a representation is that a natural solution to many tasks, such as the path planning described above, involves planning on some model of the domain.\nLet M denote the MDP of the domain for which we design our policy \u03c0. We assume that there is some unknown MDPM such that the optimal plan inM contains useful information about the optimal policy in the original task M . However, we emphasize that we do not assume to knowM in advance. Our idea is to equip the policy with the ability to learn and solveM , and to add the solution ofM as an element in the policy \u03c0. We hypothesize that this will lead to a policy that automatically learns a usefulM to plan on. We denote bys \u2208S,\u0101 \u2208\u0100,R(s,\u0101), andP (s |s,\u0101) the states, actions, rewards, and transitions inM . To facilitate a connection between M andM , we letR andP depend on the observation in M , namely,R = f R (\u03c6(s)) andP = f P (\u03c6(s)), and we will later learn the functions f R and f P as a part of the policy learning process.\nFor example, in the grid-world domain described above, we can letM have the same state and action spaces as the true grid-world M . The reward function f R can map an image of the domain to a high reward at the goal, and negative reward near an obstacle, while f P can encode deterministic movements in the grid-world that do not depend on the observation. While these rewards and transitions are not necessarily the true rewards and transitions in the task, an optimal plan inM will still follow a trajectory that avoids obstacles and reaches the goal, similarly to the optimal plan in M .\nOnce an MDPM has been specified, any standard planning algorithm can be used to obtain the value functionV * . In the next section, we shall show that using a particular implementation of VI for planning has the advantage of being differentiable, and simple to implement within a NN framework. In this section however, we focus on how to use the planning resultV * within the NN policy \u03c0. Our approach is based on two important observations. The first is that the vector of valuesV * (s) \u2200s encodes all the information about the optimal plan inM . Thus, adding the vectorV * as additional features to the policy \u03c0 is sufficient for extracting information about the optimal plan inM .\nHowever, an additional property ofV * is that the optimal decision\u03c0 * (s) at a states can depend only on a subset of the values ofV * , since\u03c0 * (s) = arg max\u0101R(s,\u0101) + \u03b3 s P (s |s,\u0101)V * (s ). Therefore, if the MDP has a local connectivity structure, such as in the grid-world example above, the states for whichP (s |s,\u0101) > 0 is a small subset ofS.\nIn NN terminology, this is a form of attention [32], in the sense that for a given label prediction (action), only a subset of the input features (value function) is relevant. Attention is known to improve learning performance by reducing the effective number of network parameters during learning. Therefore, the second element in our network is an attention module that outputs a vector of (attention modulated) values \u03c8(s). Finally, the vector \u03c8(s) is added as additional features to a reactive policy \u03c0 re (a|\u03c6(s), \u03c8(s)). The full network architecture is depicted in Figure 2 (left).\nReturning to our grid-world example, at a particular state s, the reactive policy only needs to query the values of the states neighboring s in order to select the correct action. Thus, the attention module in this case could return a \u03c8(s) vector with a subset ofV * for these neighboring states. Let \u03b8 denote all the parameters of the policy, namely, the parameters of f R , f P , and \u03c0 re , and note that \u03c8(s) is in fact a function of \u03c6(s). Therefore, the policy can be written in the form \u03c0 \u03b8 (a|\u03c6(s)), similarly to the standard policy form (cf. Section 2). If we could back-propagate through this function, then potentially we could train the policy using standard RL and IL algorithms, just like any other standard policy representation. While it is easy to design functions f R and f P that are differentiable (and we provide several examples in our experiments), back-propagating the gradient through the planning algorithm is not trivial. In the following, we propose a novel interpretation of an approximate VI algorithm as a particular form of a CNN. This allows us to conveniently treat the planning module as just another NN, and by back-propagating through it, we can train the whole policy end-to-end.", "publication_ref": ["b31"], "figure_ref": [], "table_ref": []}, {"heading": "The VI Module", "text": "We now introduce the VI module -a NN that encodes a differentiable planning computation. Our starting point is the VI algorithm (1). Our main observation is that each iteration of VI may be seen as passing the previous value function V n and reward function R through a convolution layer and max-pooling layer. In this analogy, each channel in the convolution layer corresponds to the Q-function for a specific action, and convolution kernel weights correspond to the discounted transition probabilities. Thus by recurrently applying a convolution layer K times, K iterations of VI are effectively performed.\nFollowing this idea, we propose the VI network module, as depicted in Figure 2B. The inputs to the VI module is a 'reward image'R of dimensions l, m, n, where here, for the purpose of clarity, we follow the CNN formulation and explicitly assume that the state spaceS maps to a 2-dimensional grid. However, our approach can be extended to general discrete state spaces, for example, a graph, as we report in the WikiNav experiment in Section 4.4. The reward is fed into a convolutional layerQ with\u0100 channels and a linear activation function,Q\u0101 ,i ,j = l,i,j W\u0101 l,i,jR l,i \u2212i,j \u2212j . Each channel in this layer corresponds toQ(s,\u0101) for a particular action\u0101. This layer is then max-pooled along the actions channel to produce the next-iteration value function layerV ,V i,j = max\u0101Q(\u0101, i, j).\nThe next-iteration value function layerV is then stacked with the rewardR, and fed back into the convolutional layer and max-pooling layer K times, to perform K iterations of value iteration.\nThe VI module is simply a NN architecture that has the capability of performing an approximate VI computation. Nevertheless, representing VI in this form makes learning the MDP parameters and reward function natural -by backpropagating through the network, similarly to a standard CNN. VI modules can also be composed hierarchically, by treating the value of one VI module as additional input to another VI module. We further report on this idea in the supplementary material.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Value Iteration Networks", "text": "We now have all the ingredients for a differentiable planning-based policy, which we term a value iteration network (VIN). The VIN is based on the general planning-based policy defined above, with the VI module as the planning algorithm. In order to implement a VIN, one has to specify the state and action spaces for the planning moduleS and\u0100, the reward and transition functions f R and f P , and the attention function; we refer to this as the VIN design. For some tasks, as we show in our experiments, it is relatively straightforward to select a suitable design, while other tasks may require more thought. However, we emphasize an important point: the reward, transitions, and attention can be defined by parametric functions, and trained with the whole policy 2 . Thus, a rough design can be specified, and then fine-tuned by end-to-end training.\nOnce a VIN design is chosen, implementing the VIN is straightforward, as it is simply a form of a CNN. The networks in our experiments all required only several lines of Theano [28] code. In the next section, we evaluate VIN policies on various domains, showing that by learning to plan, they achieve a better generalization capability.", "publication_ref": ["b27"], "figure_ref": [], "table_ref": []}, {"heading": "Experiments", "text": "In this section we evaluate VINs as policy representations on various domains. Additional experiments investigating RL and hierarchical VINs, as well as technical implementation details are discussed in the supplementary material. Source code is available at https://github.com/avivt/VIN. Our goal in these experiments is to investigate the following questions:\n1. Can VINs effectively learn a planning computation using standard RL and IL algorithms?\n2. Does the planning computation learned by VINs make them better than reactive policies at generalizing to new domains?\nAn additional goal is to point out several ideas for designing VINs for various tasks. While this is not an exhaustive list that fits all domains, we hope that it will motivate creative designs in future work.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Grid-World Domain", "text": "Our first experiment domain is a synthetic grid-world with randomly placed obstacles, in which the observation includes the position of the agent, and also an image of the map of obstacles and goal position. Figure 3 shows two random instances of such a grid-world of size 16 \u00d7 16. We conjecture that by learning the optimal policy for several instances of this domain, a VIN policy would learn the planning computation required to solve a new, unseen, task.\nIn such a simple domain, an optimal policy can easily be calculated using exact VI. Note, however, that here we are interested in evaluating whether a NN policy, trained using RL or IL, can learn to plan. In the following results, policies were trained using IL, by standard supervised learning from demonstrations of the optimal policy. In the supplementary material, we report additional RL experiments that show similar findings. We design a VIN for this task following the guidelines described above, where the planning MDPM is a grid-world, similar to the true MDP. The reward mapping f R is a CNN mapping the image input to a reward map in the grid-world. Thus, f R should potentially learn to discriminate between obstacles, non-obstacles and the goal, and assign a suitable reward to each. The transitionsP were defined as 3 \u00d7 3 convolution kernels in the VI block, exploiting the fact that transitions in the grid-world are local 3 . The recurrence K was chosen in proportion to the grid-world size, to ensure that information can flow from the goal state to any other state. For the attention module, we chose a trivial approach that selects theQ values in the VI block for the current state, i.e., \u03c8(s) =Q(s, \u2022). The final reactive policy is a fully connected network that maps \u03c8(s) to a probability over actions. We compare VINs to the following NN reactive policies: CNN network: We devised a CNN-based reactive policy inspired by the recent impressive results of DQN [21], with 5 convolution layers, and a fully connected output. While the network in [21] was trained to predict Q values, our network outputs a probability over actions. These terms are related, since \u03c0 * (s) = arg max a Q(s, a). Fully Convolutional Network (FCN): The problem setting for this domain is similar to semantic segmentation [19], in which each pixel in the image is assigned a semantic label (the action in our case). We therefore devised an FCN inspired by a state-of-the-art semantic segmentation algorithm [19], with 3 convolution layers, where the first layer has a filter that spans the whole image, to properly convey information from the goal to every other state.\nIn Table 1 we present the average 0 \u2212 1 prediction loss of each model, evaluated on a held-out test-set of maps with random obstacles, goals, and initial states, for different problem sizes. In addition, for each map, a full trajectory from the initial state was predicted, by iteratively rolling-out the next-states  predicted by the network. A trajectory was said to succeed if it reached the goal without hitting obstacles. For each trajectory that succeeded, we also measured its difference in length from the optimal trajectory. The average difference and the average success rate are reported in Table 1.\nClearly, VIN policies generalize to domains outside the training set. A visualization of the reward mapping f R (see supplementary material) shows that it is negative at obstacles, positive at the goal, and a small negative constant otherwise. The resulting value function has a gradient pointing towards a direction to the goal around obstacles, thus a useful planning computation was learned. VINs also significantly outperform the reactive networks, and the performance gap increases dramatically with the problem size. Importantly, note that the prediction loss for the reactive policies is comparable to the VINs, although their success rate is significantly worse. This shows that this is not a standard case of overfitting/underfitting of the reactive policies. Rather, VIN policies, by their VI structure, focus prediction errors on less important parts of the trajectory, while reactive policies do not make this distinction, and learn the easily predictable parts of the trajectory yet fail on the complete task. The VINs have an effective depth of K, which is larger than the depth of the reactive policies. One may wonder, whether any deep enough network would learn to plan. In principle, a CNN or FCN of depth K has the potential to perform the same computation as a VIN. However, it has much more parameters, requiring much more training data. We evaluate this by untying the weights in the K recurrent layers in the VIN. Our results, reported in the supplementary material, show that untying the weights degrades performance, with a stronger effect for smaller sizes of training data.", "publication_ref": ["b2", "b20", "b20", "b18", "b18"], "figure_ref": ["fig_0"], "table_ref": ["tab_1", "tab_1"]}, {"heading": "Mars Rover Navigation", "text": "In this experiment we show that VINs can learn to plan from natural image input. We demonstrate this on path-planning from overhead terrain images of a Mars landscape. Each domain is represented by a 128 \u00d7 128 image patch, on which we defined a 16 \u00d7 16 grid-world, where each state was considered an obstacle if the terrain in its corresponding 8 \u00d7 8 image patch contained an elevation angle of 10 degrees or more, evaluated using an external elevation data base. An example of the domain and terrain image is depicted in Figure 3. The MDP for shortest-path planning in this case is similar to the grid-world domain of Section 4.1, and the VIN design was similar, only with a deeper CNN in the reward mapping f R for processing the image. The policy was trained to predict the shortest-path directly from the terrain image. We emphasize that the elevation data is not part of the input, and must be inferred (if needed) from the terrain image.\nAfter training, VIN achieved a success rate of 84.8%. To put this rate in context, we compare with the best performance achievable without access to the elevation data, which is 90.3%. To make this comparison, we trained a CNN to classify whether an 8 \u00d7 8 patch is an obstacle or not. This classifier was trained using the same image data as the VIN network, but its labels were the true obstacle classifications from the elevation map (we reiterate that the VIN did not have access to these ground-truth obstacle labels during training or testing). The success rate of planner that uses the obstacle map generated by this classifier from the raw image is 90.3%, showing that obstacle identification from the raw image is indeed challenging. Thus, the success rate of the VIN, which was trained without any obstacle labels, and had to 'figure out' the planning process is quite remarkable.", "publication_ref": [], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "Continuous Control", "text": "Network Consider the domain in Figure 4. A red-colored particle needs to be navigated to a green goal using horizontal and vertical forces. Gray-colored obstacles are randomly positioned in the domain, and apply an elastic force and friction when contacted. This domain presents a non-trivial control problem, as the agent needs to both plan a feasible trajectory between the obstacles (or use them to bounce off), but also control the particle (which has mass and inertia) to follow it. The state observation consists of the particle's continuous position and velocity, and a static 16 \u00d7 16 downscaled image of the obstacles and goal position in the domain. In principle, such an observation is sufficient to devise a 'rough plan' for the particle to follow. As in our previous experiments, we investigate whether a policy trained on several instances of this domain with different start state, goal, and obstacle positions, would generalize to an unseen domain.\nFor training we chose the guided policy search (GPS) algorithm with unknown dynamics [17], which is suitable for learning policies for continuous dynamics with contacts, and we used the publicly available GPS code [7], and Mujoco [30] for physical simulation. We generated 200 random training instances, and evaluate our performance on 40 different test instances from the same distribution.\nOur VIN design is similar to the grid-world cases, with some important modifications: the attention module selects a 5 \u00d7 5 patch of the valueV , centered around the current (discretized) position in the map. The final reactive policy is a 3-layer fully connected network, with a 2-dimensional continuous output for the controls. In addition, due to the limited number of training domains, we pre-trained the VIN with transition weights that correspond to discounted grid-world transitions. This is a reasonable prior for the weights in a 2-d task, and we emphasize that even with this initialization, the initial value function is meaningless, since the reward map f R is not yet learned. We compare with a CNN-based reactive policy inspired by the state-of-the-art results in [21,20], with 2 CNN layers for image processing, followed by a 3-layer fully connected network similar to the VIN reactive policy. Figure 4 shows the performance of the trained policies, measured as the final distance to the target. The VIN clearly outperforms the CNN on test domains. We also plot several trajectories of both policies on test domains, showing that VIN learned a more sensible generalization of the task.", "publication_ref": ["b16", "b6", "b29", "b20", "b19"], "figure_ref": [], "table_ref": []}, {"heading": "WebNav Challenge", "text": "In the previous experiments, the planning aspect of the task corresponded to 2D navigation. We now consider a more general domain: WebNav [23] -a language based search task on a graph.\nIn WebNav [23], the agent needs to navigate the links of a website towards a goal web-page, specified by a short 4-sentence query. At each state s (web-page), the agent can observe average wordembedding features of the state \u03c6(s) and possible next states \u03c6(s ) (linked pages), and the features of the query \u03c6(q), and based on that has to select which link to follow. In [23], the search was performed on the Wikipedia website. Here, we report experiments on the 'Wikipedia for Schools' website, a simplified Wikipedia designed for children, with over 6000 pages and at most 292 links per page.\nIn [23], a NN-based policy was proposed, which first learns a NN mapping from (\u03c6(s), \u03c6(q)) to a hidden state vector h. The action is then selected according to \u03c0(s |\u03c6(s), \u03c6(q)) \u221d exp h \u03c6(s ) . In essence, this policy is reactive, and relies on the word embedding features at each state to contain meaningful information about the path to the goal. Indeed, this property naturally holds for an encyclopedic website that is structured as a tree of categories, sub-categories, sub-sub-categories, etc. We sought to explore whether planning, based on a VIN, can lead to better performance in this task, with the intuition that a plan on a simplified model of the website can help guide the reactive policy in difficult queries. Therefore, we designed a VIN that plans on a small subset of the graph that contains only the 1st and 2nd level categories (< 3% of the graph), and their word-embedding features.\nDesigning this VIN requires a different approach from the grid-world VINs described earlier, where the most challenging aspect is to define a meaningful mapping between nodes in the true graph and nodes in the smaller VIN graph. For the reward mapping f R , we chose a weighted similarity measure between the query features \u03c6(q), and the features of nodes in the small graph \u03c6(s). Thus, intuitively, nodes that are similar to the query should have high reward. The transitions were fixed based on the graph connectivity of the smaller VIN graph, which is known, though different from the true graph.\nThe attention module was also based on a weighted similarity measure between the features of the possible next states \u03c6(s ) and the features of each node in the simplified graph \u03c6(s). The reactive policy part of the VIN was similar to the policy of [23] described above. Note that by training such a VIN end-to-end, we are effectively learning how to exploit the small graph for doing better planning on the true, large graph. Both the VIN policy and the baseline reactive policy were trained by supervised learning, on random trajectories that start from the root node of the graph. Similarly to [23], a policy is said to succeed a query if all the correct predictions along the path are within its top-4 predictions.\nAfter training, the VIN policy performed mildly better than the baseline on 2000 held-out test queries when starting from the root node, achieving 1030 successful runs vs. 1025 for the baseline. However, when we tested the policies on a harder task of starting from a random position in the graph, VINs significantly outperformed the baseline, achieving 346 successful runs vs. 304 for the baseline, out of 4000 test queries. These results confirm that indeed, when navigating a tree of categories from the root up, the features at each state contain meaningful information about the path to the goal, making a reactive policy sufficient. However, when starting the navigation from a different state, a reactive policy may fail to understand that it needs to first go back to the root and switch to a different branch in the tree. Our results indicate such a strategy can be better represented by a VIN. We remark that there is still room for further improvements of the WebNav results, e.g., by better models for reward and attention functions, and better word-embedding representations of text.", "publication_ref": ["b22", "b22", "b22", "b22", "b22"], "figure_ref": [], "table_ref": []}, {"heading": "Conclusion and Outlook", "text": "The introduction of powerful and scalable RL methods has opened up a range of new problems for deep learning. However, few recent works investigate policy architectures that are specifically tailored for planning under uncertainty, and current RL theory and benchmarks rarely investigate the generalization properties of a trained policy [27,21,5]. This work takes a step in this direction, by exploring better generalizing policy representations.\nOur VIN policies learn an approximate planning computation relevant for solving the task, and we have shown that such a computation leads to better generalization in a diverse set of tasks, ranging from simple gridworlds that are amenable to value iteration, to continuous control, and even to navigation of Wikipedia links. In future work we intend to learn different planning computations, based on simulation [10], or optimal linear control [31], and combine them with reactive policies, to potentially develop RL solutions for task and motion planning [14].", "publication_ref": ["b26", "b20", "b4", "b9", "b30", "b13"], "figure_ref": [], "table_ref": []}, {"heading": "A Visualization of Learned Reward and Value", "text": "In Figure 5 we plot the learned reward and value function for the gridworld task. The learned reward is very negative at obstacles, very positive at goal, and a slightly negative constant otherwise. The resulting value function has a peak at the goal, and a gradient pointing towards a direction to the goal around obstacles. This plot clearly shows that the VI block learned a useful planning computation. ", "publication_ref": [], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "B Weight Sharing", "text": "The VINs have an effective depth of K, which is larger than the depth of the reactive policies. One may wonder, whether any deep enough network would learn to plan. In principle, a CNN or FCN of depth K has the potential to perform the same computation as a VIN. However, it has much more parameters, requiring much more training data. We evaluate this by untying the weights in the K recurrent layers in the VIN. Our results, in ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "C Gridworld with Reinforcement Learning", "text": "We demonstrate that the value iteration network can be trained using reinforcement learning methods and achieves favorable generalization properties as compared to standard convolutional neural networks (CNNs). The overall setup of the experiment is as follows: we train policies parameterized by VINs and policies parameterized by convolutional networks on the same set of randomly generated gridworld maps in the same way (described below) and then test their performance on a held-out set of test maps, which was generated in the same way as the set of training maps but is disjoint from the training set.\nThe MDP is what one would expect of a gridworld environment -the states are the positions on the map; the actions are movements up, down, left, and right; the rewards are +1 for reaching the goal, \u22121 for falling into a hole, and \u22120.01 otherwise (to encourage the policy to find the shortest path); the transitions are deterministic.\nStructure of the networks. The VINs used are similar to those described in the main body of the paper. After K value-iteration recurrences, we have approximate Q values for every state and action in the map. The attention selects only those for the current state, and these are converted to a  probability distribution over actions using the softmax function. We use K = 10 for the 8 \u00d7 8 maps and K = 20 for the 16 \u00d7 16 maps. The convolutional networks' structure was adapted to accommodate the size of the maps. For the 8\u00d78 maps, we use 50 filters in the first layer and then 100 filters in the second layer, all of size 3 \u00d7 3. Each of these layers is followed by a 2 \u00d7 2 max-pool. At the end we have a fully connected hidden layer with 100 hidden units, followed by a fully-connected layer to the (4) outputs, which are converted to probabilities using the softmax function.\nThe network for the 16 \u00d7 16 maps is similar but uses three convolutional layers (with 50, 100, and 100 filters respectively), the first two of which are 2 \u00d7 2 max-pooled, followed by two fully-connected hidden layers (200 and 100 hidden units respectively) before connecting to the outputs and performing softmax.\nTraining with a curriculum. To ensure that the policies are not simply memorizing specific maps, we randomly select a map before each episode. But some maps are far more difficult than others, and the agent learns best when it stands a reasonable chance of reaching this goal. Thus we found it beneficial to begin training on the easiest maps and then gradually progress to more difficult maps. This is the idea of curriculum training.\nWe consider curriculum training as a way to address the exploration problem. If a completely untrained agent is dropped into a very challenging map, it moves randomly and stands approximately zero chance of reaching the goal (and thus learning a useful reward). But even a random policy can consistently reach goals nearby and learn something useful in the process, e.g. to move toward the goal. Once the policy knows how to solve tasks of difficulty n, it can more easily learn to solve tasks of difficulty n + 1, as compared to a completely untrained policy. This strategy is well-aligned with how formal education is structured; you can't effectively learn calculus without knowing basic algebra. Not all environments have an obvious difficulty metric, but fortunately the gridworld task does. We define the difficulty of a map as the length of the shortest path from the start state to the goal state.\nIt is natural to start with difficulty 1 (the start state and goal state are adjacent) and ramp up the difficulty by one level once a certain threshold of \"success\" is reached. In our experiments we use the average discounted return to assess progress and increase the difficulty level from n to n + 1 when the average discounted return for an iteration exceeds 1 \u2212 n 35 . This rule was chosen empirically and takes into account the fact that higher difficulty levels are more difficult to learn. All networks were trained using the trust region policy optimization (TRPO) [26] algorithm, using publicly available code in the RLLab benchmark [5]. Testing. When testing, we ignore the exact rewards and measure simply whether or not the agent reaches the goal. For each map in the test set, we run an episode, noting if the policy succeeds in reaching the goal. The proportion of successful trials out of all the trials is reported for each network. (See Table 3.) On the 8 \u00d7 8 maps, we used the same number of training iterations on both types of networks to make the comparison as fair as possible. On the 16 \u00d7 16 maps, it became clear that the convolutional network was struggling, so we allowed it twice as many training iterations as the VIN, yet it still failed to achieve even a remotely similar level of performance on the test maps. (See left image of Figure 6.) We posit that this is because the VIN learns to plan, while the CNN simply follows a reactive policy. Though the CNN policy performs reasonably well on the smaller domains, it does not scale to larger domains, while the VIN does. (See right image of Figure 6.)", "publication_ref": ["b25", "b4"], "figure_ref": ["fig_2", "fig_2"], "table_ref": ["tab_5"]}, {"heading": "D Technical Details for Experiments", "text": "We report the full technical details used for training our networks. ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "D.1 Grid-world Domain", "text": "Our training set consists of N i = 5000 random grid-world instances, with N t = 7 shortest-path trajectories (calculated using an optimal planning algorithm) from a random start-state to a random goal-state for each instance; a total of N i \u00d7 N t trajectories. For each state s = (i, j) in each trajectory, we produce a (2 \u00d7 m \u00d7 n)-sized observation image s image . The first channel of s image encodes the obstacle presence (1 for obstacle, 0 otherwise), while the second channel encodes the goal position (1 at the goal, 0 otherwise). The full observation vector is \u03c6(s) = [s, s image ]. In addition, for each state we produce a label a that encodes the action (one of 8 directions) that an optimal shortest-path policy would take in that state. We design a VIN for this task as follows. The state spaceS was chosen to be a m \u00d7 n grid-world, similar to the true state space S. 4 The rewardR in this space can be represented by an m \u00d7 n map, and we chose the reward mapping f R to be a CNN with s image as its input, one layer with 150 kernels of size 3 \u00d7 3, and a second layer with one 3 \u00d7 3 filter to outputR. Thus, f R maps the image of obstacles and goal to a 'reward image'. The transitionsP were defined as 3 \u00d7 3 convolution kernels in the VI block, and exploit the fact that transitions in the grid-world are local. Note that the transitions defined this way do not depend on the states. Interestingly, we shall see that the network learned rewards and transitions that nevertheless enable it to successfully plan in this task. For the attention module, since there is a one-to-one mapping between the agent position in S and inS, we chose a trivial approach that selects theQ values in the VI block for the state in the real MDP s, i.e., \u03c8(s) =Q(s, \u2022). The final reactive policy is a fully connected softmax output layer with weights W , \u03c0 re (\u2022|\u03c8(s)) \u221d exp W \u03c8(s) . We trained several neural-network policies based on a multi-class logistic regression loss function using stochastic gradient descent, with an RMSProp step size [29], implemented in the Theano [28] library. We compare the policies:\nVIN network We used the VIN model of Section 3 as described above, with 10 channels for the q layer in the VI block. The recurrence K was set relative to the problem size: K = 10 for 8 \u00d7 8 domains, K = 20 for 16 \u00d7 16 domains, and K = 36 for 28 \u00d7 28 domains. The guideline for choosing these values was to keep the network small while guaranteeing that goal information can flow to every state in the map. CNN network: We devised a CNN-based reactive policy inspired by the recent impressive results of DQN [21], with 5 convolution layers with [50, 50, 100, 100, 100] kernels of size 3 \u00d7 3, and 2 \u00d7 2 max-pooling after the first and third layers. The final layer is fully connected, and maps to a softmax over actions. To represent the current state, we added to s image a channel that encodes the current position (1 at the current state, 0 otherwise).", "publication_ref": ["b3", "b28", "b27", "b20"], "figure_ref": [], "table_ref": []}, {"heading": "Fully Convolutional Network (FCN):", "text": "The problem setting for this domain is similar to semantic segmentation [19], in which each pixel in the image is assigned a semantic label (the action in our case). We therefore devised an FCN inspired by a state-of-the-art semantic segmentation algorithm [19], with 3 convolution layers, where the first layer has a filter that spans the whole image, to properly convey information from the goal to every other state. The first convolution layer has 150 filters of size (2m \u2212 1) \u00d7 (2n \u2212 1), which span the whole image and can convey information about the goal to every pixel. The second layer has 150 filters of size 1 \u00d7 1, and the third layer has 10 filters of size 1 \u00d7 1, to produce an output sized 10 \u00d7 m \u00d7 n, similarly to theQ layer in our VIN. Similarly to the attention mechanism in the VIN, the values that correspond to the current state (pixel) are passed to a fully connected softmax output layer.", "publication_ref": ["b18", "b18"], "figure_ref": [], "table_ref": []}, {"heading": "D.2 Mars Domain", "text": "We consider the problem of autonomously navigating the surface of Mars by a rover such as the Mars Science Laboratory (MSL) (Lockwood, 2006) over long-distance trajectories. The MSL has a limited ability for climbing high-degree slopes, and its path-planning algorithm should therefore avoid navigating into high-slope areas. In our experiment, we plan trajectories that avoid slopes of 10 degrees or more, using overhead terrain images from the High Resolution Imaging Science Experiment (HiRISE) (McEwen et al., 2007). The HiRISE data consists of grayscale images of the Mars terrain, and matching elevation data, accurate to tens of centimeters. We used an image of a 33.3km by 6.3km area at 49.96 degrees latitude and 219.2 degrees longitude, with a 10.5 sq. meters / pixel resolution. Each domain is a 128 \u00d7 128 image patch, on which we defined a 16 \u00d7 16 grid-world, where each state was considered an obstacle if its corresponding 8 \u00d7 8 image patch contained an angle of 10 degrees or more, evaluated using an additional elevation data. An example of the domain and terrain image is depicted in Figure 3. The MDP for shortest-path planning in this case is similar to the grid-world domain of Section 4.1, and the VIN design was similar, only with a deeper CNN in the reward mapping f R for processing the image. Our goal is to train a network that predicts the shortest-path trajectory directly from the terrain image data. We emphasize that the ground-truth elevation data is not part of the input, and the elevation therefore must be inferred (if needed) from the terrain image itself. Our VIN design follows the model of Section 4.1. In this case, however, instead of feeding in the obstacle map, we feed in the raw terrain image, and accordingly modify the reward mapping f R with 2 additional CNN layers for processing the image: the first with 6 kernels of size 5 \u00d7 5 and 4 \u00d7 4 max-pooling, and the second with a 12 kernels of size 3 \u00d7 3 and 2 \u00d7 2 max-pooling. The resulting 12 \u00d7 m \u00d7 n tensor is concatenated with the goal image, and passed to a third layer with 150 kernels of size 3 \u00d7 3 and a fourth layer with one 3 \u00d7 3 filter to outputR. The state inputs and output labels remain as in the grid-world experiments. We emphasize that the whole network is trained end-to-end, without pre-training the input filters. In Table 4 we present our results for training a m = n = 16 map from a 10K image-patch dataset, with 7 random trajectories per patch, evaluated on a held-out test set of 1K patches. Figure 3 shows an instance of the input image, the obstacles, the shortest-path trajectory, and the trajectory predicted by our method. To put the 84.8% success rate in context, we compare with the best performance achievable without access to the elevation data. To make this comparison, we trained a CNN to classify whether an 8 \u00d7 8 patch is an obstacle or not. This classifier was trained using the same image data as the VIN network, but its labels were the true obstacle classifications from the elevation map (we reiterate that the VIN network did not have access to these ground-truth obstacle classification labels during training or testing). Training this classifier is a standard binary classification problem, and its performance represents the best obstacle identification possible with our CNN in this domain. The best-achievable shortest-path prediction is then defined as the shortest path in an obstacle map generated by this classifier from the raw image. The results of this optimal predictor are reported in Table 1. The 90.3% success rate shows that obstacle identification from the raw image is indeed challenging. Thus, the success rate of the VIN network, which was trained without any obstacle labels, and had to 'figure out' the planning process is quite remarkable.", "publication_ref": [], "figure_ref": ["fig_0", "fig_0"], "table_ref": ["tab_1"]}, {"heading": "D.3 Continuous Control", "text": "For training we chose the guided policy search (GPS) algorithm with unknown dynamics [17], which is suitable for learning policies for continuous dynamics with contacts, and we used the publicly available GPS code [7], and Mujoco [30] for physical simulation. GPS works by learning timevarying iLQG controllers for each domain, and then fitting the controllers to a single NN policy using Pred. Succ.  4: Performance of VINs on the Mars domain. For comparison, the performance of a planner that used obstacle predictions trained from labeled obstacle data is shown. This upper bound on performance demonstrates the difficulty in identifying obstacles from the raw image data. Remarkably, the VIN achieved close performance without access to any labeled data about the obstacles. supervised learning. This process is repeated for several iterations, and a special cost function is used to enforce an agreement between the trajectory distribution of the iLQG and NN controllers. We refer to [17,7] for the full algorithm details. For our task, we ran 10 iterations of iLQG, with the cost being a quadratic distance to the goal, followed by one iteration of NN policy fitting. This allows us to cleanly compare VINs to other policies without GPS-specific effects. Our VIN design is similar to the grid-world cases: the state spaceS is a 16 \u00d7 16 grid-world, and the transitionsP are 3 \u00d7 3 convolution kernels in the VI block, similar to the grid-world of Section 4.1. However, we made some important modifications: the attention module selects a 5 \u00d7 5 patch of the valueV , centered around the current (discretized) position in the map. The final reactive policy is a 3-layer fully connected network, with a 2-dimensional continuous output for the controls. In addition, due to the limited number of training domains, we pre-trained the VIN with transition weights that correspond to discounted grid-world transitions (for example, the transitions for an action to go north-west would be \u03b3 in the top left corner and zeros otherwise), before training end-to-end. This is a reasonable prior for the weights in a 2-d task, and we emphasize that even with this initialization, the initial value function is meaningless, since the reward map f R is not yet learned. The reward mapping f R is a CNN with s image as its input, one layer with 150 kernels of size 3 \u00d7 3, and a second layer with one 3 \u00d7 3 filter to outputR.", "publication_ref": ["b16", "b6", "b29", "b16", "b6"], "figure_ref": [], "table_ref": []}, {"heading": "D.4 WebNav", "text": "\"WebNav\" [23] is a recently proposed goal-driven web navigation benchmark. In WebNav, web pages and links from some website form a directed graph G(S, E). The agent is presented with a query text, which consists of N q sentences from a target page at most N h hops away from the starting page. The goal for the agent is to navigate to that target page from the starting page via clicking at most N n links per page. Here, we choose N h = N q = N n = 4. In [23], the agent receives a reward of 1 when reaching the target page via any path no longer than 10 hops. For evaluation convenience, in our experiment, the agent can receive a reward only if it reaches the destination via the shortest path, which makes the task much harder. We measure the top-1 and top-4 prediction accuracy as well as the average reward for the baseline [23] and our VIN model. For every page s, the valid transitions are A s = {s : (s, s ) \u2208 E}. For every web page s and every query text q, we utilize the bag-of-words model with pretrained word embedding provided by [23] to produce feature vectors \u03c6(s) and \u03c6(q). The agent should choose at most N n valid actions from A s = {s : (s, s ) \u2208 E} based on the current s and q. The baseline method of [23] uses a single tanh-layer neural net parametrized by W to compute a hidden vector h: h(s, q) = tanh W \u03c6(s) \u03c6(q) . The final baseline policy is computed via \u03c0 bsl (s |s, q) \u221d exp h(s, q) \u03c6(s ) for s \u2208 A s . We design a VIN for this task as follows. We firstly selected a smaller website as the approximate graph\u1e20(S,\u0112), and chooseS as the states in VI. For query q and a pages inS, we compute the   . Finally, we combine the VI module and the baseline method as our VIN model by simply adding the outputs from these two networks together. In addition to the experiments reported in the main text, we performed experiments on the full wikipedia, using 'wikipedia for schools' as the graph for VIN planning. We report our preliminary results here. We use the whole WikiSchool website as our approximate graph and set K = 4. In VIN, to accelerate training, we firstly only train the VI module with K = 0. Then, we fixR obtained in the K = 0 case and jointly train the whole model with K = 4. The results are shown in Tab. 5 VIN achieves 1.5% better prediction accuracy than the baseline. Interestingly, with only 1.5% prediction accuracy enhancement, VIN achieves 2.5% better success rate than the baseline: note that the agent can only success when making 4 consecutive correct predictions. This indicates the VI does provide useful high-level planning information.", "publication_ref": ["b22", "b22", "b22", "b22", "b22"], "figure_ref": [], "table_ref": []}, {"heading": "D.5 Additional Technical Comments", "text": "Runtime: For the 2D domains, different samples from the same domain share the same VI computation, since they have the same observation. Therefore, a single VI computation is required for samples from the same domain. Using this, and GPU code (Theano), VINs are not much slower than the baselines. For the language task, however, since Theano doesn't support convolutions on graphs nor sparse operations on GPU, VINs were considerably slower in our implementation.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "E Hierarchical VI Modules", "text": "The number of VI iterations K required in the VIN depends on the problem size. Consider, for example, a grid-world in which the goal is located L steps away from some state s. Then, at least L iterations of VI are required to convey the reward information from the goal to state s, and clearly, any action prediction obtained with less than L VI iterations at state s is unaware of the goal location, and therefore unacceptable.\nTo convey reward information faster in VI, and reduce the effective K, we propose to perform VI at multiple levels of resolution. We term this model a hierarchical VI Network (HVIN), due to its similarity with hierarchical planning algorithms. In a HVIN, a copy of the input down-sampled by a factor of d is first fed into a VI module termed the high-level VI module. The down-sampling offers a d\u00d7 speedup of information transmission in the map, at the price of reduced accuracy. The value layer of the high-level VI module is then up-sampled, and added as an additional input channel to the input of the standard VI module. Thus, the high-level VI module learns a mapping from down-sampled image features to a suitable reward-shaping for the nominal VI module. The full HVIN model is depicted in Figure 7. This model can easily be extended to include multiple levels of hierarchy. Table 6 shows the performance of the HVIN module in the grid-world task, compared to the VIN results reported in the main text. We used a 2 \u00d7 2 down-sampling layer. Similarly to the standard VIN, 3 \u00d7 3 convolution kernels, 150 channels for each hidden layer H (for both the down-sampled image, and standard image), and 10 channels for the q layer in each VI block. Similarly to the VIN networks, the recurrence K was set relative to the problem size, taking into account the downsampling factor: K = 4 for 8 \u00d7 8 domains, K = 10 for 16 \u00d7 16 domains, and K = 16 for 28 \u00d7 28 domains (in comparison, the respective K values for standard VINs were 10, 20, and 36). The HVINs demonstrated better performance for the larger 28 \u00d7 28 map, which we attribute to the improved information transmission in the hierarchical VI module.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Acknowledgments", "text": "This research was funded in part by Siemens, by ONR through a PECASE award, by the Army Research Office through the MAST program, and by an NSF CAREER award (#1351028). A. T. was partially funded by the Viterbi Scholarship, Technion. Y. W. was partially funded by a DARPA PPAML program, contract FA8750-14-C-0011.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Dynamic Programming", "journal": "Princeton University Press", "year": "1957", "authors": "R Bellman"}, {"ref_id": "b1", "title": "", "journal": "D. Bertsekas. Dynamic Programming and Optimal Control", "year": "2012", "authors": ""}, {"ref_id": "b2", "title": "Multi-column deep neural networks for image classification", "journal": "", "year": "2012", "authors": "D Ciresan; U Meier; J Schmidhuber"}, {"ref_id": "b3", "title": "Pilco: A model-based and data-efficient approach to policy search", "journal": "", "year": "2011", "authors": "M Deisenroth; C E Rasmussen"}, {"ref_id": "b4", "title": "Benchmarking deep reinforcement learning for continuous control", "journal": "", "year": "2016", "authors": "Y Duan; X Chen; R Houthooft; J Schulman; P Abbeel"}, {"ref_id": "b5", "title": "Learning hierarchical features for scene labeling", "journal": "IEEE Transactions on Pattern Analysis and Machine Intelligence", "year": "2013", "authors": "C Farabet; C Couprie; L Najman; Y Lecun"}, {"ref_id": "b6", "title": "Guided policy search code implementation", "journal": "", "year": "2016", "authors": "C Finn; M Zhang; J Fu; X Tan; Z Mccarthy; E Scharff; S Levine"}, {"ref_id": "b7", "title": "Neural network model for a mechanism of pattern recognition unaffected by shift in position-neocognitron. Transactions of the IECE", "journal": "", "year": "1979", "authors": "K Fukushima"}, {"ref_id": "b8", "title": "A machine learning approach to visual perception of forest trails for mobile robots", "journal": "IEEE Robotics and Automation Letters", "year": "2016", "authors": "A Giusti"}, {"ref_id": "b9", "title": "Deep learning for real-time atari game play using offline monte-carlo tree search planning", "journal": "", "year": "2014", "authors": "X Guo; S Singh; H Lee; R L Lewis; X Wang"}, {"ref_id": "b10", "title": "Deep learning for reward design to improve monte carlo tree search in atari games", "journal": "", "year": "2016", "authors": "X Guo; S Singh; R Lewis; H Lee"}, {"ref_id": "b11", "title": "Efficient learning in cellular simultaneous recurrent neural networks-the case of maze navigation problem", "journal": "", "year": "2007", "authors": "R Ilin; R Kozma; P J Werbos"}, {"ref_id": "b12", "title": "Reinforcement learning with misspecified model classes", "journal": "", "year": "2013", "authors": "J Joseph; A Geramifard; J W Roberts; J P How; N Roy"}, {"ref_id": "b13", "title": "Hierarchical task and motion planning in the now", "journal": "", "year": "2011", "authors": "L P Kaelbling; T Lozano-P\u00e9rez"}, {"ref_id": "b14", "title": "Imagenet classification with deep convolutional neural networks", "journal": "", "year": "2012", "authors": "A Krizhevsky; I Sutskever; G Hinton"}, {"ref_id": "b15", "title": "Gradient-based learning applied to document recognition", "journal": "Proceedings of the IEEE", "year": "1998", "authors": "Y Lecun; L Bottou; Y Bengio; P Haffner"}, {"ref_id": "b16", "title": "Learning neural network policies with guided policy search under unknown dynamics", "journal": "", "year": "2014", "authors": "S Levine; P "}, {"ref_id": "b17", "title": "End-to-end training of deep visuomotor policies", "journal": "JMLR", "year": "2016", "authors": "S Levine; C Finn; T Darrell; P Abbeel"}, {"ref_id": "b18", "title": "Fully convolutional networks for semantic segmentation", "journal": "", "year": "2015", "authors": "J Long; E Shelhamer; T Darrell"}, {"ref_id": "b19", "title": "Asynchronous methods for deep reinforcement learning", "journal": "", "year": "2016", "authors": "V Mnih; A P Badia; M Mirza; A Graves; T Lillicrap; T Harley; D Silver; K Kavukcuoglu"}, {"ref_id": "b20", "title": "Human-level control through deep reinforcement learning", "journal": "Nature", "year": "2015", "authors": "V Mnih; K Kavukcuoglu; D Silver; A Rusu; J Veness; M Bellemare; A Graves; M Riedmiller; A Fidjeland; G Ostrovski"}, {"ref_id": "b21", "title": "Apprenticeship learning using inverse reinforcement learning and gradient methods", "journal": "", "year": "2007", "authors": "G Neu; C Szepesv\u00e1ri"}, {"ref_id": "b22", "title": "Webnav: A new large-scale task for natural language based sequential decision making", "journal": "", "year": "2016", "authors": "R Nogueira; K Cho"}, {"ref_id": "b23", "title": "A reduction of imitation learning and structured prediction to no-regret online learning", "journal": "", "year": "2011", "authors": "S Ross; G Gordon; A Bagnell"}, {"ref_id": "b24", "title": "An on-line algorithm for dynamic reinforcement learning and planning in reactive environments", "journal": "IEEE", "year": "1990", "authors": "J Schmidhuber"}, {"ref_id": "b25", "title": "Trust region policy optimization", "journal": "", "year": "2015", "authors": "J Schulman; S Levine; P Abbeel; M Jordan; P Moritz"}, {"ref_id": "b26", "title": "Reinforcement learning: An introduction", "journal": "MIT press", "year": "1998", "authors": "R S Sutton; A G Barto"}, {"ref_id": "b27", "title": "Theano Development Team. Theano: A Python framework for fast computation of mathematical expressions. arXiv e-prints", "journal": "", "year": "2016-05", "authors": ""}, {"ref_id": "b28", "title": "Lecture 6.5. COURSERA: Neural Networks for Machine Learning", "journal": "", "year": "2012", "authors": "T Tieleman; G Hinton"}, {"ref_id": "b29", "title": "Mujoco: A physics engine for model-based control", "journal": "IEEE", "year": "2012", "authors": "E Todorov; T Erez; Y Tassa"}, {"ref_id": "b30", "title": "Embed to control: A locally linear latent dynamics model for control from raw images", "journal": "", "year": "2015", "authors": "M Watter; J Springenberg; J Boedecker; M Riedmiller"}, {"ref_id": "b31", "title": "Show, attend and tell: Neural image caption generation with visual attention", "journal": "", "year": "2015", "authors": "K Xu; J Ba; R Kiros; K Cho; A Courville; R Salakhudinov; R Zemel; Y Bengio"}], "figures": [{"figure_label": "3", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 3 :3Figure3: Grid-world domains (best viewed in color). A,B: Two random instances of the 28 \u00d7 28 synthetic gridworld, with the VIN-predicted trajectories and ground-truth shortest paths between random start and goal positions. C: An image of the Mars domain, with points of elevation sharper than 10 \u2022 colored in red. These points were calculated from a matching image of elevation data (not shown), and were not available to the learning algorithm. Note the difficulty of distinguishing between obstacles and non-obstacles. D: The VIN-predicted (purple line with cross markers), and the shortest-path ground truth (blue line) trajectories between between random start and goal positions.", "figure_data": ""}, {"figure_label": "5", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 5 :5Figure 5: Visualization of learned reward and value function. Left: a sample domain. Center: learned reward f R for this domain. Right: resulting value function (in VI block) for this domain.", "figure_data": ""}, {"figure_label": "6", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Figure 6 :6Figure 6: RL results -performance of VIN and CNN on 16 \u00d7 16 test maps. Left: Performance on all maps as a function of amount of training. Right: Success rate on test maps of increasing difficulty.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "rewardR(s) by f R (s|q) = tanh (W R \u03c6(q) + b R ) \u03c6(s) with parameters W R (diagonal matrix) and b R (vector). For transition, since the graph remains unchanged,P is fixed. For the attention module \u03a0(V , s), we compute it by \u03a0(V , s) = s\u2208S sigmoid (W \u03a0 \u03c6(s) + b \u03a0 ) \u03c6(s) V (s), where W \u03a0 and b \u03a0 are parameters and W \u03a0 is diagonal. Moreover, we compute the coefficient \u03b3 based on the query q and the state s using a tanh-layer neural net parametrized by W \u03b3 : \u03b3(s, q) =", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "Full wikipedia website: The full wikipedia dataset consists 779169 training queries (3 million training samples) and 20004 testing queries (76664 testing samples) over 4.8 million pages with maximum 300 links per page.", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "", "figure_data": "DomainVIN Prediction Success Traj. Pred. Succ. CNNFCN Traj. Pred. Succ.Traj.lossratediff.lossratediff.lossratediff.8 \u00d7 80.00499.6% 0.001 0.02 97.9% 0.006 0.01 97.3% 0.00416 \u00d7 160.0599.3% 0.089 0.10 87.6% 0.060.07 88.3% 0.0528 \u00d7 280.1197%0.086 0.13 74.2% 0.078 0.09 76.6% 0.08"}, {"figure_label": "22", "figure_type": "table", "figure_id": "tab_3", "figure_caption": "show that untying the weights degrades performance, with a stronger effect for smaller sizes of training data. Performance on 16 \u00d7 16 grid-world domain. Evaluation of the effect of VI module shared weights relative to data size.", "figure_data": "Training dataVIN Pred. Succ.VIN Untied Weights Traj. Pred. Succ. Traj.lossratediff.lossratediff.20%0.06 98.2% 0.106 0.09 91.9% 0.09450%0.05 99.4% 0.018 0.07 95.2% 0.078100%0.05 99.3% 0.089 0.05 95.6% 0.068"}, {"figure_label": "3", "figure_type": "table", "figure_id": "tab_5", "figure_caption": "RL Results -performance on test maps.", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_7", "figure_caption": "Network Top-1 Test Err. Top-4 Test Err. Avg.", "figure_data": "RewardBSL52.019%24.424%0.27779VIN50.562%26.055%0.30389"}, {"figure_label": "5", "figure_type": "table", "figure_id": "tab_8", "figure_caption": "Performance on the full wikipedia dataset.", "figure_data": "tanh W \u03b3\u03c6(s) \u03c6(q)"}], "formulas": [{"formula_id": "formula_0", "formula_text": "= E \u03c0 [ \u221e t=0 \u03b3 t r(s t , a t )| s 0 = s],", "formula_coordinates": [2.0, 217.81, 513.9, 134.13, 14.11]}, {"formula_id": "formula_1", "formula_text": "V n+1 (s) = max a Q n (s, a) \u2200s, where Q n (s, a) = R(s, a) + \u03b3 s P (s |s, a)V n (s ).", "formula_coordinates": [2.0, 118.8, 585.55, 362.78, 11.15]}], "doi": ""}